#pragma once

// RealmRoyale (0.23) SDK

#ifdef _MSC_VER
	#pragma pack(push, 0x8)
#endif

#include "RL_TgGame_structs.hpp"

namespace SDK
{
//---------------------------------------------------------------------------
//Classes
//---------------------------------------------------------------------------

// Class TgGame.TgAIDirector
// 0x0258 (0x04D8 - 0x0280)
class ATgAIDirector : public AActor
{
public:
	unsigned long                                      m_bActive : 1;                                            // 0x0280(0x0004)
	unsigned long                                      m_bCanAdjustNow : 1;                                      // 0x0280(0x0004)
	unsigned long                                      m_bDisparityDetected : 1;                                 // 0x0280(0x0004)
	unsigned long                                      m_bProlongedDisparityDetected : 1;                        // 0x0280(0x0004)
	unsigned long                                      m_bHasLoweredDifficultyAtTie : 1;                         // 0x0280(0x0004)
	unsigned long                                      m_bFreezeAIDifficulty : 1;                                // 0x0280(0x0004)
	float                                              m_fTimeSinceLastUpdate;                                   // 0x0284(0x0004)
	float                                              m_fLastSkillDisparity;                                    // 0x0288(0x0004)
	int                                                m_iIncreaseTF1Difficulty;                                 // 0x028C(0x0004)
	int                                                m_iIncreaseTF2Difficulty;                                 // 0x0290(0x0004)
	int                                                m_iDisparityDetectionTime;                                // 0x0294(0x0004)
	int                                                m_iTriggerTime;                                           // 0x0298(0x0004)
	int                                                m_iTaskForce1PlayerCount;                                 // 0x029C(0x0004)
	int                                                m_iTaskForce2PlayerCount;                                 // 0x02A0(0x0004)
	float                                              LockoutTime;                                              // 0x02A4(0x0004)
	float                                              SkillDisparityTrigger;                                    // 0x02A8(0x0004)
	float                                              UpdateRate;                                               // 0x02AC(0x0004)
	float                                              m_fLastPayloadPercent;                                    // 0x02B0(0x0004)
	float                                              m_fBaseUpperKillRatio;                                    // 0x02B4(0x0004)
	float                                              m_fBaseLowerKillRatio;                                    // 0x02B8(0x0004)
	float                                              m_fBaseUpperPayloadRate;                                  // 0x02BC(0x0004)
	float                                              m_fBaseLowerPayloadRate;                                  // 0x02C0(0x0004)
	float                                              NumDeaths_Weight;                                         // 0x02C4(0x0004)
	float                                              Damage_Weight;                                            // 0x02C8(0x0004)
	float                                              Kills_Weight;                                             // 0x02CC(0x0004)
	float                                              SoloKills_Weight;                                         // 0x02D0(0x0004)
	float                                              Assists_Weight;                                           // 0x02D4(0x0004)
	float                                              ObjectiveTime_Weight;                                     // 0x02D8(0x0004)
	float                                              Healing_Weight;                                           // 0x02DC(0x0004)
	float                                              Shielding_Weight;                                         // 0x02E0(0x0004)
	float                                              Credits_Weight;                                           // 0x02E4(0x0004)
	float                                              Accuracy_Weight;                                          // 0x02E8(0x0004)
	float                                              Killstreak_Multiplier;                                    // 0x02EC(0x0004)
	float                                              numDeathsBase0;                                           // 0x02F0(0x0004)
	float                                              numDeathsBase1;                                           // 0x02F4(0x0004)
	struct FSkillLevelRawData                          PlayerSkillData[0x2];                                     // 0x02F8(0x0028)
	struct FSkillLevelRawData                          TeamSkillData[0x2];                                       // 0x0348(0x0028)
	struct FSkillLevelRawData                          OldPlayerSkillData[0x2];                                  // 0x0398(0x0028)
	struct FSkillLevelRawData                          OldTeamSkillData[0x2];                                    // 0x03E8(0x0028)
	struct FSkillLevelPercentageData                   SkillPercentages[0x4];                                    // 0x0438(0x0028)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIDirector");
		return ptr;
	}


	void UpdateDebugInfo();
	void ReallowAdjustment();
	void UpdateBotDifficultyParameters(class ATgAIController_BehaviorGod* TgAI, TEnumAsByte<EBotDifficultyLevel> NewDifficulty);
	bool AdjustDifficulty();
	void CheckDisparity();
	bool CheckParticipation(int tf);
	bool CheckTeamStatsThreshold();
	void PullDataForBot(class ATgPawn* TgP);
	void PullDataForPlayer(class ATgPawn* TgP);
	void PullRawData();
	void UpdateDifficulty();
	void STATIC_SetActive(bool NewActive);
	void Tick(float DeltaTime);
	void PostBeginPlay();
	float STATIC_GetDegreeMissedMagnitudeFromConfigSet(int ConfigSetID);
	float STATIC_GetMissLikelihoodFromConfigSet(int ConfigSetID);
	float STATIC_GetLeadAccuracyFromConfigSet(int ConfigSetID);
	int STATIC_GetShieldingForPawn(class ATgPawn* TgP);
	int STATIC_GetObjectiveTimeForPawn(class ATgPawn* TgP);
	int STATIC_GetDamageForPawn(class ATgPawn* TgP);
};


// Class TgGame.TgAimAccelerationCurves
// 0x00A0 (0x0100 - 0x0060)
class UTgAimAccelerationCurves : public UObject
{
public:
	struct FName                                       SettingsName;                                             // 0x0060(0x0008) (Edit)
	float                                              MaxAccelMultiplierX;                                      // 0x0068(0x0004) (Edit)
	float                                              MaxAccelMultiplierY;                                      // 0x006C(0x0004) (Edit)
	struct FRawDistributionFloat                       AimSpeedX;                                                // 0x0070(0x0024) (Edit, Component, NeedCtorLink)
	struct FRawDistributionFloat                       AimAccelX;                                                // 0x0094(0x0024) (Edit, Component, NeedCtorLink)
	struct FRawDistributionFloat                       AimSpeedY;                                                // 0x00B8(0x0024) (Edit, Component, NeedCtorLink)
	struct FRawDistributionFloat                       AimAccelY;                                                // 0x00DC(0x0024) (Edit, Component, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAimAccelerationCurves");
		return ptr;
	}

};


// Class TgGame.TgAimAssistKeyframe
// 0x0030 (0x0090 - 0x0060)
class UTgAimAssistKeyframe : public UObject
{
public:
	struct FName                                       KeyframeName;                                             // 0x0060(0x0008) (Edit)
	struct FRawDistributionFloat                       AimAssistCurve;                                           // 0x0068(0x0024) (Edit, Component, NeedCtorLink)
	unsigned long                                      bMirrored : 1;                                            // 0x008C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAimAssistKeyframe");
		return ptr;
	}

};


// Class TgGame.TgAITaskforceBlockingVolume
// 0x0008 (0x02C4 - 0x02BC)
class ATgAITaskforceBlockingVolume : public AVolume
{
public:
	int                                                BlockTaskforce;                                           // 0x02BC(0x0004) (Edit)
	unsigned long                                      m_bHasRegisteredObstacle : 1;                             // 0x02C0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAITaskforceBlockingVolume");
		return ptr;
	}


	void PostBeginPlay();
	void STATIC_UnRegisterObstacle();
	void STATIC_RegisterObstacle();
};


// Class TgGame.TgAIVolume
// 0x000C (0x02C8 - 0x02BC)
class ATgAIVolume : public AVolume
{
public:
	int                                                LaneIndex;                                                // 0x02BC(0x0004) (Edit)
	int                                                TaskforceIndex;                                           // 0x02C0(0x0004) (Edit)
	unsigned long                                      bEnabled : 1;                                             // 0x02C4(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIVolume");
		return ptr;
	}


	void PostBeginPlay();
	void OnToggle(class USeqAct_Toggle* Action);
	struct FVector STATIC_GetRandomPointInAIVolume(float CollisionRadius);
};


// Class TgGame.TgAkActor
// 0x0004 (0x0284 - 0x0280)
class ATgAkActor : public AActor
{
public:
	unsigned long                                      m_bCanCheckOcclusion : 1;                                 // 0x0280(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAkActor");
		return ptr;
	}


	float STATIC_CheckOcclusion();
};


// Class TgGame.TgAkActorUnoccluded
// 0x0000 (0x0284 - 0x0284)
class ATgAkActorUnoccluded : public ATgAkActor
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAkActorUnoccluded");
		return ptr;
	}

};


// Class TgGame.TgAnimNodeBlendByVerticalAim
// 0x0043 (0x0154 - 0x0111)
class UTgAnimNodeBlendByVerticalAim : public UAnimNodeBlendBase
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0111(0x0003) MISSED OFFSET
	float                                              m_Aim;                                                    // 0x0114(0x0004) (Edit)
	struct FVector2D                                   m_Range;                                                  // 0x0118(0x0008) (Edit)
	float                                              m_AngleOffset;                                            // 0x0120(0x0004) (Edit)
	float                                              m_PreviousAim;                                            // 0x0124(0x0004) (Transient)
	unsigned long                                      bInitialized : 1;                                         // 0x0128(0x0004) (Transient)
	unsigned long                                      m_bLoopChildrenOnRelevant : 1;                            // 0x0128(0x0004) (Edit)
	unsigned long                                      m_bPlayChildrenOnRelevant : 1;                            // 0x0128(0x0004) (Edit)
	struct FName                                       m_AnimName_Up;                                            // 0x012C(0x0008) (Edit)
	struct FName                                       m_AnimName_Center;                                        // 0x0134(0x0008) (Edit)
	struct FName                                       m_AnimName_Down;                                          // 0x013C(0x0008) (Edit)
	class UAnimNodeSequence*                           m_SeqNode1;                                               // 0x0144(0x0008) (Transient)
	class UAnimNodeSequence*                           m_SeqNode2;                                               // 0x014C(0x0008) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendByVerticalAim");
		return ptr;
	}


	void STATIC_OnBecomeRelevant();
	void PlayAnim(bool bLoop, float Rate, float StartTime);
};


// Class TgGame.TgAnimNotify_CameraCut
// 0x003F (0x00A4 - 0x0065)
class UTgAnimNotify_CameraCut : public UAnimNotify
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0065(0x0003) MISSED OFFSET
	float                                              m_fTweenSpeed;                                            // 0x0068(0x0004) (Edit)
	struct FVector                                     m_vTweenDir;                                              // 0x006C(0x000C) (Edit)
	struct FVector                                     m_vLocationOffset;                                        // 0x0078(0x000C) (Edit)
	struct FRotator                                    m_rRotationOffset;                                        // 0x0084(0x000C) (Edit)
	struct FRotator                                    m_rRotationTarget;                                        // 0x0090(0x000C) (Edit)
	float                                              m_fRotationDuration;                                      // 0x009C(0x0004) (Edit)
	float                                              m_fRotationDelay;                                         // 0x00A0(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNotify_CameraCut");
		return ptr;
	}

};


// Class TgGame.TgAnimNotify_Disappear
// 0x0003 (0x0068 - 0x0065)
class UTgAnimNotify_Disappear : public UAnimNotify
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0065(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNotify_Disappear");
		return ptr;
	}

};


// Class TgGame.TgAnimNotify_SpectatorSlomo
// 0x0003 (0x0068 - 0x0065)
class UTgAnimNotify_SpectatorSlomo : public UAnimNotify
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0065(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNotify_SpectatorSlomo");
		return ptr;
	}

};


// Class TgGame.TgPlayerController
// 0x0E3C (0x1614 - 0x07D8)
class ATgPlayerController : public APComPlayerController
{
public:
	struct FPointer                                    VfTable_ITgPaladinsController;                            // 0x07D8(0x0008) (Const, Native, NoExport)
	struct FPointer                                    VfTable_ITgCallbackInterface;                             // 0x07E0(0x0008) (Const, Native, NoExport)
	struct FSZombieInfo                                ZombieInfo;                                               // 0x07E8(0x005C)
	int                                                m_nAnnouncerSeriesStep[0x6];                              // 0x0844(0x0004)
	int                                                s_nPlayerId;                                              // 0x085C(0x0004)
	int                                                s_nPartyId;                                               // 0x0860(0x0004)
	struct FQWord                                      s_qwNetAccessFlags;                                       // 0x0864(0x0008)
	int                                                r_nXp;                                                    // 0x086C(0x0004) (Net)
	int                                                r_nCurrency;                                              // 0x0870(0x0004) (Net)
	float                                              s_fCurrencyRemainder;                                     // 0x0874(0x0004)
	float                                              s_fXpRemainder;                                           // 0x0878(0x0004)
	unsigned long                                      r_bCanPurchaseItems : 1;                                  // 0x087C(0x0004) (Net)
	unsigned long                                      r_bCanChangeLoadout : 1;                                  // 0x087C(0x0004) (Net)
	unsigned long                                      r_bAutoPurchase : 1;                                      // 0x087C(0x0004) (Net)
	unsigned long                                      r_bAutoSkillUp : 1;                                       // 0x087C(0x0004) (Net)
	unsigned long                                      r_bToggleZoom : 1;                                        // 0x087C(0x0004) (Net)
	unsigned long                                      m_bBlockVGS : 1;                                          // 0x087C(0x0004)
	unsigned long                                      c_bPreparingForge : 1;                                    // 0x087C(0x0004)
	unsigned long                                      c_bAttemptingPickupWep : 1;                               // 0x087C(0x0004)
	unsigned long                                      c_bRequestingPickup : 1;                                  // 0x087C(0x0004)
	unsigned long                                      s_bSentAutoKickAlert : 1;                                 // 0x087C(0x0004)
	unsigned long                                      s_bAddDeadTimeStatsTracker : 1;                           // 0x087C(0x0004) (Transient)
	unsigned long                                      c_bWeaponSwap : 1;                                        // 0x087C(0x0004)
	unsigned long                                      c_bDeviceSwap : 1;                                        // 0x087C(0x0004)
	unsigned long                                      r_bLockYawRotation : 1;                                   // 0x087C(0x0004) (Net)
	unsigned long                                      bPressingLeftMouseButton : 1;                             // 0x087C(0x0004)
	unsigned long                                      bPressingRightMouseButton : 1;                            // 0x087C(0x0004)
	unsigned long                                      bPressingMovementButton : 1;                              // 0x087C(0x0004)
	unsigned long                                      bPressingAltFireButton : 1;                               // 0x087C(0x0004)
	unsigned long                                      bPressingReloadButton : 1;                                // 0x087C(0x0004)
	unsigned long                                      bPressingHealButton : 1;                                  // 0x087C(0x0004)
	unsigned long                                      bPressingRepairButton : 1;                                // 0x087C(0x0004)
	unsigned long                                      m_bPendingReload : 1;                                     // 0x087C(0x0004)
	unsigned long                                      r_bRove : 1;                                              // 0x087C(0x0004) (Net)
	unsigned long                                      m_bNoSmoothedMovementCorrection : 1;                      // 0x087C(0x0004)
	unsigned long                                      c_bProcessedNoSmoothNotification : 1;                     // 0x087C(0x0004)
	unsigned long                                      s_bNoSmoothedMovementCorrectionRequested : 1;             // 0x087C(0x0004)
	unsigned long                                      s_bIsNoSmoothMovementCorrectionManaged : 1;               // 0x087C(0x0004)
	unsigned long                                      m_bUsingDeadSpectatorControlModule : 1;                   // 0x087C(0x0004)
	unsigned long                                      s_bClearAchievementIgnoreListsOnNextTick : 1;             // 0x087C(0x0004)
	unsigned long                                      bDebugProjectileLagCompensation : 1;                      // 0x087C(0x0004)
	unsigned long                                      c_bAssistModeSublevelLoaded : 1;                          // 0x087C(0x0004)
	unsigned long                                      c_bAllowSpecialMaterialEffects : 1;                       // 0x087C(0x0004) (Config, GlobalConfig)
	unsigned long                                      m_bIgnoreSilhouettes : 1;                                 // 0x0880(0x0004) (Transient)
	unsigned long                                      m_bForceSilhouettesOnVisibleGods : 1;                     // 0x0880(0x0004) (Transient)
	unsigned long                                      m_bDetailedViewEnabled : 1;                               // 0x0880(0x0004) (Transient)
	unsigned long                                      m_bShowPlayerCircles : 1;                                 // 0x0880(0x0004)
	unsigned long                                      m_bAllowUndrawnPurchase : 1;                              // 0x0880(0x0004)
	unsigned long                                      m_bCanHearStealthPawns : 1;                               // 0x0880(0x0004) (Const)
	unsigned long                                      c_bShowFootstepInfoDebug : 1;                             // 0x0880(0x0004)
	unsigned long                                      m_bDetailedDeviceLogging : 1;                             // 0x0880(0x0004)
	unsigned long                                      m_bOutlineEnemies : 1;                                    // 0x0880(0x0004) (Edit)
	unsigned long                                      m_bOutlineFriendlies : 1;                                 // 0x0880(0x0004) (Edit)
	unsigned long                                      c_bEnablePathfinderGuide : 1;                             // 0x0880(0x0004) (Config)
	unsigned long                                      m_fPathfinderEnabled : 1;                                 // 0x0880(0x0004)
	unsigned long                                      c_bIsPlayingFallWindSound : 1;                            // 0x0880(0x0004)
	unsigned long                                      m_bJustDidJumpDoubleTap : 1;                              // 0x0880(0x0004)
	unsigned long                                      m_bThreatSystemEnabled : 1;                               // 0x0880(0x0004)
	unsigned long                                      m_bOcclusionSystemEnabled : 1;                            // 0x0880(0x0004)
	unsigned long                                      m_bDebugThreatSystem : 1;                                 // 0x0880(0x0004)
	unsigned long                                      c_bMatchAlmostWonSwitchPrimed : 1;                        // 0x0880(0x0004)
	unsigned long                                      m_IsTimeDilationInterpolating : 1;                        // 0x0880(0x0004)
	unsigned long                                      m_IsDesaturationInterpolating : 1;                        // 0x0880(0x0004)
	unsigned long                                      m_bIsTrackingAimTowardTargetLocation : 1;                 // 0x0880(0x0004) (Transient)
	unsigned long                                      bForcedTimelapseRequested : 1;                            // 0x0880(0x0004)
	unsigned long                                      bForcedPlayOfGameRequested : 1;                           // 0x0880(0x0004)
	unsigned long                                      m_bRewindMoversForReplaySavedMoves : 1;                   // 0x0880(0x0004)
	unsigned long                                      m_bShowDebugRewindMovers : 1;                             // 0x0880(0x0004)
	unsigned long                                      c_bCaptureProgressAkEventPlaying : 1;                     // 0x0880(0x0004)
	unsigned long                                      m_bShowChampionOverviewTip : 1;                           // 0x0880(0x0004)
	unsigned long                                      m_bEnableUltimateAkEventUnocclusion : 1;                  // 0x0880(0x0004) (Config)
	unsigned long                                      c_bIsPlayOfTheGame : 1;                                   // 0x0880(0x0004)
	unsigned long                                      c_bRoyaleDeploySequence : 1;                              // 0x0880(0x0004)
	unsigned long                                      m_bHideReticle : 1;                                       // 0x0880(0x0004)
	unsigned long                                      m_bHideReticleAcc : 1;                                    // 0x0880(0x0004)
	unsigned long                                      m_bSupportsEffectSimulation : 1;                          // 0x0884(0x0004)
	unsigned long                                      m_bForced3pOption : 1;                                    // 0x0884(0x0004)
	unsigned long                                      m_bFreeCamEnabled : 1;                                    // 0x0884(0x0004)
	unsigned long                                      m_bFogPPFXInitialized : 1;                                // 0x0884(0x0004)
	unsigned long                                      bMount : 1;                                               // 0x0884(0x0004)
	unsigned long                                      bInADS : 1;                                               // 0x0884(0x0004)
	unsigned long                                      m_bSwitchingClasses : 1;                                  // 0x0884(0x0004)
	unsigned long                                      m_bAbilityOneHeld : 1;                                    // 0x0884(0x0004)
	unsigned long                                      m_bMovementHeld : 1;                                      // 0x0884(0x0004)
	unsigned long                                      m_bAbilityTwoFired : 1;                                   // 0x0884(0x0004)
	unsigned long                                      m_bCanVault : 1;                                          // 0x0884(0x0004) (Transient)
	unsigned long                                      s_bUseRespawnLocation : 1;                                // 0x0884(0x0004)
	unsigned long                                      m_bEnableAutoSprint : 1;                                  // 0x0884(0x0004)
	unsigned long                                      r_bBigHeadModeEnabled : 1;                                // 0x0884(0x0004) (Net)
	unsigned long                                      r_bBigHeadModeStarting : 1;                               // 0x0884(0x0004) (Net)
	float                                              c_fLastGoldNagTime;                                       // 0x0888(0x0004)
	int                                                m_nReviveBuybackCost;                                     // 0x088C(0x0004)
	int                                                r_nStatPoints;                                            // 0x0890(0x0004) (Net)
	struct FFLOOD                                      s_VGSFlood;                                               // 0x0894(0x0008)
	struct FFLOOD                                      s_PingFlood;                                              // 0x089C(0x0008)
	class ATgRepInfo_Player*                           r_DesiredViewPRI;                                         // 0x08A4(0x0008) (Net)
	TArray<int>                                        s_nViewingPlayerIds;                                      // 0x08AC(0x0010) (NeedCtorLink)
	class AActor*                                      c_aLastViewTarget;                                        // 0x08BC(0x0008)
	class UTgPlayerInput*                              m_CachedPlayerInput;                                      // 0x08C4(0x0008)
	class UTgSpectatorInput*                           m_CachedSpectatorInput;                                   // 0x08CC(0x0008)
	class AActor*                                      m_aHoverActor;                                            // 0x08D4(0x0008)
	struct FVector                                     m_vHoverLocation;                                         // 0x08DC(0x000C)
	float                                              m_fHoverActorActiveTime;                                  // 0x08E8(0x0004)
	struct FVector                                     m_vWorldMapLocation;                                      // 0x08EC(0x000C)
	TArray<class AReplicationInfo*>                    m_WorldMapTargetRepInfos;                                 // 0x08F8(0x0010) (Transient, AlwaysInit, NeedCtorLink)
	struct FVector                                     m_vWorldMouseLocation;                                    // 0x0908(0x000C) (Transient)
	struct FVector                                     m_vWorldMouseDirection;                                   // 0x0914(0x000C) (Transient)
	float                                              c_fTimeTillAFK;                                           // 0x0920(0x0004)
	float                                              s_bAutoKickStartTime;                                     // 0x0924(0x0004)
	struct FTG_LAST_PURCHASE                           r_LastPurchasedItems[0x1A];                               // 0x0928(0x0008) (Net)
	class APawn*                                       s_LastPossessedPawn;                                      // 0x09F8(0x0008)
	float                                              m_fRecentLostHealth;                                      // 0x0A00(0x0004)
	float                                              m_fLastLostHealthTime;                                    // 0x0A04(0x0004)
	TArray<class AActor*>                              m_TargetedPlayers;                                        // 0x0A08(0x0010) (NeedCtorLink)
	float                                              s_fWaitForSpawnSecs;                                      // 0x0A18(0x0004)
	float                                              c_fRespawnTime;                                           // 0x0A1C(0x0004)
	float                                              m_fDeathTime;                                             // 0x0A20(0x0004)
	int                                                r_bInputEnabled[0x14];                                    // 0x0A24(0x0004) (Net)
	class UTgControlModule*                            ControlModule;                                            // 0x0A74(0x0008) (Edit, EditInline)
	class UClass*                                      DefaultControlModuleClass;                                // 0x0A7C(0x0008)
	int                                                c_nCameraYawOffset;                                       // 0x0A84(0x0004)
	int                                                m_nDevicesLockingInput;                                   // 0x0A88(0x0004)
	int                                                m_nDevicesLockingCamera;                                  // 0x0A8C(0x0004)
	int                                                m_nDevicesLockingRotation;                                // 0x0A90(0x0004)
	float                                              m_fPendingReloadTime;                                     // 0x0A94(0x0004)
	float                                              m_fPendingReloadMaxTime;                                  // 0x0A98(0x0004)
	class AActor*                                      m_EndGameFocus;                                           // 0x0A9C(0x0008) (Transient)
	float                                              m_fLastVGS;                                               // 0x0AA4(0x0004)
	struct FVector                                     m_vLastServerCorrectOrigPos;                              // 0x0AA8(0x000C)
	float                                              s_fLastConfirmedSentSmoothedMovementTimestamp;            // 0x0AB4(0x0004)
	float                                              c_fLastRecievedNoSmoothTimestamp;                         // 0x0AB8(0x0004)
	unsigned char                                      m_byDesiredMoveSpeedReduction;                            // 0x0ABC(0x0001)
	TEnumAsByte<ETG_CAMERAPOSTURE>                     c_eCameraPosture;                                         // 0x0ABD(0x0001)
	TEnumAsByte<EWatchOtherPlayersMode>                r_WatchOtherPlayer;                                       // 0x0ABE(0x0001) (Net)
	TEnumAsByte<EGAME_WIN_STATE>                       c_GameWinState;                                           // 0x0ABF(0x0001)
	unsigned char                                      m_bOldbRun;                                               // 0x0AC0(0x0001)
	TEnumAsByte<EHUDOverlay>                           c_eCurrentOverlay;                                        // 0x0AC1(0x0001)
	TEnumAsByte<ETG_EQUIP_POINT>                       m_eDetailedDeviceEqp;                                     // 0x0AC2(0x0001)
	TEnumAsByte<ETG_EQUIP_POINT>                       m_LastEquipPoint;                                         // 0x0AC3(0x0001)
	unsigned char                                      c_LastSentClientRoll;                                     // 0x0AC4(0x0001) (Transient)
	unsigned char                                      m_UltHeld;                                                // 0x0AC5(0x0001) (Input)
	unsigned char                                      m_JumpHeld;                                               // 0x0AC6(0x0001) (Input)
	unsigned char                                      m_JumpHeldAlt;                                            // 0x0AC7(0x0001) (Input)
	unsigned char                                      m_PerCharacterAlt;                                        // 0x0AC8(0x0001) (Input)
	unsigned char                                      c_ePickupSlot;                                            // 0x0AC9(0x0001)
	unsigned char                                      UnknownData00[0x2];                                       // 0x0ACA(0x0002) MISSED OFFSET
	TArray<struct FCameraStackInfo>                    c_CameraStack;                                            // 0x0ACC(0x0010) (NeedCtorLink)
	int                                                c_nNextCameraStackId;                                     // 0x0ADC(0x0004)
	float                                              m_fTimeToViewOthersCamAfterDeath;                         // 0x0AE0(0x0004) (Const)
	float                                              m_fWatchOthersFadeToBlackCamTime;                         // 0x0AE4(0x0004) (Edit, Const)
	float                                              m_fWatchOthersFadeFromBlackCamTime;                       // 0x0AE8(0x0004) (Edit, Const)
	TArray<class UTgAchievement*>                      s_Achievements;                                           // 0x0AEC(0x0010) (NeedCtorLink)
	class UTgAkAudioManagement*                        c_TgAkAudio;                                              // 0x0AFC(0x0008)
	int                                                r_nFlashProjectile[0x20];                                 // 0x0B04(0x0004) (Net)
	struct FsSimProjectileFireInfo                     r_FlashProjectileEx[0x20];                                // 0x0B84(0x003C) (Net)
	int                                                r_nFirstValidProjIdx;                                     // 0x1304(0x0004) (Net)
	int                                                r_nFlashSimProjIdx;                                       // 0x1308(0x0004) (Net)
	int                                                c_nLastFlashSimProjIdx;                                   // 0x130C(0x0004)
	int                                                r_nPerkPointsAvail;                                       // 0x1310(0x0004) (Net)
	float                                              m_fCatapultPowerLevel;                                    // 0x1314(0x0004)
	float                                              m_fCatapultPowerRate;                                     // 0x1318(0x0004)
	float                                              m_fCatapultMinPower;                                      // 0x131C(0x0004)
	float                                              m_fCatapultMaxPower;                                      // 0x1320(0x0004)
	class ATgGameTipManager*                           c_GameTipManager;                                         // 0x1324(0x0008) (Transient)
	struct FPointer                                    s_pCombatMessages;                                        // 0x132C(0x0008) (Native)
	float                                              s_fLastCombatMessageProcess;                              // 0x1334(0x0004)
	int                                                c_nCurrentLevel;                                          // 0x1338(0x0004)
	class UTgTutorialAnnouncer*                        c_TutorialAnnouncer;                                      // 0x133C(0x0008)
	int                                                r_TutorialBlockedClientActions;                           // 0x1344(0x0004) (Net)
	class UTgSubtitledMessages*                        c_SubtitledMessages;                                      // 0x1348(0x0008)
	class ATgRepInfo_Player*                           CachedPRI;                                                // 0x1350(0x0008) (Transient)
	class UMaterialInstanceConstant*                   m_OverlayPathMaterial;                                    // 0x1358(0x0008)
	TArray<class ATgPawn*>                             m_HiddenPawns;                                            // 0x1360(0x0010) (NeedCtorLink)
	class UAudioComponent*                             c_AlertAudioComponent;                                    // 0x1370(0x0008) (ExportObject, Component, EditInline)
	class UAkEvent*                                    c_AlertAkEvent;                                           // 0x1378(0x0008)
	TArray<class UTgObjectReferencer*>                 c_KismetLoadedDevices;                                    // 0x1380(0x0010) (NeedCtorLink)
	class UTgCameraShake*                              m_PreviewCameraShake;                                     // 0x1390(0x0008) (Edit, EditInline)
	float                                              m_fPathfinderStreamTime;                                  // 0x1398(0x0004) (Edit)
	float                                              m_fPathfinderPulseTime;                                   // 0x139C(0x0004) (Edit)
	float                                              m_fPathfinderLifetime;                                    // 0x13A0(0x0004) (Edit)
	float                                              m_fPathfinderSpeed;                                       // 0x13A4(0x0004) (Edit)
	float                                              m_fPathfinderStartDist;                                   // 0x13A8(0x0004) (Edit)
	float                                              c_LastSentMoveTimeStamp;                                  // 0x13AC(0x0004) (Transient)
	struct FVector                                     c_LastSentMoveAcceleration;                               // 0x13B0(0x000C) (Transient)
	int                                                c_LastSentMoveCompressedFlags;                            // 0x13BC(0x0004) (Transient)
	struct FVector                                     c_LastSentClientLoc;                                      // 0x13C0(0x000C) (Transient)
	int                                                c_LastSentView;                                           // 0x13CC(0x0004) (Transient)
	class UAkEvent*                                    c_FallWindSoundPlay;                                      // 0x13D0(0x0008)
	class UAkEvent*                                    c_FallWindSoundStop;                                      // 0x13D8(0x0008)
	class UAkBaseSoundObject*                          c_HitMarkerSounds[0x5];                                   // 0x13E0(0x0008)
	class UAkBaseSoundObject*                          c_ScoreKillSound;                                         // 0x1408(0x0008)
	class UAkBaseSoundObject*                          c_ScoreDownSound;                                         // 0x1410(0x0008)
	class UAkBaseSoundObject*                          c_ChickenShardSound;                                      // 0x1418(0x0008)
	int                                                m_nKillCamTargetId;                                       // 0x1420(0x0004) (Transient)
	int                                                m_nKillCamTargetBackupId;                                 // 0x1424(0x0004) (Transient)
	float                                              r_fServerTimeStamp;                                       // 0x1428(0x0004) (Net)
	float                                              m_fLastJumpTapTime;                                       // 0x142C(0x0004)
	float                                              m_fMaxJumpDoubleTapTime;                                  // 0x1430(0x0004)
	int                                                m_nVoicePackId;                                           // 0x1434(0x0004)
	TArray<class ATgPawn*>                             m_PawnsWithThreatLevels;                                  // 0x1438(0x0010) (NeedCtorLink)
	class ATgPathfinder*                               m_Pathfinder;                                             // 0x1448(0x0008)
	float                                              m_fThreatCoefficientProximity;                            // 0x1450(0x0004) (Config)
	float                                              m_fThreatCoefficientOcclusion;                            // 0x1454(0x0004) (Config)
	float                                              m_fThreatCoefficientBinnedOcclusion;                      // 0x1458(0x0004) (Config)
	float                                              m_fThreatCoefficientUlt;                                  // 0x145C(0x0004) (Config)
	float                                              m_fThreatCoefficientShotAt;                               // 0x1460(0x0004) (Config)
	float                                              m_fThreatCoefficientSeenBy;                               // 0x1464(0x0004) (Config)
	float                                              m_fThreatCoefficientDamaged;                              // 0x1468(0x0004) (Config)
	float                                              m_fThreatCoefficientFocused;                              // 0x146C(0x0004) (Config)
	float                                              m_fThreatCoefficientFocusTarget;                          // 0x1470(0x0004) (Config)
	float                                              m_fThreatCoefficientBehind;                               // 0x1474(0x0004) (Config)
	float                                              m_fThreatCoefficientInEffectiveRange;                     // 0x1478(0x0004) (Config)
	float                                              m_fThreatDecayCoefficientShotAt;                          // 0x147C(0x0004) (Config)
	float                                              m_fThreatDecayCoefficientSeenBy;                          // 0x1480(0x0004) (Config)
	float                                              m_fThreatDecayCoefficientUlt;                             // 0x1484(0x0004) (Config)
	struct FString                                     m_DebugThreatSystemChannel;                               // 0x1488(0x0010) (NeedCtorLink)
	struct FString                                     m_CurrentMusicEventName;                                  // 0x1498(0x0010) (NeedCtorLink)
	struct FName                                       m_nameBuyBurnCardsTimer;                                  // 0x14A8(0x0008)
	struct FVector2D                                   m_TimeDilationFromTo;                                     // 0x14B0(0x0008)
	float                                              m_TimeDilationInterpolateSeconds;                         // 0x14B8(0x0004)
	float                                              m_TimeDilationUsedSeconds;                                // 0x14BC(0x0004)
	struct FVector2D                                   m_DesaturationFromTo;                                     // 0x14C0(0x0008)
	float                                              m_DesaturationInterpolateSeconds;                         // 0x14C8(0x0004)
	float                                              m_DesaturationUsedSeconds;                                // 0x14CC(0x0004)
	int                                                m_EnergyLastFrame;                                        // 0x14D0(0x0004)
	struct FVector                                     m_TrackingTargetLocation;                                 // 0x14D4(0x000C) (Transient)
	float                                              m_fTrackingTargetMaxAimDistDiff;                          // 0x14E0(0x0004) (Transient)
	class UAkBaseSoundObject*                          m_RoundEndAlert;                                          // 0x14E4(0x0008)
	class UAkEvent*                                    m_akQueuedAnnouncer;                                      // 0x14EC(0x0008)
	float                                              m_fTimeToPlayQueuedAnnouncer;                             // 0x14F4(0x0004)
	class USeqAct_Interp*                              m_CurrentDirectorMatinee;                                 // 0x14F8(0x0008)
	class UAkEvent*                                    m_CaptureProgressPlayAkEvent;                             // 0x1500(0x0008)
	class UAkEvent*                                    m_CaptureProgressStopAkEvent;                             // 0x1508(0x0008)
	float                                              m_fCachedCaptureProgress;                                 // 0x1510(0x0004)
	class UAkEvent*                                    m_PointGettingCapturedPlayAkEvent;                        // 0x1514(0x0008)
	int                                                m_nPointGettingCapturedPlayCount;                         // 0x151C(0x0004)
	float                                              m_fShowChampionOverviewTipDelay;                          // 0x1520(0x0004)
	int                                                s_nRoundsIdle;                                            // 0x1524(0x0004)
	float                                              s_fIdleTimeReduction;                                     // 0x1528(0x0004)
	int                                                c_nLeadingTeam;                                           // 0x152C(0x0004)
	int                                                c_nLeadingTeamTicketAmount;                               // 0x1530(0x0004)
	class UTgCallbackContainer*                        m_CallbackContainer;                                      // 0x1534(0x0008)
	int                                                m_nReticleColorOverride;                                  // 0x153C(0x0004)
	struct FLinearColor                                m_cReticleColor;                                          // 0x1540(0x0010)
	float                                              m_fAchievementPollRate;                                   // 0x1550(0x0004)
	float                                              m_fAchievementPollElapsed;                                // 0x1554(0x0004)
	int                                                s_nTeamMateHealMeVisibilityTest;                          // 0x1558(0x0004)
	float                                              c_fForced3pFOV;                                           // 0x155C(0x0004)
	float                                              m_fFreeCamYawOffset;                                      // 0x1560(0x0004)
	float                                              m_fFreeCamPitchOffset;                                    // 0x1564(0x0004)
	float                                              r_fSwapWeaponDelay;                                       // 0x1568(0x0004) (Net)
	float                                              m_fReviveTeammateDistance;                                // 0x156C(0x0004)
	class ATgPawn*                                     m_TeammateReviving;                                       // 0x1570(0x0008)
	class ATgPawn*                                     r_BeingRevivedByPawn;                                     // 0x1578(0x0008) (Net)
	class UMaterialInstanceConstant*                   m_RoyaleFogCameraMIC;                                     // 0x1580(0x0008)
	class UMaterialEffect*                             m_RoyaleFogMaterialEffect;                                // 0x1588(0x0008)
	int                                                c_LootPickupResponseCounter;                              // 0x1590(0x0004)
	struct FVector                                     m_vLastPOVLocation;                                       // 0x1594(0x000C)
	struct FRotator                                    m_rLastPOVRotation;                                       // 0x15A0(0x000C)
	class UTgChampionTickManager*                      c_ChampionTickManager;                                    // 0x15AC(0x0008)
	class ATgDeployable*                               c_InteractDeployable;                                     // 0x15B4(0x0008)
	class ATgForgeObjective*                           c_InteractForgeObjective;                                 // 0x15BC(0x0008)
	class ATgCatapultActor*                            c_InteractCatapult;                                       // 0x15C4(0x0008)
	class ATgHUD*                                      m_pHud;                                                   // 0x15CC(0x0008)
	class AEmitter*                                    m_3DHitIndicators[0x6];                                   // 0x15D4(0x0008)
	int                                                m_n3DHitIndicatorPoolIndex;                               // 0x1604(0x0004)
	struct FVector                                     s_vRespawnLocation;                                       // 0x1608(0x000C)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPlayerController");
		return ptr;
	}


	void SetFTZombieMode(bool bEnabled, TEnumAsByte<EZombieModex> Mode);
	void FTPlayerInit();
	void STATIC_Play3DHitIndicator(const struct FVector& HitLocation, const struct FVector& HitDirection);
	void STATIC_Init3DHitIndicators();
	void STATIC_InitFogPPFX();
	void STATIC_ServerRequestProcessStats();
	void STATIC_ClientStatsComplete();
	void STATIC_OnServerRequestProcessStats();
	void STATIC_OnClientStatsComplete();
	void STATIC_TestSwitch(bool bEnabled);
	void STATIC_TestHitMarker();
	void DoCustomEmote(int nIndex);
	void SetCustomEmote(int nIndex, int nCustomEmoteId);
	void DoCustomSpray(int nIndex);
	void ClientSetCustomSpray(int nIndex, int nCustomSprayId);
	void STATIC_SetCustomSpray(int nIndex, int nCustomSprayId);
	void Spray();
	void ClientSetSpray(int nSprayId);
	void SetSpray(int nSprayId);
	void UpdateWaypoint(const struct FVector& Loc);
	void ClientAddUse(class ATgForgeObjective* pForgeObjective, int nIndex, int nState);
	void ServerDepositShards(class ATgForgeObjective* pForgeObjective, int nIndex, int nState);
	bool STATIC_HasMaxShards();
	void STATIC_DepositShards(int nIndex, int nState);
	void STATIC_EndZoom();
	void StartZoom();
	void ReleasedAltFire();
	void PressedAltFire();
	void ServerRequestWeapon(int nIndex);
	void RequestWeapon(int nIndex);
	void EndSprint();
	void STATIC_LetGoSprint();
	void StartSprint();
	void STATIC_PlayFogHorn();
	bool STATIC_IsViewingTeamZeppelin();
	void STATIC_ClientPlayDeploy(const struct FVector& vLocation);
	void STATIC_OnPlayDeploy(const struct FVector& vLocation);
	void STATIC_ServerRequestRelease();
	void STATIC_OnRequestRelease(bool bSendHome);
	void STATIC_ClientScoreDown(const struct FScoreKillData& Data);
	void STATIC_ClientScoreKill(const struct FScoreKillData& Data);
	void STATIC_ClientPickupResponse(int nDeviceId, bool bSuccess, int nValue);
	void STATIC_OnPickupResponse(int nDeviceId, bool bSuccess, int nValue);
	void STATIC_ServerAttemptPickUp(class ATgDeployable* pDeployable, int nIndex);
	void AttemptPickUp(class ATgDeployable* pDeployable, int nIndex);
	void STATIC_ServerAttemptDisenchant(class ATgDeployable* pDeployable);
	bool AttemptDisenchant(class ATgDeployable* pDeployable);
	void STATIC_ClientDenyDisenchant(class ATgDeploy_Pickup* pPickup);
	void RequestDisenchant();
	void STATIC_ClientDenyPickup();
	void STATIC_RequestLoot();
	void ReleaseHoldUse();
	void BeginReloadOrHoldUse();
	void STATIC_ServerRequestCatapult(class ATgCatapultActor* Catapult, bool bDrive);
	bool STATIC_CanEnterCatapult(class ATgCatapultActor* Catapult, class ATgPawn* TgP);
	bool BeginHoldUse(bool bAutoChoosePickupSlot);
	bool CheckClassMenu();
	void ShowUseProgress(float fValue);
	void ShowForgeMenu();
	void STATIC_ServerRequestDeploy(const struct FVector& vLocation);
	class AActor* STATIC_GetDebugHoverActor();
	void STATIC_ServerActivateBigHeadMode();
	void STATIC_ServerStartingBigHeadMode();
	void STATIC_ToggleMountOrBigHeadMode();
	bool STATIC_TryBigHeadMode();
	void ServerChangeWeapon(TEnumAsByte<ETG_EQUIP_POINT> EquipPoint);
	void SwapToWeaponSlot(TEnumAsByte<ETG_EQUIP_POINT> EquipPoint);
	void STATIC_ChangeWeapon(TEnumAsByte<ETG_EQUIP_POINT> EquipPoint);
	void SwapWeapon();
	bool IsForceFeedbackAllowed();
	void SetPhysicsWeight(float Amount);
	void EnablePhysics(bool bEnabled);
	void SetReticleRainbow(bool bSetActive);
	void SetReticleColor(float R, float G, float B, float A);
	void STATIC_ClientDrawDebugSphere(float X, float Y, float Z, float Radius, int Segments, unsigned char R, unsigned char G, unsigned char B);
	void STATIC_ClientDrawDebugBox(float X, float Y, float Z, float extX, float extY, float extZ, unsigned char R, unsigned char G, unsigned char B);
	void STATIC_ClientDrawDebugLine(float X, float Y, float Z, float X2, float Y2, float z2, unsigned char R, unsigned char G, unsigned char B);
	void Unfix(const struct FName& BoneName);
	void FixAll();
	void STATIC_ResetCaptureProgressRTPC();
	void STATIC_LogLocalPropertyValue(int nPropId);
	void SwitchChampion(int BotId, int BodySkinId, int HeadSkinId, int WeaponSkinId, int VoicePackId);
	void SetServerCorrectionCameraInterpVars(float SnapDist, float MinBaseSpeed, float MaxBaseSpeed, float BaseSpeedMult, float NewInfoWeight, float MinCorrectionMod, float MaxCorrectionMod, float CorrectionModMult);
	void ToggleCaptureProgressAkEvent(bool bEnable);
	void ClientDeactivateDefendersSpawnGates();
	void ClientDeactivateAttackersSpawnGates();
	void ClientToggleSpawnGateTeamColors();
	void ClientDeactivateSpawnGates();
	void ClientActivateSpawnGates();
	void ResetUlt();
	void SetCredits(int nCreditsAmount);
	int STATIC_GetCredits();
	void ClientUpdateTF2Score(int nScore);
	void ClientUpdateTF1Score(int nScore);
	void STATIC_OnBurnCardPurchased(class ATgDevice* BurnCard, int nEquipSlot, int nFilledCardSlots);
	void STATIC_InputReceived(TEnumAsByte<EPlayerInputType> InputType);
	void SetAllInputAllowed(bool bEnabled);
	void SetInputAllowed(TEnumAsByte<EPlayerInputType> InputType, bool bEnabled);
	bool STATIC_IsInputAllowed(TEnumAsByte<EPlayerInputType> InputType);
	TEnumAsByte<EPlayerInputType> STATIC_GetInputType(TEnumAsByte<ETG_EQUIP_POINT> eqp);
	bool STATIC_IsDeviceLockingRotation();
	bool STATIC_IsDeviceLockingCamera();
	bool STATIC_IsDeviceLockingInput();
	void STATIC_SendEnergyUpdatedEvent();
	void STATIC_HideMeshes(bool bHide1PMesh, bool bHide3PMesh);
	bool STATIC_IsPlayerDead();
	void BuyBurnCards();
	void ClientStartBuyBurnCardsTimer();
	void StartBuyBurnCardsTimer();
	void ExecSetViewportLocationAndScale(float OriginX, float OriginY, float SizeX, float SizeY);
	void SetViewportLocationAndScale(const struct FVector2D& InOrigin, const struct FVector2D& InSize);
	void PlayCameraAnim(class UCameraAnim* CamAnim, float Rate, float Scale, float BlendInTime, float BlendOutTime, bool bLoop, bool bRandomStartTime, float Duration, bool bSingleInstance);
	void PostServerMoveUpdate();
	void PostMoveAutonomous(float DeltaTime, unsigned char CompressedFlags, const struct FVector& newAccel, const struct FRotator& DeltaRot);
	void STATIC_ClientAckGoodMove(float TimeStamp);
	void STATIC_ClientAckGoodMoveNoInterp(float TimeStamp);
	void STATIC_VeryShortClientAdjustPosition(float TimeStamp, float NewLocX, float NewLocY, float NewLocZ, class AActor* NewBase);
	void STATIC_VeryShortClientAdjustPositionNoInterp(float TimeStamp, float NewLocX, float NewLocY, float NewLocZ, class AActor* NewBase);
	void STATIC_ShortClientAdjustPosition(float TimeStamp, const struct FName& NewState, TEnumAsByte<EPhysics> newPhysics, float NewLocX, float NewLocY, float NewLocZ, class AActor* NewBase);
	void STATIC_ShortClientAdjustPositionNoInterp(float TimeStamp, const struct FName& NewState, TEnumAsByte<EPhysics> newPhysics, float NewLocX, float NewLocY, float NewLocZ, class AActor* NewBase);
	void STATIC_ClientAdjustPosition(float TimeStamp, const struct FName& NewState, TEnumAsByte<EPhysics> newPhysics, float NewLocX, float NewLocY, float NewLocZ, float NewVelX, float NewVelY, float NewVelZ, class AActor* NewBase);
	void STATIC_ClientAdjustPositionNoInterp(float TimeStamp, const struct FName& NewState, TEnumAsByte<EPhysics> newPhysics, float NewLocX, float NewLocY, float NewLocZ, float NewVelX, float NewVelY, float NewVelZ, class AActor* NewBase);
	void LongClientAdjustPosition(float TimeStamp, const struct FName& NewState, TEnumAsByte<EPhysics> newPhysics, float NewLocX, float NewLocY, float NewLocZ, float NewVelX, float NewVelY, float NewVelZ, class AActor* NewBase, float NewFloorX, float NewFloorY, float NewFloorZ);
	void LongClientAdjustPositionNoInterp(float TimeStamp, const struct FName& NewState, TEnumAsByte<EPhysics> newPhysics, float NewLocX, float NewLocY, float NewLocZ, float NewVelX, float NewVelY, float NewVelZ, class AActor* NewBase, float NewFloorX, float NewFloorY, float NewFloorZ);
	void RecievedServerMovement(float TimeStamp, bool bNoInterp);
	void ServerAckNoSmoothCorrection(float TimeStamp);
	void STATIC_SendClientAdjustment();
	void SetNoSmoothedMovementCorrection(bool bNoSmoothedCorrections, bool bManaged);
	bool STATIC_ShouldInterpolateMovementCorrections();
	void STATIC_UpdateCameraForServerCorrectionSmoothing();
	void STATIC_SavePositionForSmoothServerCorrection();
	void STATIC_ClientUpdatePosition();
	float STATIC_GetSetDefaultFOV();
	void UpdateClientFOV();
	bool STATIC_IsBattlegroundsDeadSpectator();
	class ATgRepInfo_Player* STATIC_GetCurrentPRI();
	class ATgPawn* STATIC_GetTgPawn();
	void ClientSendPayloadMissionEvent(int nEventId, unsigned char nAttackingTaskForce, unsigned char nWinningTaskForce);
	void SendProxyDamageMessage(class AActor* TargetActor, int DamageAmount, struct FExtraDamageInfo* ExtraInfo);
	void ShowHit(class AActor* Target, float DamageAmount, struct FExtraDamageInfo* ExtraInfo);
	void STATIC_ClientOnScoredPoints(int nValue, TEnumAsByte<ERewardValueType> eType, int nPlayerId);
	void FireDebugConsoleKismetTestNode();
	void DebugDisableAllAI();
	void DebugEnableAllAI();
	void DebugNextPlayerStart();
	void SetBlur(float TargetBlurAmount, float InterpSpeed, float BlurKernelSize);
	void TestHelpTip(int HelpTipId);
	void STATIC_ClientRequestHelpText(int HelpTipId);
	class AActor* STATIC_GetPathfinderTarget();
	struct FVector STATIC_GetPathfinderStartLocation(float StartDist);
	void SpawnPathfinder();
	void ShowPathfinder(bool bEnabled, float interval);
	void STATIC_OnAllMarketplaceProductDetailsRead();
	void UpdatePartyUI();
	void TryOpenPartyUI();
	void STATIC_BlockPartySceneInput(bool bBlockInput);
	bool TryAutoLogin();
	bool STATIC_IsInGame();
	void ShowCustomGameDisallowedPopup();
	void ShowPackageNotInstalledForPartyInviteWarning();
	void ShowPartyNoLongerAvailableWarning();
	void ShowPartyFullWarning(bool bPartySession);
	void ShowUnableToReadFriendsListWarning();
	void ShowNoFriendsForPartyInviteWarning();
	void ShowCurrentUserChangeWarning(const struct FString& CurrentUser, const struct FString& LoggedInUser);
	void ShowControllerDisconnectedWarning();
	void STATIC_OnRemoteTalkerStatusChange(const struct FUniqueNetId& RemoteNetId, bool bIsTalking);
	void STATIC_OnCurrentUserChanged(unsigned char LocalUserNum, const struct FString& CurrentUser, const struct FString& LoggedInUser);
	void STATIC_OnConnectionStatusChange(TEnumAsByte<EOnlineServerConnectionStatus> ConnectionStatus);
	void STATIC_OnLoginStatusChange(TEnumAsByte<ELoginStatus> NewStatus, const struct FUniqueNetId& NewId);
	void OnControllerChanged(int ControllerId, bool bIsConnected, bool bPauseGame);
	void STATIC_OnPlayerLoggedIn();
	void ClientPlayTakeoverSecondPhaseInstructions(bool bFriendlyCapture);
	void STATIC_OpenUpgradeMenuTimer();
	void TorvaldCheck();
	void SetDesaturation(float DesiredDesaturation, float SecondsToInterpolate);
	void SetTimeDilation(float DesiredDilation, float SecondsToInterpolate);
	void ServerSetJumpZ(float NewJumpZ);
	void STATIC_SetJumpZ(float NewJumpZ);
	void SetOutlines(bool bFriendly, bool bEnemy);
	void STATIC_FrontFacingCamera(bool bEnabled);
	void STATIC_OnCardSelection(class ATgDevice* pDevice);
	void STATIC_OnDeckUpdatedOnServer(int nBotId, int nDeckIndex);
	void STATIC_ClientChangedDeck(int nBotId, int nDeckIndex);
	void STATIC_ServerRequestDeck(int nIndex, bool bIsTemplate);
	void STATIC_ClientChangedTalent(int nBotId, int nDeviceId);
	void STATIC_ServerRequestDrop(unsigned char eEquipPoint);
	void STATIC_ServerRequestTalent(int nDeviceId);
	void STATIC_ServerRequestCard(int nDeviceId, int nRank);
	void ServerAutoMelee(bool bEnabled);
	void AutoMelee(bool bEnabled);
	void ServerSetServerFlags(bool bSprint, bool bMinimapTeamVisibility, float DamageMultiplier, bool bForce3P, bool bForce1P, bool bOutOfCombatSprint);
	void SetServerFlags(bool bSprint, bool bMinimapTeamVisibility, float DamageMultiplier, bool bForce3P, bool bForce1P, bool bOutOfCombatSprint);
	void SSF(bool bSprint, bool bMinimapTeamVisibility, float DamageMultiplier, bool bForce3P, bool bForce1P, bool bOutOfCombatSprint);
	void ReloadWeaponWithFlourish();
	void ReloadWeapon();
	void STATIC_LetGoReloadWeapon();
	void STATIC_ServerReviveTeammate(class ATgPawn* TeammatePawn);
	void STATIC_ReviveTeammate(class ATgPawn* TeammatePawn);
	bool STATIC_IsInFreeCam();
	class ATgPawn* STATIC_GetTeammateToRevive();
	bool TryToReviveTeammate();
	void HandleWalking();
	void STATIC_ClientSetForced3p(bool b3pEnabled);
	void STATIC_ServerNotifyClient3p(bool b3pEnabled);
	void SetForced3pFreeCam(bool bEnabled);
	bool STATIC_IsClient3pEnabled();
	bool CanToggleClient3p();
	void ToggleClient3p();
	void ToggleMount();
	void STATIC_OnJumpHeldAltPressed();
	void STATIC_OnJumpRelease();
	void STATIC_HoldJump();
	void DoJumpOnDoubleJetpack();
	void STATIC_ServerStartLaunch(float PowerLevel);
	void STATIC_StartCatapultLaunch(float PowerLevel);
	void DoJump();
	void STATIC_RequestDeploy(const struct FVector& vLocation);
	void STATIC_ServerDeployFromZeppelin();
	void STATIC_ClientPlayRoadkillNotify();
	void STATIC_PlayEpicFatality(unsigned char TaskForceNumber, int MeshAsmId);
	void ToggleDetailedView();
	bool STATIC_IsPawnWithin(class APawn* aPawn, float Distance);
	void SetCommandBindPC(bool bSpectator, int nAlternate, const struct FString& ExtendedBinding, const struct FString& Command);
	void SetBindPC(bool bSpectator, const struct FString& ExtendedBinding, const struct FString& Command);
	void UnbindCommandAllPC(bool bSpectator, const struct FString& Command);
	void UnbindCommandPC(bool bSpectator, int nAlternate, const struct FString& Command);
	class UTgSpectatorInput* STATIC_GetSpectatorInputClass();
	class UTgPlayerInput* STATIC_GetPlayerInputClass();
	void RemoveAdditionalPostProcess(class UPostProcessChain* PP, class ATgPawn* OtherDepthTarget);
	void STATIC_InsertAdditionalPostProcess(class UPostProcessChain* PP, bool bAlterMeshDepth, class ATgPawn* OtherDepthTarget);
	void STATIC_IgnoreOverlays(bool bIgnore);
	void STATIC_OnScoreChange(int nTeam);
	void STATIC_ArenaCrowdEvent(unsigned char EventType);
	void PlayTutorialAnnouncement(int SoundIndex, class USoundCue* OptionalCue, bool bPlayImmediately, bool bFlushOthers);
	void SetAllowAnimationFrameRateLOD(bool Value, float lLODDistanceFactor, int lLODFrameRate);
	void SetAllowParticleSystems(bool Value);
	void AllowRagdollUpdated();
	bool AllowRagdoll();
	void ServerToggleAIDebug(class AActor* Target);
	void ServerRequestScoreBoard();
	void ResetGameTips();
	void SuppressHelpText();
	void RequestScoreBoard();
	void UpdateLockedTarget(class AActor* LockedActor);
	void ServerSurrender(bool bSurrender);
	void STATIC_ClientSurrender(bool bSurrender);
	void STATIC_ClientPlayPing(float X, float Y, float Z, TEnumAsByte<EPING_TYPE> pingType);
	void STATIC_ClientPlayVGS(int nId, int usedVPSetting);
	bool STATIC_OnInstantCastOffhandSlotPressed(TEnumAsByte<ETG_EQUIP_POINT> eqp);
	bool STATIC_OnQuickCastOffhandSlotReleased(TEnumAsByte<ETG_EQUIP_POINT> eqp);
	bool STATIC_OnQuickCastOffhandSlotPressed(TEnumAsByte<ETG_EQUIP_POINT> eqp);
	bool STATIC_OnDefaultCastOffhandSlotReleased(TEnumAsByte<ETG_EQUIP_POINT> eqp);
	bool STATIC_OnDefaultCastOffhandSlotPressed(TEnumAsByte<ETG_EQUIP_POINT> eqp);
	bool STATIC_OnOffhandSlotReleasedGamepad(TEnumAsByte<ETG_EQUIP_POINT> eqp);
	bool STATIC_OnOffhandSlotPressedGamepad(TEnumAsByte<ETG_EQUIP_POINT> eqp);
	bool STATIC_OnOffhandSlotReleased(TEnumAsByte<ETG_EQUIP_POINT> eqp);
	bool STATIC_OnOffhandSlotPressed(TEnumAsByte<ETG_EQUIP_POINT> eqp);
	void STATIC_OnPerCharacterAltPressed();
	void STATIC_OnFlourish();
	void STATIC_OnRespawnBeaconButtonReleased();
	void STATIC_OnRespawnBeaconButtonPressed();
	void SprintIfICan(float DeltaTime);
	void DoSprint();
	void DoCrouch();
	void STATIC_DeviceOnStopFire(class ATgDevice* Device, bool WasInterrupted);
	void STATIC_DeviceOnStartFire(class ATgDevice* Device);
	void STATIC_DeviceOnStopBuildup(class ATgDevice* Device, bool WasInterrupted);
	void STATIC_DeviceOnStartBuildup(class ATgDevice* Device);
	void AllocateAbilitySkillPoint(TEnumAsByte<ETG_EQUIP_POINT> eqp);
	void STATIC_OnGiveFullVitals(class UTgSeqAct_GiveFullVitals* inAction);
	void STATIC_GivePlayerFullVitals();
	void ClientTutorialHighlighter(bool bShow, int highlightedElement);
	void ClientForceTutorialAction(int Action, int ActionElement);
	void STATIC_OnTutorialHighlighter(class UTgSeqAct_TutorialHighlighter* inAction);
	void STATIC_OnForceClientTutorialAction(class UTgSeqAct_ForceClientTutorialAction* inAction);
	void STATIC_ClientNotifyTutorialUIEvent(int Evt, int evtData);
	void ServerNotifyTutorialUIEvent(int Evt, int evtData);
	void STATIC_OnTutorialPlayerAction(class UTgSeqAct_LogTutorialAction* inAction);
	void TestShake(int Index);
	void StopTgCameraShake(class UTgCameraShake* CameraShake);
	void STATIC_PlayTgCameraShake(class UTgCameraShake* CameraShake, const struct FVector& Epicenter, class AActor* ShakeInstigator);
	void TestTgCameraShake(class UTgCameraShake* CameraShake);
	void STATIC_OnTgCameraShake(class UTgSeqAct_TgCameraShake* inAction);
	void STATIC_Cloth(bool bEnabled);
	void DoFade(bool bInToGameplay, float Time);
	void STATIC_OnClientLoadDevices(class UTgSeqAct_ClientLoadDevices* Action);
	void STATIC_ClientSetCameraMode(const struct FName& NewCamMode);
	void STATIC_ServerCamera(const struct FName& NewMode);
	void Camera(const struct FName& NewMode);
	void ClientCheatFly(bool bOn);
	void STATIC_CheatFly(bool bOn);
	void STATIC_ServerUpdateStats();
	bool STATIC_CanCommunicate();
	void STATIC_SpeakTTS(const struct FString& S, class APlayerReplicationInfo* PRI);
	void DumpClassInfo(const struct FString& sClassName);
	void TestCrash();
	bool CanPlayerMove(class APawn* P);
	class ATgRepInfo_TaskForce* STATIC_GetTFRI();
	void ServerCycleTeammateView(bool bForward);
	void EndWatchingTeam();
	void StartWatchingTeam();
	void ViewPreviousTeammate();
	void ViewNextTeammate();
	void SkipKillCam();
	void EndTimelapsePlayback();
	void ServerSkipKillCam();
	void ForceKillCamViewTargetChange(class AActor* ForceTarget);
	void ClearKillCamTarget();
	void ClientSetKillCamTarget(int KillCamTargetId, int BackupKillCamTargetId);
	void SetKillCamTarget(class ATgPawn* KillCamTarget);
	void STATIC_KillCurrentDirectorMatinee();
	void ServerKillCurrentDirectorMatinee();
	void STATIC_ClientKillCurrentDirectorMatinee();
	void STATIC_NotifyDirectorControl(bool bNowControlling, class USeqAct_Interp* CurrentMatinee, float fFadeTime);
	void DestroySimulatedProjectiles();
	void STATIC_OnPostTimeLapse();
	void STATIC_OnPreTimeLapse();
	void STATIC_ControllerPostTimeLapse();
	void STATIC_ControllerPreTimeLapse();
	void STATIC_OnBroadcastRemaining(int Team1, int Team2);
	void STATIC_OnBroadcastKill(const struct FString& sKiller, const struct FString& sVictim, int nDeviceId);
	void ClientDebugPlayPotg();
	void StartPlayOfGamePlayback();
	void StartPlayOfTheGamePlaybackDelayed();
	void StartTimelapsePlayback(float BeginTimeOffset, float EndTimeOffset, bool bPlayOfGame);
	void ServerStartTimelapse(float Begin, float End, bool bPlayOfGame, bool bForced);
	void StartTimelapse(float Begin, float End, bool bPlayOfGame, bool bForced);
	void SavePlayOfGame(float Begin, float End);
	void ServerStorePlayOfGame(float Begin, float End);
	void StorePlayOfGame(float Begin, float End);
	void STATIC_GetServerValue(const struct FString& strObject, const struct FString& strVariable);
	void STATIC_GetClientValue(const struct FString& strObject, const struct FString& strVariable);
	void SetServerValue(const struct FString& strObject, const struct FString& strVariable, const struct FString& StrValue);
	void SetClientValue(const struct FString& strObject, const struct FString& strVariable, const struct FString& StrValue);
	void ServerGetValue(const struct FString& strObject, const struct FString& strVariable);
	void ClientGetValue(const struct FString& strObject, const struct FString& strVariable);
	void ServerSetValue(const struct FString& strObject, const struct FString& strVariable, const struct FString& StrValue);
	void ClientSetValue(const struct FString& strObject, const struct FString& strVariable, const struct FString& StrValue);
	void ServerKillPets();
	void STATIC_KillPets();
	void ServerGotoFly();
	void STATIC_GotoFly();
	void StunTypeChanged();
	void Stun(bool bStunController, TEnumAsByte<EStunType> eType);
	void ClientResetStunnedBehavior(bool bStunController, TEnumAsByte<EStunType> eType);
	bool ShouldStunChangePhysics();
	void STATIC_OnRestartPlayers(class UTgSeqAct_RestartPlayers* inAction);
	bool ClientPerformedUseAction();
	bool ServerPerformedUseAction();
	void STATIC_ServerRequestClassChange(int nClassID);
	void ClientUse();
	void STATIC_ServerUse();
	bool CanUseNow();
	void UpdateReviveTimeRemaining(float fTimeRemaining);
	void ViewObjectiveCamerasTimer();
	struct FName STATIC_GetStateNameEx();
	void STATIC_ReplicatedEvent(const struct FName& VarName);
	void UpdateFirstValidProjIdx();
	void STATIC_OnCanPurchaseItemChange();
	void PawnDied(class APawn* P);
	void ClientSetReadyState(bool bReadyToPlay);
	void ServerSetReadyToPlay();
	void SetReadyToPlay();
	void STATIC_CancelCrouch();
	void SprintPenalty();
	void STATIC_CancelSprint(bool applySprintPenalty);
	void STATIC_CheckJumpOrDuck();
	void STATIC_NotifyJumpApex();
	void UpdateAssistModeSubLevel();
	void EnableColorBlindEffect(bool bEnable, int Type, bool bSimulate);
	void STATIC_OnSettingsChanged(class UTgClientSettings* Settings, int settingsType);
	void STATIC_ReceivedPlayer();
	void STATIC_OnCameraPostureChange();
	bool PopCameraPosture(int nStackId);
	int PushCameraPosture(TEnumAsByte<ETG_CAMERAPOSTURE> eCamPosture);
	void SwitchCamera(const struct FString& sCamera);
	void SwitchControl(class UClass* ControlModuleClass);
	void PostBeginPlay();
	void ShowChampionOverviewTip();
	void ServerToggleSceneCaptureState();
	int STATIC_GetCurrentDeviceType();
	TEnumAsByte<ETG_EQUIP_POINT> STATIC_GetCurrentEqPoint();
	class ATgDevice* STATIC_GetEqPointDevice(TEnumAsByte<ETG_EQUIP_POINT> eEqPoint);
	class UTgDeviceFire* STATIC_GetEqPointDevFire();
	bool STATIC_IsValidTarget(class AActor* HoverActor);
	bool STATIC_IsTargetDied(class AActor* TargetActor);
	bool STATIC_IsTargetInPawnAim(const struct FVector& TargetLocation, float MaxAimFeetOffset);
	bool STATIC_IsTargetInFrontOfPawn(const struct FVector& TargetLocation);
	struct FRotator GetAdjustedAimFor(class AWeapon* W, const struct FVector& StartFireLoc);
	struct FRotator STATIC_ApplyAimVectorModification(class ATgDevice* Device, const struct FRotator& InRotation);
	void STATIC_ClientSetOnlineStatus();
	void DisplayHiddenActorsTimer();
	void DisplayHiddenActors(float Time);
	bool CanAFK(class ATgPawn* ThePawn);
	void ServerToggleAFK(bool bEnabled);
	void STATIC_GoAFKTimer();
	void STATIC_PlayerTick(float DeltaTime);
	void STATIC_InitInputSystem();
	bool STATIC_IsForceFeedbackEnabled();
	void STATIC_SetPlayerTeam(class ATeamInfo* NewTeam);
	void STATIC_TeamTalk();
	void STATIC_Talk();
	float STATIC_GetOutroTime();
	void STATIC_ClientGameEnded(class AActor* EndGameFocus, bool bIsWinner);
	void GameHasEnded(class AActor* EndGameFocus, bool bIsWinner);
	void EndIntro();
	void SetupIntro();
	void STATIC_ResetPlayer();
	void PlayIntro();
	void PrepareIntro();
	void ClientPlayIntro();
	void ClientSetGameWinState(TEnumAsByte<EGAME_WIN_STATE> gameWinState);
	void STATIC_NativeClientSetGameWinState(TEnumAsByte<EGAME_WIN_STATE> gameWinState);
	void STATIC_SendClientSetGameWinState(TEnumAsByte<EGAME_WIN_STATE> gameWinState);
	void FindGoodView();
	void STATIC_GoSpectate();
	void AddNavFailedAlert(bool bAlreadyThere);
	void ShowPathTo(class AActor* destActor);
	void ClientShowPathTo(class AActor* destActor);
	void STATIC_OnNavIndicator(class UTgSeqAct_NavIndicator* Action);
	void ShowPathToNearestPOI();
	void ServerSetZoomFactor(float fZoom);
	void ZoomOut();
	void ZoomIn();
	class UTgCameraModule* STATIC_GetCurrentCameraModule();
	void ServerViewPlayerByName(const struct FString& PlayerName);
	void STATIC_DoSetViewTarget(class AActor* NewTarget);
	void ViewPlayerByName(const struct FString& PlayerName);
	void STATIC_ServerSetViewPRI(class ATgRepInfo_Player* pPRI);
	void SetViewPRI(class ATgRepInfo_Player* pPRI);
	void ServerViewAPlayer(int Dir, bool bFriendlyOnly);
	void HandleViewTargetOnAdjustPosition();
	void STATIC_ServerViewPrevPlayer(bool bFriendlyOnly);
	void STATIC_ServerViewNextPlayer(bool bFriendlyOnly);
	float STATIC_GetFOVAngle();
	int BlendRot(float DeltaTime, int BlendC, int NewC);
	void ClientEnterStartState();
	void EnterStartState();
	bool AllowVoiceMessage(const struct FName& MessageType);
	void AddPostRenderActors();
	void STATIC_ClientSetHUD(class UClass* newHUDType);
	void STATIC_ConfirmHUD(class UClass* newHUDType);
	void GetPlayerViewPoint(struct FVector* POVLocation, struct FRotator* POVRotation);
	void STATIC_GetAimingViewPoint(struct FVector* POVLocation, struct FRotator* POVRotation);
	bool STATIC_UsingFirstPersonCamera();
	void SetRadius(float NewRadius);
	void STATIC_ClientReset();
	void STATIC_Reset();
	void STATIC_ClientSetCinematicMode(bool bInCinematicMode, bool bAffectsMovement, bool bAffectsTurning, bool bAffectsHUD);
	void STATIC_SetCinematicMode(bool bInCinematicMode, bool bHidePlayer, bool bAffectsHUD, bool bAffectsMovement, bool bAffectsTurning, bool bAffectsButtons);
	void OnToggleCinematicMode(class USeqAct_ToggleCinematicMode* Action);
	void DisplayDebug(class AHUD* HUD, float* out_YL, float* out_YPos);
	void STATIC_DisplayKillingBlowGameTip(const struct FCombatMessageInfo& Info);
	void FadeForViewPlayersTimer();
	void ViewPlayersTimer();
	bool STATIC_IsViewedTeamAlive();
	void ReviveTimer();
	void STATIC_LiveRespawn(bool bResetHealth, bool bResetDevices);
	void STATIC_Revive();
	void STATIC_LadderLetGo();
	void ServerLadderLetGo();
	void STATIC_RestartPlayerOnTransfer();
	void CancelInBombRange();
	void STATIC_NotifyInBombRange();
	void ClientNotifyBodyUnderAttack(unsigned char Damage);
	void STATIC_NotifyBodyUnderAttack(unsigned char Damage);
	void STATIC_UnPossess();
	void STATIC_Possess(class APawn* aPawn, bool bVehicleTransition);
	void STATIC_ServerAcknowledgePossession(class APawn* P);
	void STATIC_AcknowledgePossession(class APawn* P);
	void SetControlModuleOnPossess();
	void STATIC_PreRender(class UCanvas* Canvas);
	void STATIC_CopyPropertiesTo(class AController* C);
	void STATIC_CleanupPRI();
	void InitPlayerReplicationInfo();
	void Destroyed();
	void STATIC_ClientSellItem(int nInventoryId);
	void STATIC_ClientPurchaseItem(int nLootTableId, int nLootTableItemId, int nItemCount);
	void STATIC_ResetViewOrientation();
	void STATIC_PressJump(bool bOn);
	void ServerProfiling(const struct FString& Command);
	void ServerProfileScript(const struct FString& Command);
	void SelfAlert(int nPriority, float fDuration, int nMsgId);
	void RemoveAlertScript(int nMsgId);
	void AddAlertScript(TEnumAsByte<EAlertPriority> Priority, TEnumAsByte<EAlertType> Type, float fDuration, int nMsgId, bool bBlockDuplicates);
	void STATIC_ClientSetRotationAndDesired(const struct FRotator& NewRotation, bool bResetCamera);
	void ServerRove(bool bOn);
	void ToggleRove();
	void STATIC_ServerViewSelf(const struct FViewTargetTransitionParams& TransitionParams);
	void ServerWatchOtherPlayer(TEnumAsByte<EWatchOtherPlayersMode> Mode);
	void StopWatchOthers();
	void StartWatchOthers(TEnumAsByte<EWatchOtherPlayersMode> Mode);
	void SetCorrectViewTarget();
	void ServerSetViewTarget(class AActor* me);
	void STATIC_OnInGamePing();
	void STATIC_OnRightMouseReleased();
	void STATIC_OnRightMousePressed();
	void StopFireMouse(bool bLeftMouse);
	void TryFire(bool bLeftMouse);
	void STATIC_OnLeftMouseReleased();
	void STATIC_OnLeftMousePressed();
	void STATIC_TryPing();
	void CCE(const struct FName& EventName);
	void STATIC_CauseClientEvent(const struct FName& EventName);
	void RemoveScreenCapturePostProcess();
	void TestScreenCapturePostProcess();
	void WhereAmI();
	void AddAutoKickAlert();
	void AddAssistAlert(const struct FString& KilledName, const struct FString& KillerName);
	void AddKillAlert(const struct FString& KilledName, const struct FString& KillerName, bool KillerWasPlayer);
	void ServerSetToggleZoom(bool bToggleZoom);
	void SetToggleZoom(bool bToggleZoom);
	void ServerSetAutoSkillUp(bool bAutoSkill);
	void STATIC_SetAutoSkillUp(bool bAutoSkill);
	void ServerSetAutoPurchase(bool bAutoPurchase);
	void STATIC_SetAutoPurchase(bool bAutoPurchase);
	void SetCanPurchaseFlag(bool bCanPurchase);
	void SetCanChangeLoadout(bool bCanChangeLoadout);
	void ShowBinoculars(bool bShow);
	void SetTaskforceLead(const struct FString& fsName);
	void ShowRespawnTimerExpired();
	void STATIC_RequestShowRespawnBuyback();
	void STATIC_ClientShowRespawnBuyback(int nCost);
	void STATIC_ClientOnBroadcastRemaining(int FriendlyTeam, int EnemyTeam);
	void STATIC_ClientOnBroadcastKill(const struct FString& sKiller, const struct FString& sVictim, int nDeviceId);
	void ClientPlaySoundBase(class UAkBaseSoundObject* ASound);
	void STATIC_ClientPlaySound(class USoundCue* ASound);
	void STATIC_Logoff(bool bForced);
	void STATIC_AllocateDevicePoint(int nDeviceId);
	void STATIC_CallServerMove(class USavedMove* NewMove, const struct FVector& ClientLoc, unsigned char ClientRoll, int View, class USavedMove* OldMove);
	void STATIC_TurnOffBigHeadVGSVoice();
	void SetAudioFriendlyAndLocal();
	void ServerMove(float TimeStamp, const struct FVector& InAccel, const struct FVector& ClientLoc, unsigned char MoveFlags, unsigned char ClientRoll, int View);
	void ReloadKeybindsForPawn();
	void SetPlayerWard(int nWardSkinId);
	void SetPlayerProfile(int nProfileId, int nSkinId, int nWeaponSkinId, int nHeadSkinId, int nVoicePackId);
	void SetLevel(int nLevel);
	bool STATIC_OnRespawnRuleChanged();
	float StartReviveTimer(bool bDoNotUpdateStatsTracker);
	void SetNWCondition(int nPktLoss, int nPktLag);
	void TestCrashReport();
	class UMaterialInstanceConstant* STATIC_GetMICResource(int nResourceId);
	bool STATIC_IsTeamDead();
	bool STATIC_IsInCustomGame();
	void STATIC_OnFallOutofNamedArea(const struct FString& sNamedArea);
	void STATIC_OnExitNamedArea(const struct FString& sNamedArea);
	void STATIC_OnFallIntoNamedArea(const struct FString& sNamedArea);
	void STATIC_OnEnteredNamedArea(const struct FString& sNamedArea);
	void STATIC_TickFogPPFX(float DeltaSeconds);
	void STATIC_SetOnlineStatus(unsigned char LocalUserNum, const struct FString& StatusString);
	void STATIC_RevalidatePartySession();
	void CreateOrJoinPartySession();
	void STATIC_UpdateLoadProgress(float fValue);
	void SwitchClassFinished();
	void PopCurrentScene();
	bool CheckPickupSlot(TEnumAsByte<ETG_EQUIP_POINT> eEquipSlot);
	bool StartPickup(bool bAutoChooseSlot);
	void ReleasePlayerInput();
	unsigned char STATIC_GetEquippedTypeSlot(int nDeviceId);
	unsigned char STATIC_GetUpgradeSlot(class ATgDeployable* pDeployable);
	bool CanDisenchant(class ATgDeployable* pDeployable);
	bool CanEquip(class ATgDeployable* pDeployable, int* nErrorCode);
	void STATIC_OnForgeLocation(class ATgDeploy_Forge* pForgeItem);
	void STATIC_OnLootLocation(const struct FVector& vLocation, bool bShow);
	void UpdateThreatLineOfSight();
	void STATIC_NotifyUpdatedInhandAmmoCount(int nAmmo, class ATgDevice* pDevice, int nDeviceId);
	void SetReticleVisibility(bool bShowReticle, bool bShowReticleAccessories);
	void STATIC_NextScoreboardDisplayType();
	bool CanPlayKillCam(bool bPlayOfGame);
	void UpdateMinimap(class ATgMapBoundsVolume* pMapBoundsVolume);
	void SetAkWorldTimeDilation();
	void CloseHUDMenus();
	bool STATIC_IsTopMenu(const struct FName& nmName);
	void ShowAutoPurchaseTip();
	void RefreshLastActiveTime();
	bool Wants3P();
	bool ShouldHideUIHudOverlay();
	bool STATIC_IsConfused();
	class AActor* STATIC_GetBestKillCamTarget();
	void STATIC_OnScoredPoints(int nValue, TEnumAsByte<ERewardValueType> eType, int nPlayerId);
	void UIFadeEndOfRound(bool bFade, float fTime, float fDelay, float FailSafeTime);
	void STATIC_UIFade(bool bFade, float fTime, float fDelay, float FailSafeTime);
	void STATIC_OnRequestWeapon(int nIndex);
	void STATIC_OnRequestDrop(unsigned char eEquipPoint);
	void STATIC_OnRequestDeck(int nIndex, bool bIsTemplate);
	void STATIC_OnRequestTalent(int nDeviceId);
	bool STATIC_OnRequestCard(int nDeviceId, int nRank);
	void SetRewardValues(int XP, int nCredits, class AActor* Source, TEnumAsByte<ERewardValueType> RewardType, bool bFlankKill);
	void SetSelectedDeck(int nBotId, int nIndex);
	void SetSelectedTalent(int nBotId, int nDeviceIndex);
	void STATIC_LogAntiCheatPlayerState();
	void AchievementModifiedHealthProp(int nHealth, int nMaxHealth);
	void AchievementAchievedById(int nActivityId);
	void STATIC_NativeUnPossess();
	void STATIC_NativePossess(class APawn* aPawn);
	void ServerRequestGraphData();
	void ServerGiveCard(int nDeviceId);
	void STATIC_ClientAddCheats();
	void CheckHealthFX(float fCurrent, float fMaximum);
	void PlayEventFX();
	void StartFX();
	void UpdateKeybindsUI();
	void UpdateRuntimeInput(bool bSpectator);
	void ResetKeysToDefault(bool bSpectator);
	bool CheckSwap(class ATgDeployable* pDeployable, bool bSecondary);
	bool IsLocalPlayerController();
	void STATIC_LiveSpectateStop();
	void STATIC_LiveSpectate(const struct FString& sPlayerNameInstanceId);
	void SpectateStop();
	void Spectate(const struct FString& sPlayerName, const struct FString& sSpectatePassword);
	void SpectateGM(const struct FString& sPlayerName, const struct FString& sSpectatePassword);
	void STATIC_KickWarning();
	void SendCombatMessage(const struct FCombatMessageInfo& msgInfo);
	void ShowRespawnBuyback(int nCost);
	void SetBinocularSettings(const struct FBinocularSettings& BinocSettings);
	void SetSniperChargedMeter(float fPercent);
	void SetHUDOverlay(TEnumAsByte<EHUDOverlay> eOverlay);
	void UpdateTransitionUI();
	void UpdatePlayerVitalsUI();
	void ToggleMiniMapPing(bool bStart);
	void ClearTargetingList();
	void UpdateTargetingList(TArray<struct FImpactInfo> ImpactList, bool bLightUp);
	void STATIC_OnSceneLoadChange(const struct FString& SceneName, bool bLoaded);
	bool STATIC_IsTutorialBlockingAction(TEnumAsByte<EeTutorialForceableElements> Action);
	bool STATIC_HandleTutorialActionOnServer(class UTgSeqAct_ForceClientTutorialAction* inAction);
	void STATIC_HandleTutorialHighlighter(bool bShow, int highlightedElement);
	void STATIC_HandleForcedClientTutorialAction(int nAction, int nActionElement);
	void TriggerTutorialEvent(int nTutEvent, int nInfoData);
	void STATIC_LogTutorialAction(int nPlayerAction, int nEventData);
	void ChangeClass(int nClassID);
	void ClientLogoff(bool bForced);
	void FadeHud();
	void ServerPlayPing(float X, float Y, float Z, TEnumAsByte<EPING_TYPE> pingType);
	void ServerPlayVGS(int nVgsId, int usedVPSetting);
	void ServerSellItem(int nInventoryId);
	void ServerUpgradeItem(int nLootTableId, int nLootTableItemId, int nUpgradeInvId);
	void ServerPurchaseItem(int nLootTableId, int nLootTableItemId, int nItemCount);
	bool STATIC_IsFiringUlt();
	int STATIC_GetTaskForceNumber();
	void ClientUpdateTutorialBlockingActions();
	bool ClientUpdateUIDeviceState();
	void ServerAllocateDevicePoint(int nDeviceId);
	bool STATIC_HaveBasicAbilitiesBeenActivated();
	int STATIC_GetDevicePointsSpent();
	int STATIC_GetDevicePointsAvailable();
	bool CanAllocateDevicePoint(int nDeviceId, class ATgDevice* aDevice, bool ignorePause);
	int STATIC_GetPerkPointsSpent();
	int STATIC_GetPerkPointsAvailable();
	TEnumAsByte<EGiveGoldResult> ServerTransferGoldBetweenFriendlyPlayers(int ReceivingPlayerID, int GoldCount);
	TEnumAsByte<EGiveGoldResult> STATIC_GiveGoldToFriendlyPlayer(int PlayerID, int GoldCount);
	void SetToggleZoomFlag(bool bOn, bool bForce);
	void SetAutoSkillUpFlag(bool bOn, bool bForce);
	void SetAutoPurchaseFlag(bool bOn, bool bForce);
	void ToggleZoom();
	void AutoSkillUp();
	void AutoPurchase();
	void CheckInterfaceError(unsigned char eType);
	void STATIC_GetDamageAngle(const struct FRotator& HitDir, float* PitchDegrees, float* YawDegrees);
	void SendUICurrencyChange();
	void SendUIXpChange();
	void STATIC_HandleSimulatedProjectile();
	void DebugGetLangMsg(int nMsgId);
	void STATIC_SetSoundMode(const struct FName& NewSoundMode);
	void DumpPerfTrackData();
	void TgPerfTrack(bool bStart);
	void SetPawnTickState(int nState);
	void ToggleTick(const struct FString& ClassName, bool bDisable);
	void DoClientSidePerfTracking(int nLength);
	void STATIC_OutputRelevantActors();
	void BlockVGS(bool bBlock);
	bool CheckMaxEffectDistance(class APlayerController* P, const struct FVector& SpawnLocation, float CullDistance);
	void ConvertTimeDisplay(int nMinutes, struct FString* sDisplay);
	class ATgPawn* STATIC_GetPlayerControlPawn();
	void SendGameOverEvent(TEnumAsByte<EGAME_WIN_STATE> gameWinState, bool bPlayerIsAttacker);
	void DumpClassInfoToFile(const struct FString& sClassName);
	void ClientLoadDevices(class UTgSeqAct_ClientLoadDevices* Action);
	int STATIC_GetDeviceIdByName(const struct FString& sDeviceName);
	void SetValue(const struct FString& fsObject, const struct FString& fsVariable, const struct FString& fsValue);
	void STATIC_GetValue(const struct FString& fsObject, const struct FString& fsValue);
	bool STATIC_bIsEditor();
	void ForceRelevant(class AActor* pActor, float fDuration);
	void FinalSave();
	void ToggleCombatInfo();
	void SpectateOutlines(bool bShow);
	void SpectateXP(bool bShow);
	void SpectateGold(bool bShow);
	void SpectateCrits(bool bShow);
	void SpectateHeals(bool bShow);
	void SpectateDamage(bool bShow);
	void DisableProfanityFilter(bool bDisable);
	void ToggleInHandTargeting(bool bHide);
	void StopLogTo();
	void STATIC_LogTo(const struct FString& fsHost, int nPort);
	void _Crash();
	void Bug();
	class UTgClientSettings* STATIC_GetClientSettings();
	void STATIC_MatchAccept(bool bAccepted);
	void STATIC_MatchLeave(bool bAsTeam);
	void ConfirmMatchLeave(bool bLeave);
	void Friend(const struct FString& sCmd, const struct FString& sName);
	void ServerSetTaskforceLead(const struct FString& fsName);
	bool CanCameraSeeActorCenter(class AActor* Other, float ZOffset);
	bool CanCameraSeePawnCenter(class ATgPawn* Other);
	class UClass* STATIC_GetHudClass(class UClass* pNewHudType);
	void StoreOfflineData();
	void TestVGSPOTG(int nPackId, int nBotId, int nSkinId);
	void STATIC_LogPerfLeakData();
	void STATIC_NativeAnnounceEOM(bool bVictory);
	bool SeesInViewFrustum(class AActor* aOther, float fViewDist);
	void PlayNotifySound(TEnumAsByte<ENotifySound> eSound);
	void AnnouncerPlayFogLine();
	void PlayAnnouncerEvent(class UAkEvent* akSound, bool bForce);
	void PlayMessageAkEvent(const struct Fdword& dwMsgId);
	bool AnnouncerPlaySeries(TEnumAsByte<EAnnouncerSeries> series, int Step);
	void AnnouncerReset();
	int AnnouncerGetStep(TEnumAsByte<EAnnouncerSeries> series);
	bool STATIC_IsInGameType(int nGameType);
	void QueueReviveTimeChanged();
	bool STATIC_IsReadyForStart();
	void CanDoFullSellback();
	void SetViewTarget(class AActor* NewViewTarget, const struct FViewTargetTransitionParams& TransitionParams);
};


// Class TgGame.TgBattleCheatManager
// 0x0020 (0x00C0 - 0x00A0)
class UTgBattleCheatManager : public UPComCheatManager
{
public:
	class ATgDemoRecSpectator_Debug*                   m_DebugCameraController;                                  // 0x00A0(0x0008)
	TArray<class APlayerStart*>                        m_DebugPlayerStarts;                                      // 0x00A8(0x0010) (NeedCtorLink)
	class APlayerReplicationInfo*                      m_LastGotoPRI;                                            // 0x00B8(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgBattleCheatManager");
		return ptr;
	}


	void STATIC_QuickEndTutorial();
	void STATIC_TestSubtitle(int nMessageId, float fTime);
	void STATIC_TestWaveform(class UForceFeedbackWaveform* FFWaveform, float fScale, float fScaleDuration);
	void STATIC_ShowPathToNearestChest();
	void STATIC_MountAll();
	void ToggleDevStats();
	void DoCustomSpray(int nIndex);
	void STATIC_SetCustomSpray(int nIndex, int nCustomSprayId);
	void DoCustomEmote(int nIndex);
	void SetCustomEmote(int nIndex, int nCustomEmoteId);
	void Spray();
	void SetSpray(int nSprayId);
	void TestCircles();
	void STATIC_CloseChest();
	void DropArmorPotion();
	void DropHealthPotion();
	void STATIC_GiveShards(int Count);
	void PlaceOnTopOfTarget(bool bSkydive, float fHeight);
	void Skydive(float fHeight);
	void SetTickGroupCount(int nTickGroupCount);
	void SetGuaranteedTickDistance(float fDistance);
	void ToggleTickThrottling();
	void DropInventory();
	void BugItGo(float X, float Y, float Z, int Pitch, int Yaw, int Roll);
	void STATIC_GoToPlayer(int Dir, bool bGoblin);
	void STATIC_KillAllButTrace();
	void STATIC_FreezeAllButTrace();
	void STATIC_GoToPrevGoblin();
	void STATIC_GoToNextGoblin();
	void STATIC_GoToPrevPlayer();
	void STATIC_GoToNextPlayer();
	void SetPawnLoc(float X, float Y, float Z);
	void STATIC_gputest8();
	void STATIC_gputest7();
	void STATIC_gputest6();
	void STATIC_gputest5();
	void STATIC_gputest4();
	void STATIC_gputest3();
	void STATIC_gputest2();
	void STATIC_gputest1();
	void STATIC_SetBotFireRate(float Pct);
	void STATIC_SetBotDamageMitigation(float Pct);
	void STATIC_Log3pOffset();
	void Adjust3pOffset(int X, int Y, int Z);
	void FTZombie(bool bEnabled);
	void FTPlayerInit();
	void ResetDebugPropertyMods(const struct FString& sProperty);
	void ApplyDebugPropertyMod(const struct FString& sProperty, bool bPercent, float fModifier1, float fModifier2, float fModifier3, float fModifier4, float fModifier5, float fModifier6);
	struct FString STATIC_GetBotNameFromAlias(const struct FString& sBot);
	void DrawActorEncroachmentFire(bool bDraw);
	void DisableEffectLagCompensation();
	void EnableEffectLagCompensation();
	void _SetVoicePack(int nVoicePackId);
	void SetVoicePack(int nVoicePackId);
	void _SetContrailSkin(int nSkinId);
	void _SetDownedSkin(int nSkinId);
	void _SetMountSkin(int nSkinId);
	void SetContrailSkin(int nSkinId);
	void SetDownedSkin(int nSkinId);
	void SetMountSkin(int nSkinId);
	void PlayIntroAnim();
	void SetFogDistance(int Distance);
	void EnableAI(bool bEnabled);
	void STATIC_LockPotG(bool bLocked);
	void ResetPotG();
	void PlayPotGForAll();
	void PlayPotG();
	void AllowMount(bool bEnabled);
	void TSHM(int nHeadMeshID);
	void TargetSetHeadMesh(int nHeadMeshID);
	void TSBM(int nBodyMeshID);
	void TargetSetBodyMesh(int nBodyMeshID);
	void TSM(int nBodyMeshID, int nHeadMeshID);
	void TargetSetMeshes(int nBodyMeshID, int nHeadMeshID);
	void ToggleHeadMesh();
	void EnableHeadMesh(bool bEnabled);
	void decapitate();
	void rhm();
	void RemoveHeadMesh();
	void SHBN();
	void SetHeadMeshByName();
	void SHM(int nHeadMeshID);
	void STATIC_ToggleChicken();
	void SetHeadMesh(int nHeadMeshID);
	void SBMBN();
	void SetBodyMeshByName();
	void SBM(int nBodyMeshID);
	void SetBodyMesh(int nBodyMeshID);
	void STATIC_LiveRespawn(bool bResetHealth, bool bResetDevices);
	void AllowHeadShots(bool bEnable);
	void AllNoah(const struct FString& ChannelName);
	void ShowThreats(bool bEnabled, const struct FString& ChannelName);
	void DisplayThreatParams();
	void EnableOcclusion(bool bEnabled);
	void EnableThreat(bool bEnabled);
	void SetAIAccuracy(float DegreeMissed, float MissLikelihood);
	void GainXP(int xpAmount);
	void Toggle3p();
	void Set3p(bool bForce3P);
	void Set1p(bool bForce1P);
	void STATIC_LevelAim();
	void FRSE();
	void ForceRoundSetupEnd();
	void SetVaultImmuneHealth(float fHealth);
	void ToggleSiegeEngineRequiresAllies();
	void SetAutoHealingMultiplier(float NewMult);
	void SetGroundSpeedMultiplier(float NewMult);
	void SetDamageMultiplier(float NewMult);
	void DumpLastClientAims();
	void DumpLastServerAims();
	void DumpWeaponPredictionStats();
	void SetMaximumLagPrediction(float NewMaximum);
	void ToggleWeaponLagPrediction();
	void SetInstantFireMeshTrace(bool bEnabled);
	void TestSpawnPoints(float PauseTime);
	void SetFlyingFriction(float frictionAmt);
	void SetFallingFriction(float frictionAmt);
	void SetAirFriction(float frictionAmt);
	void SetGameRespawnRule(TEnumAsByte<EGameRespawnRule> Rule);
	void SetGameEnvironmentRule(TEnumAsByte<EGameEnvironmentRule> Rule);
	void STATIC_HelpMe();
	void STATIC_GiveCard(int nDeviceId);
	void DisableProximity(bool bEnabled);
	void ShowProjectileDebug(bool bEnabled);
	void StopHP5();
	void ShieldTarget(int Amount);
	void STATIC_HealTarget(int HealAmount);
	void DamageTarget(int DamageAmount);
	void PossessTarget();
	void STATIC_Heal(int HealAmount);
	void DamageHealth(int DamageAmount);
	void SetMana(int mana);
	void SetHealth(int Health);
	void STATIC_InvisMe(bool bInvis);
	void ToggleSpectatorCamera();
	void ShowPlayerCircles(bool bEnabled);
	void TestStun(TEnumAsByte<EStunType> Type);
	void TestStunEffect(float fDuration);
	void TestShowInventory();
	void SetEnergy(float Value);
	void QEG(bool bWin);
	void STATIC_QuickEndGame(bool bWin);
	void SL(int nLevel);
	void SetMeLevel(int nLevel);
	void STATIC_Obama(int nCurrency);
	void AddGold(int nCurrency);
	void RemoveAllItems();
	void RemoveAllCards();
	void RemoveDeviceAt(int nDeviceId);
	void UnequipDeviceAt(int nEquipPointId);
	void RemoveDevice(int nDeviceId);
	void UD(int nDeviceId);
	void UnequipDevice(int nDeviceId);
	void ED(int nDeviceId, int nEquipPointId, int nLevel, int FireMode);
	void EquipDevice(int nDeviceId, int nEquipPointId, int nLevel, int FireMode);
	void AEDBN(const struct FString& sDeviceName, int nEquipPointId, int nLevel, int FireMode);
	void ClearTalents();
	void EquipTalentByName(const struct FString& sDeviceName, int nIndex);
	void AddBattlePassXPReward(int nXp);
	void AddCharacterXPReward(int nXp);
	void ForgeItem(int nIndex, int nDurationOverride);
	void ETBN(const struct FString& sDeviceName, int nIndex);
	void EquipBingoByName(const struct FString& sDeviceName, int nBingoIndex);
	void EBBN(const struct FString& sDeviceName, int nBingoIndex);
	void EDBN(const struct FString& sDeviceName, int nEquipPointId, int nLevel, int FireMode);
	void EquipDeviceByName(const struct FString& sDeviceName, int nEquipPointId, int nLevel, int FireMode);
	void TEDBN(const struct FString& sDeviceName, int nEquipPointId, int nLevel, int FireMode);
	void TargetEquipDeviceByName(const struct FString& sDeviceName, int nEquipPointId, int nLevel, int FireMode);
	void TED(int nDeviceId, int nEquipPointId, int nLevel, int FireMode);
	void TargetEquipDevice(int nDeviceId, int nEquipPointId, int nLevel, int FireMode);
	void EquipDeviceOnPawn(class ATgPawn* TgP, int nDeviceId, int nEquipPointId, int nLevel, int FireMode);
	void RemoveDeviceFromPawnAt(class ATgPawn* TgP, int nEquipPointId);
	void ToggleTaskForce();
	void ct(unsigned char nTaskForce);
	void ChangeTaskForce(unsigned char nTaskForce);
	void SetMaxAmmo(int TotalSize, int ClipSize);
	void RefillAmmo();
	void ResetAimAssistKeyframes(const struct FString& keyframeType);
	void AddAimAssistKeyframe(const struct FString& keyframeType, const struct FString& KeyframeName, float Distance);
	void SetAimAssistValues(float MagnetScaleX, float MagnetScaleY, float FrictionScaleX, float FrictionScaleY, float TrackingScaleX, float TrackingScaleY);
	void ResetAimAssistValues();
	void SetAimAssistTargetWeightVars(float CurrentTargetBonus, float NotCurrentTargetPenalty, float MinAccuracyBonus, float MaxAccuracyBonus, float MinInaccuracyPenalty, float MaxInaccuracyPenalty, float MaxWeight);
	void ToggleAimAssist();
	void ShowFootstepInfo();
	void BeTheBoss();
	void ApplyProp(int nPropId, float nValue, int nCategory);
	void SpectatorCamera(bool bOn);
	void botslevel(int nLevel);
	void FreezeAI(bool bOn);
	void botsgod(bool bOn);
	void RequestRelease();
	void TestObstacleAvoidance(int TestType);
	void ToggleAIDebug(bool bAttachAIDebugger);
	void ToggleCustomPhysics();
	void ToggleDeviceLog(TEnumAsByte<ETG_EQUIP_POINT> eqp);
	void STATIC_KillAllPawnsByClass(const struct FString& PawnClassName);
	void STATIC_KillAllPawnsHelper(class UClass* PawnClass);
	void _SpawnTemplatePlayer(int nProfileId, int nSkinId, int nWeaponSkinId, int nHeadSkinId);
	void DebugProjectileLagCompensationClient();
	void DebugProjectileLagCompensationServer();
	void TestChangeClass(int nClassID);
	void ShowMoveErrors();
	void SetStealth(bool bOn);
	void SetGroundspeed(float val);
	void STATIC_GiveRecommendedItems();
	void STATIC_HookMeUp();
	void STATIC_MaxPower();
	void ForceToggleMount();
	void STATIC_Cooldown();
	void energy();
	void God();
	void CheatLog(const struct FString& cheatText, bool bOn);
	void SimNWCondition(int nPktLoss, int nPktLag);
	void STATIC_ML();
	void STATIC_MaxLevel();
	void TestSkinGallery(int nGallery);
	void SpawnBot(const struct FString& sName, int nTaskForce, int nCount, int BotDifficulty, const struct FString& BehaviorTreeName, int nSkinId, int nHeadId, int nWeaponId);
	void _SpawnBot(const struct FString& sName, int nTaskForce, int nCount);
	void stb(const struct FString& sName, const struct FString& sDeviceName, int nFireMode, int nTaskForce, int nCount);
	void SpawnEmoteTestBot(const struct FString& sName, int nTaskForce, int nCount);
	void SpawnStillBot(const struct FString& sName, int nTaskForce, int nCount, int nSkinId, int nHeadId, int nWeaponId);
	void SpawnTestBot(const struct FString& sName, const struct FString& sDeviceName, int nFireMode, int nTaskForce, int nCount);
	void ServerExec(const struct FString& FSCommand);
	void Loc();
	void echo(const struct FString& inputString);
	void FillEnergyAll(float fPercent);
	void sc(const struct FString& godName, const struct FString& SkinName, const struct FString& weaponSkinName, const struct FString& headName);
	void separator();
	void STATIC_PlayGlobalAkEvent(const struct FName& nmEvent);
	void STATIC_GivePotions(int nCount, int nSlot);
	void STATIC_ShowInventorySlot(int nSlot);
	void STATIC_ShowInventory();
	void STATIC_ShowTalents();
	void STATIC_SetForgesEnabled(bool bEnabled);
	void STATIC_SetLootGoblinEnabled(bool bEnabled);
	void SetFogTimerEnabled(bool bEnabled);
	void STATIC_SetLocation(float Fx, float fY, float fZ);
	void ToggleTransitionManifest();
	void PrecacheContrailSkin(int nSkinId);
	void PrecacheDownedSkin(int nSkinId);
	void ClearAllIconReferences();
	void STATIC_ListAllIconReferences(bool bIncludeManifests);
	void SetAILevel(class ATgAIController_BehaviorGod* aic, int nLevel);
	void SetTickets(int nAlliance, int nValue);
	void FillEnergy();
	void SpawnDeployable(int dep_id);
	void ToggleLoadFailureOutput();
	void SpawnBotAllSkins(int nBatch);
	class ATgPawn* SpawnBotByName(const struct FString& BotName, int Taskforce, int nCount, int BotDifficulty, const struct FString& BehaviorTreeName, int nSkinId, int nHeadId, int nWeaponId);
	void STATIC_NativeMaxLevel();
	void TestLanguage(const struct FString& newLangExt);
	void TestPanningRule(const struct FString& sPanningRule);
	void TestDj();
	void STATIC_ListTickableActors(TEnumAsByte<ETickingGroup> checkgroup);
	void STATIC_JoinMatchQueue(int nQueueId, int god1, int god2, int god3, int god4, int god5);
	void PurchaseGod(const struct FString& godName);
	void SwitchWard(const struct FString& wardSkinName);
	void STATIC_SwitchSkin(const struct FString& godName, const struct FString& SkinName);
	void SwitchClass(const struct FString& godName, const struct FString& SkinName, const struct FString& weaponSkinName, const struct FString& headName);
};


// Class TgGame.TgCharacterBuilderLight
// 0x0000 (0x028C - 0x028C)
class ATgCharacterBuilderLight : public ASpotLightToggleable
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCharacterBuilderLight");
		return ptr;
	}

};


// Class TgGame.TgChestManagerVolume
// 0x0064 (0x0320 - 0x02BC)
class ATgChestManagerVolume : public AVolume
{
public:
	int                                                m_nPointOfInterestId;                                     // 0x02BC(0x0004) (Edit)
	TEnumAsByte<EChestVolumeTypes>                     m_eType;                                                  // 0x02C0(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x02C1(0x0003) MISSED OFFSET
	float                                              m_fSmallChestPercent;                                     // 0x02C4(0x0004) (Config)
	TArray<struct FChestSpawnConfig>                   m_SmallPOIConfig;                                         // 0x02C8(0x0010) (Config, NeedCtorLink)
	float                                              m_fMediumChestPercent;                                    // 0x02D8(0x0004) (Config)
	TArray<struct FChestSpawnConfig>                   m_MediumPOIConfig;                                        // 0x02DC(0x0010) (Config, NeedCtorLink)
	float                                              m_fLargeChestPercent;                                     // 0x02EC(0x0004) (Config)
	TArray<struct FChestSpawnConfig>                   m_LargePOIConfig;                                         // 0x02F0(0x0010) (Config, NeedCtorLink)
	TArray<class ATgDeployableFactory*>                m_Factories;                                              // 0x0300(0x0010) (NeedCtorLink)
	TArray<struct FInternalChestInfo>                  m_InternalChestData;                                      // 0x0310(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgChestManagerVolume");
		return ptr;
	}


	void PostBeginPlay();
	void STATIC_SpawnChests();
	void CacheChests();
	void STATIC_GetAllPotentialDeployableIds(TArray<int>* DeployableIds);
};


// Class TgGame.TgClientSettings
// 0x003C (0x009C - 0x0060)
class UTgClientSettings : public UObject
{
public:
	unsigned long                                      m_bMute : 1;                                              // 0x0060(0x0004)
	unsigned long                                      MuteOnLoseFocus : 1;                                      // 0x0060(0x0004) (Config, GlobalConfig)
	unsigned long                                      EnableGyroInput : 1;                                      // 0x0060(0x0004) (Edit, Config, GlobalConfig)
	float                                              fGamma;                                                   // 0x0064(0x0004) (Config, GlobalConfig)
	float                                              SFXVolume;                                                // 0x0068(0x0004) (Config, GlobalConfig)
	float                                              MusicVolume;                                              // 0x006C(0x0004) (Config, GlobalConfig)
	float                                              VoiceVolume;                                              // 0x0070(0x0004) (Config, GlobalConfig)
	float                                              MasterVolume;                                             // 0x0074(0x0004) (Config, GlobalConfig)
	int                                                MaxSlotsPlayerSkins;                                      // 0x0078(0x0004) (Config, GlobalConfig)
	int                                                MaxSlotsChickenSkins;                                     // 0x007C(0x0004) (Config, GlobalConfig)
	int                                                MaxSlotsMountSkins;                                       // 0x0080(0x0004) (Config, GlobalConfig)
	int                                                MaxSlotsContrails;                                        // 0x0084(0x0004) (Config, GlobalConfig)
	TEnumAsByte<EAspectRatio>                          DesiredAspectRatio;                                       // 0x0088(0x0001) (Config, GlobalConfig)
	TEnumAsByte<EControlIconStyle>                     ControlIconStyle;                                         // 0x0089(0x0001) (Config, GlobalConfig)
	unsigned char                                      UnknownData00[0x2];                                       // 0x008A(0x0002) MISSED OFFSET
	TArray<struct FLOCALPROPERTY>                      LocalProperties;                                          // 0x008C(0x0010) (Config, GlobalConfig, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgClientSettings");
		return ptr;
	}


	bool UpdatePlayerMuteSetting(bool PlayerMuteSetting);
	void SetCastMode(TEnumAsByte<ECastMode> castModeVal, int nCharId, TEnumAsByte<ETG_EQUIP_POINT> EquipPoint);
	TEnumAsByte<ECastMode> STATIC_GetCastMode(int nCharId, TEnumAsByte<ETG_EQUIP_POINT> EquipPoint);
	bool WriteSaveGameDataViaInterface(unsigned char LocalUserNum, const struct FString& Title, const struct FString& SubTitle, const struct FString& Description, struct FString* SaveFileName, TArray<unsigned char>* SaveGameData);
	bool STATIC_GetSaveGameDataViaInterface(unsigned char LocalUserNum, struct FString* SaveFileName, unsigned char* bIsValid, TArray<unsigned char>* SaveGameData);
	bool STATIC_ConditionalReadSaveGameData(int PlayerID, const struct FString& SaveFileName);
	void STATIC_OnReadSaveGameData(bool bWasSuccessful, unsigned char LocalUserNum, const struct FString& SaveFileName);
	void STATIC_OnSettingsChanged(int settingtype, bool bSkipSave);
	float STATIC_GetDesiredAspectRatio();
	void SavePlayerSettings();
	void STATIC_LoadPlayerSettingsFromIni();
	void STATIC_LoadPlayerSettings();
};


// Class TgGame.TgCollisionProxy
// 0x0034 (0x02B4 - 0x0280)
class ATgCollisionProxy : public AActor
{
public:
	TArray<class ATgPawn*>                             m_NearByPlayers;                                          // 0x0280(0x0010) (NeedCtorLink)
	unsigned long                                      m_bIgnoreStealthPlayers : 1;                              // 0x0290(0x0004)
	unsigned long                                      m_bIgnoreNonPlayers : 1;                                  // 0x0290(0x0004)
	unsigned long                                      m_bIgnoreInvulnerablePlayers : 1;                         // 0x0290(0x0004)
	unsigned long                                      m_bForwardOwnerOnly : 1;                                  // 0x0290(0x0004)
	struct FScriptDelegate                             __ProxyTouch__Delegate;                                   // 0x0294(0x000C) (NeedCtorLink)
	unsigned char                                      UnknownData00[0x4];                                       // 0x0294(0x0004) FIX WRONG TYPE SIZE OF PREVIOUS PROPERTY
	struct FScriptDelegate                             __ProxyUnTouch__Delegate;                                 // 0x02A4(0x000C) (NeedCtorLink)
	unsigned char                                      UnknownData01[0x4];                                       // 0x02A4(0x0004) FIX WRONG TYPE SIZE OF PREVIOUS PROPERTY

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCollisionProxy");
		return ptr;
	}


	void STATIC_SetAux(const struct FName& AuxBusName, float Level);
	void ForceProximityScan(float Radius);
	void STATIC_GetNearByPlayersTaskforce(bool bEndWhenMultipleFound, TArray<int>* NearByPlayerTaskforces);
	int STATIC_GetNearByPlayers(bool bOnlyValid);
	void STATIC_OnPlayerRemoved(class ATgPawn* aPawn);
	void STATIC_OnPlayerAdded(class ATgPawn* aPawn);
	void CheckNearByPlayers(class ATgPawn* aPawn, bool bAdd);
	void Destroyed();
	void STATIC_ForceClearNearByPlayersList();
	bool ShouldIgnoreActor(class ATgPawn* aPawn);
	void UnTouch(class AActor* Other);
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void TouchOther(class AActor* Other, class UPrimitiveComponent* OtherComp);
	void DelegatesUpdated();
	void ForwardUnTouch(class AActor* Other);
	void ForwardTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_ProxyUnTouch(class AActor* Other);
	void STATIC_ProxyTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
};


// Class TgGame.TgCollisionProxy_Capture
// 0x0000 (0x02B4 - 0x02B4)
class ATgCollisionProxy_Capture : public ATgCollisionProxy
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCollisionProxy_Capture");
		return ptr;
	}


	void STATIC_SetCaptureEnabled(bool bEnabled);
};


// Class TgGame.TgCollisionProxy_Cylinder
// 0x0008 (0x02BC - 0x02B4)
class ATgCollisionProxy_Cylinder : public ATgCollisionProxy
{
public:
	class UCylinderComponent*                          m_CollisionCylinder;                                      // 0x02B4(0x0008) (ExportObject, Component, EditInline)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCollisionProxy_Cylinder");
		return ptr;
	}

};


// Class TgGame.TgCollisionProxy_SpectatorActionListener
// 0x0010 (0x02CC - 0x02BC)
class ATgCollisionProxy_SpectatorActionListener : public ATgCollisionProxy_Cylinder
{
public:
	struct FScriptDelegate                             __ProxyDeviceOnStartFire__Delegate;                       // 0x02BC(0x000C) (NeedCtorLink)
	unsigned char                                      UnknownData00[0x4];                                       // 0x02BC(0x0004) FIX WRONG TYPE SIZE OF PREVIOUS PROPERTY

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCollisionProxy_SpectatorActionListener");
		return ptr;
	}


	void STATIC_PostDemoRewind();
	bool STATIC_HasMixedTaskforcePlayersNearby();
	void ForwardDeviceOnStartFire(class ATgPawn* FiringPawn, int nEquipSlot);
	void STATIC_ProxyDeviceOnStartFire(class ATgPawn* FiringPawn, int nEquipSlot);
};


// Class TgGame.TgCollisionProxy_Mesh
// 0x0008 (0x02BC - 0x02B4)
class ATgCollisionProxy_Mesh : public ATgCollisionProxy
{
public:
	class UMeshComponent*                              m_MeshComponent;                                          // 0x02B4(0x0008) (ExportObject, Component, EditInline)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCollisionProxy_Mesh");
		return ptr;
	}


	void ScaleCollisionMesh(const struct FVector& NewScale);
	void SpawnMesh(int AssemblyID);
};


// Class TgGame.TgCollisionProxy_Objective
// 0x0000 (0x02B4 - 0x02B4)
class ATgCollisionProxy_Objective : public ATgCollisionProxy
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCollisionProxy_Objective");
		return ptr;
	}

};


// Class TgGame.TgCollisionProxy_Vortex
// 0x001C (0x02D0 - 0x02B4)
class ATgCollisionProxy_Vortex : public ATgCollisionProxy
{
public:
	float                                              m_fGroundSpeedStrafePct;                                  // 0x02B4(0x0004) (Edit)
	float                                              m_fGroundSpeedToVortex;                                   // 0x02B8(0x0004) (Edit)
	float                                              m_fGroundSpeedPctRetained;                                // 0x02BC(0x0004) (Edit)
	float                                              m_fInnerRadius;                                           // 0x02C0(0x0004) (Edit)
	unsigned long                                      m_bEnabled : 1;                                           // 0x02C4(0x0004) (Edit)
	unsigned long                                      m_bOnlyAffectCurrentTarget : 1;                           // 0x02C4(0x0004) (Edit)
	class APawn*                                       m_LastInstigator;                                         // 0x02C8(0x0008) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCollisionProxy_Vortex");
		return ptr;
	}


	void STATIC_OnPlayerRemoved(class ATgPawn* aPawn);
	void STATIC_OnPlayerAdded(class ATgPawn* aPawn);
	bool ShouldIgnoreActor(class ATgPawn* aPawn);
	void UnTouch(class AActor* Other);
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_InstigatorChanged();
	void Tick(float DeltaTime);
};


// Class TgGame.TgCombinedPostProcessEffect
// 0x003B (0x00C0 - 0x0085)
class UTgCombinedPostProcessEffect : public UPostProcessEffect
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0085(0x0003) MISSED OFFSET
	struct FColor                                      HitEffectColor;                                           // 0x0088(0x0004) (Edit)
	struct FVector                                     SceneShadows;                                             // 0x008C(0x000C)
	struct FVector                                     SceneHighLights;                                          // 0x0098(0x000C)
	struct FVector                                     SceneMidTones;                                            // 0x00A4(0x000C)
	float                                              SceneDesaturation;                                        // 0x00B0(0x0004)
	struct FVector                                     SceneColorize;                                            // 0x00B4(0x000C)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCombinedPostProcessEffect");
		return ptr;
	}

};


// Class TgGame.TgCustomCharacterComponent
// 0x004B (0x00D0 - 0x0085)
class UTgCustomCharacterComponent : public UActorComponent
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0085(0x0003) MISSED OFFSET
	TArray<class USkeletalMesh*>                       m_SourceMeshList;                                         // 0x0088(0x0010) (NeedCtorLink)
	TArray<struct FCompositeTextureType>               m_CompositeTextures;                                      // 0x0098(0x0010) (NeedCtorLink)
	int                                                m_nCompositeTextureSizeX;                                 // 0x00A8(0x0004)
	int                                                m_nCompositeTextureSizeY;                                 // 0x00AC(0x0004)
	TArray<struct FCompositePartInfo>                  m_CompositeParts;                                         // 0x00B0(0x0010) (Edit, NeedCtorLink)
	TArray<class UTgSpecialFx*>                        m_CompositeFxList;                                        // 0x00C0(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCustomCharacterComponent");
		return ptr;
	}


	void SetupCompositeRegion(int MeshAsmId, int DestOffsetX, int DestOffsetY, int SizeX, int SizeY);
	void ComposeCharacter(class USkeletalMeshComponent* Mesh);
	void STATIC_MergeMeshParts(class USkeletalMeshComponent* Mesh);
};


// Class TgGame.TgDamageType
// 0x00C4 (0x0154 - 0x0090)
class UTgDamageType : public UDamageType
{
public:
	unsigned long                                      m_bImpulseMesh : 1;                                       // 0x0090(0x0004)
	unsigned long                                      m_bDisableRagdoll : 1;                                    // 0x0090(0x0004)
	unsigned long                                      m_bEnableMotors : 1;                                      // 0x0090(0x0004)
	unsigned long                                      m_bShouldRagdollAfterDeathAnim : 1;                       // 0x0090(0x0004)
	unsigned long                                      m_bCanPlayDeathSpecialFXOnDefaultDeath : 1;               // 0x0090(0x0004)
	unsigned long                                      m_bHarvestMaterialParameters : 1;                         // 0x0090(0x0004)
	unsigned long                                      m_bFreezeAnimsOnDeath : 1;                                // 0x0090(0x0004)
	unsigned long                                      m_bIgnorePersonalShields : 1;                             // 0x0090(0x0004)
	unsigned long                                      m_bIsLatent : 1;                                          // 0x0090(0x0004)
	unsigned long                                      m_bIsAOE : 1;                                             // 0x0090(0x0004)
	unsigned long                                      m_bDismountVictim : 1;                                    // 0x0090(0x0004)
	unsigned long                                      m_bPreventHitDirectionNotify : 1;                         // 0x0090(0x0004)
	float                                              m_bMinImpulse;                                            // 0x0094(0x0004)
	float                                              m_bMaxImpulse;                                            // 0x0098(0x0004)
	float                                              m_bMinUpKick;                                             // 0x009C(0x0004)
	float                                              m_bMaxUpKick;                                             // 0x00A0(0x0004)
	TArray<struct FName>                               m_nmDeathAnimNames;                                       // 0x00A4(0x0010) (NeedCtorLink)
	TArray<struct FName>                               m_nmDeathFlailAnimNames;                                  // 0x00B4(0x0010) (NeedCtorLink)
	float                                              m_fMinAngularVelocity;                                    // 0x00C4(0x0004)
	float                                              m_fMaxAngularVelocity;                                    // 0x00C8(0x0004)
	int                                                m_nDeathSpecialFXId;                                      // 0x00CC(0x0004)
	struct FName                                       m_nmDeathSpecialFXSocket;                                 // 0x00D0(0x0008)
	class UMaterialInstanceConstant*                   m_OverrideMaterial;                                       // 0x00D8(0x0008)
	float                                              m_fLifeAfterDeathSeconds;                                 // 0x00E0(0x0004)
	float                                              m_fHideAfterDeathSeconds;                                 // 0x00E4(0x0004)
	int                                                m_nFadeOutSpecialFXId;                                    // 0x00E8(0x0004)
	TArray<struct FName>                               ActivateSkelControlListOnDeath;                           // 0x00EC(0x0010) (NeedCtorLink)
	class UAkEvent*                                    m_TakeHitAkEvent;                                         // 0x00FC(0x0008)
	class UAkEvent*                                    m_TakeHeadShotAkEvent;                                    // 0x0104(0x0008)
	class UClass*                                      m_LatentDamageType;                                       // 0x010C(0x0008)
	class UTgCameraShake*                              m_LeftCameraShake;                                        // 0x0114(0x0008)
	class UTgCameraShake*                              m_RightCameraShake;                                       // 0x011C(0x0008)
	class UTgCameraShake*                              m_ForwardCameraShake;                                     // 0x0124(0x0008)
	class UTgCameraShake*                              m_BackwardCameraShake;                                    // 0x012C(0x0008)
	class UTgCameraShake*                              m_BackwardRightCameraShake;                               // 0x0134(0x0008)
	class UTgCameraShake*                              m_BackwardLeftCameraShake;                                // 0x013C(0x0008)
	class UTgCameraShake*                              m_ForwardRightCameraShake;                                // 0x0144(0x0008)
	class UTgCameraShake*                              m_ForwardLeftCameraShake;                                 // 0x014C(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDamageType");
		return ptr;
	}


	struct FName STATIC_GetRandomDeathAnimName();
	struct FName STATIC_GetRandomDeathFlailAnimName();
};


// Class TgGame.TgDamageType_AbilityCost
// 0x0000 (0x0154 - 0x0154)
class UTgDamageType_AbilityCost : public UTgDamageType
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDamageType_AbilityCost");
		return ptr;
	}

};


// Class TgGame.TgDamageType_IgnoreShields
// 0x0000 (0x0154 - 0x0154)
class UTgDamageType_IgnoreShields : public UTgDamageType
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDamageType_IgnoreShields");
		return ptr;
	}

};


// Class TgGame.TgDamageType_Latent
// 0x0000 (0x0154 - 0x0154)
class UTgDamageType_Latent : public UTgDamageType
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDamageType_Latent");
		return ptr;
	}

};


// Class TgGame.TgDamageType_NoRagdoll
// 0x0000 (0x0154 - 0x0154)
class UTgDamageType_NoRagdoll : public UTgDamageType
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDamageType_NoRagdoll");
		return ptr;
	}

};


// Class TgGame.TgDamageType_GoldenWeaponSkin
// 0x0000 (0x0154 - 0x0154)
class UTgDamageType_GoldenWeaponSkin : public UTgDamageType_NoRagdoll
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDamageType_GoldenWeaponSkin");
		return ptr;
	}

};


// Class TgGame.TgDamageType_LegendaryWeaponSkin
// 0x0000 (0x0154 - 0x0154)
class UTgDamageType_LegendaryWeaponSkin : public UTgDamageType_NoRagdoll
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDamageType_LegendaryWeaponSkin");
		return ptr;
	}

};


// Class TgGame.TgDamageType_PaladinsExecute
// 0x0000 (0x0154 - 0x0154)
class UTgDamageType_PaladinsExecute : public UTgDamageType
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDamageType_PaladinsExecute");
		return ptr;
	}

};


// Class TgGame.TgDamageType_PaladinsRoyaleFog
// 0x0000 (0x0154 - 0x0154)
class UTgDamageType_PaladinsRoyaleFog : public UTgDamageType
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDamageType_PaladinsRoyaleFog");
		return ptr;
	}

};


// Class TgGame.TgDamageType_PaladinsSniper
// 0x0000 (0x0154 - 0x0154)
class UTgDamageType_PaladinsSniper : public UTgDamageType
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDamageType_PaladinsSniper");
		return ptr;
	}

};


// Class TgGame.TgDestructible
// 0x0020 (0x0308 - 0x02E8)
class ATgDestructible : public ASkeletalMeshActor
{
public:
	class ATgEffectManager*                            r_EffectManager;                                          // 0x02E8(0x0008) (Net)
	int                                                r_nMaxHealth;                                             // 0x02F0(0x0004) (Edit, Net)
	unsigned long                                      m_bDisplayHealth : 1;                                     // 0x02F4(0x0004) (Edit)
	unsigned long                                      m_bDestroyed : 1;                                         // 0x02F4(0x0004)
	unsigned long                                      m_bInitialized : 1;                                       // 0x02F4(0x0004) (Transient)
	unsigned long                                      m_bFogOfWarBlocker : 1;                                   // 0x02F4(0x0004) (Edit)
	unsigned long                                      m_bOneDirectional : 1;                                    // 0x02F4(0x0004) (Edit)
	int                                                m_nPhysicalType;                                          // 0x02F8(0x0004) (Edit)
	unsigned char                                      m_nTaskForce;                                             // 0x02FC(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x02FD(0x0003) MISSED OFFSET
	int                                                r_nHealth;                                                // 0x0300(0x0004) (Net)
	int                                                r_nActorInstanceId;                                       // 0x0304(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDestructible");
		return ptr;
	}


	bool STATIC_CanApplyEffects();
	void Destroyed();
	void STATIC_DestroyIt(bool bSkipFx);
	void STATIC_TakeDamage(int Damage, class AController* EventInstigator, const struct FVector& HitLocation, const struct FVector& Momentum, class UClass* DamageType, const struct FTraceHitInfo& HitInfo, class AActor* DamageCauser);
	void STATIC_ReplicatedEvent(const struct FName& VarName);
	void PostBeginPlay();
	void STATIC_ForceNetRelevant();
	bool STATIC_IsFriendlyWithLocalPawn();
};


// Class TgGame.TgRespawnBeaconBase
// 0x0024 (0x032C - 0x0308)
class ATgRespawnBeaconBase : public ATgDestructible
{
public:
	int                                                m_nMeshAssemblyId;                                        // 0x0308(0x0004) (Edit, Const, EditConst)
	class UMeshComponent*                              m_ActualMeshComponent;                                    // 0x030C(0x0008) (ExportObject, Transient, Component, EditInline)
	TArray<class UTgAnimBlendByTeleportBeacon*>        m_BeaconNodes;                                            // 0x0314(0x0010) (Transient, NeedCtorLink)
	unsigned long                                      c_bEnemyMatLoaded : 1;                                    // 0x0324(0x0004) (Transient)
	unsigned long                                      m_bShouldShowSilhouetteToFriends : 1;                     // 0x0324(0x0004) (Const)
	float                                              m_fDeployTime;                                            // 0x0328(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgRespawnBeaconBase");
		return ptr;
	}


	void NotifyLocalPlayerTeamReceived();
	void STATIC_PostInitAnimTree(class USkeletalMeshComponent* SkelComp);
	void STATIC_RecalculateMaterial(bool bIsFriendlyWithLocalPawn, bool bForce);
	void ForceRecalculateMaterial();
};


// Class TgGame.TgRespawnBeaconEntrance
// 0x0038 (0x0364 - 0x032C)
class ATgRespawnBeaconEntrance : public ATgRespawnBeaconBase
{
public:
	class ATgRespawnBeaconExit*                        ExitBeacon;                                               // 0x032C(0x0008) (Edit)
	unsigned long                                      r_bEntranceActive : 1;                                    // 0x0334(0x0004) (Edit, Net)
	unsigned char                                      r_nPendingTeleport;                                       // 0x0338(0x0001) (Net)
	TEnumAsByte<ERespawnBeaconChargingState>           c_LocalChargingState;                                     // 0x0339(0x0001) (Transient)
	TEnumAsByte<ERespawnBeaconChargingState>           r_ChargingState;                                          // 0x033A(0x0001) (Net)
	unsigned char                                      UnknownData00[0x1];                                       // 0x033B(0x0001) MISSED OFFSET
	class UTgParticleSystemComponent*                  m_TeleportPSC;                                            // 0x033C(0x0008) (ExportObject, Component, EditInline)
	float                                              m_fChargeDelay;                                           // 0x0344(0x0004)
	float                                              m_fTeleportDelay;                                         // 0x0348(0x0004)
	float                                              m_fPreTeleportFXTime;                                     // 0x034C(0x0004)
	float                                              s_fChargeStateTimeStamp;                                  // 0x0350(0x0004)
	TArray<struct FPendingTeleportInfo>                s_PendingTeleports;                                       // 0x0354(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgRespawnBeaconEntrance");
		return ptr;
	}


	bool STATIC_CanApplyEffects();
	void DisableBeaconFX();
	void EnableBeaconSetupFX();
	void BeaconSetActive();
	void SetChargingState(TEnumAsByte<ERespawnBeaconChargingState> chargeState);
	void ChargingStateChangedFX();
	void ClientFlashTeleportFX();
	void STATIC_FlashTeleportFx(class ATgPawn* TgP);
	void UnTouch(class AActor* Other);
	void STATIC_PostTouch(class AActor* Other);
	class AActor* STATIC_GetNextPendingTeleport();
	bool RemovePendingTeleport(class AActor* Other);
	bool AddPendingTeleport(class AActor* Other);
	bool VerifyCanTeleport(class ATgPawn* Other);
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_OnBeaconEntranceSetActive(class UTgSeqAct_BeaconEntranceSetActive* inAction);
	void ConnectToExit();
	void PostBeginPlay();
	void STATIC_ReplicatedEvent(const struct FName& VarName);
};


// Class TgGame.TgRespawnBeaconExit
// 0x00C4 (0x03F0 - 0x032C)
class ATgRespawnBeaconExit : public ATgRespawnBeaconBase
{
public:
	unsigned long                                      m_bChangesYaw : 1;                                        // 0x032C(0x0004) (Edit)
	unsigned long                                      c_bHiddenToLocalPlayer : 1;                               // 0x032C(0x0004)
	float                                              m_fPercHealthPerSec;                                      // 0x0330(0x0004) (Edit)
	float                                              m_fHealthRegenLockoutTime;                                // 0x0334(0x0004) (Edit)
	int                                                r_nRespawnTime;                                           // 0x0338(0x0004) (Net)
	float                                              m_fTimeUntilHealTick;                                     // 0x033C(0x0004)
	struct FRotator                                    m_rInitialRot;                                            // 0x0340(0x000C)
	struct FVector                                     m_vInitialPos;                                            // 0x034C(0x000C)
	class ATgRepInfo_Player*                           r_CarrierRepInfo;                                         // 0x0358(0x0008) (Net)
	class AActor*                                      m_SpawnPointOverride;                                     // 0x0360(0x0008)
	class ATgVisibilityVolume*                         r_CurrentVisibilityVolumes[0x2];                          // 0x0368(0x0008) (Net)
	TEnumAsByte<ERespawnBeaconActiveState>             c_LocalActiveState;                                       // 0x0378(0x0001)
	TEnumAsByte<ERespawnBeaconActiveState>             r_ActiveState;                                            // 0x0379(0x0001) (Net)
	unsigned char                                      r_nPlayTakeHit;                                           // 0x037A(0x0001) (Net)
	unsigned char                                      UnknownData00[0x1];                                       // 0x037B(0x0001) MISSED OFFSET
	TArray<class ATgRespawnBeaconEntrance*>            m_Entrances;                                              // 0x037C(0x0010) (Transient, NeedCtorLink)
	TArray<struct FScriptDelegate>                     m_CarriedDel;                                             // 0x038C(0x0010) (Transient, NeedCtorLink)
	TArray<struct FScriptDelegate>                     m_DestroyedDel;                                           // 0x039C(0x0010) (Transient, NeedCtorLink)
	TArray<struct FScriptDelegate>                     m_DeployingDel;                                           // 0x03AC(0x0010) (Transient, NeedCtorLink)
	TArray<struct FScriptDelegate>                     m_ActiveDel;                                              // 0x03BC(0x0010) (Transient, NeedCtorLink)
	struct FVector                                     r_nDeathLocation;                                         // 0x03CC(0x000C) (Net)
	class AController*                                 m_LastDamager;                                            // 0x03D8(0x0008)
	struct FScriptDelegate                             __BeaconStateChanged__Delegate;                           // 0x03E0(0x000C) (NeedCtorLink)
	unsigned char                                      UnknownData01[0x4];                                       // 0x03E0(0x0004) FIX WRONG TYPE SIZE OF PREVIOUS PROPERTY

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgRespawnBeaconExit");
		return ptr;
	}


	void SetPendingTeleportFx(bool bIsPendingTeleport);
	void ClientFlashTeleportFX();
	void STATIC_SetActiveState(TEnumAsByte<ERespawnBeaconActiveState> NewState);
	void STATIC_TakeDamage(int Damage, class AController* EventInstigator, const struct FVector& HitLocation, const struct FVector& Momentum, class UClass* DamageType, const struct FTraceHitInfo& HitInfo, class AActor* DamageCauser);
	void PlayTakeHitEffect();
	void FXEndActive();
	void FXEndDeploying();
	void FXActive();
	void FXDeploying();
	void FXDestroyed();
	void FXCarried();
	void STATIC_Respawn();
	void UpdateRespawnTime();
	void BeginRespawnTimer();
	float STATIC_GetDesiredLifeSpan();
	void STATIC_DestroyIt(bool bSkipFx);
	void Deployed();
	void PlaceAtLocation(const struct FVector& NewLocation, const struct FRotator& NewRotation);
	void PlaceFromDeploy(class ATgDeploy_RespawnBeacon* TgD);
	void Place(class ATgPawn* TgP);
	bool PickUp(class ATgPawn* TgP);
	bool CanBePickedUp(class ATgPawn* TgP);
	bool STATIC_IsValidTarget(class ATgPawn* TgP);
	void UnTouch(class AActor* Other);
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void SetBeaconCollision(bool IsActive);
	bool STATIC_AcceptTeleport(class ATgPawn* Incoming, class ATgRespawnBeaconEntrance* Source);
	void PostBeginPlay();
	void RemoveVisibilityVolume(class ATgVisibilityVolume* Vol);
	void AddVisibilityVolume(class ATgVisibilityVolume* Vol);
	void STATIC_OnBeaconExitSetRespawn(class UTgSeqAct_BeaconExitSetRespawn* inAction);
	void STATIC_ReplicatedEvent(const struct FName& VarName);
	bool STATIC_HasAnyEnabledEntrances();
	void STATIC_OnBeaconReset();
	void STATIC_BeaconStateChanged();
};


// Class TgGame.TgDeviceInterface_DismountModifier
// 0x0000 (0x0060 - 0x0060)
class UTgDeviceInterface_DismountModifier : public UInterface
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceInterface_DismountModifier");
		return ptr;
	}


	bool ShouldOverrideDismount(int DamageAmt);
};


// Class TgGame.TgDistributionFloatLitParticleBrightness
// 0x0000 (0x0080 - 0x0080)
class UTgDistributionFloatLitParticleBrightness : public UDistributionFloatConstant
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDistributionFloatLitParticleBrightness");
		return ptr;
	}

};


// Class TgGame.TgDistributionFloatSoundAttenuation
// 0x0040 (0x00BC - 0x007C)
class UTgDistributionFloatSoundAttenuation : public UDistributionFloat
{
public:
	TEnumAsByte<ESoundAttenuationType>                 AttenuationType;                                          // 0x007C(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x007D(0x0003) MISSED OFFSET
	float                                              Attenuation_Sm_foley;                                     // 0x0080(0x0004) (Config)
	float                                              Attenuation_Lg_foley;                                     // 0x0084(0x0004) (Config)
	float                                              Attenuation_Melee_hit;                                    // 0x0088(0x0004) (Config)
	float                                              Attenuation_Sm_gun;                                       // 0x008C(0x0004) (Config)
	float                                              Attenuation_Med_gun;                                      // 0x0090(0x0004) (Config)
	float                                              Attenuation_Lg_gun;                                       // 0x0094(0x0004) (Config)
	float                                              Attenuation_Sm_exp;                                       // 0x0098(0x0004) (Config)
	float                                              Attenuation_Med_exp;                                      // 0x009C(0x0004) (Config)
	float                                              Attenuation_Lg_exp;                                       // 0x00A0(0x0004) (Config)
	struct FName                                       GroupName;                                                // 0x00A4(0x0008) (Edit)
	TArray<struct FAttenuationGroup>                   AttenuationGroups;                                        // 0x00AC(0x0010) (Config, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDistributionFloatSoundAttenuation");
		return ptr;
	}

};


// Class TgGame.TgExplosionLight
// 0x0034 (0x0274 - 0x0240)
class UTgExplosionLight : public UPointLightComponent
{
public:
	unsigned long                                      bCheckFrameRate : 1;                                      // 0x0240(0x0004)
	unsigned long                                      bInitialized : 1;                                         // 0x0240(0x0004)
	unsigned long                                      bIsEnemy : 1;                                             // 0x0240(0x0004) (Edit)
	unsigned long                                      bIsLocal : 1;                                             // 0x0240(0x0004) (Edit)
	unsigned long                                      bIsLooping : 1;                                           // 0x0240(0x0004)
	float                                              HighDetailFrameTime;                                      // 0x0244(0x0004)
	float                                              Lifetime;                                                 // 0x0248(0x0004)
	int                                                TimeShiftIndex;                                           // 0x024C(0x0004)
	TArray<struct FLightValues>                        TimeShift;                                                // 0x0250(0x0010) (Edit, NeedCtorLink)
	int                                                LoopIndex;                                                // 0x0260(0x0004) (Edit)
	struct FScriptDelegate                             __OnLightFinished__Delegate;                              // 0x0264(0x000C) (NeedCtorLink)
	unsigned char                                      UnknownData00[0x4];                                       // 0x0264(0x0004) FIX WRONG TYPE SIZE OF PREVIOUS PROPERTY

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgExplosionLight");
		return ptr;
	}


	void STATIC_OnLightFinished(class UTgExplosionLight* Light);
	void ResetLight();
};


// Class TgGame.TgFatalityMeshActor
// 0x000C (0x028C - 0x0280)
class ATgFatalityMeshActor : public AActor
{
public:
	int                                                m_nTaskForceId;                                           // 0x0280(0x0004) (Edit)
	class UTgSkeletalMeshComponent*                    m_Mesh;                                                   // 0x0284(0x0008) (Edit, ExportObject, Component, EditInline)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgFatalityMeshActor");
		return ptr;
	}


	void Initialize(int MeshAssemblyId, int TaskForceId);
};


// Class TgGame.TgFlagContentData
// 0x0010 (0x0070 - 0x0060)
class UTgFlagContentData : public UObject
{
public:
	TArray<struct FFlagMeshData>                       m_MeshData;                                               // 0x0060(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgFlagContentData");
		return ptr;
	}


	void PreloadTextures(float ForceDuration);
	void STATIC_GetMeshData(TEnumAsByte<EFlagContentDataType> ContentDataType, struct FFlagMeshData* Data);
	void Init();
};


// Class TgGame.TgFogOfWarBarrier
// 0x0008 (0x02AC - 0x02A4)
class ATgFogOfWarBarrier : public AStaticMeshActor
{
public:
	unsigned long                                      m_bOneDirectional : 1;                                    // 0x02A4(0x0004) (Edit)
	float                                              m_fBlockMinimumDistance;                                  // 0x02A8(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgFogOfWarBarrier");
		return ptr;
	}

};


// Class TgGame.TgFortressVolume
// 0x0004 (0x02C0 - 0x02BC)
class ATgFortressVolume : public AVolume
{
public:
	int                                                TaskforceIndex;                                           // 0x02BC(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgFortressVolume");
		return ptr;
	}


	void PostBeginPlay();
	void UnTouch(class AActor* Other);
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
};


// Class TgGame.TgGameEngine
// 0x0000 (0x0AAC - 0x0AAC)
class UTgGameEngine : public UPComGameEngine
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGameEngine");
		return ptr;
	}

};


// Class TgGame.TgHUD
// 0x0000 (0x05A0 - 0x05A0)
class ATgHUD : public AHUD
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgHUD");
		return ptr;
	}


	void STATIC_PlayDeviceFailResponse(TEnumAsByte<EDeviceFailType> failType);
	bool STATIC_PopScene(int nIndex);
	void STATIC_ShowSubtitle(int nMessage, float fTime);
	void STATIC_ShowLootGoblinSpawned(class ATgPawn* DiscoveringPawn, class ATgPawn* TargetGoblin);
	void ShowHit(class AActor* Target, float fDamageAmount, bool bIsShieldHit, struct FExtraDamageInfo* ExtraInfo);
	void STATIC_ShowScope(bool bValue, unsigned char eType);
	void ShowCursor(bool bShow);
	void STATIC_HideGameTip(bool bNoSound);
	void ShowGameTip(int nTipId, bool bNoSound, bool bPopup);
	void EndMission(bool bPlayerAttacker, TEnumAsByte<EGAME_WIN_STATE> finalWinState);
	void UpdatePlayerReady(class ATgRepInfo_Player* pPRI);
	void STATIC_MapOutroFinished();
	void FinishIntro();
	void PlayIntro();
};


// Class TgGame.TgInterface_YingIllusion
// 0x0000 (0x0060 - 0x0060)
class UTgInterface_YingIllusion : public UInterface
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInterface_YingIllusion");
		return ptr;
	}


	class ATgPawn* STATIC_GetOwningYing();
	class AActor* STATIC_GetActorFromInterface();
	bool STATIC_IsNotDestroyed();
	void PlayDimensionalLinkFX();
	void Shatter();
	void TriggerShatter(float fDelay);
	void AddOnDestroyDelegate(const struct FScriptDelegate& delDestroy);
	void STATIC_DestroyedEvent(class AActor* destroyedActor);
};


// Class TgGame.TgInternalChestManagerVolume
// 0x0004 (0x02C0 - 0x02BC)
class ATgInternalChestManagerVolume : public AVolume
{
public:
	int                                                m_nMinChests;                                             // 0x02BC(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInternalChestManagerVolume");
		return ptr;
	}


	void STATIC_SpawnChests(TArray<class ATgDeployableFactory*> Factories);
};


// Class TgGame.TgKActorSpawnable
// 0x0000 (0x03B8 - 0x03B8)
class ATgKActorSpawnable : public AKActorSpawnable
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgKActorSpawnable");
		return ptr;
	}

};


// Class TgGame.TgKAsset_ClientSideSim
// 0x0068 (0x0304 - 0x029C)
class ATgKAsset_ClientSideSim : public AKAsset
{
public:
	float                                              m_fDamageImpulse;                                         // 0x029C(0x0004) (Edit)
	class UArrowComponent*                             m_Arrow;                                                  // 0x02A0(0x0008) (ExportObject, Component, EditInline)
	class USpriteComponent*                            m_ForceSprite;                                            // 0x02A8(0x0008) (ExportObject, Component, EditInline)
	unsigned long                                      m_bEnableWind : 1;                                        // 0x02B0(0x0004) (Edit)
	unsigned long                                      m_bEnableGusts : 1;                                       // 0x02B0(0x0004) (Edit)
	unsigned long                                      bAnimates : 1;                                            // 0x02B0(0x0004) (Edit)
	float                                              m_fWindForceMin;                                          // 0x02B4(0x0004) (Edit)
	float                                              m_fWindForceMax;                                          // 0x02B8(0x0004) (Edit)
	float                                              m_fWindForceStrength;                                     // 0x02BC(0x0004)
	float                                              m_fWindForceTargetStrength;                               // 0x02C0(0x0004)
	float                                              m_fWindFrequency;                                         // 0x02C4(0x0004) (Edit)
	float                                              m_fWindForceRemainingTime;                                // 0x02C8(0x0004)
	struct FVector                                     m_vWindDirection;                                         // 0x02CC(0x000C) (Edit)
	float                                              m_fForceDistance;                                         // 0x02D8(0x0004) (Edit)
	float                                              m_fForceZOffsetMultiplier;                                // 0x02DC(0x0004) (Edit)
	float                                              m_fGustActiveTime;                                        // 0x02E0(0x0004) (Edit)
	struct FVector2D                                   m_vTimeBetweenGusts;                                      // 0x02E4(0x0008) (Edit)
	float                                              m_fGustActiveRemainingTime;                               // 0x02EC(0x0004)
	float                                              m_fTimeTillNextGust;                                      // 0x02F0(0x0004)
	struct FVector2D                                   m_WindFrequencyMultiplier;                                // 0x02F4(0x0008) (Edit)
	struct FVector2D                                   m_WindForceMultiplier;                                    // 0x02FC(0x0008) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgKAsset_ClientSideSim");
		return ptr;
	}


	void STATIC_OnHit(const struct FVector& HitLocation, const struct FVector& HitNormal, class AActor* SourceActor, const struct FTraceHitInfo& HitInfo);
};


// Class TgGame.TgKAssetSpawnable
// 0x0000 (0x029C - 0x029C)
class ATgKAssetSpawnable : public AKAssetSpawnable
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgKAssetSpawnable");
		return ptr;
	}

};


// Class TgGame.TgLevelStreamingSpectator
// 0x0001 (0x0101 - 0x0100)
class UTgLevelStreamingSpectator : public ULevelStreaming
{
public:
	TEnumAsByte<ESpectatorStreamingMethod>             m_LoadingMethod;                                          // 0x0100(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgLevelStreamingSpectator");
		return ptr;
	}

};


// Class TgGame.TgLevelStreamingWorldDetail
// 0x0010 (0x0110 - 0x0100)
class UTgLevelStreamingWorldDetail : public ULevelStreaming
{
public:
	int                                                MinimumWorldDetailLevel;                                  // 0x0100(0x0004) (Edit)
	int                                                MaximumWorldDetailLevel;                                  // 0x0104(0x0004) (Edit)
	unsigned char                                      CachedDetailCheck;                                        // 0x0108(0x0001) (Transient)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0109(0x0003) MISSED OFFSET
	int                                                LastUpdateTime;                                           // 0x010C(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgLevelStreamingWorldDetail");
		return ptr;
	}

};


// Class TgGame.TgLocalPlayer
// 0x0039 (0x04AD - 0x0474)
class UTgLocalPlayer : public ULocalPlayer
{
public:
	float                                              m_fViewScale;                                             // 0x0474(0x0004)
	struct FVector                                     m_vViewPan;                                               // 0x0478(0x000C)
	unsigned long                                      m_bEnableOutlineEffect : 1;                               // 0x0484(0x0004)
	unsigned long                                      m_bEnableColorBlindEffect : 1;                            // 0x0484(0x0004)
	unsigned long                                      m_bColorBlindSimulate : 1;                                // 0x0484(0x0004)
	unsigned long                                      m_bBlurForeground : 1;                                    // 0x0484(0x0004)
	float                                              m_fHitOnlyAlpha;                                          // 0x0488(0x0004)
	float                                              m_fHealthOnlyAlpha;                                       // 0x048C(0x0004)
	float                                              m_fHealthPPAlpha;                                         // 0x0490(0x0004)
	float                                              m_fDeathDesatPPAlpha;                                     // 0x0494(0x0004)
	int                                                m_eColorBlindEffectType;                                  // 0x0498(0x0004)
	float                                              m_fTargetBlurAmount;                                      // 0x049C(0x0004)
	float                                              m_fBlurAmount;                                            // 0x04A0(0x0004)
	float                                              m_fBlurInterpSpeed;                                       // 0x04A4(0x0004)
	float                                              m_fBlurKernelSize;                                        // 0x04A8(0x0004)
	TEnumAsByte<EDOFType>                              m_eCurrentDOFType;                                        // 0x04AC(0x0001)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgLocalPlayer");
		return ptr;
	}


	class UPostProcessEffect* STATIC_GetPostProcessEffect(const struct FName& EffectName);
	void SetBlurAmount(float TargetBlurAmount, float InterpSpeed, float BlurKernelSize, bool bForeground);
	void UpdateLowHealthEffect(float DeltaSeconds, float fHealthPCT, float fHealthLostPCT, bool bDeathVision);
	void EnableColorBlindEffect(bool bEnable, int Type, bool bSimulateMode);
	void EnableOutlineEffect(bool bEnable);
	void STATIC_InitMaterialEffects();
};


// Class TgGame.TgLootManager
// 0x00F0 (0x0370 - 0x0280)
class ATgLootManager : public AActor
{
public:
	TArray<int>                                        m_SlotLoot;                                               // 0x0280(0x0010) (NeedCtorLink)
	TArray<unsigned char>                              m_SlotChosen;                                             // 0x0290(0x0010) (NeedCtorLink)
	TArray<class UTgCached_LootTable*>                 m_CachedTables;                                           // 0x02A0(0x0010) (NeedCtorLink)
	int                                                m_nChosenCount;                                           // 0x02B0(0x0004) (Config)
	TArray<int>                                        m_LootTables;                                             // 0x02B4(0x0010) (Config, NeedCtorLink)
	TArray<int>                                        m_SlotTables;                                             // 0x02C4(0x0010) (Config, NeedCtorLink)
	TArray<unsigned char>                              m_SlotExceptions;                                         // 0x02D4(0x0010) (Config, NeedCtorLink)
	int                                                m_nShardDropCount;                                        // 0x02E4(0x0004) (Config)
	float                                              m_fLootSpawnMinVelocity;                                  // 0x02E8(0x0004) (Edit)
	float                                              m_fLootSpawnMaxVelocity;                                  // 0x02EC(0x0004) (Edit)
	float                                              m_fLootSpawnMinZVelocity;                                 // 0x02F0(0x0004) (Edit)
	float                                              m_fLootSpawnMaxZVelocity;                                 // 0x02F4(0x0004) (Edit)
	float                                              m_fLootSpawnAngle;                                        // 0x02F8(0x0004) (Edit)
	TArray<struct FPendingLoot>                        m_PendingLootList;                                        // 0x02FC(0x0010) (NeedCtorLink)
	float                                              m_fLastPendingLootSpawnTimestamp;                         // 0x030C(0x0004)
	float                                              m_fPendingLootSpawnFrequency;                             // 0x0310(0x0004)
	unsigned long                                      m_bLTEDisableLootArmorPotions : 1;                        // 0x0314(0x0004)
	unsigned long                                      m_bLTEDisableLootHealingPotions : 1;                      // 0x0314(0x0004)
	unsigned long                                      m_bLTEDisableLootWeapons : 1;                             // 0x0314(0x0004)
	unsigned long                                      m_bLTEDisableLootSupportAbilities : 1;                    // 0x0314(0x0004)
	unsigned long                                      m_bLTEDisableLootOffensiveAbilities : 1;                  // 0x0314(0x0004)
	unsigned long                                      m_bLTEDisableLootMovementAbilities : 1;                   // 0x0314(0x0004)
	unsigned long                                      m_bLTEDisableLootRunes : 1;                               // 0x0314(0x0004)
	unsigned long                                      m_bLTESingleWeaponLimit : 1;                              // 0x0314(0x0004)
	unsigned long                                      m_bLTESingleSupportAbilityLimit : 1;                      // 0x0314(0x0004)
	unsigned long                                      m_bLTESingleOffensiveAbilityLimit : 1;                    // 0x0314(0x0004)
	unsigned long                                      m_bLTESingleMovementAbilityLimit : 1;                     // 0x0314(0x0004)
	int                                                m_nLTESingleWeaponType;                                   // 0x0318(0x0004)
	int                                                m_nLTESingleSupportAbilityType;                           // 0x031C(0x0004)
	int                                                m_nLTESingleOffensiveAbilityType;                         // 0x0320(0x0004)
	int                                                m_nLTESingleMovementAbilityType;                          // 0x0324(0x0004)
	struct FMultiMap_Mirror                            m_CachedItemSubtypeLookup;                                // 0x0328(0x0048) (Native)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgLootManager");
		return ptr;
	}

};


// Class TgGame.TgManifestGroup
// 0x0048 (0x00A8 - 0x0060)
class UTgManifestGroup : public UObject
{
public:
	struct FPointer                                    VfTable_FCallbackEventDevice;                             // 0x0060(0x0008) (Const, Native, NoExport)
	TArray<struct FPointer>                            m_ManifestList;                                           // 0x0068(0x0010) (Native, AlwaysInit)
	TArray<class UTgObjectReferencer*>                 m_pObjectReferencers;                                     // 0x0078(0x0010) (AlwaysInit, NeedCtorLink)
	class UObject*                                     m_OwningObject;                                           // 0x0088(0x0008)
	unsigned long                                      m_bIsInCallback : 1;                                      // 0x0090(0x0004)
	unsigned long                                      m_bInitialized : 1;                                       // 0x0090(0x0004)
	unsigned long                                      m_bResetOnMapLoad : 1;                                    // 0x0090(0x0004)
	TEnumAsByte<EAsyncLoadPriority>                    m_AsyncLoadPriority;                                      // 0x0094(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	struct FScriptDelegate                             __OnAllManifestsLoaded__Delegate;                         // 0x0098(0x000C) (NeedCtorLink)
	unsigned char                                      UnknownData01[0x4];                                       // 0x0095(0x0004) FIX WRONG TYPE SIZE OF PREVIOUS PROPERTY

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgManifestGroup");
		return ptr;
	}


	void STATIC_OnAllManifestsLoaded();
};


// Class TgGame.TgMapInfo
// 0x006C (0x00CC - 0x0060)
class UTgMapInfo : public UMapInfo
{
public:
	class AActor*                                      m_EndFocusActor_TF1;                                      // 0x0060(0x0008) (Edit)
	class AActor*                                      m_EndFocusActor_TF2;                                      // 0x0068(0x0008) (Edit)
	class ATgFatalityFactory*                          m_FatalityFactory_TF1_2;                                  // 0x0070(0x0008) (Edit)
	class ATgFatalityFactory*                          m_FatalityFactory_TF1_3;                                  // 0x0078(0x0008) (Edit)
	class ATgFatalityFactory*                          m_FatalityFactory_TF1_4;                                  // 0x0080(0x0008) (Edit)
	class ATgFatalityFactory*                          m_FatalityFactory_TF2_2;                                  // 0x0088(0x0008) (Edit)
	class ATgFatalityFactory*                          m_FatalityFactory_TF2_3;                                  // 0x0090(0x0008) (Edit)
	class ATgFatalityFactory*                          m_FatalityFactory_TF2_4;                                  // 0x0098(0x0008) (Edit)
	class AStaticMeshActor*                            m_OverlayPathMesh;                                        // 0x00A0(0x0008) (Edit)
	struct FVector2D                                   m_vMapCenter;                                             // 0x00A8(0x0008) (Edit)
	struct FVector2D                                   m_vTaskForce1BaseLocation;                                // 0x00B0(0x0008) (Edit)
	struct FVector2D                                   m_vTaskForce2BaseLocation;                                // 0x00B8(0x0008) (Edit)
	float                                              m_fLockViewBufferZoneSize;                                // 0x00C0(0x0004) (Edit)
	unsigned long                                      m_bSupportsGuardianThrone : 1;                            // 0x00C4(0x0004) (Edit)
	float                                              m_LitParticleBrightness;                                  // 0x00C8(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgMapInfo");
		return ptr;
	}


	class ATgFatalityFactory* STATIC_GetEmptyFatalityFactory(unsigned char TaskForceNumber);
};


// Class TgGame.TgMarkComponent
// 0x0037 (0x00BC - 0x0085)
class UTgMarkComponent : public UActorComponent
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0085(0x0003) MISSED OFFSET
	TArray<struct FTargetMark>                         s_MarkList;                                               // 0x0088(0x0010) (Transient, AlwaysInit, NeedCtorLink)
	TArray<class UTgEffectGroup*>                      s_MarkEffectGroup;                                        // 0x0098(0x0010) (Transient, AlwaysInit, NeedCtorLink)
	int                                                m_nHostItemId;                                            // 0x00A8(0x0004) (Const)
	unsigned long                                      m_bStackEffects : 1;                                      // 0x00AC(0x0004) (Const)
	unsigned long                                      m_bRemoveMarksOnDeath : 1;                                // 0x00AC(0x0004) (Const)
	float                                              m_fMarkDuration;                                          // 0x00B0(0x0004) (Const)
	int                                                m_nMaxMarks;                                              // 0x00B4(0x0004) (Const)
	int                                                m_nPhysicalType;                                          // 0x00B8(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgMarkComponent");
		return ptr;
	}


	int STATIC_GetNumMarksFor(class AActor* Target);
	void RemoveAllMarks();
	void RemoveMarkByIndex(int nIndex);
	void RemoveAllMarksByIndex(int nIndex);
	void RemoveMarkByActor(class AActor* Target);
	void RemoveAllMarksByActor(class AActor* Target);
	void AddMark(class AActor* Target);
};


// Class TgGame.TgMenuContentData
// 0x0028 (0x0088 - 0x0060)
class UTgMenuContentData : public UObject
{
public:
	TArray<struct FMeshData>                           m_MeshData;                                               // 0x0060(0x0010) (NeedCtorLink)
	class USoundCue*                                   m_LoginMusic;                                             // 0x0070(0x0008)
	class USoundCue*                                   m_GodSelectionMusic;                                      // 0x0078(0x0008)
	class USoundCue*                                   m_BattleReadyMusic;                                       // 0x0080(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgMenuContentData");
		return ptr;
	}


	void PreloadTextures(float ForceDuration);
	void STATIC_GetMeshData(TEnumAsByte<EMenuContentDataType> ContentDataType, struct FMeshData* Data);
	void Init();
};


// Class TgGame.TgMenuMeshInfo
// 0x008C (0x00EC - 0x0060)
class UTgMenuMeshInfo : public UObject
{
public:
	struct FLobbyMeshInfo                              MeshInfo;                                                 // 0x0060(0x0064) (Edit, NeedCtorLink)
	TArray<class UTgMenuMeshInfo*>                     Children;                                                 // 0x00C4(0x0010) (Edit, NeedCtorLink, EditInline)
	struct FName                                       ParentSocketName;                                         // 0x00D4(0x0008)
	TArray<struct FParticleSystemInfo>                 AttachedParticleSystems;                                  // 0x00DC(0x0010) (Edit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgMenuMeshInfo");
		return ptr;
	}


	void PreloadTextures(float ForceDuration);
	bool STATIC_IsFullyConfigured();
	void AddFxAttachments(class UTgSkeletalMeshComponent* SkelComp);
	void SetupMeshFromMeshInfo(class UTgSkeletalMeshComponent* SkelComp);
	void ConfigureMesh(class ATgSkeletalMeshActor_Loader* lobbyOwner);
};


// Class TgGame.TgMeshAssembly
// 0x0018 (0x0298 - 0x0280)
class ATgMeshAssembly : public AActor
{
public:
	int                                                m_nMeshAsmId;                                             // 0x0280(0x0004) (Edit)
	int                                                m_nTeam;                                                  // 0x0284(0x0004) (Edit)
	class UMeshComponent*                              m_Mesh;                                                   // 0x0288(0x0008) (ExportObject, Transient, Component, EditInline)
	class ULightEnvironmentComponent*                  m_LightEnvironment;                                       // 0x0290(0x0008) (Const, ExportObject, EditConst, Component, EditInline)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgMeshAssembly");
		return ptr;
	}


	void NotifyLocalPlayerTeamReceived();
	void PostBeginPlay();
	void RecalculateTeamColor();
	void STATIC_LoadMesh();
};


// Class TgGame.TgNamedPOIActor
// 0x0018 (0x0298 - 0x0280)
class ATgNamedPOIActor : public AActor
{
public:
	int                                                m_nMessageId;                                             // 0x0280(0x0004) (Edit)
	struct FString                                     m_PreviewText;                                            // 0x0284(0x0010) (Edit, EditConst, NeedCtorLink)
	unsigned long                                      m_bIsRegion : 1;                                          // 0x0294(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgNamedPOIActor");
		return ptr;
	}


	struct FString STATIC_GetPOINamedString();
};


// Class TgGame.TgNewUserSettings
// 0x0010 (0x0070 - 0x0060)
class UTgNewUserSettings : public UObject
{
public:
	TArray<int>                                        WatchedVideoIds;                                          // 0x0060(0x0010) (Edit, Config, GlobalConfig, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgNewUserSettings");
		return ptr;
	}

};


// Class TgGame.TgObject
// 0x0000 (0x0060 - 0x0060)
class UTgObject : public UObject
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgObject");
		return ptr;
	}


	bool STATIC_IsOffhandEquipSlot(int EquipSlot);
	class UTgSpecialFx* CreateSpecialFx(int nSpecialFxId);
	void ScriptSetParticleFloatParamOnMesh(class UMeshComponent* MeshComp, const struct FName& nmName, float fValue, const struct FName& nmDisplayGroup, int nEqpSlot);
	void ScriptSetVectorMaterialParamOnMesh(class UMeshComponent* MeshComp, const struct FName& nmName, const struct FLinearColor& Value, int nMaterialIndex);
	void ScriptSetScalarMaterialParamOnMesh(class UMeshComponent* MeshComp, const struct FName& nmName, float fValue, int nMaterialIndex);
	float STATIC_GetPseudoRandomFractionFromSeed(int nSeed);
	class ATgPlayerController* ScriptGetLocalTGPlayerController();
	void STATIC_StartFire();
	void SetTaskForceNumber();
	void STATIC_InitializeDefaultProps();
	void SortDamageDisplay();
	void STATIC_IsFriendlyWithLocalPawn();
};


// Class TgGame.TgCached_LootItem
// 0x000C (0x006C - 0x0060)
class UTgCached_LootItem : public UTgObject
{
public:
	int                                                m_nId;                                                    // 0x0060(0x0004)
	float                                              m_fDropChance;                                            // 0x0064(0x0004)
	int                                                m_nQuantity;                                              // 0x0068(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCached_LootItem");
		return ptr;
	}

};


// Class TgGame.TgCached_LootTable
// 0x0024 (0x0090 - 0x006C)
class UTgCached_LootTable : public UTgCached_LootItem
{
public:
	float                                              m_fTotalDropChance;                                       // 0x006C(0x0004)
	TArray<class UTgCached_LootItem*>                  m_Items;                                                  // 0x0070(0x0010) (NeedCtorLink)
	TArray<class UTgCached_LootTable*>                 m_Tables;                                                 // 0x0080(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCached_LootTable");
		return ptr;
	}

};


// Class TgGame.TgObjectReferencer
// 0x0008 (0x008C - 0x0084)
class UTgObjectReferencer : public UObjectReferencer
{
public:
	struct FPointer                                    m_Manifest;                                               // 0x0084(0x0008) (Native)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgObjectReferencer");
		return ptr;
	}

};


// Class TgGame.TgParticleSystemComponent
// 0x000C (0x03D4 - 0x03C8)
class UTgParticleSystemComponent : public UParticleSystemComponent
{
public:
	class USkeletalMeshComponent*                      m_AttachedToSkelMesh;                                     // 0x03C8(0x0008) (Edit, ExportObject, Component, EditInline)
	unsigned long                                      m_bReenableAfterTeleport : 1;                             // 0x03D0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgParticleSystemComponent");
		return ptr;
	}

};


// Class TgGame.TgProperty
// 0x0000 (0x0060 - 0x0060)
class UTgProperty : public UObject
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProperty");
		return ptr;
	}


	int STATIC_GetPropIndexByName(const struct FString& propName);
	int STATIC_GetPropIndex(int propId);
	float STATIC_GetCurrentValue(struct FTgPropertyInstance* prop);
};


// Class TgGame.TgRecoilKeyframe
// 0x0028 (0x0088 - 0x0060)
class UTgRecoilKeyframe : public UObject
{
public:
	float                                              firingTime;                                               // 0x0060(0x0004) (Edit)
	struct FRawDistributionFloat                       RecoilPerShot;                                            // 0x0064(0x0024) (Edit, Component, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgRecoilKeyframe");
		return ptr;
	}

};


// Class TgGame.TgRoyaleZeppelin
// 0x0058 (0x02D8 - 0x0280)
class ATgRoyaleZeppelin : public AActor
{
public:
	class USkeletalMeshComponent*                      m_SkeletalMeshComponent;                                  // 0x0280(0x0008) (Edit, ExportObject, Component, EditInline)
	class USkeletalMeshComponent*                      m_LootCrateSkeletalMeshComponent;                         // 0x0288(0x0008) (Edit, ExportObject, Component, EditInline)
	class ULightEnvironmentComponent*                  m_LightEnvironment;                                       // 0x0290(0x0008) (Edit, Const, ExportObject, EditConst, Component, EditInline)
	class UTgAnimNodeBlendList*                        m_ZeppelinAnimNodeBlendList;                              // 0x0298(0x0008)
	struct FVector                                     m_vLootSpawnOffset;                                       // 0x02A0(0x000C)
	struct FVector                                     m_vLootSpawnLocation;                                     // 0x02AC(0x000C)
	float                                              m_fAirSpeed;                                              // 0x02B8(0x0004)
	float                                              m_fDeployTime;                                            // 0x02BC(0x0004)
	struct FVector                                     r_vRouteDir;                                              // 0x02C0(0x000C) (Net)
	unsigned long                                      r_bSpawnedEpicLootCrate : 1;                              // 0x02CC(0x0004) (Net)
	int                                                m_nZeppelinMeshAsmId;                                     // 0x02D0(0x0004)
	int                                                m_nLootCrateMeshAsmId;                                    // 0x02D4(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgRoyaleZeppelin");
		return ptr;
	}


	void SetupZeppelinRoute(const struct FVector& LootSpawnLoc);
	void STATIC_OnSpawnedEpicLootCrate();
	void PostBeginPlay();
	void STATIC_PostInitAnimTree(class USkeletalMeshComponent* SkelComp);
	void UpdateVelocity();
	void STATIC_ReplicatedEvent(const struct FName& VarName);
	void STATIC_InitializeMesh();
	void DeployTimer();
};


// Class TgGame.TgSavedMove
// 0x0010 (0x0128 - 0x0118)
class UTgSavedMove : public USavedMove
{
public:
	unsigned char                                      m_byMoveSpeed;                                            // 0x0118(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0119(0x0003) MISSED OFFSET
	unsigned long                                      m_bJumpHeld : 1;                                          // 0x011C(0x0004)
	unsigned long                                      m_bUltHeld : 1;                                           // 0x011C(0x0004)
	unsigned long                                      m_bMounted : 1;                                           // 0x011C(0x0004)
	unsigned long                                      m_bInADS : 1;                                             // 0x011C(0x0004)
	float                                              m_fSimulatedModifiedMovementSpeed;                        // 0x0120(0x0004)
	int                                                m_nBigTeleportCount;                                      // 0x0124(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSavedMove");
		return ptr;
	}


	TEnumAsByte<EDoubleClickDir> STATIC_SetFlags(unsigned char Flags, class APlayerController* PC);
	unsigned char STATIC_CompressedFlags();
	void STATIC_ResetMoveFor(class APawn* P);
	void PrepMoveFor(class APawn* P);
	void PostUpdate(class APlayerController* P);
	void STATIC_SetMoveFor(class APlayerController* P, float DeltaTime, const struct FVector& newAccel, TEnumAsByte<EDoubleClickDir> InDoubleClick);
	bool STATIC_CanCombineWith(class USavedMove* NewMove, class APawn* inPawn, float MaxDelta);
	bool IsImportantMove(const struct FVector& CompareAccel);
	void Clear();
};


// Class TgGame.TgScreenCapturePostEffect
// 0x000C (0x009C - 0x0090)
class UTgScreenCapturePostEffect : public UMaterialEffect
{
public:
	class UTextureRenderTarget2D*                      ScreenCapture;                                            // 0x0090(0x0008) (Transient)
	unsigned long                                      bIsScreenCaptureReady : 1;                                // 0x0098(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgScreenCapturePostEffect");
		return ptr;
	}


	void STATIC_Cleanup(class UPostProcessChain* InPostProcessChain);
	void CleanupRenderTarget();
	void STATIC_InitializeRenderTarget(class APlayerController* PlayerController);
};


// Class TgGame.TgSeqEvent_BotDied
// 0x0008 (0x0130 - 0x0128)
class UTgSeqEvent_BotDied : public USequenceEvent
{
public:
	int                                                m_nBotsKilled;                                            // 0x0128(0x0004) (Edit)
	int                                                m_nBotsKilledCounter;                                     // 0x012C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_BotDied");
		return ptr;
	}


	void UpdateLinkedVars(class AActor* Killer);
};


// Class TgGame.TgSeqEvent_BotSpawned
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_BotSpawned : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_BotSpawned");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_BurnCardPurchased
// 0x0008 (0x0130 - 0x0128)
class UTgSeqEvent_BurnCardPurchased : public USequenceEvent
{
public:
	int                                                nFilledSlots;                                             // 0x0128(0x0004)
	unsigned long                                      bAllBurnSlotsFull : 1;                                    // 0x012C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_BurnCardPurchased");
		return ptr;
	}


	bool TriggerGlobal(class AActor* InInstigator, int InFilledSlotsCount, bool bInAllBurnSlotsFull);
};


// Class TgGame.TgSeqEvent_ChaosGameEvent
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_ChaosGameEvent : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_ChaosGameEvent");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_ClassSelected
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_ClassSelected : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_ClassSelected");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_DebugConsoleKismetTest
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_DebugConsoleKismetTest : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_DebugConsoleKismetTest");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_DoorStatusChanged
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_DoorStatusChanged : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_DoorStatusChanged");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_FactoryEmpty
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_FactoryEmpty : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_FactoryEmpty");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_InputReceived
// 0x0004 (0x012C - 0x0128)
class UTgSeqEvent_InputReceived : public USequenceEvent
{
public:
	unsigned long                                      bAllowInputDisabling : 1;                                 // 0x0128(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_InputReceived");
		return ptr;
	}


	bool TriggerGlobal(class AActor* InInstigator, TEnumAsByte<EPlayerInputType> InputType, bool bInputEnabled);
};


// Class TgGame.TgSeqEvent_LoadoutChanged
// 0x0004 (0x012C - 0x0128)
class UTgSeqEvent_LoadoutChanged : public USequenceEvent
{
public:
	int                                                DeckIndex;                                                // 0x0128(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_LoadoutChanged");
		return ptr;
	}


	bool TriggerGlobal(class AActor* InInstigator, int InDeckIndex);
};


// Class TgGame.TgSeqEvent_LobbyEvents
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_LobbyEvents : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_LobbyEvents");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_LocalPlayerDied
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_LocalPlayerDied : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_LocalPlayerDied");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_LocalPlayerRecalled
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_LocalPlayerRecalled : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_LocalPlayerRecalled");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_LocalPlayerScoredKill
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_LocalPlayerScoredKill : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_LocalPlayerScoredKill");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_LocalPlayersTeamScoredPhoenixKill
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_LocalPlayersTeamScoredPhoenixKill : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_LocalPlayersTeamScoredPhoenixKill");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_LocalPlayersTeamScoredTowerKill
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_LocalPlayersTeamScoredTowerKill : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_LocalPlayersTeamScoredTowerKill");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_LookAtReceived
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_LookAtReceived : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_LookAtReceived");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_MICParameterEvent
// 0x0014 (0x013C - 0x0128)
class UTgSeqEvent_MICParameterEvent : public USequenceEvent
{
public:
	TEnumAsByte<EeMICEventType>                        MICEventType;                                             // 0x0128(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0129(0x0003) MISSED OFFSET
	TArray<class UMaterialInstanceConstant*>           AttachedMICs;                                             // 0x012C(0x0010) (Edit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_MICParameterEvent");
		return ptr;
	}


	void STATIC_SetVectorParameterValue(const struct FName& ParamName, const struct FLinearColor& Value);
	void STATIC_SetScalarParameterValue(const struct FName& ParamName, float fValue);
};


// Class TgGame.TgSeqEvent_PayloadGameEvent
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_PayloadGameEvent : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_PayloadGameEvent");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_PlaceableDestroyed
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_PlaceableDestroyed : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_PlaceableDestroyed");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_PlayerCountHit
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_PlayerCountHit : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_PlayerCountHit");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_PlayerInitialized
// 0x0004 (0x012C - 0x0128)
class UTgSeqEvent_PlayerInitialized : public USequenceEvent
{
public:
	unsigned long                                      bLocalPlayerOnly : 1;                                     // 0x0128(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_PlayerInitialized");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_PlayOfTheGame
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_PlayOfTheGame : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_PlayOfTheGame");
		return ptr;
	}


	void UpdateLinkedVars(int MapLane);
};


// Class TgGame.TgSeqEvent_SurvivalGameEvent
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_SurvivalGameEvent : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_SurvivalGameEvent");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_TutorialEvent
// 0x0008 (0x0130 - 0x0128)
class UTgSeqEvent_TutorialEvent : public USequenceEvent
{
public:
	TEnumAsByte<ETUTORIAL_EVENT>                       TutEvent;                                                 // 0x0128(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0129(0x0003) MISSED OFFSET
	int                                                EventData;                                                // 0x012C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_TutorialEvent");
		return ptr;
	}


	int STATIC_GetObjClassVersion();
};


// Class TgGame.TgSeqEvent_VaultLowHealth
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_VaultLowHealth : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_VaultLowHealth");
		return ptr;
	}

};


// Class TgGame.TgSkinnableInterface
// 0x0000 (0x0060 - 0x0060)
class UTgSkinnableInterface : public UInterface
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkinnableInterface");
		return ptr;
	}

};


// Class TgGame.TgSoundNodeAttenuation
// 0x0000 (0x0094 - 0x0094)
class UTgSoundNodeAttenuation : public USoundNodeAttenuation
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSoundNodeAttenuation");
		return ptr;
	}

};


// Class TgGame.TgSpectatorDirector
// 0x006C (0x02EC - 0x0280)
class ATgSpectatorDirector : public AInfo
{
public:
	unsigned long                                      m_bIsActive : 1;                                          // 0x0280(0x0004) (Transient)
	unsigned long                                      m_bIsPending : 1;                                         // 0x0280(0x0004) (Transient)
	unsigned long                                      m_bAutoSwitchCameraViews : 1;                             // 0x0280(0x0004) (Transient)
	unsigned long                                      m_bForceThirdPersonView : 1;                              // 0x0280(0x0004) (Transient)
	float                                              m_fRemainingAutoUpdateCheckTime;                          // 0x0284(0x0004)
	float                                              m_fTimeSinceViewSwitchedTeams;                            // 0x0288(0x0004)
	float                                              m_fTimeSinceViewSwitchedMode;                             // 0x028C(0x0004)
	float                                              m_fRemainingAutoReturnCheckTime;                          // 0x0290(0x0004)
	TEnumAsByte<ESpectatorCameraMode>                  m_CurrentCameraMode;                                      // 0x0294(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0295(0x0003) MISSED OFFSET
	struct FViewTargetInfo                             m_CurrentRatedViewTarget;                                 // 0x0298(0x0024)
	struct FViewTargetInfo                             m_DemoRewindViewTarget;                                   // 0x02BC(0x0024) (Transient)
	struct FVector2D                                   m_v2dForcedDirectorLocation;                              // 0x02E0(0x0008) (Transient)
	float                                              m_fForcedDirectorLocationTimestamp;                       // 0x02E8(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSpectatorDirector");
		return ptr;
	}


	void SetForcedDirectorLocation(const struct FVector2D& NewLocation);
	void STATIC_ClearAssistModeTarget();
	void STATIC_PostDemoRewind();
	void STATIC_PreDemoRewind();
	bool STATIC_IsPending();
	bool STATIC_IsActive();
	bool STATIC_IsCurrentlyViewing();
	void ResetCamera(class ATgSpectatorController* PC);
	void STATIC_SetActive(bool bIsActive);
	void STATIC_SetCameraMode(TEnumAsByte<ESpectatorCameraMode> NewCameraMode);
	void SetViewTarget(const struct FViewTargetInfo& NewViewTarget);
	void UpdateOverviewCamUI(bool bEnable);
	void STATIC_OnPlayerMoved();
};


// Class TgGame.TgSplineLoftActorSpawnable
// 0x0000 (0x0340 - 0x0340)
class ATgSplineLoftActorSpawnable : public ASplineLoftActorMovable
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSplineLoftActorSpawnable");
		return ptr;
	}

};


// Class TgGame.TgStealthGrassActor
// 0x0080 (0x0300 - 0x0280)
class ATgStealthGrassActor : public AActor
{
public:
	struct FVector                                     c_vBaseOffset;                                            // 0x0280(0x000C)
	struct FVector                                     c_vGrassOffset;                                           // 0x028C(0x000C) (Edit)
	float                                              c_fGrassOffsetInterpSpeed;                                // 0x0298(0x0004) (Edit)
	unsigned long                                      c_bLowerGrass : 1;                                        // 0x029C(0x0004)
	unsigned long                                      m_bHasLoot : 1;                                           // 0x029C(0x0004)
	unsigned long                                      r_bCanHealNow : 1;                                        // 0x029C(0x0004) (Net)
	float                                              c_fLowerGrassAlpha;                                       // 0x02A0(0x0004)
	class UStaticMeshComponent*                        c_GrassMesh;                                              // 0x02A4(0x0008) (Edit, ExportObject, Component, EditInline)
	class UStaticMeshComponent*                        c_GroundMesh;                                             // 0x02AC(0x0008) (Edit, ExportObject, Component, EditInline)
	class UParticleSystemComponent*                    m_ParticleSystemComponent;                                // 0x02B4(0x0008) (Edit, Const, ExportObject, EditConst, Component, EditInline)
	class UParticleSystem*                             m_LootParticleSystem;                                     // 0x02BC(0x0008)
	class UParticleSystem*                             m_NoLootParticleSystem;                                   // 0x02C4(0x0008)
	class ATgDeployable*                               m_SpawnedDeployable;                                      // 0x02CC(0x0008)
	float                                              m_fDeployableSpawnTimer;                                  // 0x02D4(0x0004) (Edit)
	float                                              m_fDeployableSpawnChanceOnInit;                           // 0x02D8(0x0004) (Edit)
	float                                              m_fDeployableSpawnChanceOnTimer;                          // 0x02DC(0x0004) (Edit)
	int                                                m_nLootDeployableId;                                      // 0x02E0(0x0004)
	class ATgDevice*                                   m_HealingDevice;                                          // 0x02E4(0x0008)
	int                                                m_HealingDeviceId;                                        // 0x02EC(0x0004)
	float                                              m_fDisableHealingTime;                                    // 0x02F0(0x0004)
	float                                              m_fEnableHealingTime;                                     // 0x02F4(0x0004)
	float                                              AlwaysRelevantDistanceSquared;                            // 0x02F8(0x0004)
	float                                              MaxRelevantDistanceSquared;                               // 0x02FC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgStealthGrassActor");
		return ptr;
	}


	void STATIC_OnTouchedHealthNugget(bool bTouched);
	void SetCanHealNow(bool bEnabled);
	void SpawnDeployableTimer();
	void EnableHealingTimer();
	void DisableHealingTimer();
	void ApplyHealingTimer();
	void CacheHealingDevice();
	void PostBeginPlay();
	void SpawnDeployable(float SpawnChance);
	void STATIC_ReplicatedEvent(const struct FName& VarName);
};


// Class TgGame.TgTargetAimTrackingCurves
// 0x0098 (0x00F8 - 0x0060)
class UTgTargetAimTrackingCurves : public UObject
{
public:
	struct FName                                       SettingsName;                                             // 0x0060(0x0008) (Edit)
	struct FRawDistributionFloat                       StrengthByAccuracyX;                                      // 0x0068(0x0024) (Edit, Component, NeedCtorLink)
	struct FRawDistributionFloat                       StrengthByDesiredAngleX;                                  // 0x008C(0x0024) (Edit, Component, NeedCtorLink)
	struct FRawDistributionFloat                       StrengthByAccuracyY;                                      // 0x00B0(0x0024) (Edit, Component, NeedCtorLink)
	struct FRawDistributionFloat                       StrengthByDesiredAngleY;                                  // 0x00D4(0x0024) (Edit, Component, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgTargetAimTrackingCurves");
		return ptr;
	}

};


// Class TgGame.TgTeamRoyaleZeppelin
// 0x0099 (0x0319 - 0x0280)
class ATgTeamRoyaleZeppelin : public AActor
{
public:
	class USkeletalMeshComponent*                      m_SkeletalMeshComponent;                                  // 0x0280(0x0008) (Edit, ExportObject, Component, EditInline)
	class ULightEnvironmentComponent*                  m_LightEnvironment;                                       // 0x0288(0x0008) (Edit, Const, ExportObject, EditConst, Component, EditInline)
	TArray<class ATgRepInfo_Player*>                   m_PlayerList;                                             // 0x0290(0x0010) (NeedCtorLink)
	TArray<class ATgRepInfo_TaskForce*>                m_TaskForceList;                                          // 0x02A0(0x0010) (NeedCtorLink)
	struct FVector                                     m_DeployLocation;                                         // 0x02B0(0x000C)
	struct FRotator                                    m_DeployRotation;                                         // 0x02BC(0x000C)
	float                                              m_fDeployTime;                                            // 0x02C8(0x0004)
	float                                              m_fFlightDistance;                                        // 0x02CC(0x0004)
	float                                              m_fFlightTime;                                            // 0x02D0(0x0004)
	float                                              m_fFlightLerpAlpha;                                       // 0x02D4(0x0004)
	float                                              m_fDownFlightTime;                                        // 0x02D8(0x0004)
	float                                              r_fDownFlightDist;                                        // 0x02DC(0x0004) (Net)
	float                                              m_fDownFlightAlpha;                                       // 0x02E0(0x0004)
	float                                              r_fHealthPool;                                            // 0x02E4(0x0004) (Net)
	struct FVector                                     r_vInitialLoc;                                            // 0x02E8(0x000C) (Net)
	struct FVector                                     r_vTargetFlightLoc;                                       // 0x02F4(0x000C) (Net)
	int                                                m_nZeppelinMeshAsmId;                                     // 0x0300(0x0004)
	unsigned long                                      c_bLocalViewTarget : 1;                                   // 0x0304(0x0004)
	unsigned long                                      m_bStopAtInitialDeployRange : 1;                          // 0x0304(0x0004)
	unsigned long                                      r_bDestroyAfterDeploy : 1;                                // 0x0304(0x0004) (Net)
	unsigned long                                      r_bReadyForDeploy : 1;                                    // 0x0304(0x0004) (Net)
	int                                                r_nTeam;                                                  // 0x0308(0x0004) (Net)
	float                                              m_fInitialDeployRemainingTime;                            // 0x030C(0x0004)
	float                                              m_fAutoDeployRemainingTime;                               // 0x0310(0x0004)
	float                                              m_fAutoDeployTime;                                        // 0x0314(0x0004)
	TEnumAsByte<EZepFlightStatus>                      m_eFlightStatus;                                          // 0x0318(0x0001)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgTeamRoyaleZeppelin");
		return ptr;
	}


	void STATIC_EndViewTarget(class APlayerController* PC);
	void STATIC_BecomeViewTarget(class APlayerController* PC);
	void TakeFlight();
	void STATIC_AutoDeployPlayers();
	void DeployPlayerTimer();
	void DeployPlayerFromTimer(class ATgPawn* pPawn, class ATgRepInfo_Player* TgPRI, const struct FVector& DeployOffset);
	void STATIC_DeployPlayer(class ATgPawn* pPawn);
	void STATIC_InitFlightPath();
	void STATIC_PlayReadyToDeployVFX();
	void STATIC_ReplicatedEvent(const struct FName& VarName);
	void PostBeginPlay();
	void STATIC_InitializeMesh();
	void AddTaskForce(class ATgRepInfo_TaskForce* pTaskForce);
	void AddPlayer(class ATgRepInfo_Player* Player);
};


// Class TgGame.TgTournamentRoyaleZeppelin
// 0x0003 (0x031C - 0x0319)
class ATgTournamentRoyaleZeppelin : public ATgTeamRoyaleZeppelin
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0319(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgTournamentRoyaleZeppelin");
		return ptr;
	}


	void STATIC_AutoDeployPlayers();
};


// Class TgGame.TgTimerManager
// 0x0054 (0x00B4 - 0x0060)
class UTgTimerManager : public UObject
{
public:
	struct FPointer                                    VfTable_FTickableObject;                                  // 0x0060(0x0008) (Const, Native, NoExport)
	unsigned char                                      UnknownData00[0x48];                                      // 0x0068(0x0048) UNKNOWN PROPERTY: MapProperty TgGame.TgTimerManager.m_TimerMap
	unsigned long                                      m_bActive : 1;                                            // 0x00B0(0x0004)
	unsigned long                                      m_bGameWasPaused : 1;                                     // 0x00B0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgTimerManager");
		return ptr;
	}


	void CloseAllTimers(bool bFireEvent);
	bool STATIC_IsActiveTimers();
	bool UnRegisterForEvents(int byTimerIndex, class UObject* HostObject);
	bool RegisterForEvents(int byTimerIndex, class UObject* HostObject, const struct FName& nmFunc);
	void SetRate(int TimerIndex, float Rate);
	float STATIC_GetTimeInitial(int byTimerIndex);
	float STATIC_GetPercentRemaining(int byTimerIndex);
	float STATIC_GetTimeRemaining(int byTimerIndex);
	float STATIC_GetTimeElapsed(int byTimerIndex);
	bool STATIC_IsPaused(int byTimerIndex);
	bool STATIC_IsSet(int byTimerIndex);
	bool STATIC_Close(int byTimerIndex, bool bFireEvent);
	bool Pause(int byTimerIndex, float fTime);
	bool STATIC_Update(int byTimerIndex, float fTime, float fTimeInitial, float Rate);
	bool STATIC_Start(int byTimerIndex, float fTime, bool bRepeat, bool bPausedByGame, float Rate);
};


// Class TgGame.TgVolumePathNode
// 0x001C (0x039C - 0x0380)
class ATgVolumePathNode : public AVolumePathNode
{
public:
	unsigned long                                      m_bIsAboveGround : 1;                                     // 0x0380(0x0004) (Edit, EditConst)
	struct FVector                                     m_vGroundHitLocation;                                     // 0x0384(0x000C) (Edit, EditConst)
	float                                              m_fGroundTraceDistance;                                   // 0x0390(0x0004) (Edit)
	class USpriteComponent*                            m_GroundSprite;                                           // 0x0394(0x0008) (ExportObject, Component, EditInline)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgVolumePathNode");
		return ptr;
	}

};


// Class TgGame.TgWaterFXVolume
// 0x0000 (0x02BC - 0x02BC)
class ATgWaterFXVolume : public AVolume
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgWaterFXVolume");
		return ptr;
	}


	void UnTouch(class AActor* Other);
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
};


// Class TgGame.TgWeaponMeshActor
// 0x0284 (0x0504 - 0x0280)
class ATgWeaponMeshActor : public AActor
{
public:
	class ATgPawn*                                     m_OwningPawn;                                             // 0x0280(0x0008)
	class UClass*                                      m_WeaponMesh1PClass;                                      // 0x0288(0x0008) (Const)
	class UTgSkeletalMeshComponent_Weapon*             m_WeaponMesh1P;                                           // 0x0290(0x0008) (ExportObject, Component, EditInline)
	class UClass*                                      m_WeaponMesh3PClass;                                      // 0x0298(0x0008) (Const)
	class UTgSkeletalMeshComponent_Weapon*             m_WeaponMesh3P;                                           // 0x02A0(0x0008) (ExportObject, Component, EditInline)
	TArray<class UTgAnimNodeSimpleTransitioner*>       m_SimpleTransitionerNodes1P;                              // 0x02A8(0x0010) (NeedCtorLink)
	TArray<class UTgAnimBlendByFireMode*>              m_DeviceModeBlendNodes;                                   // 0x02B8(0x0010) (NeedCtorLink)
	TArray<class UTgAnimNodeFitToDuration*>            m_FitToDurationNodes;                                     // 0x02C8(0x0010) (NeedCtorLink)
	TArray<class UTgAnimBlendByRealmCharacter*>        m_RealmCharacterNodes;                                    // 0x02D8(0x0010) (NeedCtorLink)
	TArray<class UTgAnimNodeTriggerCameraAnim*>        m_TriggerCameraAnimNodes;                                 // 0x02E8(0x0010) (NeedCtorLink)
	class UTgAnimNodeSlot*                             PoseTransitioner;                                         // 0x02F8(0x0008)
	class UTgAnimNodeBlendByWeaponAnim*                m_PrimaryWeaponBlendNode;                                 // 0x0300(0x0008)
	TArray<class UTgAnimBlendByRecoilTime*>            m_PawnMeshRecoilBlendNode;                                // 0x0308(0x0010) (NeedCtorLink)
	TArray<class UTgAnimNodeSimpleTransitioner*>       m_PawnMeshSimpleTransitionerNodes;                        // 0x0318(0x0010) (NeedCtorLink)
	TArray<class UTgAnimNodeFitToDuration*>            m_PawnMeshFitToDurationNodes;                             // 0x0328(0x0010) (NeedCtorLink)
	TArray<class UTgAnimBlendByRealmCharacter*>        m_PawnMeshRealmCharacterNodes;                            // 0x0338(0x0010) (NeedCtorLink)
	TArray<class UTgAnimNodeTriggerCameraAnim*>        m_PawnMeshTriggerCameraAnimNodes;                         // 0x0348(0x0010) (NeedCtorLink)
	TArray<class UTgAnimBlendByFireMode*>              m_PawnDeviceModeBlendNodes;                               // 0x0358(0x0010) (NeedCtorLink)
	TArray<class UTgAnimNodeBlendByFireType*>          m_PawnMeshBlendByFireTypeNodes;                           // 0x0368(0x0010) (NeedCtorLink)
	TArray<class UTgAnimNodeAimOffset*>                m_PawnMeshAimOffsets;                                     // 0x0378(0x0010) (NeedCtorLink)
	TArray<class UTgAnimNodeBlendByMovementAbility*>   m_PawnMovementAbilityNodes;                               // 0x0388(0x0010) (NeedCtorLink)
	TArray<class UTgAnimBlendByWeaponSwapType*>        m_PawnWeaponSwapNodes;                                    // 0x0398(0x0010) (NeedCtorLink)
	TArray<class UTgAnimBlendByRealmCharacter*>        m_WeaponRealmCharacterNodes;                              // 0x03A8(0x0010) (NeedCtorLink)
	int                                                m_nEquipSlot;                                             // 0x03B8(0x0004)
	int                                                m_nDeviceId;                                              // 0x03BC(0x0004)
	int                                                m_MeshAsmId1P;                                            // 0x03C0(0x0004)
	int                                                m_MeshAsmId3P;                                            // 0x03C4(0x0004)
	class UClass*                                      m_WeaponClass;                                            // 0x03C8(0x0008) (Edit, EditInline)
	TEnumAsByte<ETG_PLAY_FIRE_EFFECT_ON>               m_PlayFireEffectsOn[0x14];                                // 0x03D0(0x0001)
	TEnumAsByte<ETG_EQUIP_POINT>                       m_ActiveEquipPoint;                                       // 0x03E4(0x0001)
	TEnumAsByte<EFirstPersonWeaponAttachState>         Current1pAttachState;                                     // 0x03E5(0x0001) (Transient)
	unsigned char                                      UnknownData00[0x2];                                       // 0x03E6(0x0002) MISSED OFFSET
	unsigned long                                      m_bShouldLoopingMuzzleTrace : 1;                          // 0x03E8(0x0004)
	unsigned long                                      m_bUseSocketForCameraAttach : 1;                          // 0x03E8(0x0004)
	unsigned long                                      m_bProceduralBob : 1;                                     // 0x03E8(0x0004)
	unsigned long                                      m_bIsFOVZoomed : 1;                                       // 0x03E8(0x0004)
	unsigned long                                      m_bFlourishBlocked : 1;                                   // 0x03E8(0x0004)
	unsigned long                                      m_bIsHoldingBeacon : 1;                                   // 0x03E8(0x0004) (Transient)
	unsigned long                                      m_bWasViewTargetLastTick : 1;                             // 0x03E8(0x0004)
	unsigned long                                      m_bUseCameraAnims : 1;                                    // 0x03E8(0x0004)
	unsigned long                                      c_bEnemyMatLoaded : 1;                                    // 0x03E8(0x0004)
	unsigned long                                      m_bFullScreenScope : 1;                                   // 0x03E8(0x0004) (Edit)
	float                                              m_fBobMult1;                                              // 0x03EC(0x0004) (Edit)
	float                                              m_fBobMult2;                                              // 0x03F0(0x0004) (Edit)
	class UTgSkeletalMeshComponent*                    m_HandsMesh;                                              // 0x03F4(0x0008) (ExportObject, Component, EditInline)
	class UTgSkeletalMeshComponent*                    m_HeadMesh1P;                                             // 0x03FC(0x0008) (ExportObject, Component, EditInline)
	struct FVector2D                                   m_v2WeaponLagAimOffset;                                   // 0x0404(0x0008)
	struct FVector2D                                   m_nMaxWeaponLag;                                          // 0x040C(0x0008) (Edit)
	struct FVector2D                                   m_v2WeaponLagInterpSpeed;                                 // 0x0414(0x0008) (Edit)
	struct FVector2D                                   m_v2WeaponLagSmoothingFactor;                             // 0x041C(0x0008) (Edit)
	struct FRotator                                    m_rLastRotation;                                          // 0x0424(0x000C)
	struct FVector2D                                   m_fSmoothedAimOffset;                                     // 0x0430(0x0008)
	float                                              m_fSmoothAimFactor;                                       // 0x0438(0x0004) (Edit)
	class UTgCameraShake*                              m_FireCameraShake;                                        // 0x043C(0x0008) (Edit, EditInline)
	int                                                m_nTracerCounter;                                         // 0x0444(0x0004)
	int                                                m_nTracerFrequency;                                       // 0x0448(0x0004) (Edit)
	struct FName                                       m_TracerName;                                             // 0x044C(0x0008)
	float                                              m_fTracerLifetime;                                        // 0x0454(0x0004)
	struct FName                                       m_HitTargetName;                                          // 0x0458(0x0008)
	struct FName                                       m_HitWallName;                                            // 0x0460(0x0008)
	struct FName                                       m_WhizbyName;                                             // 0x0468(0x0008)
	float                                              m_BeamEmitterEndPointOffset;                              // 0x0470(0x0004) (Edit)
	int                                                m_nBeaconMeshId;                                          // 0x0474(0x0004) (Const)
	TArray<class UTgSkelCon_HitReaction*>              m_HitReactionSkelControls;                                // 0x0478(0x0010) (NeedCtorLink)
	TArray<struct FQueuedImpactEffect>                 m_QueuedImpactEffects;                                    // 0x0488(0x0010) (NeedCtorLink)
	class UGameSkelCtrl_Recoil*                        m_LandSkelControl;                                        // 0x0498(0x0008) (Transient)
	class UTgGameplayCurves*                           m_GameplayCurves;                                         // 0x04A0(0x0008)
	class USkelControlSingleBone*                      m_FlyingSkelControl;                                      // 0x04A8(0x0008)
	class USkelControlSingleBone*                      m_WeaponDownSkelControl;                                  // 0x04B0(0x0008)
	class UGameSkelCtrl_Recoil*                        m_JumpSkelControl;                                        // 0x04B8(0x0008)
	class UGameSkelCtrl_Recoil*                        m_DoubleJumpSkelControl;                                  // 0x04C0(0x0008)
	float                                              m_fDesiredZoomMeshFOV;                                    // 0x04C8(0x0004) (Edit)
	float                                              m_fDesiredZoomViewFOV;                                    // 0x04CC(0x0004) (Edit)
	float                                              m_fADSZoomInTime;                                         // 0x04D0(0x0004) (Edit)
	float                                              m_fADSZoomOutTime;                                        // 0x04D4(0x0004) (Edit)
	struct FVector                                     m_vZoomMeshOffset;                                        // 0x04D8(0x000C) (Edit)
	class UTgMuzzleFlash*                              m_MuzzleFlashLight;                                       // 0x04E4(0x0008) (ExportObject, Component, EditInline)
	TArray<class UTgSkelCon_Recoil*>                   m_RecoilSkelControls;                                     // 0x04EC(0x0010) (NeedCtorLink)
	struct FName                                       m_nAnimSetPackageName;                                    // 0x04FC(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgWeaponMeshActor");
		return ptr;
	}


	void PlayMuzzleFlashLight(bool bIsEnemy, bool bIsLocal, class UTgMuzzleFlash** MuzzleFlash);
	void PlayCharSpecificAnim(int nSlot, float fActivationTime);
	void STATIC_OnCompletelyNotZoomed();
	void STATIC_OnCompletelyZoomed();
	void STATIC_EndADS();
	void StartADS();
	void PlayWeaponQuickRetrieve();
	void PlayWeaponQuickPutaway();
	void StopVault();
	void STATIC_PlayVault();
	void PlayLand();
	void PlayMeshTransitionAnimation(const struct FWeaponMeshSwapStrategy& SwapStrategy, TEnumAsByte<ETG_EQUIP_POINT> eqp, class ATgDevice* PreviousTargetingDevice, class ATgDevice* NextTargetingDevice);
	void Unhide3PWeaponMesh();
	void STATIC_Hide3PWeaponMesh();
	void STATIC_PlayHitReaction(TEnumAsByte<ERecoilHitDir> Dir, float DamageAmount);
	void CacheSkelControls();
	void NotifyLocalPlayerTeamReceived();
	void STATIC_OnPolymorphChanged(bool bDead);
	void AddWeaponLeading(const struct FRotator& NewRotation, const struct FRotator& OldRotation, float DeltaTime);
	void ResetFireLoopDisplayGroup();
	void SetFireLoopDisplayGroup(const struct FName& FireLoop, const struct FName& FireLoopTailSound);
	void SetFOVZoomed(bool bEnabled);
	void BlockFlourish(bool bBlock);
	void STATIC_PlayFlourish();
	void StopReloadAnim();
	void STATIC_PlayReload(int nEqpPoint, float ReloadTime, int AmmoRemainingInClip, int ReloadType);
	void StopFireEffects(int nEquipSlot, TEnumAsByte<EDeviceSubtype> eDeviceSubtype, bool bForceBlendOutOnAnimEnd);
	struct FVector STATIC_GetClampedEmitDirection(const struct FVector& vInput, const struct FVector& vReflect);
	void PlayInstantHitImpactEffects(const struct FVector& HitLocation, bool bSuccessfulHit, class AActor* HitActor, const struct FVector& HitNormal, const struct FVector& FireOrigin, int nEquipSlot);
	class UTgSpecialFx* STATIC_GetMeshFx(const struct FName& nmDisplayGroupName, int nEquipSlot);
	void STATIC_GetFiringSocketTransform(struct FVector* fireLoc, struct FRotator* FireRot);
	void PlayQueuedInstantHitImpactEffects();
	void QueueInstantHitImpactEffects(const struct FVector& HitLocation, bool bSuccessfulHit, class AActor* HitActor, const struct FVector& HitNormal, const struct FVector& FireOrigin, int nEquipSlot);
	void STATIC_OverrideTracerFireLoc(struct FVector* fireLoc);
	void PlayTracerEffects(const struct FVector& endLocation, int nEquipSlot);
	class UTgSkeletalMeshComponent* STATIC_Get3PWeaponMesh();
	void Play3pFireAimedFX();
	void PlayDeviceFiredEffects(int nEquipSlot, float fRefireTime, int nFireMode, TEnumAsByte<EDeviceSubtype> eDeviceSubtype);
	void PlayFireAnimation(int nEquipSlot, float fRefireTime, TEnumAsByte<EDeviceSubtype> eDeviceSubtype, TEnumAsByte<EeMovementType> eMoveType, bool bForceBlendOutOnAnimEnd);
	bool CanEquipSlotPlayAnims(int nEquipSlot);
	void STATIC_PlayFireFx(int nEquipSlot, int nFireMode, TEnumAsByte<EDeviceSubtype> eDeviceSubtype);
	void PlayFireEffects(int nEquipSlot, float fRefireTime, int nFireMode, TEnumAsByte<EDeviceSubtype> eDeviceSubtype, TEnumAsByte<EeMovementType> eMoveType, bool bForceBlendOutOnAnimEnd);
	bool ShowAsLocallyOwned();
	void SetLoopingMuzzleEffects(bool bSetActive, int nEquipSlot);
	void AttackComboTimeout();
	void PlayBuildupEffects(int nEquipSlot, TEnumAsByte<EDeviceSubtype> eDeviceSubtype);
	void PlayTargetingEffects(int nEquipSlot);
	bool STATIC_GetSimulatedBeamTarget(int nEquipSlot, struct FVector* HitLocation);
	bool STATIC_GetAccurateBeamTarget(int nEquipSlot, struct FVector* HitLocation);
	void UpdateFireLoopBeamParams(bool bHasEndPoint, const struct FVector& HitLocation, int nEquipSlot);
	bool ShouldUpdateBeamEffects(int nEquipSlot);
	void UpdateBeamEffects(int nEquipSlotToUpdate);
	void STATIC_GetAllFireLoopParticleSystemComponents(int nEquipSlot, TArray<class UParticleSystemComponent*>* FireLoopParticles);
	void UpdateTransform(float DeltaTime, bool bFromCameraUpdate);
	void Tick(float DeltaTime);
	bool CanUseCameraBone();
	void Toggle1PVisibility(bool bVisible);
	void Set1PAttachState(TEnumAsByte<EFirstPersonWeaponAttachState> NewAttachState);
	void STATIC_OnBehindViewUpdated(bool bNewBehindView);
	void STATIC_PlayRetrieve(float fEquipTime);
	void STATIC_PlayPutAwayAnim(float fPutAwayTime);
	void PlayPutaway(TEnumAsByte<ETG_EQUIP_POINT> eqp, int DeviceID, class UClass* WeaponClass);
	void STATIC_SetActiveWeapon(unsigned char EquipPoint, int DeviceID, class UClass* WeaponClass, const struct FWeaponMeshSwapStrategy& SwapStrategy);
	void STATIC_Initialize3P(unsigned char EquipPoint, int DeviceID);
	void STATIC_PostInitAnimTree(class USkeletalMeshComponent* SkelComp);
	void STATIC_Initialize1P(unsigned char EquipPoint, int DeviceID, int MeshAsmId1P);
	void FixUpReferencesToWeaponMesh3P(class USkeletalMeshComponent* WeaponMesh);
	void FixUpReferencesToPawnMesh(class USkeletalMeshComponent* PawnMesh);
	void FixUpReferencesToWeaponMesh1P(class USkeletalMeshComponent* WeaponMesh);
	void STATIC_InitializeForWeapon(unsigned char EquipPoint, int DeviceID, bool bClearEquipPoint);
	void ClearEquipPoint(unsigned char EquipPoint);
	void Destroyed();
	bool STATIC_IsFirstPerson();
	void PostBeginPlay();
	int STATIC_GetFxOverrideFor(int nBaseFXID);
	float STATIC_CheckOcclusion();
	void SetLocationForWeapon(const struct FVector& NewLocation, class AActor* OwningPawn);
	void STATIC_RecalculateMaterial(bool bIsFriendlyWithLocalPawn, bool bForce);
	void ForceRecalculateMaterial();
	bool STATIC_IsFriendlyWithLocalPawn();
	class ATgDevice* STATIC_GetDefaultDevice();
	void STATIC_NativeInit(unsigned char EquipPoint, int DeviceID);
	void UpdateHeadMesh1P();
	void UpdateHandsMesh();
	float STATIC_GetMaxWhizbyDistSqr();
	void UpdateReticule();
	struct FString STATIC_GetWeaponClassById(int DeviceID);
	void STATIC_GetMeshAsmIds(int DeviceID, int* MeshId1P, int* MeshId3P);
};


// Class TgGame.TgWindowVaultVolume
// 0x0014 (0x02D0 - 0x02BC)
class ATgWindowVaultVolume : public AVolume
{
public:
	struct FRotator                                    m_WallDir;                                                // 0x02BC(0x000C) (Edit)
	class UArrowComponent*                             WallDirArrow;                                             // 0x02C8(0x0008) (ExportObject, Component, EditInline)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgWindowVaultVolume");
		return ptr;
	}

};


// Class TgGame.TgAnimBlendByPosture_Player
// 0x0000 (0x01AC - 0x01AC)
class UTgAnimBlendByPosture_Player : public UAnimNodeSequence
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendByPosture_Player");
		return ptr;
	}

};


// Class TgGame.TgAnimBlendByRecoilTime
// 0x002C (0x0150 - 0x0124)
class UTgAnimBlendByRecoilTime : public UAnimNodeBlend
{
public:
	class UTgDeviceForm*                               m_pDeviceForm;                                            // 0x0124(0x0008)
	class ATgDevice*                                   m_pDevice;                                                // 0x012C(0x0008)
	class ATgPawn*                                     m_TgPawn;                                                 // 0x0134(0x0008)
	float                                              m_PctBlend;                                               // 0x013C(0x0004)
	float                                              m_fFireHoldTimer;                                         // 0x0140(0x0004)
	float                                              m_fMaxFireHoldTime;                                       // 0x0144(0x0004)
	float                                              m_fBlendTime;                                             // 0x0148(0x0004) (Edit)
	float                                              m_fMaxRecoilTime;                                         // 0x014C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendByRecoilTime");
		return ptr;
	}


	void StartFireHoldTimer(float fFireHoldTime);
};


// Class TgGame.TgAnimBlendBySpeed
// 0x00A4 (0x021C - 0x0178)
class UTgAnimBlendBySpeed : public UAnimNodeBlendBySpeed
{
public:
	class ATgPawn*                                     m_TgPawn;                                                 // 0x0178(0x0008)
	TEnumAsByte<ESpeedType>                            m_SpeedType;                                              // 0x0180(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0181(0x0003) MISSED OFFSET
	TArray<struct FResetSynchGroup>                    ResetSynchGroups;                                         // 0x0184(0x0010) (Edit, NeedCtorLink)
	unsigned long                                      m_bIgnoreRootMotion : 1;                                  // 0x0194(0x0004) (Edit)
	unsigned long                                      m_bIgnoreZVelocity : 1;                                   // 0x0194(0x0004) (Edit)
	unsigned long                                      m_bNotifyOwnerOnChildChange : 1;                          // 0x0194(0x0004) (Edit)
	unsigned long                                      m_bEnableClassOverrides : 1;                              // 0x0194(0x0004) (Edit)
	TArray<int>                                        m_WalkChildren;                                           // 0x0198(0x0010) (Edit, NeedCtorLink)
	TArray<int>                                        m_SprintChildren;                                         // 0x01A8(0x0010) (Edit, NeedCtorLink)
	TArray<float>                                      m_BaseSpeed;                                              // 0x01B8(0x0010) (Edit, NeedCtorLink)
	TArray<TEnumAsByte<EPhysics>>                      m_IgnoredPhysics;                                         // 0x01C8(0x0010) (Edit, NeedCtorLink)
	int                                                m_nIndexToOverride;                                       // 0x01D8(0x0004) (Edit)
	float                                              m_fBaseSpeedRecon;                                        // 0x01DC(0x0004) (Edit)
	float                                              m_fBaseSpeedRobotics;                                     // 0x01E0(0x0004) (Edit)
	float                                              m_fBaseSpeedAssault;                                      // 0x01E4(0x0004) (Edit)
	float                                              m_fBaseSpeedMedic;                                        // 0x01E8(0x0004) (Edit)
	float                                              m_fBaseSpeedReconFemale;                                  // 0x01EC(0x0004) (Edit)
	float                                              m_fBaseSpeedRoboticsFemale;                               // 0x01F0(0x0004) (Edit)
	float                                              m_fBaseSpeedAssaultFemale;                                // 0x01F4(0x0004) (Edit)
	float                                              m_fBaseSpeedMedicFemale;                                  // 0x01F8(0x0004) (Edit)
	float                                              m_fBaseSpeedReconCity;                                    // 0x01FC(0x0004) (Edit)
	float                                              m_fBaseSpeedRoboticsCity;                                 // 0x0200(0x0004) (Edit)
	float                                              m_fBaseSpeedAssaultCity;                                  // 0x0204(0x0004) (Edit)
	float                                              m_fBaseSpeedMedicCity;                                    // 0x0208(0x0004) (Edit)
	float                                              m_fBaseSpeedReconFemaleCity;                              // 0x020C(0x0004) (Edit)
	float                                              m_fBaseSpeedRoboticsFemaleCity;                           // 0x0210(0x0004) (Edit)
	float                                              m_fBaseSpeedAssaultFemaleCity;                            // 0x0214(0x0004) (Edit)
	float                                              m_fBaseSpeedMedicFemaleCity;                              // 0x0218(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendBySpeed");
		return ptr;
	}


	void STATIC_OnInit();
	class UAnimNodeSynch* FindSynchAnimNode(const struct FName& nmNodeName);
};


// Class TgGame.TgAnimBlendBySpeedWithExhaustion
// 0x0038 (0x0254 - 0x021C)
class UTgAnimBlendBySpeedWithExhaustion : public UTgAnimBlendBySpeed
{
public:
	unsigned long                                      m_bEnableExhaustion : 1;                                  // 0x021C(0x0004) (Edit)
	float                                              m_fExhaustionLevel;                                       // 0x0220(0x0004) (Edit)
	TArray<int>                                        m_ExhaustedChildren;                                      // 0x0224(0x0010) (Edit, NeedCtorLink)
	TArray<int>                                        m_GainExhaustionChildren;                                 // 0x0234(0x0010) (Edit, NeedCtorLink)
	float                                              m_fExhaustionGainSpeed;                                   // 0x0244(0x0004) (Edit)
	float                                              m_fExhaustionLossSpeed;                                   // 0x0248(0x0004) (Edit)
	float                                              m_fExhaustionLevelMax;                                    // 0x024C(0x0004) (Edit)
	float                                              m_fExhaustionLevelMin;                                    // 0x0250(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendBySpeedWithExhaustion");
		return ptr;
	}

};


// Class TgGame.TgAnimBlendInterpBySpeed
// 0x0014 (0x0138 - 0x0124)
class UTgAnimBlendInterpBySpeed : public UAnimNodeBlend
{
public:
	class ATgPawn*                                     m_TgPawn;                                                 // 0x0124(0x0008)
	float                                              m_fBlendTime;                                             // 0x012C(0x0004) (Edit)
	float                                              m_fFullRunSpeed;                                          // 0x0130(0x0004) (Edit)
	float                                              m_fFullIdleSpeed;                                         // 0x0134(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendInterpBySpeed");
		return ptr;
	}

};


// Class TgGame.TgAnimBlendPerBone
// 0x0044 (0x019C - 0x0158)
class UTgAnimBlendPerBone : public UAnimNodeBlendPerBone
{
public:
	unsigned long                                      m_bLoopSourceChild : 1;                                   // 0x0158(0x0004) (Edit)
	unsigned long                                      m_bLoopTargetChild : 1;                                   // 0x0158(0x0004) (Edit)
	unsigned long                                      m_bPlaySourceChild : 1;                                   // 0x0158(0x0004) (Edit)
	unsigned long                                      m_bPlayTargetChild : 1;                                   // 0x0158(0x0004) (Edit)
	unsigned long                                      m_bSetStrengthFromAnimNode : 1;                           // 0x0158(0x0004) (Edit)
	unsigned long                                      m_bInvertStrengthFromAnimNode : 1;                        // 0x0158(0x0004) (Edit)
	unsigned long                                      m_bInitializedCachedNodeList : 1;                         // 0x0158(0x0004) (Transient)
	TArray<struct FName>                               m_StrengthAnimNodeNameList;                               // 0x015C(0x0010) (Edit, NeedCtorLink)
	TArray<TEnumAsByte<EEmote>>                        m_StrengthEmoteList;                                      // 0x016C(0x0010) (Edit, NeedCtorLink)
	TArray<class UAnimNode*>                           m_CachedNodeList;                                         // 0x017C(0x0010) (Transient, NeedCtorLink)
	TArray<class UTgAnimNodeEmoteSequence*>            m_CachedEmoteSequences;                                   // 0x018C(0x0010) (Transient, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendPerBone");
		return ptr;
	}


	void PlayAnim(bool bLoop, float Rate, float StartTime);
};


// Class TgGame.TgAnimMetaData_InvisibleWallFailSafe
// 0x0008 (0x0068 - 0x0060)
class UTgAnimMetaData_InvisibleWallFailSafe : public UAnimMetaData
{
public:
	struct FName                                       WallEnableBaseName;                                       // 0x0060(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimMetaData_InvisibleWallFailSafe");
		return ptr;
	}

};


// Class TgGame.TgAnimMetaData_Keyframed
// 0x0020 (0x0080 - 0x0060)
class UTgAnimMetaData_Keyframed : public UAnimMetaData
{
public:
	TArray<struct FMetaDataKeyFrame>                   KeyFrames;                                                // 0x0060(0x0010) (Edit, NeedCtorLink, EditInline)
	unsigned long                                      bForceFirstKeyFrameOnBecomeRelevant : 1;                  // 0x0070(0x0004) (Edit, Deprecated)
	unsigned long                                      bForceLastKeyFrameOnCeaseRelevant : 1;                    // 0x0070(0x0004) (Edit, Deprecated)
	TEnumAsByte<EOnRelevanceBehavior>                  OnBecomeRelevantBehavior;                                 // 0x0074(0x0001) (Edit)
	TEnumAsByte<EOnRelevanceBehavior>                  OnCeaseRelevantBehavior;                                  // 0x0075(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x2];                                       // 0x0076(0x0002) MISSED OFFSET
	float                                              OnBecomeRelevantStrength;                                 // 0x0078(0x0004) (Edit)
	float                                              OnCeaseRelevantStrength;                                  // 0x007C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimMetaData_Keyframed");
		return ptr;
	}

};


// Class TgGame.TgAnimMetaData_DisplayGroupPSCParam
// 0x0018 (0x0098 - 0x0080)
class UTgAnimMetaData_DisplayGroupPSCParam : public UTgAnimMetaData_Keyframed
{
public:
	struct FName                                       ParamName;                                                // 0x0080(0x0008) (Edit)
	struct FName                                       DisplayGroup;                                             // 0x0088(0x0008) (Edit)
	TEnumAsByte<ETG_EQUIP_POINT>                       EqpSlot;                                                  // 0x0090(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0091(0x0003) MISSED OFFSET
	unsigned long                                      bActivateGroupOnRelevant : 1;                             // 0x0094(0x0004) (Edit)
	unsigned long                                      bDeactivateGroupOnCeaseRelevant : 1;                      // 0x0094(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimMetaData_DisplayGroupPSCParam");
		return ptr;
	}

};


// Class TgGame.TgAnimMetaData_MICScalarParameter
// 0x000C (0x008C - 0x0080)
class UTgAnimMetaData_MICScalarParameter : public UTgAnimMetaData_Keyframed
{
public:
	struct FName                                       MICParameterName;                                         // 0x0080(0x0008) (Edit)
	int                                                MaterialIndex;                                            // 0x0088(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimMetaData_MICScalarParameter");
		return ptr;
	}

};


// Class TgGame.TgAnimMetaData_MICScalarParameterExtended
// 0x0054 (0x00E0 - 0x008C)
class UTgAnimMetaData_MICScalarParameterExtended : public UTgAnimMetaData_MICScalarParameter
{
public:
	unsigned long                                      bSearchSelf : 1;                                          // 0x008C(0x0004) (Edit)
	unsigned long                                      bSearchSiblings : 1;                                      // 0x008C(0x0004) (Edit)
	unsigned long                                      bSearchChildren : 1;                                      // 0x008C(0x0004) (Edit)
	unsigned long                                      bIncludeSearchParticles : 1;                              // 0x008C(0x0004) (Edit)
	unsigned long                                      bIncludeSearchMeshes : 1;                                 // 0x008C(0x0004) (Edit)
	unsigned long                                      bForceAllMaterials : 1;                                   // 0x008C(0x0004) (Edit)
	unsigned long                                      bFindAllMatchingMaterials : 1;                            // 0x008C(0x0004) (Edit)
	unsigned long                                      bHasSetMICs : 1;                                          // 0x008C(0x0004) (Transient)
	class UMaterialInstanceConstant*                   MaterialToFind;                                           // 0x0090(0x0008) (Edit, Const)
	class UMaterialInstanceConstant*                   MaterialToReplace;                                        // 0x0098(0x0008) (Edit, Const)
	TArray<struct FAlternateMaterialOverride>          AlternateMaterialList;                                    // 0x00A0(0x0010) (Edit, NeedCtorLink)
	TArray<struct FName>                               TexturesToHarvest;                                        // 0x00B0(0x0010) (Edit, Const, NeedCtorLink)
	TArray<struct FSwappedMeshResetInfo>               MaterialsToReset;                                         // 0x00C0(0x0010) (Transient, Component, NeedCtorLink)
	TArray<class UMaterialInstanceConstant*>           CurrentModifiedMICs;                                      // 0x00D0(0x0010) (Transient, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimMetaData_MICScalarParameterExtended");
		return ptr;
	}

};


// Class TgGame.TgAnimMetaData_MaskingPlane
// 0x0040 (0x0120 - 0x00E0)
class UTgAnimMetaData_MaskingPlane : public UTgAnimMetaData_MICScalarParameterExtended
{
public:
	int                                                WallIndex;                                                // 0x00E0(0x0004) (Edit)
	struct FVector                                     WallNormal;                                               // 0x00E4(0x000C) (Edit)
	struct FVector                                     WallPosition0;                                            // 0x00F0(0x000C) (Edit)
	struct FVector                                     WallPosition1;                                            // 0x00FC(0x000C) (Edit)
	struct FName                                       WallEnableBaseName;                                       // 0x0108(0x0008) (Const)
	struct FName                                       WallPositionBaseName;                                     // 0x0110(0x0008) (Const)
	struct FName                                       WallNormalBaseName;                                       // 0x0118(0x0008) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimMetaData_MaskingPlane");
		return ptr;
	}

};


// Class TgGame.TgAnimMetaData_ScaleWeaponMesh
// 0x0004 (0x0084 - 0x0080)
class UTgAnimMetaData_ScaleWeaponMesh : public UTgAnimMetaData_Keyframed
{
public:
	unsigned long                                      m_bSetKeysNoInterp : 1;                                   // 0x0080(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimMetaData_ScaleWeaponMesh");
		return ptr;
	}

};


// Class TgGame.TgAnimMetaData_MeshAccessory
// 0x002C (0x008C - 0x0060)
class UTgAnimMetaData_MeshAccessory : public UAnimMetaData
{
public:
	TArray<struct FMeshPlacement>                      m_Meshes;                                                 // 0x0060(0x0010) (Edit, NeedCtorLink, EditInline)
	unsigned long                                      m_bSkinIndependent : 1;                                   // 0x0070(0x0004) (Edit)
	unsigned long                                      m_bSetKeysNoInterp : 1;                                   // 0x0070(0x0004) (Edit)
	unsigned long                                      m_bUseScaling : 1;                                        // 0x0070(0x0004) (Edit)
	TArray<struct FTimeModifier>                       m_KeyFrames;                                              // 0x0074(0x0010) (Edit, NeedCtorLink, EditInline)
	float                                              m_fBecomeRelevantScale;                                   // 0x0084(0x0004) (Edit)
	float                                              m_fCeaseRelevantScale;                                    // 0x0088(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimMetaData_MeshAccessory");
		return ptr;
	}

};


// Class TgGame.TgAnimMetaData_MeshAccessory_Mastery
// 0x0000 (0x008C - 0x008C)
class UTgAnimMetaData_MeshAccessory_Mastery : public UTgAnimMetaData_MeshAccessory
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimMetaData_MeshAccessory_Mastery");
		return ptr;
	}

};


// Class TgGame.TgAnimMetaData_SkelControl_BoneScale
// 0x0020 (0x0080 - 0x0060)
class UTgAnimMetaData_SkelControl_BoneScale : public UAnimMetaData
{
public:
	TArray<struct FName>                               SkelControlNameList;                                      // 0x0060(0x0010) (Edit, NeedCtorLink)
	float                                              BoneScale;                                                // 0x0070(0x0004) (Edit)
	unsigned long                                      bFullControlOverController : 1;                           // 0x0074(0x0004) (Edit)
	struct FName                                       SkelControlName;                                          // 0x0078(0x0008) (Deprecated)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimMetaData_SkelControl_BoneScale");
		return ptr;
	}

};


// Class TgGame.TgAnimMetaData_SkelControl_BoneScale_KeyFrame
// 0x0038 (0x0098 - 0x0060)
class UTgAnimMetaData_SkelControl_BoneScale_KeyFrame : public UAnimMetaData
{
public:
	TArray<struct FName>                               SkelControlNameList;                                      // 0x0060(0x0010) (Edit, NeedCtorLink)
	TArray<struct FTimeModifier>                       KeyFrames;                                                // 0x0070(0x0010) (Edit, NeedCtorLink, EditInline)
	unsigned long                                      bAllowScaleUp : 1;                                        // 0x0080(0x0004) (Edit)
	unsigned long                                      bAllowScaleDown : 1;                                      // 0x0080(0x0004) (Edit)
	unsigned long                                      bAdjustControllerStrength : 1;                            // 0x0080(0x0004) (Const)
	unsigned long                                      bFullControlOverController : 1;                           // 0x0080(0x0004) (Edit)
	unsigned long                                      bSetKeysNoInterp : 1;                                     // 0x0080(0x0004) (Edit)
	unsigned long                                      bForceFirstKeyFrameOnBecomeRelevant : 1;                  // 0x0080(0x0004) (Deprecated)
	unsigned long                                      bForceLastKeyFrameOnCeaseRelevant : 1;                    // 0x0080(0x0004) (Deprecated)
	struct FName                                       SkelControlName;                                          // 0x0084(0x0008) (Deprecated)
	TEnumAsByte<EOnRelevanceChange>                    OnBecomeRelevantBehavior;                                 // 0x008C(0x0001) (Edit)
	TEnumAsByte<EOnRelevanceChange>                    OnCeaseRelevantBehavior;                                  // 0x008D(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x2];                                       // 0x008E(0x0002) MISSED OFFSET
	float                                              OnBecomeRelevantStrength;                                 // 0x0090(0x0004) (Edit)
	float                                              OnCeaseRelevantStrength;                                  // 0x0094(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimMetaData_SkelControl_BoneScale_KeyFrame");
		return ptr;
	}

};


// Class TgGame.TgAnimMetaData_SkelControl_Shalin
// 0x0000 (0x0098 - 0x0098)
class UTgAnimMetaData_SkelControl_Shalin : public UTgAnimMetaData_SkelControl_BoneScale_KeyFrame
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimMetaData_SkelControl_Shalin");
		return ptr;
	}

};


// Class TgGame.TgAnimNodeAdditiveBlending
// 0x0044 (0x016C - 0x0128)
class UTgAnimNodeAdditiveBlending : public UAnimNodeAdditiveBlending
{
public:
	unsigned long                                      m_bSetStrengthFromAnimNode : 1;                           // 0x0128(0x0004) (Edit)
	unsigned long                                      m_bInvertStrengthFromAnimNode : 1;                        // 0x0128(0x0004) (Edit)
	unsigned long                                      m_bInitializedCachedNodeList : 1;                         // 0x0128(0x0004) (Transient)
	TArray<struct FName>                               m_StrengthAnimNodeNameList;                               // 0x012C(0x0010) (Edit, NeedCtorLink)
	TArray<TEnumAsByte<EEmote>>                        m_StrengthEmoteList;                                      // 0x013C(0x0010) (Edit, NeedCtorLink)
	TArray<class UAnimNode*>                           m_CachedNodeList;                                         // 0x014C(0x0010) (Transient, NeedCtorLink)
	TArray<class UTgAnimNodeEmoteSequence*>            m_CachedEmoteSequences;                                   // 0x015C(0x0010) (Transient, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeAdditiveBlending");
		return ptr;
	}

};


// Class TgGame.TgAnimNodeAimOffset_Base
// 0x0004 (0x0170 - 0x016C)
class UTgAnimNodeAimOffset_Base : public UAnimNodeAimOffset
{
public:
	unsigned long                                      m_bBakeAllProfileOffsetsFromAnimations : 1;               // 0x016C(0x0004) (Edit)
	unsigned long                                      m_bPopulateAnimNamesWithPrefixes : 1;                     // 0x016C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeAimOffset_Base");
		return ptr;
	}

};


// Class TgGame.TgAnimNodeAimOffset
// 0x0088 (0x01F8 - 0x0170)
class UTgAnimNodeAimOffset : public UTgAnimNodeAimOffset_Base
{
public:
	class ATgPawn*                                     Owner;                                                    // 0x0170(0x0008) (Const, Transient)
	TArray<class UAnimNode*>                           m_CachedNodeList;                                         // 0x0178(0x0010) (NeedCtorLink)
	unsigned long                                      m_bInitializedCachedNodeList : 1;                         // 0x0188(0x0004) (Transient)
	unsigned long                                      m_bDisableVerticalAiming : 1;                             // 0x0188(0x0004) (Deprecated)
	unsigned long                                      bInterpolating : 1;                                       // 0x0188(0x0004) (Const, Transient)
	unsigned long                                      m_bBakeProfileForAllAnimOffsets : 1;                      // 0x0188(0x0004) (Edit)
	unsigned long                                      m_bRandomAimPointsEnabled : 1;                            // 0x0188(0x0004) (Edit)
	unsigned long                                      m_bOverrideAim : 1;                                       // 0x0188(0x0004) (Edit)
	unsigned long                                      m_bAimAtTarget : 1;                                       // 0x0188(0x0004) (Edit)
	unsigned long                                      m_bDisableWeaponLeading : 1;                              // 0x0188(0x0004) (Edit)
	TEnumAsByte<EPitchControlType>                     m_PitchControlType;                                       // 0x018C(0x0001) (Edit, Const)
	unsigned char                                      UnknownData00[0x3];                                       // 0x018D(0x0003) MISSED OFFSET
	struct FInterpCurveFloat                           m_PitchControlUserCurve;                                  // 0x0190(0x0014) (Edit, Const, NeedCtorLink)
	float                                              TurnInPlaceOffset;                                        // 0x01A4(0x0004) (Edit, Const, Transient)
	float                                              LastAimX;                                                 // 0x01A8(0x0004) (Const, Transient)
	float                                              InterpSpeed;                                              // 0x01AC(0x0004) (Edit)
	int                                                m_nBakeProfileIndex;                                      // 0x01B0(0x0004) (Edit)
	struct FVector2D                                   m_AimOffsetPct;                                           // 0x01B4(0x0008) (Const, Transient)
	struct FVector2D                                   m_RandomAimPointsRangeX;                                  // 0x01BC(0x0008) (Edit)
	struct FVector2D                                   m_RandomAimPointsRangeY;                                  // 0x01C4(0x0008) (Edit)
	float                                              m_fRandomAimPointsInterpRate;                             // 0x01CC(0x0004) (Edit)
	float                                              m_fRandomAimPointsIntervalMin;                            // 0x01D0(0x0004) (Edit)
	float                                              m_fRandomAimPointsIntervalMax;                            // 0x01D4(0x0004) (Edit)
	float                                              m_fCurrentRandomAimPointsInterval;                        // 0x01D8(0x0004)
	struct FVector2D                                   m_TargetRandomAimLocation;                                // 0x01DC(0x0008)
	float                                              m_fDeltaTime;                                             // 0x01E4(0x0004)
	struct FVector2D                                   m_OverriddenAim;                                          // 0x01E8(0x0008) (Edit)
	class ATgWeaponMeshActor*                          m_WeaponMeshActor;                                        // 0x01F0(0x0008) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeAimOffset");
		return ptr;
	}

};


// Class TgGame.TgAnimNodeAimOffset_Charge
// 0x001C (0x0214 - 0x01F8)
class UTgAnimNodeAimOffset_Charge : public UTgAnimNodeAimOffset
{
public:
	unsigned long                                      m_bInterpToCurrentTurnRate : 1;                           // 0x01F8(0x0004) (Edit)
	float                                              m_fInterpSpeed;                                           // 0x01FC(0x0004) (Edit)
	float                                              m_fMaxYawRate;                                            // 0x0200(0x0004) (Edit)
	float                                              m_fAimYawOffset;                                          // 0x0204(0x0004) (Transient)
	struct FRotator                                    m_rCachedOwnerRotator;                                    // 0x0208(0x000C) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeAimOffset_Charge");
		return ptr;
	}

};


// Class TgGame.TgAnimNodeHitReactionOffset
// 0x002C (0x019C - 0x0170)
class UTgAnimNodeHitReactionOffset : public UTgAnimNodeAimOffset_Base
{
public:
	class ATgPawn*                                     Owner;                                                    // 0x0170(0x0008) (Const, Transient)
	struct FVector2D                                   m_vCurrentAngle;                                          // 0x0178(0x0008)
	unsigned long                                      m_bSecondaryReaction : 1;                                 // 0x0180(0x0004) (Edit)
	float                                              m_fMaxReactionTime;                                       // 0x0184(0x0004) (Edit)
	float                                              m_fMinTimeBetweenReactions;                               // 0x0188(0x0004) (Edit)
	TArray<struct FHitReactionInfo>                    m_ActiveReactions;                                        // 0x018C(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeHitReactionOffset");
		return ptr;
	}


	void AddHit(const struct FVector2D& vHitDir, int nDamage);
};


// Class TgGame.TgAnimNodeBlendAnimsByDirection
// 0x0038 (0x01F4 - 0x01BC)
class UTgAnimNodeBlendAnimsByDirection : public UAnimNodeSequenceBlendBase
{
public:
	float                                              m_BlendSpeed;                                             // 0x01BC(0x0004) (Edit)
	unsigned long                                      m_bUsePlayRateByDirection : 1;                            // 0x01C0(0x0004) (Edit)
	unsigned long                                      m_bIncludeStandingAnim : 1;                               // 0x01C0(0x0004) (Edit)
	unsigned long                                      m_bForceStanding : 1;                                     // 0x01C0(0x0004) (Transient)
	unsigned long                                      m_bInterpolateWeights : 1;                                // 0x01C0(0x0004) (Const, Transient)
	unsigned long                                      m_bMirrorDirectionsWhenPawnMirrored : 1;                  // 0x01C0(0x0004) (Edit)
	unsigned long                                      m_bForwardLeftCorrection : 1;                             // 0x01C0(0x0004) (Edit)
	float                                              m_PlayRateByDirection[0x8];                               // 0x01C4(0x0004) (Edit)
	float                                              m_PlayRateStanding;                                       // 0x01E4(0x0004) (Edit)
	float                                              m_fStillThreshold;                                        // 0x01E8(0x0004) (Edit)
	float                                              m_DirAngle;                                               // 0x01EC(0x0004)
	float                                              m_LastRelevantTime;                                       // 0x01F0(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendAnimsByDirection");
		return ptr;
	}

};


// Class TgGame.TgAnimNodeBlendByBlink
// 0x0044 (0x019C - 0x0158)
class UTgAnimNodeBlendByBlink : public UAnimNodeBlendPerBone
{
public:
	class ATgPawn*                                     m_TgPawn;                                                 // 0x0158(0x0008) (Transient)
	class USkeletalMeshComponent*                      m_SkelMesh;                                               // 0x0160(0x0008) (ExportObject, Transient, Component, EditInline)
	float                                              m_fBlinkAnimRate;                                         // 0x0168(0x0004) (Edit)
	struct FVector2D                                   m_vTimeBetweenBlinks;                                     // 0x016C(0x0008) (Edit)
	float                                              m_fTimeTillNextBlink;                                     // 0x0174(0x0004)
	TArray<struct FName>                               m_DisableBlinkingAnimNodeNameList;                        // 0x0178(0x0010) (Edit, NeedCtorLink)
	TArray<class UAnimNode*>                           m_CachedNodeList;                                         // 0x0188(0x0010) (Transient, NeedCtorLink)
	unsigned long                                      m_bInitializedCachedNodeList : 1;                         // 0x0198(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendByBlink");
		return ptr;
	}

};


// Class TgGame.TgAnimNodeBlendByPhysics
// 0x0038 (0x017C - 0x0144)
class UTgAnimNodeBlendByPhysics : public UAnimNodeBlendList
{
public:
	class ATgPawn*                                     m_TgPawn;                                                 // 0x0144(0x0008)
	TEnumAsByte<EPhysics>                              m_LastPhysics;                                            // 0x014C(0x0001)
	TEnumAsByte<EPhysics>                              m_CurrentPhysics;                                         // 0x014D(0x0001)
	unsigned char                                      UnknownData00[0x2];                                       // 0x014E(0x0002) MISSED OFFSET
	int                                                m_CurrentPhysicsChildIndex;                               // 0x0150(0x0004)
	TArray<TEnumAsByte<EPhysics>>                      m_PhysicsChildren;                                        // 0x0154(0x0010) (Edit, NeedCtorLink)
	unsigned long                                      m_bDirectUnspecifiedPhysicsThroughChild0 : 1;             // 0x0164(0x0004) (Edit)
	float                                              DefaultBlendTime;                                         // 0x0168(0x0004) (Edit)
	TArray<struct FChildrenBlendInfo>                  m_ChildrenBlendInfo;                                      // 0x016C(0x0010) (Edit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendByPhysics");
		return ptr;
	}

};


// Class TgGame.TgAnimNodeBlendByProperty
// 0x0014 (0x01A0 - 0x018C)
class UTgAnimNodeBlendByProperty : public UAnimNodeBlendByProperty
{
public:
	float                                              m_fBaseBlendTime;                                         // 0x018C(0x0004) (Edit)
	TArray<struct FChildBlendParam>                    SpecificChildBlendTimes;                                  // 0x0190(0x0010) (Edit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendByProperty");
		return ptr;
	}


	float GetBlendTime(int ChildIndex);
};


// Class TgGame.TgAnimNodeBlendByStrafe
// 0x000C (0x0130 - 0x0124)
class UTgAnimNodeBlendByStrafe : public UAnimNodeBlend
{
public:
	class ATgPawn*                                     m_TgPawn;                                                 // 0x0124(0x0008)
	float                                              m_fBlendTime;                                             // 0x012C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendByStrafe");
		return ptr;
	}

};


// Class TgGame.TgAnimNodeBlendList
// 0x0024 (0x0168 - 0x0144)
class UTgAnimNodeBlendList : public UAnimNodeBlendList
{
public:
	float                                              DefaultBlendTime;                                         // 0x0144(0x0004) (Edit)
	TArray<float>                                      ChildBlendTimes;                                          // 0x0148(0x0010) (Edit, NeedCtorLink)
	TArray<struct FChildBlendParam>                    SpecificChildBlendTimes;                                  // 0x0158(0x0010) (Edit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendList");
		return ptr;
	}


	float GetBlendTime(int ChildIndex);
};


// Class TgGame.TgAnimBlendBy1P3P
// 0x0008 (0x0170 - 0x0168)
class UTgAnimBlendBy1P3P : public UTgAnimNodeBlendList
{
public:
	class ATgPawn*                                     m_TgPawn;                                                 // 0x0168(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendBy1P3P");
		return ptr;
	}

};


// Class TgGame.TgAnimBlendByAmmo
// 0x0024 (0x018C - 0x0168)
class UTgAnimBlendByAmmo : public UTgAnimNodeBlendList
{
public:
	int                                                m_nDefaultChild;                                          // 0x0168(0x0004) (Edit)
	int                                                m_nDeviceType;                                            // 0x016C(0x0004) (Edit)
	unsigned long                                      m_bDelayUpdateUntilReplay : 1;                            // 0x0170(0x0004) (Edit)
	unsigned long                                      m_bCheckAmmoPerTick : 1;                                  // 0x0170(0x0004) (Edit)
	TArray<struct FAmmoBlendParams>                    m_ChildAmmoParams;                                        // 0x0174(0x0010) (Edit, NeedCtorLink)
	int                                                m_nPendingChildIndex;                                     // 0x0184(0x0004)
	int                                                m_nAmmoUpdateTickTag;                                     // 0x0188(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendByAmmo");
		return ptr;
	}


	void SetAmmoChild(int targetAmmoChild);
	void SetAmmoAmt(int nAmmo);
	void STATIC_ReplayAnim();
	void PlayAnim(bool bLoop, float Rate, float StartTime);
	void CheckDelayedSetChild();
};


// Class TgGame.TgAnimBlendByBuffMonsterIntro
// 0x0018 (0x0180 - 0x0168)
class UTgAnimBlendByBuffMonsterIntro : public UTgAnimNodeBlendList
{
public:
	unsigned long                                      m_bScalePlayRateOfSpawnAndIntro : 1;                      // 0x0168(0x0004) (Edit)
	unsigned long                                      m_bEndIntroStateEarly : 1;                                // 0x0168(0x0004) (Edit)
	unsigned long                                      m_bIntroHasBeenSetup : 1;                                 // 0x0168(0x0004)
	float                                              m_fIntroTimeHittableAt;                                   // 0x016C(0x0004) (Edit)
	float                                              m_fTimeToStartIntroAnim;                                  // 0x0170(0x0004)
	class ATgPawn*                                     m_CachedPawn;                                             // 0x0174(0x0008)
	float                                              m_fSpawnIntroScaleRate;                                   // 0x017C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendByBuffMonsterIntro");
		return ptr;
	}


	void SetupIntro(float fTotalIntroTime, float fIntroOffset);
};


// Class TgGame.TgAnimBlendByCatapult
// 0x0008 (0x0170 - 0x0168)
class UTgAnimBlendByCatapult : public UTgAnimNodeBlendList
{
public:
	class ATgPawn*                                     m_TgPawn;                                                 // 0x0168(0x0008) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendByCatapult");
		return ptr;
	}

};


// Class TgGame.TgAnimBlendByChurchillDrone
// 0x0004 (0x016C - 0x0168)
class UTgAnimBlendByChurchillDrone : public UTgAnimNodeBlendList
{
public:
	unsigned long                                      m_bLeftDrone : 1;                                         // 0x0168(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendByChurchillDrone");
		return ptr;
	}


	void ForceSetActive(bool bActive);
	void STATIC_Fire();
	void Destroyed();
	void Spawned();
};


// Class TgGame.TgAnimBlendByDeployable
// 0x0000 (0x0168 - 0x0168)
class UTgAnimBlendByDeployable : public UTgAnimNodeBlendList
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendByDeployable");
		return ptr;
	}


	void STATIC_Fire();
	void Destroyed();
	void Spawned();
};


// Class TgGame.TgAnimBlendByDirection
// 0x0010 (0x0178 - 0x0168)
class UTgAnimBlendByDirection : public UTgAnimNodeBlendList
{
public:
	class ATgPawn*                                     m_TgPawn;                                                 // 0x0168(0x0008)
	TEnumAsByte<EBlendByDirectionSpeedType>            m_SpeedType;                                              // 0x0170(0x0001) (Edit)
	TEnumAsByte<EBlendDirTypes>                        LastDirection;                                            // 0x0171(0x0001) (Const)
	unsigned char                                      UnknownData00[0x2];                                       // 0x0172(0x0002) MISSED OFFSET
	unsigned long                                      bAdjustRateByVelocity : 1;                                // 0x0174(0x0004) (Edit)
	unsigned long                                      bNoDirectionIsEnabled : 1;                                // 0x0174(0x0004) (Edit)
	unsigned long                                      bResetLooping : 1;                                        // 0x0174(0x0004) (Edit)
	unsigned long                                      m_bDelayBlendOutToPlayAnim : 1;                           // 0x0174(0x0004) (Edit)
	unsigned long                                      m_bIsAllowedToBlendOut : 1;                               // 0x0174(0x0004)
	unsigned long                                      m_bMirrorDirectionsWhenPawnMirrored : 1;                  // 0x0174(0x0004) (Edit)
	unsigned long                                      m_bStopChildrenOnCeaseRelevant : 1;                       // 0x0174(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendByDirection");
		return ptr;
	}

};


// Class TgGame.TgAnimBlendByEmote
// 0x004C (0x01B4 - 0x0168)
class UTgAnimBlendByEmote : public UTgAnimNodeBlendList
{
public:
	struct FName                                       nmEmotePrefix;                                            // 0x0168(0x0008)
	struct FName                                       mnEmoteMovingSuffix;                                      // 0x0170(0x0008)
	struct FName                                       nmEmoteFullMovingSuffix;                                  // 0x0178(0x0008)
	unsigned long                                      bForceTreatAsMovingEmoteNode : 1;                         // 0x0180(0x0004) (Edit)
	TArray<class UTgAnimNodeEmoteSequence*>            EmoteSequenceChildren;                                    // 0x0184(0x0010) (NeedCtorLink)
	TArray<class UAnimNodeBlendPerBone*>               PerBoneChildren;                                          // 0x0194(0x0010) (NeedCtorLink)
	TArray<class UAnimNodeBlendList*>                  FullMovingBlendLists;                                     // 0x01A4(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendByEmote");
		return ptr;
	}


	bool STATIC_IsFullBody();
	void CancelEmote(bool bNoBlend);
	float PlayEmote(TEnumAsByte<EEmote> Emote);
};


// Class TgGame.TgAnimBlendByFall
// 0x0034 (0x019C - 0x0168)
class UTgAnimBlendByFall : public UTgAnimNodeBlendList
{
public:
	TEnumAsByte<EFallSource>                           m_FallSource;                                             // 0x0168(0x0001) (Edit)
	TEnumAsByte<EBlendFallTypes>                       FallState;                                                // 0x0169(0x0001) (Const)
	TEnumAsByte<EPhysics>                              m_PreviousTickPhysics;                                    // 0x016A(0x0001)
	unsigned char                                      UnknownData00[0x1];                                       // 0x016B(0x0001) MISSED OFFSET
	float                                              LastFallingVelocity;                                      // 0x016C(0x0004) (Const)
	class ATgPawn*                                     pOwner;                                                   // 0x0170(0x0008)
	float                                              m_fPrelandDistance;                                       // 0x0178(0x0004) (Edit)
	unsigned long                                      m_bDebugMeasureJumpUp : 1;                                // 0x017C(0x0004) (Edit)
	unsigned long                                      m_bDebugMeasureJumpDownToLand : 1;                        // 0x017C(0x0004) (Edit)
	unsigned long                                      m_bMeasuring : 1;                                         // 0x017C(0x0004)
	unsigned long                                      m_bUsesPreDown : 1;                                       // 0x017C(0x0004)
	unsigned long                                      m_bJumpOnly : 1;                                          // 0x017C(0x0004) (Edit)
	struct FVector                                     m_StartMeasureJump;                                       // 0x0180(0x000C)
	float                                              m_fMeasureTime;                                           // 0x018C(0x0004)
	float                                              m_fLandingMovementPlayRate;                               // 0x0190(0x0004) (Edit)
	struct FName                                       m_nmNameLandingSynchGroup;                                // 0x0194(0x0008) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendByFall");
		return ptr;
	}

};


// Class TgGame.TgAnimBlendByFallTransition
// 0x0004 (0x01A0 - 0x019C)
class UTgAnimBlendByFallTransition : public UTgAnimBlendByFall
{
public:
	float                                              m_fPreDownVelocity;                                       // 0x019C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendByFallTransition");
		return ptr;
	}

};


// Class TgGame.TgAnimBlendByFire
// 0x0084 (0x01EC - 0x0168)
class UTgAnimBlendByFire : public UTgAnimNodeBlendList
{
public:
	unsigned long                                      m_bSetToIdleOnCeaseRelevant : 1;                          // 0x0168(0x0004) (Edit)
	unsigned long                                      m_bShouldReplayIfAlreadyActive : 1;                       // 0x0168(0x0004) (Edit)
	struct FDeviceParameters                           m_InHandDeviceParameters;                                 // 0x016C(0x0014) (Edit, NeedCtorLink)
	struct FDeviceParameters                           m_OffHand1DeviceParameters;                               // 0x0180(0x0014) (Edit, NeedCtorLink)
	struct FDeviceParameters                           m_OffHand2DeviceParameters;                               // 0x0194(0x0014) (Edit, NeedCtorLink)
	struct FDeviceParameters                           m_OffHand3DeviceParameters;                               // 0x01A8(0x0014) (Edit, NeedCtorLink)
	struct FDeviceParameters                           m_OffHand4DeviceParameters;                               // 0x01BC(0x0014) (Edit, NeedCtorLink)
	struct FDeviceParameters                           m_RecallDeviceParameters;                                 // 0x01D0(0x0014) (Edit, NeedCtorLink)
	class ATgPawn*                                     m_OwningPawn;                                             // 0x01E4(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendByFire");
		return ptr;
	}


	void STATIC_OnDeviceFormInterruptFire(class UTgDeviceForm* DeviceForm);
	void STATIC_OnDeviceFormStopFire(class UTgDeviceForm* DeviceForm);
	void STATIC_OnDeviceFormStartFire(class UTgDeviceForm* DeviceForm, float FireDuration);
	void STATIC_OnDeviceFormBuildup(class UTgDeviceForm* DeviceForm, float BuildupTime);
};


// Class TgGame.TgAnimBlendByFireMode
// 0x0005 (0x016D - 0x0168)
class UTgAnimBlendByFireMode : public UTgAnimNodeBlendList
{
public:
	int                                                m_nDefaultFireMode;                                       // 0x0168(0x0004) (Edit)
	TEnumAsByte<ETG_EQUIP_POINT>                       m_EquipPoint;                                             // 0x016C(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendByFireMode");
		return ptr;
	}


	void SetDefaultFiremode();
	void SelectFireMode(int FireMode);
};


// Class TgGame.TgAnimBlendByFlying
// 0x0038 (0x01A0 - 0x0168)
class UTgAnimBlendByFlying : public UTgAnimNodeBlendList
{
public:
	unsigned long                                      bAdjustRateByVelocity : 1;                                // 0x0168(0x0004) (Edit)
	unsigned long                                      m_bAdjustRateByAcceleration : 1;                          // 0x0168(0x0004) (Edit)
	unsigned long                                      m_bPreviewJetpackPerBoneBlend : 1;                        // 0x0168(0x0004) (Edit, Transient)
	unsigned long                                      m_bIsUsingHandsFreeJetpack : 1;                           // 0x0168(0x0004)
	float                                              m_fUpLoopStartTime;                                       // 0x016C(0x0004) (Edit)
	TEnumAsByte<EFlyDirTypes>                          LastDirection;                                            // 0x0170(0x0001) (Const)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0171(0x0003) MISSED OFFSET
	struct FName                                       m_nmHandsFreeJetpackPerBoneBlendNodeName;                 // 0x0174(0x0008) (Edit)
	class UAnimNodeBlendPerBone*                       m_HandsFreeJetpackPerBoneBlendNode;                       // 0x017C(0x0008)
	float                                              m_fHandsFreeJetpackBlendBias;                             // 0x0184(0x0004) (Edit)
	struct FName                                       m_nmHandsFreeJetpackBiasBlendNodeName;                    // 0x0188(0x0008) (Edit)
	class UAnimNodeBlend*                              m_HandsFreeJetpackBiasBlendNode;                          // 0x0190(0x0008)
	class ATgPawn*                                     m_TgPawn;                                                 // 0x0198(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendByFlying");
		return ptr;
	}

};


// Class TgGame.TgAnimBlendByHeadSkin
// 0x0010 (0x0178 - 0x0168)
class UTgAnimBlendByHeadSkin : public UTgAnimNodeBlendList
{
public:
	TArray<struct FHeadSkinChildInfo>                  m_SkinMap;                                                // 0x0168(0x0010) (Edit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendByHeadSkin");
		return ptr;
	}

};


// Class TgGame.TgAnimBlendByMountSkin
// 0x0010 (0x0178 - 0x0168)
class UTgAnimBlendByMountSkin : public UTgAnimNodeBlendList
{
public:
	TArray<struct FMountSkinChildInfo>                 m_SkinMap;                                                // 0x0168(0x0010) (Edit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendByMountSkin");
		return ptr;
	}


	void STATIC_Reinitialize(class USkeletalMeshComponent* MeshComp);
};


// Class TgGame.TgAnimBlendByNodeName
// 0x002C (0x0194 - 0x0168)
class UTgAnimBlendByNodeName : public UTgAnimNodeBlendList
{
public:
	TArray<struct FNodeNameToChildIndex>               m_NodeNameToChildIndex;                                   // 0x0168(0x0010) (Edit, NeedCtorLink)
	TArray<struct FRelevantNodeNameNodes>              m_CachedNodes;                                            // 0x0178(0x0010) (Transient, NeedCtorLink)
	class UAnimNode*                                   m_LastSuccessfulAnimNode;                                 // 0x0188(0x0008) (Transient)
	unsigned long                                      m_bHasCachedNodes : 1;                                    // 0x0190(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendByNodeName");
		return ptr;
	}

};


// Class TgGame.TgAnimBlendByPaladinsCharacter
// 0x03DC (0x0544 - 0x0168)
class UTgAnimBlendByPaladinsCharacter : public UTgAnimNodeBlendList
{
public:
	class ATgWeaponMeshActor*                          m_WeaponMeshActor;                                        // 0x0168(0x0008)
	TEnumAsByte<ETG_EQUIP_POINT>                       m_SubNodeEquipSlot;                                       // 0x0170(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0171(0x0003) MISSED OFFSET
	struct FChildAnimParameters                        m_ChildParams[0x11];                                      // 0x0174(0x0038) (Edit, NeedCtorLink)
	TArray<TEnumAsByte<EPalCharParams>>                m_nChildAnimStack;                                        // 0x052C(0x0010) (NeedCtorLink)
	int                                                m_nCustomRetrieveIndex;                                   // 0x053C(0x0004)
	unsigned long                                      m_bBlendToIdleOnInterruptInspect : 1;                     // 0x0540(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendByPaladinsCharacter");
		return ptr;
	}


	void STATIC_ReplayAnim();
	void PlayAnim(bool bLoop, float InRate, float StartTime);
	void STATIC_SetActiveChild(int ChildIndex, float BlendTime);
	TEnumAsByte<EPalCharParams> STATIC_GetParamIndexFromChildIndex(int Index);
	TEnumAsByte<EPalCharParams> STATIC_GetParamIndexFromEqpSlot(TEnumAsByte<ETG_EQUIP_POINT> eqp);
	void UpdateAnimViaStackRemoval(TEnumAsByte<EPalCharParams> toRemove);
	void PlayTopOfStackAnim();
	void ForceInterruptFlourish();
	void STATIC_InterruptReload();
	void STATIC_OnPutAway(unsigned char EquipPoint, int DeviceID, class UClass* WeaponClass);
	void STATIC_OnRetrieve();
	void STATIC_OnFlourish();
	void STATIC_OnReload(float fReloadTime);
	void STATIC_OnTriggerCharacterSpecific(int nCharacterSpecificSlot, float fActivationTime);
	void STATIC_OnDeviceStopFire(TEnumAsByte<ETG_EQUIP_POINT> eqp);
	void STATIC_OnDeviceFire(TEnumAsByte<ETG_EQUIP_POINT> eqp, float fRefireRate);
	void STATIC_OnDeviceStartFire(TEnumAsByte<ETG_EQUIP_POINT> eqp, float fRefireRate);
	void STATIC_OnDeviceBuildup(TEnumAsByte<ETG_EQUIP_POINT> eqp);
	void STATIC_OnDeviceTargeting(TEnumAsByte<ETG_EQUIP_POINT> eqp);
};


// Class TgGame.TgAnimBlendByPaladinsCharacter_BarrierTank
// 0x0028 (0x056C - 0x0544)
class UTgAnimBlendByPaladinsCharacter_BarrierTank : public UTgAnimBlendByPaladinsCharacter
{
public:
	TArray<struct FName>                               m_AmmoSkelControlNames;                                   // 0x0544(0x0010) (Edit, NeedCtorLink)
	TArray<class USkelControlBase*>                    m_AmmoSkelControls;                                       // 0x0554(0x0010) (NeedCtorLink)
	class ATgPawn_BarrierTank*                         m_CachedBarrierTankPawn;                                  // 0x0564(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendByPaladinsCharacter_BarrierTank");
		return ptr;
	}


	void STATIC_OnRetrieve();
	bool STATIC_HasCachedBarrierTankPawn();
	void STATIC_SetActiveChild(int ChildIndex, float BlendTime);
	void UpdateAmmoSkelControls();
};


// Class TgGame.TgAnimBlendByPaladinsCharacter_BombKing
// 0x0000 (0x0544 - 0x0544)
class UTgAnimBlendByPaladinsCharacter_BombKing : public UTgAnimBlendByPaladinsCharacter
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendByPaladinsCharacter_BombKing");
		return ptr;
	}


	void STATIC_OnDeviceStartFire(TEnumAsByte<ETG_EQUIP_POINT> eqp, float fRefireRate);
};


// Class TgGame.TgAnimBlendByPaladinsCharacter_Drogoz
// 0x0020 (0x0564 - 0x0544)
class UTgAnimBlendByPaladinsCharacter_Drogoz : public UTgAnimBlendByPaladinsCharacter
{
public:
	TArray<struct FName>                               m_AmmoSkelControlNames;                                   // 0x0544(0x0010) (Edit, NeedCtorLink)
	TArray<class USkelControlBase*>                    m_AmmoSkelControls;                                       // 0x0554(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendByPaladinsCharacter_Drogoz");
		return ptr;
	}


	void STATIC_OnRetrieve();
	bool STATIC_HasCachedDrogozPawn();
	void STATIC_SetActiveChild(int ChildIndex, float BlendTime);
	void UpdateAmmoSkelControls();
};


// Class TgGame.TgAnimBlendByPaladinsCharacter_Flak
// 0x0000 (0x0544 - 0x0544)
class UTgAnimBlendByPaladinsCharacter_Flak : public UTgAnimBlendByPaladinsCharacter
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendByPaladinsCharacter_Flak");
		return ptr;
	}


	bool STATIC_HasCachedFlakPawn();
	void STATIC_OnRetrieve();
};


// Class TgGame.TgAnimBlendByPaladinsCharacter_Owl
// 0x0000 (0x0544 - 0x0544)
class UTgAnimBlendByPaladinsCharacter_Owl : public UTgAnimBlendByPaladinsCharacter
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendByPaladinsCharacter_Owl");
		return ptr;
	}


	TEnumAsByte<EPalCharParams> STATIC_GetParamIndexFromEqpSlot(TEnumAsByte<ETG_EQUIP_POINT> eqp);
};


// Class TgGame.TgAnimBlendByPercent
// 0x0014 (0x017C - 0x0168)
class UTgAnimBlendByPercent : public UTgAnimNodeBlendList
{
public:
	float                                              m_fCurrentPercent;                                        // 0x0168(0x0004)
	TArray<struct FBlendByPercentValues>               m_ChildParams;                                            // 0x016C(0x0010) (Edit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendByPercent");
		return ptr;
	}


	void STATIC_SetActiveChild(int ChildIndex, float BlendTime);
	void UpdatePercent(float fPercent);
};


// Class TgGame.TgAnimBlendByPhase
// 0x0024 (0x018C - 0x0168)
class UTgAnimBlendByPhase : public UTgAnimNodeBlendList
{
public:
	class ATgPawn*                                     m_TgPawn;                                                 // 0x0168(0x0008)
	int                                                m_LastPhase;                                              // 0x0170(0x0004)
	int                                                m_CurrentPhase;                                           // 0x0174(0x0004)
	unsigned long                                      m_bEnableTransitionAnims : 1;                             // 0x0178(0x0004) (Edit)
	TArray<struct Fm_PhaseProfile>                     m_PhaseProfiles;                                          // 0x017C(0x0010) (Edit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendByPhase");
		return ptr;
	}

};


// Class TgGame.TgAnimBlendByPhysics
// 0x003C (0x01A4 - 0x0168)
class UTgAnimBlendByPhysics : public UTgAnimNodeBlendList
{
public:
	int                                                PhysicsMap[0xE];                                          // 0x0168(0x0004) (Edit)
	int                                                LastPhysics;                                              // 0x01A0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendByPhysics");
		return ptr;
	}

};


// Class TgGame.TgAnimBlendByPosture
// 0x0034 (0x019C - 0x0168)
class UTgAnimBlendByPosture : public UTgAnimNodeBlendList
{
public:
	class ATgPawn*                                     m_TgPawn;                                                 // 0x0168(0x0008)
	class ATgSkeletalMeshActor_Posture*                m_TgPostureMesh;                                          // 0x0170(0x0008)
	TEnumAsByte<ETG_POSTURE>                           m_LastPosture;                                            // 0x0178(0x0001)
	TEnumAsByte<ETG_POSTURE>                           m_CurrentPosture;                                         // 0x0179(0x0001)
	TEnumAsByte<ETG_POSTURE>                           m_TransitionFromPosture;                                  // 0x017A(0x0001)
	unsigned char                                      UnknownData00[0x1];                                       // 0x017B(0x0001) MISSED OFFSET
	unsigned long                                      m_bEnableTransitionAnims : 1;                             // 0x017C(0x0004) (Edit)
	unsigned long                                      m_bCheckLowerPriorityPostures : 1;                        // 0x017C(0x0004) (Edit)
	int                                                m_CurrentPostureChildIndex;                               // 0x0180(0x0004)
	TArray<struct Fm_PostureProfile>                   m_PostureProfiles;                                        // 0x0184(0x0010) (Edit, NeedCtorLink)
	class UAnimNodeSequence*                           m_TransitionAnimNodeSeq;                                  // 0x0194(0x0008) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendByPosture");
		return ptr;
	}


	void ForceAllCameraAnimsEnd();
	bool ForcePostureChange(bool bAllowTransitionAnims);
};


// Class TgGame.TgAnimBlendByProgressiveReload
// 0x0000 (0x0168 - 0x0168)
class UTgAnimBlendByProgressiveReload : public UTgAnimNodeBlendList
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendByProgressiveReload");
		return ptr;
	}


	void SetReloadType(int ReloadType);
};


// Class TgGame.TgAnimBlendByRealmCharacter
// 0x08AC (0x0A14 - 0x0168)
class UTgAnimBlendByRealmCharacter : public UTgAnimNodeBlendList
{
public:
	class ATgWeaponMeshActor*                          m_WeaponMeshActor;                                        // 0x0168(0x0008)
	TEnumAsByte<EDeviceSubtype>                        m_SubNodeDeviceSubtype;                                   // 0x0170(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0171(0x0003) MISSED OFFSET
	struct FChildAnimParameters                        m_ChildParams[0x27];                                      // 0x0174(0x0038) (Edit, NeedCtorLink)
	TArray<unsigned char>                              m_nChildAnimStack;                                        // 0x09FC(0x0010) (NeedCtorLink)
	int                                                m_nCustomRetrieveIndex;                                   // 0x0A0C(0x0004)
	unsigned long                                      m_bBlendToIdleOnInterruptInspect : 1;                     // 0x0A10(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendByRealmCharacter");
		return ptr;
	}


	bool STATIC_IsPlayingCustomEmote();
	void UpdateFireAnimType(bool bIsLooping);
	void STATIC_ReplayAnim();
	void PlayAnim(bool bLoop, float InRate, float StartTime);
	void STATIC_SetActiveChild(int ChildIndex, float BlendTime);
	unsigned char STATIC_GetParamIndexFromChildIndex(int Index);
	unsigned char STATIC_GetParamIndexFromDeviceType(unsigned char eDeviceSubtype);
	void UpdateAnimViaStackRemoval(unsigned char toRemove);
	void PlayTopOfStackAnim();
	void ForceInterruptFlourish();
	void STATIC_InterruptReload();
	void CancelCustomEmote();
	void PlayCustomEmote();
	void STATIC_OnPutAway(float fPutAwayTime);
	void STATIC_OnRetrieve(float fRetrieveTime);
	void STATIC_OnFlourish();
	void STATIC_OnReload(float fReloadTime);
	void STATIC_OnTriggerCharacterSpecific(int nCharacterSpecificSlot, float fActivationTime);
	void STATIC_OnDeviceStopFire(TEnumAsByte<EDeviceSubtype> eDeviceSubtype, bool bForceBlendOutOnAnimEnd);
	void STATIC_OnDeviceFire(TEnumAsByte<EDeviceSubtype> eDeviceSubtype, float fRefireRate);
	void STATIC_OnDeviceStartFire(TEnumAsByte<EDeviceSubtype> eDeviceSubtype, float fRefireRate, bool bForceBlendOutOnAnimEnd);
	void STATIC_OnDeviceBuildup(TEnumAsByte<EDeviceSubtype> eDeviceSubtype);
	void STATIC_OnDeviceTargeting();
};


// Class TgGame.TgAnimBlendByRealmCharacter_FullAbilities
// 0x0000 (0x0A14 - 0x0A14)
class UTgAnimBlendByRealmCharacter_FullAbilities : public UTgAnimBlendByRealmCharacter
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendByRealmCharacter_FullAbilities");
		return ptr;
	}


	unsigned char STATIC_GetParamIndexFromDeviceType(unsigned char eDeviceSubtype);
	bool STATIC_IsPlayingCustomEmote();
	void CancelCustomEmote();
	void PlayCustomEmote();
	void STATIC_OnPutAway(float fPutAwayTime);
	void STATIC_OnRetrieve(float fRetrieveTime);
};


// Class TgGame.TgAnimBlendBySkin
// 0x0010 (0x0178 - 0x0168)
class UTgAnimBlendBySkin : public UTgAnimNodeBlendList
{
public:
	TArray<struct FSkinChildInfo>                      m_SkinMap;                                                // 0x0168(0x0010) (Edit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendBySkin");
		return ptr;
	}

};


// Class TgGame.TgAnimBlendBySkydive
// 0x0008 (0x0170 - 0x0168)
class UTgAnimBlendBySkydive : public UTgAnimNodeBlendList
{
public:
	class ATgPawn*                                     m_TgPawn;                                                 // 0x0168(0x0008) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendBySkydive");
		return ptr;
	}

};


// Class TgGame.TgAnimBlendByStartingPosture
// 0x0010 (0x0178 - 0x0168)
class UTgAnimBlendByStartingPosture : public UTgAnimNodeBlendList
{
public:
	class ATgPawn*                                     m_TgPawn;                                                 // 0x0168(0x0008)
	TEnumAsByte<ETG_POSTURE>                           m_StartingPosture;                                        // 0x0170(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0171(0x0003) MISSED OFFSET
	unsigned long                                      m_bExpired : 1;                                           // 0x0174(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendByStartingPosture");
		return ptr;
	}

};


// Class TgGame.TgAnimBlendByViewTarget
// 0x0010 (0x0178 - 0x0168)
class UTgAnimBlendByViewTarget : public UTgAnimNodeBlendList
{
public:
	class ATgPawn*                                     m_TgPawn;                                                 // 0x0168(0x0008)
	class ATgPlayerController*                         m_LocalPlayerController;                                  // 0x0170(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendByViewTarget");
		return ptr;
	}

};


// Class TgGame.TgAnimBlendByWeaponSkin
// 0x0010 (0x0178 - 0x0168)
class UTgAnimBlendByWeaponSkin : public UTgAnimNodeBlendList
{
public:
	TArray<struct FWeaponSkinChildInfo>                m_SkinMap;                                                // 0x0168(0x0010) (Edit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendByWeaponSkin");
		return ptr;
	}

};


// Class TgGame.TgAnimBlendByWeaponSwapType
// 0x0010 (0x0178 - 0x0168)
class UTgAnimBlendByWeaponSwapType : public UTgAnimNodeBlendList
{
public:
	TArray<struct FWeaponSwapTypeData>                 m_WeaponSwaps;                                            // 0x0168(0x0010) (Edit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendByWeaponSwapType");
		return ptr;
	}


	void STATIC_SetWeaponSwapType(const struct FName& nAnimSetPackageName);
};


// Class TgGame.TgAnimNodeBlendByAbilityDrag
// 0x0000 (0x0168 - 0x0168)
class UTgAnimNodeBlendByAbilityDrag : public UTgAnimNodeBlendList
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendByAbilityDrag");
		return ptr;
	}


	void STATIC_HookCloseRangeEnd();
	void STATIC_HookEndMissInvalid();
	void STATIC_HookMissInvalid();
	void STATIC_HookEndMissNoHit();
	void STATIC_HookMissNotHit();
	void STATIC_HookEnd();
	void STATIC_HookPull();
	void STATIC_HookHit();
	void ThrowHook();
};


// Class TgGame.TgAnimNodeBlendByAbilityDragonSlam
// 0x0000 (0x0168 - 0x0168)
class UTgAnimNodeBlendByAbilityDragonSlam : public UTgAnimNodeBlendList
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendByAbilityDragonSlam");
		return ptr;
	}


	void EndFlying();
	void STATIC_HitTarget();
	void Fly();
	void ReadyFlightFromAir();
	void ReadyFlightFromGround();
};


// Class TgGame.TgAnimNodeBlendByAbilityFragGrenade
// 0x0000 (0x0168 - 0x0168)
class UTgAnimNodeBlendByAbilityFragGrenade : public UTgAnimNodeBlendList
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendByAbilityFragGrenade");
		return ptr;
	}


	void STATIC_OnInterrupt();
	void StartThrow();
};


// Class TgGame.TgAnimNodeBlendByAbilityHyperShot
// 0x0000 (0x0168 - 0x0168)
class UTgAnimNodeBlendByAbilityHyperShot : public UTgAnimNodeBlendList
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendByAbilityHyperShot");
		return ptr;
	}

};


// Class TgGame.TgAnimNodeBlendByAbilityReversal
// 0x0000 (0x0168 - 0x0168)
class UTgAnimNodeBlendByAbilityReversal : public UTgAnimNodeBlendList
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendByAbilityReversal");
		return ptr;
	}

};


// Class TgGame.TgAnimNodeBlendByAbilitySimple
// 0x0005 (0x016D - 0x0168)
class UTgAnimNodeBlendByAbilitySimple : public UTgAnimNodeBlendList
{
public:
	unsigned long                                      m_bBlendToActiveOnStartFire : 1;                          // 0x0168(0x0004) (Edit)
	unsigned long                                      m_bBlendToActiveOnFire : 1;                               // 0x0168(0x0004) (Edit)
	unsigned long                                      m_bDelayBlendToActiveUntilAnimEnd : 1;                    // 0x0168(0x0004) (Edit)
	unsigned long                                      m_bDelayBlendToActiveUntilReplay : 1;                     // 0x0168(0x0004) (Edit)
	unsigned long                                      m_bDelayBlendToIdleUntilAnimEnd : 1;                      // 0x0168(0x0004) (Edit)
	unsigned long                                      m_bDelayBlendToIdleUntilReplay : 1;                       // 0x0168(0x0004) (Edit)
	unsigned long                                      m_bBlendToIdleImmediatelyOnInterrupt : 1;                 // 0x0168(0x0004) (Edit)
	unsigned long                                      m_bIsAbilityFiring : 1;                                   // 0x0168(0x0004) (Transient)
	TEnumAsByte<ETG_EQUIP_POINT>                       m_EqpPoint;                                               // 0x016C(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendByAbilitySimple");
		return ptr;
	}


	void STATIC_ReplayAnim();
	void PlayAnim(bool bLoop, float InRate, float StartTime);
	void SetAbilityFiring(bool bIsFiring, bool bIsOnFire, bool bIsInterrupted);
};


// Class TgGame.TgAnimNodeBlendByAbilitySmash
// 0x0000 (0x0168 - 0x0168)
class UTgAnimNodeBlendByAbilitySmash : public UTgAnimNodeBlendList
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendByAbilitySmash");
		return ptr;
	}


	void Attack();
	void BeginChargeUp();
};


// Class TgGame.TgAnimNodeBlendByAbilityVine
// 0x0000 (0x0168 - 0x0168)
class UTgAnimNodeBlendByAbilityVine : public UTgAnimNodeBlendList
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendByAbilityVine");
		return ptr;
	}


	void VineInactive();
	void VinePost();
	void VineHitPost();
	void VinePull();
	void VineThrow();
};


// Class TgGame.TgAnimNodeBlendByAFK
// 0x0008 (0x0170 - 0x0168)
class UTgAnimNodeBlendByAFK : public UTgAnimNodeBlendList
{
public:
	class ATgPawn*                                     PawnOwner;                                                // 0x0168(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendByAFK");
		return ptr;
	}

};


// Class TgGame.TgAnimNodeBlendByAndroxusDrift
// 0x0024 (0x018C - 0x0168)
class UTgAnimNodeBlendByAndroxusDrift : public UTgAnimNodeBlendList
{
public:
	TArray<struct FDriftInfo>                          m_DriftRecords;                                           // 0x0168(0x0010) (NeedCtorLink)
	unsigned long                                      m_bInDrift : 1;                                           // 0x0178(0x0004)
	unsigned long                                      m_bTransitionsCanBeInterrupted : 1;                       // 0x0178(0x0004) (Edit)
	float                                              m_fDriftStartTime;                                        // 0x017C(0x0004)
	float                                              m_fDriftRelevancyWindow;                                  // 0x0180(0x0004) (Edit)
	float                                              m_fDriftTriggerPercent;                                   // 0x0184(0x0004) (Edit)
	float                                              m_fMaxFallSpeed;                                          // 0x0188(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendByAndroxusDrift");
		return ptr;
	}


	void StoppedDrift();
	void StartedDrift();
	float STATIC_GetDriftUsePercent();
};


// Class TgGame.TgAnimNodeBlendByCombat
// 0x0008 (0x0170 - 0x0168)
class UTgAnimNodeBlendByCombat : public UTgAnimNodeBlendList
{
public:
	class ATgPawn*                                     m_TgP;                                                    // 0x0168(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendByCombat");
		return ptr;
	}

};


// Class TgGame.TgAnimNodeBlendByCombatWariness
// 0x000C (0x0174 - 0x0168)
class UTgAnimNodeBlendByCombatWariness : public UTgAnimNodeBlendList
{
public:
	float                                              CombatWarinessDuration;                                   // 0x0168(0x0004) (Edit)
	unsigned long                                      AllowIdleAnimToComplete : 1;                              // 0x016C(0x0004) (Edit)
	unsigned long                                      AllowWaryAnimToComplete : 1;                              // 0x016C(0x0004) (Edit)
	unsigned long                                      IsWary : 1;                                               // 0x016C(0x0004) (Transient)
	float                                              WaryTime;                                                 // 0x0170(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendByCombatWariness");
		return ptr;
	}


	void BecomeWary();
};


// Class TgGame.TgAnimNodeBlendByDeviceEquipped
// 0x0004 (0x016C - 0x0168)
class UTgAnimNodeBlendByDeviceEquipped : public UTgAnimNodeBlendList
{
public:
	int                                                m_DeviceId;                                               // 0x0168(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendByDeviceEquipped");
		return ptr;
	}


	void SetDeviceEquipped(bool bEquipped);
};


// Class TgGame.TgAnimNodeBlendByDrogozFlying
// 0x0024 (0x018C - 0x0168)
class UTgAnimNodeBlendByDrogozFlying : public UTgAnimNodeBlendList
{
public:
	TArray<struct FBoosterFlightInfo>                  m_BoosterRecords;                                         // 0x0168(0x0010) (NeedCtorLink)
	unsigned long                                      m_bInThrust : 1;                                          // 0x0178(0x0004)
	unsigned long                                      m_bInBooster : 1;                                         // 0x0178(0x0004)
	unsigned long                                      m_bTransitionsCanBeInterrupted : 1;                       // 0x0178(0x0004) (Edit)
	float                                              m_fBoosterStartTime;                                      // 0x017C(0x0004)
	float                                              m_fBoosterRelevancyWindow;                                // 0x0180(0x0004) (Edit)
	float                                              m_fBoosterTriggerPercent;                                 // 0x0184(0x0004) (Edit)
	float                                              m_fMaxFlightFallSpeed;                                    // 0x0188(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendByDrogozFlying");
		return ptr;
	}


	void StoppedBooster();
	void StartedBooster();
	float STATIC_GetBoosterUsePercent();
};


// Class TgGame.TgAnimNodeBlendByEmoteType
// 0x0000 (0x0168 - 0x0168)
class UTgAnimNodeBlendByEmoteType : public UTgAnimNodeBlendList
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendByEmoteType");
		return ptr;
	}


	void PlayLooping();
	void PlayNormal();
};


// Class TgGame.TgAnimNodeBlendByFireType
// 0x0000 (0x0168 - 0x0168)
class UTgAnimNodeBlendByFireType : public UTgAnimNodeBlendList
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendByFireType");
		return ptr;
	}


	void SetLoopingOutput(bool bActive);
};


// Class TgGame.TgAnimNodeBlendByGameState
// 0x0008 (0x0170 - 0x0168)
class UTgAnimNodeBlendByGameState : public UTgAnimNodeBlendList
{
public:
	class ATgPawn*                                     PawnOwner;                                                // 0x0168(0x0008) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendByGameState");
		return ptr;
	}

};


// Class TgGame.TgAnimNodeBlendByGrapplingHook
// 0x0000 (0x0168 - 0x0168)
class UTgAnimNodeBlendByGrapplingHook : public UTgAnimNodeBlendList
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendByGrapplingHook");
		return ptr;
	}


	void STATIC_HookInactive();
	void STATIC_HookPost();
	void STATIC_HookHitPost();
	void STATIC_HookPull();
	void STATIC_HookThrow();
};


// Class TgGame.TgAnimNodeBlendByHealth
// 0x0018 (0x0180 - 0x0168)
class UTgAnimNodeBlendByHealth : public UTgAnimNodeBlendList
{
public:
	TArray<float>                                      m_HealthChildren;                                         // 0x0168(0x0010) (Edit, NeedCtorLink)
	class ATgPawn*                                     m_TgPawn;                                                 // 0x0178(0x0008) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendByHealth");
		return ptr;
	}

};


// Class TgGame.TgAnimNodeBlendByHitReaction
// 0x0000 (0x0168 - 0x0168)
class UTgAnimNodeBlendByHitReaction : public UTgAnimNodeBlendList
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendByHitReaction");
		return ptr;
	}


	void STATIC_OnMajorHit(const struct FVector& DirectionFromHit);
	void STATIC_OnMinorHit(const struct FVector& DirectionFromHit);
};


// Class TgGame.TgAnimNodeBlendByIntroduction
// 0x0004 (0x016C - 0x0168)
class UTgAnimNodeBlendByIntroduction : public UTgAnimNodeBlendList
{
public:
	unsigned long                                      m_bIsRelevant : 1;                                        // 0x0168(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendByIntroduction");
		return ptr;
	}


	void PlayIntroduction();
	void PrepareIntroduction();
};


// Class TgGame.TgAnimNodeBlendByKnockdown
// 0x0034 (0x019C - 0x0168)
class UTgAnimNodeBlendByKnockdown : public UTgAnimNodeBlendList
{
public:
	unsigned long                                      m_bAdjustPlayRateByVelocity : 1;                          // 0x0168(0x0004) (Edit)
	float                                              m_fVelocityMultiplier;                                    // 0x016C(0x0004) (Edit)
	float                                              m_PreviewVelocity;                                        // 0x0170(0x0004) (Edit)
	class ATgPawn*                                     m_TgPawn;                                                 // 0x0174(0x0008)
	struct FName                                       m_FaceDownAnimName;                                       // 0x017C(0x0008) (Edit)
	struct FName                                       m_FaceUpAnimName;                                         // 0x0184(0x0008) (Edit)
	struct FName                                       m_FaceDownRecoverAnimName;                                // 0x018C(0x0008) (Edit)
	struct FName                                       m_FaceUpRecoverAnimName;                                  // 0x0194(0x0008) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendByKnockdown");
		return ptr;
	}


	void SetDownStateAnim(bool bFaceDown);
};


// Class TgGame.TgAnimNodeBlendByLobby
// 0x0000 (0x0168 - 0x0168)
class UTgAnimNodeBlendByLobby : public UTgAnimNodeBlendList
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendByLobby");
		return ptr;
	}

};


// Class TgGame.TgAnimNodeBlendByMeleeIdle
// 0x0008 (0x0170 - 0x0168)
class UTgAnimNodeBlendByMeleeIdle : public UTgAnimNodeBlendList
{
public:
	class ATgPawn*                                     m_TgPawn;                                                 // 0x0168(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendByMeleeIdle");
		return ptr;
	}

};


// Class TgGame.TgAnimNodeBlendByMountState
// 0x0000 (0x0168 - 0x0168)
class UTgAnimNodeBlendByMountState : public UTgAnimNodeBlendList
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendByMountState");
		return ptr;
	}


	bool STATIC_IsPlayingEmote();
	void CancelIdleEmote();
	void STATIC_PlayIdleEmote();
};


// Class TgGame.TgAnimNodeBlendByMovementAbility
// 0x0000 (0x0168 - 0x0168)
class UTgAnimNodeBlendByMovementAbility : public UTgAnimNodeBlendList
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendByMovementAbility");
		return ptr;
	}


	void SetActiveChildFromMoveType(TEnumAsByte<EeMovementType> eMoveType);
};


// Class TgGame.TgAnimNodeBlendBySlowFall
// 0x0000 (0x0168 - 0x0168)
class UTgAnimNodeBlendBySlowFall : public UTgAnimNodeBlendList
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendBySlowFall");
		return ptr;
	}


	void STATIC_SetActiveAnimationIndex(int ChildIndex);
};


// Class TgGame.TgAnimNodeBlendByWeaponAnim
// 0x00C5 (0x022D - 0x0168)
class UTgAnimNodeBlendByWeaponAnim : public UTgAnimNodeBlendList
{
public:
	class ATgPawn*                                     m_TgPawn;                                                 // 0x0168(0x0008) (Transient)
	class ATgDevice*                                   m_Device;                                                 // 0x0170(0x0008) (Transient)
	struct FName                                       m_nmBuildupFireSpinControlName;                           // 0x0178(0x0008) (Edit)
	class UTgSkelCon_Spinner*                          m_BuildupFireSpinControl;                                 // 0x0180(0x0008)
	TArray<struct FName>                               m_nmRecoilControlNames;                                   // 0x0188(0x0010) (Edit, NeedCtorLink)
	TArray<class UGameSkelCtrl_Recoil*>                m_RecoilControls;                                         // 0x0198(0x0010) (NeedCtorLink)
	TArray<class UGameSkelCtrl_Recoil*>                m_TinyWeaponsRecoilControls;                              // 0x01A8(0x0010) (NeedCtorLink)
	TArray<struct FName>                               m_nmMeleeControlNames;                                    // 0x01B8(0x0010) (Edit, NeedCtorLink)
	TArray<class UGameSkelCtrl_Recoil*>                m_MeleeControls;                                          // 0x01C8(0x0010) (NeedCtorLink)
	unsigned long                                      m_bPlayBuildUp : 1;                                       // 0x01D8(0x0004) (Edit)
	unsigned long                                      m_bPlayFire : 1;                                          // 0x01D8(0x0004) (Edit)
	unsigned long                                      m_bScaleFireByRefireTime : 1;                             // 0x01D8(0x0004) (Edit)
	unsigned long                                      m_bScalePutawayRetrieveAnims : 1;                         // 0x01D8(0x0004)
	unsigned long                                      m_bSetIdleOnNonRelevant : 1;                              // 0x01D8(0x0004) (Edit)
	unsigned long                                      m_bPlayFireOnlyWhenRelevant : 1;                          // 0x01D8(0x0004) (Edit)
	struct FName                                       m_FireFinalRoundAnimName;                                 // 0x01DC(0x0008) (Edit)
	struct FName                                       m_DryFireAnimName;                                        // 0x01E4(0x0008) (Edit)
	struct FName                                       m_MovingFireAnimName;                                     // 0x01EC(0x0008) (Edit)
	struct FName                                       m_StandardFireAnimName;                                   // 0x01F4(0x0008) (Transient)
	struct FName                                       m_StandardPostFireAnimName;                               // 0x01FC(0x0008) (Transient)
	struct FName                                       m_ReloadPartialClipAnimName;                              // 0x0204(0x0008) (Edit)
	struct FName                                       m_StandardReloadAnimName;                                 // 0x020C(0x0008) (Transient)
	TArray<struct FDeviceNodeCameraAnimation>          m_CameraAnimations;                                       // 0x0214(0x0010) (Edit, NeedCtorLink)
	class UTgCameraShake*                              m_FireCameraShake;                                        // 0x0224(0x0008) (Edit)
	TEnumAsByte<ETG_EQUIP_POINT>                       m_EquipPoint;                                             // 0x022C(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendByWeaponAnim");
		return ptr;
	}


	void PlayPostFire();
	void PlayMelee();
	void PlayQuickPutaway();
	void PlayQuickRetrieve();
	void PlayDryFire();
	void STATIC_OnStopFire();
	void PlayOffhand(float Rate);
	void STATIC_PlayReload(float ReloadTime, int RoundsRemainingInClip);
	void STATIC_PlayRetrieve(float RetrieveTime, float ForcedRateBuff);
	void PlayPutaway(float PutAwayTime, float ForcedRateBuff);
	void PlayFire(int SocketIndex, float RefireTime, int RoundsRemainingInClip);
	void PlayBuildup(float BuildupTime);
	void PlayAltIdle();
	void PlayIdle();
	void STATIC_SetActiveChild(int ChildIndex, float BlendTime);
	void STATIC_StopAnim();
};


// Class TgGame.TgAnimNodeBlendByZoomPostFireTransition
// 0x0000 (0x0168 - 0x0168)
class UTgAnimNodeBlendByZoomPostFireTransition : public UTgAnimNodeBlendList
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendByZoomPostFireTransition");
		return ptr;
	}


	void SetZoomState(bool ZoomIn);
	void StartZoomTransition(float transitionTimeRemaining, bool ZoomIn);
};


// Class TgGame.TgAnimNodeBlendByZoomTransition
// 0x0004 (0x016C - 0x0168)
class UTgAnimNodeBlendByZoomTransition : public UTgAnimNodeBlendList
{
public:
	float                                              m_fTransitionStartTime;                                   // 0x0168(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendByZoomTransition");
		return ptr;
	}


	void SetZoomState(bool ZoomIn);
	void StartZoomTransition(float zoomPercent, float totalTransitionTime, bool ZoomIn);
};


// Class TgGame.TgAnimNodeBlendCrouch
// 0x0000 (0x0168 - 0x0168)
class UTgAnimNodeBlendCrouch : public UTgAnimNodeBlendList
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendCrouch");
		return ptr;
	}


	void SetCrouchState(bool bCrouch);
	void UpdateSyncGroups();
};


// Class TgGame.TgAnimNodeBlendList_EquipScreen
// 0x0000 (0x0168 - 0x0168)
class UTgAnimNodeBlendList_EquipScreen : public UTgAnimNodeBlendList
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendList_EquipScreen");
		return ptr;
	}


	void PlayIdleAnim();
	void PlayBackpackReaction();
	void PlaySuitReaction();
	void PlayHelmetReaction();
	void PlayWeaponReaction();
};


// Class TgGame.TgAnimNodeChannelFire
// 0x0018 (0x0180 - 0x0168)
class UTgAnimNodeChannelFire : public UTgAnimNodeBlendList
{
public:
	TEnumAsByte<ETG_EQUIP_POINT>                       m_EquipPoint;                                             // 0x0168(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0169(0x0003) MISSED OFFSET
	unsigned long                                      m_bResetOnRelevant : 1;                                   // 0x016C(0x0004) (Edit)
	unsigned long                                      m_bCheckAnimSeqForAnim : 1;                               // 0x016C(0x0004) (Edit)
	unsigned long                                      m_bUseCooldownForEndChannel : 1;                          // 0x016C(0x0004) (Edit)
	unsigned long                                      m_bOnlyCallAnimEndWhenRelevant : 1;                       // 0x016C(0x0004) (Edit)
	unsigned long                                      m_bDoneChanneling : 1;                                    // 0x016C(0x0004) (Transient)
	float                                              m_fMaxLoopTime;                                           // 0x0170(0x0004) (Edit)
	float                                              m_fPreCooldownEndTimeTrigger;                             // 0x0174(0x0004) (Edit)
	float                                              m_fCooldownEndTime;                                       // 0x0178(0x0004) (Transient)
	float                                              m_fEndLoopTime;                                           // 0x017C(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeChannelFire");
		return ptr;
	}


	void SetLockedBase(bool bLocked);
	bool ShouldSetActiveChild(class UAnimNode* pAnimNode);
	void STATIC_ReplayAnim();
	void EndChannel();
	void StartCooldownTimer(float fCooldown);
};


// Class TgGame.TgAnimNodeLockableChannelFire
// 0x0004 (0x0184 - 0x0180)
class UTgAnimNodeLockableChannelFire : public UTgAnimNodeChannelFire
{
public:
	unsigned long                                      m_bPlayStartOnLock : 1;                                   // 0x0180(0x0004) (Edit)
	unsigned long                                      m_bPlayStartOnUnlock : 1;                                 // 0x0180(0x0004) (Edit)
	unsigned long                                      m_bPlayStartAfterLockLost : 1;                            // 0x0180(0x0004) (Edit)
	unsigned long                                      m_bLocked : 1;                                            // 0x0180(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeLockableChannelFire");
		return ptr;
	}


	void SetLockedBase(bool bLocked);
	void SetLocked(bool bLocked);
};


// Class TgGame.TgAnimNodeEmoteSwitch
// 0x0000 (0x0168 - 0x0168)
class UTgAnimNodeEmoteSwitch : public UTgAnimNodeBlendList
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeEmoteSwitch");
		return ptr;
	}


	void PlayEmote(TEnumAsByte<EEmote> Emote);
};


// Class TgGame.TgAnimNodePlayFireAnim
// 0x0010 (0x0178 - 0x0168)
class UTgAnimNodePlayFireAnim : public UTgAnimNodeBlendList
{
public:
	struct FName                                       FireAnimNodeName;                                         // 0x0168(0x0008) (Edit)
	class UAnimNodeSequence*                           FireAnimNodeSequence;                                     // 0x0170(0x0008) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodePlayFireAnim");
		return ptr;
	}


	void PlayFireAnim(const struct FName& FireName);
};


// Class TgGame.TgAnimNodeRandom
// 0x0048 (0x01B0 - 0x0168)
class UTgAnimNodeRandom : public UTgAnimNodeBlendList
{
public:
	int                                                m_iDefaultChildIndex;                                     // 0x0168(0x0004) (Edit)
	unsigned long                                      m_bConsiderRelevancy : 1;                                 // 0x016C(0x0004) (Edit)
	unsigned long                                      m_bMasterOtherNodes : 1;                                  // 0x016C(0x0004) (Edit)
	unsigned long                                      m_bIsASlave : 1;                                          // 0x016C(0x0004) (Transient)
	unsigned long                                      m_bEnableTimer : 1;                                       // 0x016C(0x0004) (Edit)
	unsigned long                                      m_TimeAllChildren : 1;                                    // 0x016C(0x0004) (Edit)
	TArray<struct FName>                               m_SlaveNames;                                             // 0x0170(0x0010) (Edit, NeedCtorLink)
	TArray<class UTgAnimNodeRandom*>                   m_Slaves;                                                 // 0x0180(0x0010) (Transient, NeedCtorLink)
	int                                                m_nPrimaryChild;                                          // 0x0190(0x0004) (Edit)
	struct FVector2D                                   m_TimeRange;                                              // 0x0194(0x0008) (Edit)
	float                                              m_fRemainingTime;                                         // 0x019C(0x0004)
	TArray<struct FTgRandomAnimInfo>                   RandomInfo;                                               // 0x01A0(0x0010) (Edit, EditFixedSize, NeedCtorLink, EditInline)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeRandom");
		return ptr;
	}

};


// Class TgGame.TgAnimNodeStanceFireIntercept
// 0x0008 (0x0170 - 0x0168)
class UTgAnimNodeStanceFireIntercept : public UTgAnimNodeBlendList
{
public:
	int                                                m_nStanceToAllow;                                         // 0x0168(0x0004) (Edit)
	int                                                m_nCurrentStance;                                         // 0x016C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeStanceFireIntercept");
		return ptr;
	}


	void STATIC_ReplayAnim();
	void PlayAnim(bool bLoop, float Rate, float StartTime);
};


// Class TgGame.TgAnimNodeStanceTransitionerSynchronized
// 0x0020 (0x0188 - 0x0168)
class UTgAnimNodeStanceTransitionerSynchronized : public UTgAnimNodeBlendList
{
public:
	float                                              StanceResetTime;                                          // 0x0168(0x0004) (Edit)
	unsigned long                                      CanResetStanceOnTick : 1;                                 // 0x016C(0x0004) (Edit)
	unsigned long                                      m_bDelayingChildSwitch : 1;                               // 0x016C(0x0004)
	int                                                m_nCurrentStance;                                         // 0x0170(0x0004)
	float                                              m_fTimestampToSwitchStance;                               // 0x0174(0x0004)
	TArray<struct FStanceTransitionParam>              StanceTransitionControl;                                  // 0x0178(0x0010) (Edit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeStanceTransitionerSynchronized");
		return ptr;
	}


	void STATIC_ReplayAnim();
	void PlayAnim(bool bLoop, float Rate, float StartTime);
	void ChangeStance(int Stance, bool bAutoSync, bool bForceUpdate);
};


// Class TgGame.TgAnimNodeStanceDualFire
// 0x0008 (0x0190 - 0x0188)
class UTgAnimNodeStanceDualFire : public UTgAnimNodeStanceTransitionerSynchronized
{
public:
	unsigned long                                      m_bFireParityDirty : 1;                                   // 0x0188(0x0004)
	int                                                m_nDesiredStance;                                         // 0x018C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeStanceDualFire");
		return ptr;
	}


	void ChangeStance(int Stance, bool bAutoSync, bool bForceUpdate);
};


// Class TgGame.TgAnimNodeTargeting
// 0x0008 (0x0170 - 0x0168)
class UTgAnimNodeTargeting : public UTgAnimNodeBlendList
{
public:
	TEnumAsByte<ETG_EQUIP_POINT>                       m_EquipPoint;                                             // 0x0168(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0169(0x0003) MISSED OFFSET
	unsigned long                                      m_bResetOnRelevant : 1;                                   // 0x016C(0x0004) (Edit)
	unsigned long                                      m_bDoneTargeting : 1;                                     // 0x016C(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeTargeting");
		return ptr;
	}


	void STATIC_ReplayAnim();
	void EndTargeting();
	void STATIC_InterruptTargeting();
};


// Class TgGame.TgAnimNodeToggleWithTransition
// 0x0008 (0x0170 - 0x0168)
class UTgAnimNodeToggleWithTransition : public UTgAnimNodeBlendList
{
public:
	float                                              m_fTransitionStartTime;                                   // 0x0168(0x0004)
	float                                              m_fTransitionTimeRemaining;                               // 0x016C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeToggleWithTransition");
		return ptr;
	}


	void SetToggleState(bool IsActive);
	void StartTransition(float transitionPercent, float totalTransitionTime, bool transitionToActive);
};


// Class TgGame.TgAnimNodeToggleWithTransition_Disengage
// 0x0008 (0x0178 - 0x0170)
class UTgAnimNodeToggleWithTransition_Disengage : public UTgAnimNodeToggleWithTransition
{
public:
	int                                                m_nPendingChildIndex;                                     // 0x0170(0x0004)
	unsigned long                                      m_bForceNewActiveChild : 1;                               // 0x0174(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeToggleWithTransition_Disengage");
		return ptr;
	}


	void STATIC_ReplayAnim();
	void PlayAnim(bool bLoop, float Rate, float StartTime);
	void STATIC_SetActiveChild(int ChildIndex, float BlendTime);
};


// Class TgGame.TgAnimSequenceChain
// 0x0004 (0x016C - 0x0168)
class UTgAnimSequenceChain : public UTgAnimNodeBlendList
{
public:
	unsigned long                                      m_bLoopChain : 1;                                         // 0x0168(0x0004) (Edit)
	unsigned long                                      m_bResetOnRelevant : 1;                                   // 0x0168(0x0004) (Edit)
	unsigned long                                      m_bDelayBlendOutToPlayAnim : 1;                           // 0x0168(0x0004) (Edit)
	unsigned long                                      m_bAdvanceOnReplay : 1;                                   // 0x0168(0x0004) (Edit)
	unsigned long                                      m_bAdvanceOnAnimEnd : 1;                                  // 0x0168(0x0004) (Edit)
	unsigned long                                      m_bIsAllowedToBlendOut : 1;                               // 0x0168(0x0004)
	unsigned long                                      m_ReplayedThisFrame : 1;                                  // 0x0168(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimSequenceChain");
		return ptr;
	}

};


// Class TgGame.TgAnimNodeEmoteCustomAnim
// 0x0004 (0x0130 - 0x012C)
class UTgAnimNodeEmoteCustomAnim : public UAnimNodePlayCustomAnim
{
public:
	unsigned long                                      c_bIsInHandDeviceMeshInvisible : 1;                       // 0x012C(0x0004)
	unsigned long                                      c_bHasReachedFullWeight : 1;                              // 0x012C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeEmoteCustomAnim");
		return ptr;
	}

};


// Class TgGame.TgAnimNodeEmoteSequence
// 0x000C (0x01C8 - 0x01BC)
class UTgAnimNodeEmoteSequence : public UAnimNodeSequenceBlendBase
{
public:
	TEnumAsByte<EEmote>                                ActiveEmote;                                              // 0x01BC(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x01BD(0x0003) MISSED OFFSET
	float                                              BlendSpeed;                                               // 0x01C0(0x0004) (Edit)
	unsigned long                                      InterpWeights : 1;                                        // 0x01C4(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeEmoteSequence");
		return ptr;
	}


	bool SetActiveEmote(const struct FName& FullBody, const struct FName& Moving, TEnumAsByte<EEmote> Emote, bool bResetSynchGroup);
};


// Class TgGame.TgAnimNodeFidget
// 0x0024 (0x0168 - 0x0144)
class UTgAnimNodeFidget : public UAnimNodeBlendList
{
public:
	float                                              m_SelectedIdleTimeBeforeFidgeting;                        // 0x0144(0x0004) (Transient)
	float                                              m_CurrentIdleTime;                                        // 0x0148(0x0004) (Transient)
	float                                              BlendToFidgetDuration;                                    // 0x014C(0x0004) (Edit)
	float                                              BlendFromFidgetDuration;                                  // 0x0150(0x0004) (Edit)
	TEnumAsByte<EFidgetType>                           FidgetType;                                               // 0x0154(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0155(0x0003) MISSED OFFSET
	float                                              MinimumIdleTimeBeforeFidgeting;                           // 0x0158(0x0004) (Edit)
	float                                              MaximumIdleTimeBeforeFidgeting;                           // 0x015C(0x0004) (Edit)
	unsigned long                                      AllowIdleAnimToComplete : 1;                              // 0x0160(0x0004) (Edit)
	float                                              ChanceToFidgetWhenIdleCompletes;                          // 0x0164(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeFidget");
		return ptr;
	}

};


// Class TgGame.TgAnimNodeFitToDuration
// 0x001F (0x0130 - 0x0111)
class UTgAnimNodeFitToDuration : public UAnimNodeBlendBase
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0111(0x0003) MISSED OFFSET
	float                                              Duration;                                                 // 0x0114(0x0004) (Edit)
	float                                              OverrideDuration;                                         // 0x0118(0x0004)
	unsigned long                                      bAllowIncreasedPlayRate : 1;                              // 0x011C(0x0004) (Edit)
	unsigned long                                      bAllowDecreasedPlayRate : 1;                              // 0x011C(0x0004) (Edit)
	unsigned long                                      bClampDuration : 1;                                       // 0x011C(0x0004) (Edit)
	unsigned long                                      m_bScaleByReload : 1;                                     // 0x011C(0x0004) (Edit)
	float                                              ClampedMinDuration;                                       // 0x0120(0x0004) (Edit)
	float                                              ClampedMaxDuration;                                       // 0x0124(0x0004) (Edit)
	TEnumAsByte<ETG_EQUIP_POINT>                       m_EquipPoint;                                             // 0x0128(0x0001) (Edit)
	unsigned char                                      UnknownData01[0x3];                                       // 0x0129(0x0003) MISSED OFFSET
	float                                              m_fDurationMultiplier;                                    // 0x012C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeFitToDuration");
		return ptr;
	}

};


// Class TgGame.TgAnimNodeJumpLeanOffset
// 0x0030 (0x019C - 0x016C)
class UTgAnimNodeJumpLeanOffset : public UAnimNodeAimOffset
{
public:
	float                                              JumpLeanStrength;                                         // 0x016C(0x0004) (Edit)
	float                                              MaxLeanChangeSpeed;                                       // 0x0170(0x0004) (Edit)
	unsigned long                                      bMultiplyByZVelocity : 1;                                 // 0x0174(0x0004) (Edit)
	class UAnimNodeAimOffset*                          CachedAimNode;                                            // 0x0178(0x0008)
	struct FName                                       OldAimProfileName;                                        // 0x0180(0x0008)
	struct FVector2D                                   PreBlendAim;                                              // 0x0188(0x0008)
	float                                              LeanWeight;                                               // 0x0190(0x0004)
	float                                              LeanWeightTarget;                                         // 0x0194(0x0004)
	float                                              BlendTimeToGo;                                            // 0x0198(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeJumpLeanOffset");
		return ptr;
	}


	void SetLeanWeight(float WeightTarget, float BlendTime);
};


// Class TgGame.TgAnimNodeLog
// 0x0000 (0x0144 - 0x0144)
class UTgAnimNodeLog : public UAnimNodeBlendList
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeLog");
		return ptr;
	}

};


// Class TgGame.TgAnimNodeMountSync
// 0x001B (0x012C - 0x0111)
class UTgAnimNodeMountSync : public UAnimNodeBlendBase
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0111(0x0003) MISSED OFFSET
	class ATgPawn*                                     m_TgP;                                                    // 0x0114(0x0008)
	TArray<struct FName>                               m_nmSyncGroupNames;                                       // 0x011C(0x0010) (Edit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeMountSync");
		return ptr;
	}

};


// Class TgGame.TgAnimNodePlayCustomAnim
// 0x000C (0x0138 - 0x012C)
class UTgAnimNodePlayCustomAnim : public UAnimNodePlayCustomAnim
{
public:
	unsigned long                                      m_bOverrideBlendInTime : 1;                               // 0x012C(0x0004) (Edit)
	unsigned long                                      m_bOverrideBlendOutTime : 1;                              // 0x012C(0x0004) (Edit)
	float                                              m_fOverriddenBlendInTime;                                 // 0x0130(0x0004) (Edit)
	float                                              m_fOverriddenBlendOutTime;                                // 0x0134(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodePlayCustomAnim");
		return ptr;
	}


	void STATIC_PlayOverriddenCustomAnim(const struct FName& AnimName, float Rate, float BlendInTime, float BlendOutTime, bool bLooping, bool bOverride);
};


// Class TgGame.TgAnimNodePlayTgCameraAnim
// 0x0013 (0x0124 - 0x0111)
class UTgAnimNodePlayTgCameraAnim : public UAnimNodeBlendBase
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0111(0x0003) MISSED OFFSET
	class UTgCameraShake*                              m_CameraShake;                                            // 0x0114(0x0008) (Edit)
	class ATgPawn*                                     m_TgPawn;                                                 // 0x011C(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodePlayTgCameraAnim");
		return ptr;
	}

};


// Class TgGame.TgAnimNodeSequence
// 0x0010 (0x01BC - 0x01AC)
class UTgAnimNodeSequence : public UAnimNodeSequence
{
public:
	unsigned long                                      bAutoPlay : 1;                                            // 0x01AC(0x0004) (Edit)
	unsigned long                                      bResetOnActivate : 1;                                     // 0x01AC(0x0004)
	unsigned long                                      HasDynamicLength : 1;                                     // 0x01AC(0x0004) (Edit)
	unsigned long                                      EnableFootControlsOnCease : 1;                            // 0x01AC(0x0004) (Edit)
	unsigned long                                      SynchronizeGroupOnReplay : 1;                             // 0x01AC(0x0004) (Edit)
	unsigned long                                      bRandomStartPosition : 1;                                 // 0x01AC(0x0004) (Edit)
	float                                              ChainedSequenceDuration;                                  // 0x01B0(0x0004) (Edit)
	struct FName                                       m_nmDisplayGroup;                                         // 0x01B4(0x0008) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeSequence");
		return ptr;
	}


	void PlayAnim(bool bLoop, float InRate, float StartTime);
};


// Class TgGame.TgAnimNodeSelfDestruct
// 0x0040 (0x01FC - 0x01BC)
class UTgAnimNodeSelfDestruct : public UTgAnimNodeSequence
{
public:
	int                                                NumberOfLoopsBeforeDestruct;                              // 0x01BC(0x0004) (Edit)
	int                                                LoopsCompleted;                                           // 0x01C0(0x0004)
	TArray<struct FName>                               ScaleOutSkelControlNames;                                 // 0x01C4(0x0010) (Edit, NeedCtorLink)
	float                                              TimeRemaingForScaleOut;                                   // 0x01D4(0x0004) (Edit)
	TArray<class USkelControlBase*>                    ScaleOutSkelControls;                                     // 0x01D8(0x0010) (Transient, NeedCtorLink)
	TArray<float>                                      ScaleOutStartScales;                                      // 0x01E8(0x0010) (Transient, NeedCtorLink)
	float                                              ScaleOutStartTime;                                        // 0x01F8(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeSelfDestruct");
		return ptr;
	}

};


// Class TgGame.TgAnimNodeSequence_SyncToCooldown
// 0x0018 (0x01D4 - 0x01BC)
class UTgAnimNodeSequence_SyncToCooldown : public UTgAnimNodeSequence
{
public:
	TEnumAsByte<ETG_EQUIP_POINT>                       m_EqpPoint;                                               // 0x01BC(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x01BD(0x0003) MISSED OFFSET
	float                                              m_fMaxPlayRate;                                           // 0x01C0(0x0004) (Edit)
	float                                              m_fPlayRateWaitForCooldown;                               // 0x01C4(0x0004) (Edit)
	float                                              m_fPctStartWaitForCooldown;                               // 0x01C8(0x0004) (Edit)
	float                                              fCooldownEndTime;                                         // 0x01CC(0x0004)
	unsigned long                                      bWaitForCooldown : 1;                                     // 0x01D0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeSequence_SyncToCooldown");
		return ptr;
	}


	void PlayAnim(bool bLoop, float InRate, float StartTime);
	void STATIC_EndCooldown();
	void StartCooldownTimer(float fCooldown);
};


// Class TgGame.TgAnimNodeSimpleTransitioner
// 0x0020 (0x0164 - 0x0144)
class UTgAnimNodeSimpleTransitioner : public UAnimNodeBlendList
{
public:
	int                                                m_nDeviceId;                                              // 0x0144(0x0004) (Edit)
	unsigned long                                      m_bConfigureBasedOnDevice : 1;                            // 0x0148(0x0004) (Edit)
	unsigned long                                      m_bIgnoreFireMode : 1;                                    // 0x0148(0x0004) (Edit)
	int                                                m_nNumberOfStances;                                       // 0x014C(0x0004) (Edit)
	struct FName                                       m_StanceBaseName;                                         // 0x0150(0x0008) (Edit)
	struct FName                                       m_TransitionBaseName;                                     // 0x0158(0x0008) (Edit)
	float                                              m_BlendTransitionDuration;                                // 0x0160(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeSimpleTransitioner");
		return ptr;
	}


	bool STATIC_Fire(int nMode);
	bool SetStance(int nStance, bool bNoBlend);
	void STATIC_ReplayAnim();
	void PlayAnim(bool bLoop, float InRate, float StartTime);
};


// Class TgGame.TgAnimNodeSlot
// 0x0034 (0x016C - 0x0138)
class UTgAnimNodeSlot : public UAnimNodeSlot
{
public:
	class ATgPawn*                                     m_TgPawn;                                                 // 0x0138(0x0008) (Transient)
	unsigned long                                      m_bBlendOutIfVelocityIsGreaterThanZero : 1;               // 0x0140(0x0004) (Transient)
	unsigned long                                      m_bIsTransitionAnim : 1;                                  // 0x0140(0x0004) (Transient)
	unsigned long                                      m_bNotifyActorOnChildAnimEnd : 1;                         // 0x0140(0x0004) (Edit)
	struct FName                                       m_nmHackingTransitionAnimName;                            // 0x0144(0x0008) (Edit)
	struct FName                                       m_nmHackingLoopingAnimName;                               // 0x014C(0x0008) (Edit)
	struct FName                                       m_nmAFKTransitionAnimName;                                // 0x0154(0x0008) (Edit)
	struct FName                                       m_nmAFKLoopingAnimName;                                   // 0x015C(0x0008) (Edit)
	struct FName                                       m_nmQueuedAnim;                                           // 0x0164(0x0008) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeSlot");
		return ptr;
	}


	void STATIC_StopCustomAnim(float BlendOutTime);
	void StopHacking();
	void PlayHacking();
	void StopAFK();
	void PlayAFK();
	void STATIC_SetPlayRate(float fPlayRate);
	float PlayLoopingCustomAnimWithTransition(const struct FName& TransitionAnimName, const struct FName& LoopingAnimName, float Rate, float BlendInTime, float BlendOutTime);
};


// Class TgGame.TgAnimNodeStance
// 0x0004 (0x0148 - 0x0144)
class UTgAnimNodeStance : public UAnimNodeBlendList
{
public:
	int                                                m_Stance;                                                 // 0x0144(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeStance");
		return ptr;
	}

};


// Class TgGame.TgAnimNodeStanceTransition
// 0x0008 (0x014C - 0x0144)
class UTgAnimNodeStanceTransition : public UAnimNodeBlendList
{
public:
	int                                                m_SourceStance;                                           // 0x0144(0x0004) (Edit)
	int                                                m_DestinationStance;                                      // 0x0148(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeStanceTransition");
		return ptr;
	}

};


// Class TgGame.TgAnimNodeStanceTransitioner
// 0x0030 (0x0174 - 0x0144)
class UTgAnimNodeStanceTransitioner : public UAnimNodeBlendList
{
public:
	int                                                m_DefaultStance;                                          // 0x0144(0x0004) (Edit)
	int                                                m_CurrentStance;                                          // 0x0148(0x0004) (Edit)
	unsigned long                                      m_bIsPlayingTransition : 1;                               // 0x014C(0x0004)
	float                                              m_BlendTransitionDuration;                                // 0x0150(0x0004) (Edit)
	TArray<struct FCachedTgAnimNodeStanceInfo>         m_StanceNodeInfos;                                        // 0x0154(0x0010) (NeedCtorLink)
	TArray<struct FCachedTgAnimNodeStanceTransitionInfo> m_TransitionNodeInfos;                                    // 0x0164(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeStanceTransitioner");
		return ptr;
	}


	bool BlendToStance(int DestinationStance);
	bool TransitionToStance(int DestinationStance);
	void STATIC_GetTransitionableStances(int SourceStance, TArray<int>* DestinationStances);
	bool SetStance(int Stance);
	void STATIC_ReplayAnim();
	void PlayAnim(bool bLoop, float InRate, float StartTime);
	void STATIC_GetStances(TArray<int>* Stances);
	int STATIC_GetCurrentStance();
};


// Class TgGame.TgAnimNodeTiltTowardsVelocity
// 0x0023 (0x0134 - 0x0111)
class UTgAnimNodeTiltTowardsVelocity : public UAnimNodeBlendBase
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0111(0x0003) MISSED OFFSET
	struct FVector2D                                   m_MaximumVelocity;                                        // 0x0114(0x0008) (Edit)
	int                                                m_PitchOffset;                                            // 0x011C(0x0004) (Transient)
	int                                                m_MaximumPitchOffset;                                     // 0x0120(0x0004) (Edit)
	int                                                m_RollOffset;                                             // 0x0124(0x0004) (Transient)
	int                                                m_MaximumRollOffset;                                      // 0x0128(0x0004) (Edit)
	class ATgPawn*                                     m_Pawn;                                                   // 0x012C(0x0008) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeTiltTowardsVelocity");
		return ptr;
	}

};


// Class TgGame.TgAnimNodeTriggerCameraAnim
// 0x0023 (0x0134 - 0x0111)
class UTgAnimNodeTriggerCameraAnim : public UAnimNodeBlendBase
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0111(0x0003) MISSED OFFSET
	class UCameraAnim*                                 CameraAnim;                                               // 0x0114(0x0008) (Edit)
	float                                              fBlendInTime;                                             // 0x011C(0x0004) (Edit)
	float                                              fBlendOutTime;                                            // 0x0120(0x0004) (Edit)
	unsigned long                                      bLoopAnimation : 1;                                       // 0x0124(0x0004) (Edit)
	unsigned long                                      bBlendInOnBecomeRelevant : 1;                             // 0x0124(0x0004) (Edit)
	unsigned long                                      bBlendInOnReplayAnim : 1;                                 // 0x0124(0x0004) (Edit)
	unsigned long                                      bBlendOutOnStopFire : 1;                                  // 0x0124(0x0004) (Edit)
	unsigned long                                      bPlayAnimInLocalSpace : 1;                                // 0x0124(0x0004) (Edit)
	TEnumAsByte<ETG_EQUIP_POINT>                       m_StopFireEquipSlotTarget;                                // 0x0128(0x0001) (Edit)
	unsigned char                                      UnknownData01[0x3];                                       // 0x0129(0x0003) MISSED OFFSET
	class UCameraAnimInst*                             CameraAnimInst;                                           // 0x012C(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeTriggerCameraAnim");
		return ptr;
	}


	void STATIC_OnDeviceStopFire(TEnumAsByte<ETG_EQUIP_POINT> eqp);
	void STATIC_ReplayAnim();
	void EndCameraAnim();
	void StartCameraAnim();
};


// Class TgGame.TgAnimNotify_AkEvent
// 0x0010 (0x008C - 0x007C)
class UTgAnimNotify_AkEvent : public UAnimNotify_AkEvent
{
public:
	TArray<struct FPSE_SkinAk>                         m_SkinOverrideList;                                       // 0x007C(0x0010) (Edit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNotify_AkEvent");
		return ptr;
	}


	class UAkEvent* GetAkEventToPlay(class USkeletalMeshComponent* skel);
};


// Class TgGame.TgAnimNotify_AkEventMusic
// 0x0008 (0x0084 - 0x007C)
class UTgAnimNotify_AkEventMusic : public UAnimNotify_AkEvent
{
public:
	class UAkEvent*                                    AkEventStop;                                              // 0x007C(0x0008) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNotify_AkEventMusic");
		return ptr;
	}


	void STATIC_OnAnimNodeSequenceCeaseRelevant(class UAnimNodeSequence* OwningNode);
	void StopAkEvent(class USkeletalMeshComponent* skel);
};


// Class TgGame.TgAnimNotify_ApplyRigidBodyPhysics
// 0x0023 (0x0088 - 0x0065)
class UTgAnimNotify_ApplyRigidBodyPhysics : public UAnimNotify
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0065(0x0003) MISSED OFFSET
	unsigned long                                      ShouldAttachToBone : 1;                                   // 0x0068(0x0004) (Edit)
	struct FName                                       BoneName;                                                 // 0x006C(0x0008) (Edit)
	struct FVector                                     ImpulseLocation;                                          // 0x0074(0x000C) (Edit)
	float                                              ImpulseRadius;                                            // 0x0080(0x0004) (Edit)
	float                                              ImpulseStrength;                                          // 0x0084(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNotify_ApplyRigidBodyPhysics");
		return ptr;
	}

};


// Class TgGame.TgAnimNotify_AudioGroup
// 0x0014 (0x0079 - 0x0065)
class UTgAnimNotify_AudioGroup : public UAnimNotify
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0065(0x0003) MISSED OFFSET
	class USoundCue*                                   c_PreviewSound;                                           // 0x0068(0x0008) (Edit)
	struct FName                                       c_SoundCueName;                                           // 0x0070(0x0008) (Edit)
	TEnumAsByte<ETG_MESH_SOURCE>                       c_eMeshSource;                                            // 0x0078(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNotify_AudioGroup");
		return ptr;
	}

};


// Class TgGame.TgAnimNotify_Footstep
// 0x0003 (0x0078 - 0x0075)
class UTgAnimNotify_Footstep : public UAnimNotify_Footstep
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0075(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNotify_Footstep");
		return ptr;
	}

};


// Class TgGame.TgAnimNotify_InterpolateMorphTargetWeight
// 0x001B (0x0080 - 0x0065)
class UTgAnimNotify_InterpolateMorphTargetWeight : public UAnimNotify
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0065(0x0003) MISSED OFFSET
	struct FName                                       MorphNodePoseName;                                        // 0x0068(0x0008) (Edit)
	float                                              MorphTargetWeight;                                        // 0x0070(0x0004) (Edit)
	TEnumAsByte<EInterruptMorphTargetBehavior>         OnInterruptBehavior;                                      // 0x0074(0x0001) (Edit)
	unsigned char                                      UnknownData01[0x3];                                       // 0x0075(0x0003) MISSED OFFSET
	float                                              InterruptMorphTargetWeight;                               // 0x0078(0x0004) (Edit)
	float                                              InitialMorphTargetWeight;                                 // 0x007C(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNotify_InterpolateMorphTargetWeight");
		return ptr;
	}


	void STATIC_OnAnimNodeSequenceCeaseRelevant(class UAnimNodeSequence* OwningNode);
};


// Class TgGame.TgAnimNotify_PlayParticleEffect_Skinned
// 0x0014 (0x00AC - 0x0098)
class UTgAnimNotify_PlayParticleEffect_Skinned : public UAnimNotify_PlayParticleEffect
{
public:
	TArray<struct FPPE_Skin>                           m_SkinOverrideList;                                       // 0x0098(0x0010) (Edit, NeedCtorLink)
	unsigned long                                      m_bApplyTeamColor : 1;                                    // 0x00A8(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNotify_PlayParticleEffect_Skinned");
		return ptr;
	}


	struct FParticleChannelContainer GetParticleChannels(class USkeletalMeshComponent* skel);
	class UParticleSystem* GetParticleSystemToPlay(class USkeletalMeshComponent* skel);
};


// Class TgGame.TgAnimNotify_PlayPetAnim
// 0x000B (0x0070 - 0x0065)
class UTgAnimNotify_PlayPetAnim : public UAnimNotify
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0065(0x0003) MISSED OFFSET
	struct FName                                       m_ChildSeqName;                                           // 0x0068(0x0008) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNotify_PlayPetAnim");
		return ptr;
	}

};


// Class TgGame.TgAnimNotify_SetMICParam
// 0x000F (0x0074 - 0x0065)
class UTgAnimNotify_SetMICParam : public UAnimNotify
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0065(0x0003) MISSED OFFSET
	struct FName                                       m_nmParamName;                                            // 0x0068(0x0008) (Edit)
	float                                              m_fTargetValue;                                           // 0x0070(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNotify_SetMICParam");
		return ptr;
	}

};


// Class TgGame.TgAnimNotify_Sound
// 0x0010 (0x0098 - 0x0088)
class UTgAnimNotify_Sound : public UAnimNotify_Sound
{
public:
	TArray<struct FPSE_Skin>                           m_SkinOverrideList;                                       // 0x0088(0x0010) (Edit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNotify_Sound");
		return ptr;
	}


	class USoundCue* GetSoundCueToPlay(class USkeletalMeshComponent* skel);
};


// Class TgGame.TgAnimNotify_Sound_ByBotId
// 0x0010 (0x008C - 0x007C)
class UTgAnimNotify_Sound_ByBotId : public UAnimNotify_AkEvent
{
public:
	TArray<struct FPSE_BotData>                        m_BotOverrideList;                                        // 0x007C(0x0010) (Edit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNotify_Sound_ByBotId");
		return ptr;
	}


	class UAkEvent* GetAkEventToPlay(class USkeletalMeshComponent* skel);
};


// Class TgGame.TgAnimNotify_SwapToInhandWeaponMesh
// 0x0003 (0x0068 - 0x0065)
class UTgAnimNotify_SwapToInhandWeaponMesh : public UAnimNotify
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0065(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNotify_SwapToInhandWeaponMesh");
		return ptr;
	}

};


// Class TgGame.TgAnimNotify_ToggleInvisibleWall
// 0x003B (0x00A0 - 0x0065)
class UTgAnimNotify_ToggleInvisibleWall : public UAnimNotify
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0065(0x0003) MISSED OFFSET
	unsigned long                                      TurnWallOn : 1;                                           // 0x0068(0x0004) (Edit)
	unsigned long                                      TurnOffOnCeaseRelevant : 1;                               // 0x0068(0x0004) (Edit)
	int                                                WallIndex;                                                // 0x006C(0x0004) (Edit)
	struct FVector                                     WallPosition;                                             // 0x0070(0x000C) (Edit)
	struct FVector                                     WallNormal;                                               // 0x007C(0x000C) (Edit)
	struct FName                                       WallEnableBaseName;                                       // 0x0088(0x0008) (Const)
	struct FName                                       WallPositionBaseName;                                     // 0x0090(0x0008) (Const)
	struct FName                                       WallNormalBaseName;                                       // 0x0098(0x0008) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNotify_ToggleInvisibleWall");
		return ptr;
	}


	void STATIC_OnAnimNodeSequenceCeaseRelevant(class UAnimNodeSequence* OwningNode);
};


// Class TgGame.TgAnimNotify_ToggleRigidBodies
// 0x0014 (0x0079 - 0x0065)
class UTgAnimNotify_ToggleRigidBodies : public UAnimNotify
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0065(0x0003) MISSED OFFSET
	TArray<struct FName>                               BoneNames;                                                // 0x0068(0x0010) (Edit, NeedCtorLink)
	TEnumAsByte<ERigidBodyFixationChange>              Effect;                                                   // 0x0078(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNotify_ToggleRigidBodies");
		return ptr;
	}


	void STATIC_OnAnimNodeSequenceBecomeRelevant(class UAnimNodeSequence* OwningNode);
	void STATIC_OnAnimNodeSequenceCeaseRelevant(class UAnimNodeSequence* OwningNode);
};


// Class TgGame.TgAnimNotify_ToggleSocketSpecialFX
// 0x0013 (0x0078 - 0x0065)
class UTgAnimNotify_ToggleSocketSpecialFX : public UAnimNotify
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0065(0x0003) MISSED OFFSET
	struct FName                                       m_DisplayGroupName;                                       // 0x0068(0x0008) (Edit)
	int                                                m_EquipSlot;                                              // 0x0070(0x0004) (Edit)
	unsigned long                                      m_bActivateFxGroup : 1;                                   // 0x0074(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNotify_ToggleSocketSpecialFX");
		return ptr;
	}

};


// Class TgGame.TgAnimNotify_ViewShake
// 0x0010 (0x00CC - 0x00BC)
class UTgAnimNotify_ViewShake : public UAnimNotify_ViewShake
{
public:
	float                                              m_fShakeRadius;                                           // 0x00BC(0x0004) (EditConst)
	float                                              m_fDuration;                                              // 0x00C0(0x0004) (EditConst)
	float                                              m_fAmplitude;                                             // 0x00C4(0x0004) (EditConst)
	unsigned long                                      m_bUseLocationRadiusBasedShake : 1;                       // 0x00C8(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNotify_ViewShake");
		return ptr;
	}


	void STATIC_Notify(class AActor* Owner, class UAnimNodeSequence* AnimSeqInstigator);
	void Clear1pCameraAnim();
};


// Class TgGame.TgAnimNotifySkinData
// 0x0028 (0x0088 - 0x0060)
class UTgAnimNotifySkinData : public UObject
{
public:
	struct FString                                     OwningNotify;                                             // 0x0060(0x0010) (AlwaysInit, NeedCtorLink)
	class USoundCue*                                   SoundCueTemplate;                                         // 0x0070(0x0008)
	class UParticleSystem*                             ParticleSystemTemplate;                                   // 0x0078(0x0008)
	int                                                nSkinId;                                                  // 0x0080(0x0004)
	int                                                nSkinLevel;                                               // 0x0084(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNotifySkinData");
		return ptr;
	}

};


// Class TgGame.TgAnimTurnInPlace
// 0x0088 (0x01AC - 0x0124)
class UTgAnimTurnInPlace : public UAnimNodeBlend
{
public:
	unsigned long                                      bInitialized : 1;                                         // 0x0124(0x0004) (Const, Transient)
	unsigned long                                      bRootRotInitialized : 1;                                  // 0x0124(0x0004) (Const, Transient)
	unsigned long                                      m_bDisableRotation : 1;                                   // 0x0124(0x0004) (Edit)
	unsigned long                                      bDelayBlendOutToPlayAnim : 1;                             // 0x0124(0x0004) (Edit)
	unsigned long                                      bPlayingTurnTransition : 1;                               // 0x0124(0x0004) (Const)
	unsigned long                                      m_bCanChooseNewTransition : 1;                            // 0x0124(0x0004) (Edit)
	unsigned long                                      m_bOverrideInterpolationTime : 1;                         // 0x0124(0x0004) (Edit)
	unsigned long                                      m_bMirrorOffsetWhenPawnMirrored : 1;                      // 0x0124(0x0004) (Edit)
	unsigned long                                      m_bAlwaysUpdateYawOffset : 1;                             // 0x0124(0x0004) (Edit)
	unsigned long                                      m_bIgnoreTransitionAnimations : 1;                        // 0x0124(0x0004) (Edit)
	unsigned long                                      m_bOnlyUpdateRotationWhenMoving : 1;                      // 0x0124(0x0004) (Edit)
	unsigned long                                      m_bTurnTowardsVelocity : 1;                               // 0x0124(0x0004) (Edit)
	unsigned long                                      m_bUsePawnRotationAtZeroVelocity : 1;                     // 0x0124(0x0004) (Edit)
	unsigned long                                      m_bUse180ShortestRoute : 1;                               // 0x0124(0x0004) (Edit)
	unsigned long                                      m_bConstrictIdleYawOffset : 1;                            // 0x0124(0x0004) (Edit)
	unsigned long                                      m_bDisableAllTurning : 1;                                 // 0x0124(0x0004) (Edit)
	unsigned long                                      m_bJustBecameRelevant : 1;                                // 0x0124(0x0004)
	int                                                LastPawnYaw;                                              // 0x0128(0x0004) (Const, Transient)
	int                                                LastPawnPitch;                                            // 0x012C(0x0004) (Const, Transient)
	float                                              PawnRotationRate;                                         // 0x0130(0x0004) (Const, Transient)
	int                                                LastRootBoneYaw;                                          // 0x0134(0x0004) (Const, Transient)
	int                                                YawOffset;                                                // 0x0138(0x0004) (Edit, Const, Transient)
	int                                                PitchOffset;                                              // 0x013C(0x0004) (Edit, Const, Transient)
	float                                              RelativeOffset;                                           // 0x0140(0x0004) (Const, Transient)
	class ATgPawn*                                     m_TgPawn;                                                 // 0x0144(0x0008) (Const, Transient)
	TArray<class UTgAnimNodeAimOffset*>                OffsetNodes2;                                             // 0x014C(0x0010) (NeedCtorLink)
	TArray<struct FRotTransitionInfo>                  RotTransitions;                                           // 0x015C(0x0010) (Edit, NeedCtorLink)
	float                                              TransitionBlendTime;                                      // 0x016C(0x0004) (Edit)
	int                                                CurrentTransitionIndex;                                   // 0x0170(0x0004) (Const)
	float                                              TransitionThresholdAngle;                                 // 0x0174(0x0004) (Edit)
	TEnumAsByte<EForcedTransitionAngle>                m_ForcedTransitionAngle;                                  // 0x0178(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0179(0x0003) MISSED OFFSET
	float                                              m_fChooseNewTransitionPercent;                            // 0x017C(0x0004) (Edit)
	float                                              m_fInterpolationTime;                                     // 0x0180(0x0004) (Edit)
	float                                              m_RemainingInterpolationTime;                             // 0x0184(0x0004)
	TArray<class UTgAnimTurnInPlace_Player*>           PlayerNodes;                                              // 0x0188(0x0010) (NeedCtorLink)
	float                                              m_fIgnoredTransitionTime;                                 // 0x0198(0x0004) (Edit)
	float                                              m_fTurnInterpTime;                                        // 0x019C(0x0004) (Edit)
	struct FRotator                                    m_InterpRotation;                                         // 0x01A0(0x000C)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimTurnInPlace");
		return ptr;
	}


	void STATIC_OverrideYawOffset(float Value);
};


// Class TgGame.TgAnimTurnInPlace_Player
// 0x0010 (0x01BC - 0x01AC)
class UTgAnimTurnInPlace_Player : public UAnimNodeSequence
{
public:
	TArray<struct FTIP_Transition>                     TIP_Transitions;                                          // 0x01AC(0x0010) (Edit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimTurnInPlace_Player");
		return ptr;
	}

};


// Class TgGame.TgAnimTurnInPlace_Rotator
// 0x001B (0x012C - 0x0111)
class UTgAnimTurnInPlace_Rotator : public UAnimNodeBlendBase
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0111(0x0003) MISSED OFFSET
	TArray<class UTgAnimTurnInPlace*>                  c_TurnInPlaceNodes;                                       // 0x0114(0x0010) (Const, NeedCtorLink)
	class ATgPawn*                                     m_TgPawn;                                                 // 0x0124(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimTurnInPlace_Rotator");
		return ptr;
	}

};


// Class TgGame.TgSkelCon_CCD_IK_FootPlacement
// 0x0064 (0x0134 - 0x00D0)
class UTgSkelCon_CCD_IK_FootPlacement : public USkelControlBase
{
public:
	int                                                NumBones;                                                 // 0x00D0(0x0004) (Edit)
	int                                                MaxPerBoneIterations;                                     // 0x00D4(0x0004) (Edit)
	int                                                IterationsCount;                                          // 0x00D8(0x0004) (Const)
	float                                              Precision;                                                // 0x00DC(0x0004) (Edit)
	unsigned long                                      bStartFromTail : 1;                                       // 0x00E0(0x0004) (Edit)
	unsigned long                                      bNoTurnOptimization : 1;                                  // 0x00E0(0x0004) (Edit)
	unsigned long                                      bAllowStretching : 1;                                     // 0x00E0(0x0004) (Edit)
	unsigned long                                      bInvertFootUpAxis : 1;                                    // 0x00E0(0x0004) (Edit)
	unsigned long                                      bOrientFootToGround : 1;                                  // 0x00E0(0x0004) (Edit)
	unsigned long                                      bOnlyEnableForUpAdjustment : 1;                           // 0x00E0(0x0004) (Edit)
	unsigned long                                      m_bUseCachedFootOffset : 1;                               // 0x00E0(0x0004)
	TArray<struct FJointConstraintInformation>         JointConstraints;                                         // 0x00E4(0x0010) (Edit, Const, NeedCtorLink)
	float                                              MaxAngleSteps;                                            // 0x00F4(0x0004) (Edit)
	float                                              MaxStretchSteps;                                          // 0x00F8(0x0004) (Edit)
	float                                              FootOffset;                                               // 0x00FC(0x0004) (Edit)
	TEnumAsByte<EAxis>                                 FootUpAxis;                                               // 0x0100(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0101(0x0003) MISSED OFFSET
	struct FRotator                                    FootRotOffset;                                            // 0x0104(0x000C) (Edit)
	float                                              MaxUpAdjustment;                                          // 0x0110(0x0004) (Edit)
	float                                              MaxDownAdjustment;                                        // 0x0114(0x0004) (Edit)
	float                                              MaxFootOrientAdjust;                                      // 0x0118(0x0004) (Edit)
	struct FVector                                     EffectorLocation;                                         // 0x011C(0x000C)
	struct FVector                                     m_vCachedFootOffset;                                      // 0x0128(0x000C)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkelCon_CCD_IK_FootPlacement");
		return ptr;
	}

};


// Class TgGame.TgSkelCon_ClockworkSpinner
// 0x0044 (0x0144 - 0x0100)
class UTgSkelCon_ClockworkSpinner : public USkelControlSingleBone
{
public:
	float                                              m_fInterpTime;                                            // 0x0100(0x0004) (Edit)
	float                                              m_fRemainingInterpTime;                                   // 0x0104(0x0004)
	float                                              m_fPauseTime;                                             // 0x0108(0x0004) (Edit)
	float                                              m_fRemainingPauseTime;                                    // 0x010C(0x0004)
	TEnumAsByte<EAxis>                                 RotationAxis;                                             // 0x0110(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0111(0x0003) MISSED OFFSET
	int                                                DeltaRotation;                                            // 0x0114(0x0004)
	float                                              m_fInterpRotation;                                        // 0x0118(0x0004) (Edit)
	unsigned long                                      bLimitedRotation : 1;                                     // 0x011C(0x0004) (Edit)
	unsigned long                                      bForward : 1;                                             // 0x011C(0x0004)
	unsigned long                                      m_bResetRotationOnZeroStrength : 1;                       // 0x011C(0x0004) (Edit)
	float                                              m_fRotationMin;                                           // 0x0120(0x0004) (Edit)
	float                                              m_fRotationMax;                                           // 0x0124(0x0004) (Edit)
	float                                              m_fResetInterpTime;                                       // 0x0128(0x0004) (Edit)
	float                                              m_fResetPauseTime;                                        // 0x012C(0x0004) (Edit)
	float                                              m_fResetRotation;                                         // 0x0130(0x0004) (Edit)
	float                                              m_fRotatorMin;                                            // 0x0134(0x0004)
	float                                              m_fRotatorMax;                                            // 0x0138(0x0004)
	float                                              RotationsPerSecond;                                       // 0x013C(0x0004)
	float                                              ResetRotationsPerSecond;                                  // 0x0140(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkelCon_ClockworkSpinner");
		return ptr;
	}

};


// Class TgGame.TgSkelCon_FootPlacement
// 0x0004 (0x0160 - 0x015C)
class UTgSkelCon_FootPlacement : public USkelControlFootPlacement
{
public:
	unsigned long                                      bShouldUseWorldDown : 1;                                  // 0x015C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkelCon_FootPlacement");
		return ptr;
	}

};


// Class TgGame.TgSkelCon_Gate
// 0x0010 (0x00E0 - 0x00D0)
class UTgSkelCon_Gate : public USkelControlBase
{
public:
	TArray<struct FSkelControlGateChild>               ChildControls;                                            // 0x00D0(0x0010) (Edit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkelCon_Gate");
		return ptr;
	}

};


// Class TgGame.TgSkelCon_HitReaction
// 0x03A8 (0x0510 - 0x0168)
class UTgSkelCon_HitReaction : public UGameSkelCtrl_Recoil
{
public:
	TEnumAsByte<ERecoilHitDir>                         m_CurrentRecoilDir;                                       // 0x0168(0x0001) (Edit)
	TEnumAsByte<EHitReactionMoveType>                  m_MoveType;                                               // 0x0169(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x2];                                       // 0x016A(0x0002) MISSED OFFSET
	struct FRecoilInfo                                 m_RecoilFromFront;                                        // 0x016C(0x00E0) (Edit)
	struct FRecoilInfo                                 m_RecoilFromBack;                                         // 0x024C(0x00E0) (Edit)
	struct FRecoilInfo                                 m_RecoilFromLeft;                                         // 0x032C(0x00E0) (Edit)
	struct FRecoilInfo                                 m_RecoilFromRight;                                        // 0x040C(0x00E0) (Edit)
	TArray<struct FName>                               m_SlaveSkelControlNames;                                  // 0x04EC(0x0010) (Edit, NeedCtorLink)
	TArray<class USkelControlBase*>                    m_SlaveSkelControls;                                      // 0x04FC(0x0010) (Transient, NeedCtorLink)
	unsigned long                                      m_bInitialized : 1;                                       // 0x050C(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkelCon_HitReaction");
		return ptr;
	}


	struct FRecoilDef STATIC_GenRecoil(const struct FRecoilInfo& RecoilParam);
	struct FVector VRandRange(const struct FVector& v1, const struct FVector& v2);
	void STATIC_SetRecoilParam();
	void SetRecoilDir(TEnumAsByte<ERecoilHitDir> NewDir);
};


// Class TgGame.TgSkelCon_Limb
// 0x0008 (0x0134 - 0x012C)
class UTgSkelCon_Limb : public USkelControlLimb
{
public:
	class ATgPawn*                                     m_PawnOwner;                                              // 0x012C(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkelCon_Limb");
		return ptr;
	}

};


// Class TgGame.TgSkelCon_LookAt
// 0x000C (0x0178 - 0x016C)
class UTgSkelCon_LookAt : public USkelControlLookAt
{
public:
	class ATgPawn*                                     m_Owner;                                                  // 0x016C(0x0008)
	unsigned long                                      m_bAimAtEnemyTarget : 1;                                  // 0x0174(0x0004) (Edit)
	unsigned long                                      m_AlwaysInterpolateTarget : 1;                            // 0x0174(0x0004) (Edit)
	unsigned long                                      m_bHadTargetLastTick : 1;                                 // 0x0174(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkelCon_LookAt");
		return ptr;
	}

};


// Class TgGame.TgSkelCon_OscillateBoneScale
// 0x0010 (0x0110 - 0x0100)
class UTgSkelCon_OscillateBoneScale : public USkelControlSingleBone
{
public:
	float                                              OscillationAmplitude;                                     // 0x0100(0x0004) (Edit)
	float                                              OscillationFrequency;                                     // 0x0104(0x0004) (Edit)
	float                                              OscillationBaseScale;                                     // 0x0108(0x0004) (Edit)
	float                                              Theta;                                                    // 0x010C(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkelCon_OscillateBoneScale");
		return ptr;
	}

};


// Class TgGame.TgSkelCon_OscillateRotation
// 0x0024 (0x0124 - 0x0100)
class UTgSkelCon_OscillateRotation : public USkelControlSingleBone
{
public:
	float                                              OscillationAmplitude;                                     // 0x0100(0x0004) (Edit)
	float                                              OscillationFrequency;                                     // 0x0104(0x0004) (Edit)
	struct FVector                                     OscillationAxis;                                          // 0x0108(0x000C) (Edit)
	TEnumAsByte<EBoneControlSpace>                     OscillationAxisSpace;                                     // 0x0114(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0115(0x0003) MISSED OFFSET
	struct FName                                       OscillationAxisSpaceBoneName;                             // 0x0118(0x0008) (Edit)
	float                                              Theta;                                                    // 0x0120(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkelCon_OscillateRotation");
		return ptr;
	}

};


// Class TgGame.TgSkelCon_OscillateTranslation
// 0x0024 (0x0124 - 0x0100)
class UTgSkelCon_OscillateTranslation : public USkelControlSingleBone
{
public:
	float                                              OscillationAmplitude;                                     // 0x0100(0x0004) (Edit)
	float                                              OscillationFrequency;                                     // 0x0104(0x0004) (Edit)
	struct FVector                                     OscillationAxis;                                          // 0x0108(0x000C) (Edit)
	TEnumAsByte<EBoneControlSpace>                     OscillationAxisSpace;                                     // 0x0114(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0115(0x0003) MISSED OFFSET
	struct FName                                       OscillationAxisSpaceBoneName;                             // 0x0118(0x0008) (Edit)
	float                                              Theta;                                                    // 0x0120(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkelCon_OscillateTranslation");
		return ptr;
	}

};


// Class TgGame.TgSkelCon_Recoil
// 0x0014 (0x017C - 0x0168)
class UTgSkelCon_Recoil : public UGameSkelCtrl_Recoil
{
public:
	TArray<struct FRecoilProfile>                      m_Profiles;                                               // 0x0168(0x0010) (Edit, NeedCtorLink)
	int                                                m_nActiveProfileIndex;                                    // 0x0178(0x0004) (Edit, Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkelCon_Recoil");
		return ptr;
	}


	void STATIC_SetRecoilParam();
	void SetActiveProfile(const struct FName& ProfileName);
};


// Class TgGame.TgSkelCon_RotateToAim
// 0x0020 (0x0120 - 0x0100)
class UTgSkelCon_RotateToAim : public USkelControlSingleBone
{
public:
	float                                              m_fRotationSpeed;                                         // 0x0100(0x0004) (Edit)
	unsigned long                                      m_bUseConstantSpeed : 1;                                  // 0x0104(0x0004) (Edit)
	struct FRotator                                    Aim;                                                      // 0x0108(0x000C) (Edit)
	struct FRotator                                    m_rTargetRotation;                                        // 0x0114(0x000C)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkelCon_RotateToAim");
		return ptr;
	}

};


// Class TgGame.TgSkelCon_RotateToVelocity
// 0x0018 (0x0118 - 0x0100)
class UTgSkelCon_RotateToVelocity : public USkelControlSingleBone
{
public:
	float                                              m_fRotationSpeed;                                         // 0x0100(0x0004) (Edit)
	unsigned long                                      m_bUseConstantSpeed : 1;                                  // 0x0104(0x0004) (Edit)
	unsigned long                                      m_bVelocity2DOnly : 1;                                    // 0x0104(0x0004) (Edit)
	float                                              m_fMinVelocity;                                           // 0x0108(0x0004) (Edit)
	struct FRotator                                    m_rTargetRotation;                                        // 0x010C(0x000C)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkelCon_RotateToVelocity");
		return ptr;
	}

};


// Class TgGame.TgSkelCon_SkinGate
// 0x0024 (0x00F4 - 0x00D0)
class UTgSkelCon_SkinGate : public USkelControlBase
{
public:
	struct FSkelControlSkinGateChild                   DefaultChild;                                             // 0x00D0(0x0014)
	TArray<struct FSkelControlSkinGateChild>           ChildControls;                                            // 0x00E4(0x0010) (Edit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkelCon_SkinGate");
		return ptr;
	}

};


// Class TgGame.TgSkelCon_DeviceGate
// 0x0000 (0x00F4 - 0x00F4)
class UTgSkelCon_DeviceGate : public UTgSkelCon_SkinGate
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkelCon_DeviceGate");
		return ptr;
	}

};


// Class TgGame.TgSkelCon_Spinner
// 0x0088 (0x0188 - 0x0100)
class UTgSkelCon_Spinner : public USkelControlSingleBone
{
public:
	float                                              m_fDegreesPerSecond;                                      // 0x0100(0x0004) (Edit)
	struct FVector                                     m_vAxis;                                                  // 0x0104(0x000C) (Edit)
	unsigned long                                      m_PreviewStartStop : 1;                                   // 0x0110(0x0004) (Edit, Transient)
	unsigned long                                      m_bSpinDownToZero : 1;                                    // 0x0110(0x0004) (Edit)
	unsigned long                                      m_bIsSpinning : 1;                                        // 0x0110(0x0004)
	unsigned long                                      m_bSpinningUp : 1;                                        // 0x0110(0x0004)
	unsigned long                                      m_bSpinningDown : 1;                                      // 0x0110(0x0004)
	unsigned long                                      m_bRotateToTargetRotation : 1;                            // 0x0110(0x0004) (Edit)
	float                                              m_fSpinUpTime;                                            // 0x0114(0x0004) (Edit)
	float                                              m_fSpinDownTime;                                          // 0x0118(0x0004) (Edit)
	float                                              m_fCurrentDegreesPerSecond;                               // 0x011C(0x0004)
	float                                              m_fLerpTime;                                              // 0x0120(0x0004)
	struct FRotator                                    m_TargetRotation;                                         // 0x0124(0x000C) (Edit)
	float                                              m_TimeToInterpToTargetRotation;                           // 0x0130(0x0004) (Edit)
	int                                                m_nRotationSpeedState;                                    // 0x0134(0x0004) (Transient)
	TArray<float>                                      m_fRotationSpeedStateMultipliers;                         // 0x0138(0x0010) (Edit, NeedCtorLink)
	TArray<struct FScriptDelegate>                     m_OnSpinUpFinishedCallbacks;                              // 0x0148(0x0010) (Transient, NeedCtorLink)
	TArray<struct FScriptDelegate>                     m_OnSpinDownFinishedCallbacks;                            // 0x0158(0x0010) (Transient, NeedCtorLink)
	struct FScriptDelegate                             __OnSpinUpFinishedEvent__Delegate;                        // 0x0168(0x000C) (NeedCtorLink)
	unsigned char                                      UnknownData00[0x4];                                       // 0x0168(0x0004) FIX WRONG TYPE SIZE OF PREVIOUS PROPERTY
	struct FScriptDelegate                             __OnSpinDownFinishedEvent__Delegate;                      // 0x0178(0x000C) (NeedCtorLink)
	unsigned char                                      UnknownData01[0x4];                                       // 0x0178(0x0004) FIX WRONG TYPE SIZE OF PREVIOUS PROPERTY

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkelCon_Spinner");
		return ptr;
	}


	void TriggerSpinDownDelegates();
	void TriggerSpinUpDelegates();
	void STATIC_OnSpinDownFinishedEvent();
	void STATIC_OnSpinUpFinishedEvent();
	void SpinToTargetRotation(const struct FRotator& TargetRotation, float Time, bool bReset);
	void Spin(bool bEnabled);
};


// Class TgGame.TgSkelCon_AstroSpinner
// 0x0008 (0x0190 - 0x0188)
class UTgSkelCon_AstroSpinner : public UTgSkelCon_Spinner
{
public:
	class ATgPawn*                                     m_PawnOwner;                                              // 0x0188(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkelCon_AstroSpinner");
		return ptr;
	}

};


// Class TgGame.TgSkelCon_RuckusSpinner
// 0x0000 (0x0188 - 0x0188)
class UTgSkelCon_RuckusSpinner : public UTgSkelCon_Spinner
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkelCon_RuckusSpinner");
		return ptr;
	}

};


// Class TgGame.TgSkelCon_Spring
// 0x002C (0x0198 - 0x016C)
class UTgSkelCon_Spring : public USkelControlLookAt
{
public:
	struct FVector                                     m_vWorldSpaceGoal;                                        // 0x016C(0x000C)
	struct FVector                                     m_vInitialWorldSpaceGoalOffset;                           // 0x0178(0x000C) (Edit)
	struct FVector                                     m_vVelocity;                                              // 0x0184(0x000C)
	float                                              m_fSpringStiffness;                                       // 0x0190(0x0004) (Edit)
	float                                              m_fSpringDamping;                                         // 0x0194(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkelCon_Spring");
		return ptr;
	}

};


// Class TgGame.TgSkelCon_WheelSpinner
// 0x0014 (0x0114 - 0x0100)
class UTgSkelCon_WheelSpinner : public USkelControlSingleBone
{
public:
	float                                              m_fWheelRadius;                                           // 0x0100(0x0004) (Edit)
	struct FVector                                     m_vAxis;                                                  // 0x0104(0x000C) (Edit)
	float                                              m_fVelocity;                                              // 0x0110(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkelCon_WheelSpinner");
		return ptr;
	}

};


// Class TgGame.TgSkelControlSingleBone
// 0x0044 (0x0144 - 0x0100)
class UTgSkelControlSingleBone : public USkelControlSingleBone
{
public:
	unsigned long                                      SnapStrengthFromAnimNodes : 1;                            // 0x0100(0x0004) (Edit)
	unsigned long                                      m_bIsWidescreen : 1;                                      // 0x0100(0x0004) (Edit, Transient)
	float                                              SnapStrengthThreshold;                                    // 0x0104(0x0004) (Edit)
	TArray<TEnumAsByte<EEmote>>                        StrengthEmoteList;                                        // 0x0108(0x0010) (Edit, NeedCtorLink)
	TArray<class UTgAnimNodeEmoteSequence*>            CachedEmoteSequences;                                     // 0x0118(0x0010) (Transient, NeedCtorLink)
	struct FVector                                     m_WidescreenBoneTranslationOffset;                        // 0x0128(0x000C) (Edit)
	struct FRotator                                    m_WidescreenBoneRotationOffset;                           // 0x0134(0x000C) (Edit)
	float                                              m_WidescreenBoneScaleOffset;                              // 0x0140(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkelControlSingleBone");
		return ptr;
	}

};


// Class TgGame.TgSkelControlSingleBone_Ammo
// 0x0020 (0x0164 - 0x0144)
class UTgSkelControlSingleBone_Ammo : public UTgSkelControlSingleBone
{
public:
	class ATgPawn*                                     m_PawnOwner;                                              // 0x0144(0x0008)
	unsigned long                                      m_bInvertStrengthFromAmmo : 1;                            // 0x014C(0x0004) (Edit)
	float                                              m_fFlatInterpolationRateDecrease;                         // 0x0150(0x0004) (Edit)
	float                                              m_fInterpolationRateDecrease;                             // 0x0154(0x0004) (Edit)
	float                                              m_fFlatInterpolationRateIncrease;                         // 0x0158(0x0004) (Edit)
	float                                              m_fInterpolationRateIncrease;                             // 0x015C(0x0004) (Edit)
	int                                                m_nMaxAmmoFallback;                                       // 0x0160(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkelControlSingleBone_Ammo");
		return ptr;
	}

};


// Class TgGame.TgSkelControlSingleBone_DisplayGroup
// 0x0014 (0x0158 - 0x0144)
class UTgSkelControlSingleBone_DisplayGroup : public UTgSkelControlSingleBone
{
public:
	TArray<struct FDisplayGroupInfo>                   DisplayGroupInfos;                                        // 0x0144(0x0010) (Edit, ExportObject, NeedCtorLink, EditInline)
	unsigned long                                      m_bPawnOwner : 1;                                         // 0x0154(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkelControlSingleBone_DisplayGroup");
		return ptr;
	}

};


// Class TgGame.TgSkelControlSingleBone_PistonBarrel
// 0x0008 (0x014C - 0x0144)
class UTgSkelControlSingleBone_PistonBarrel : public UTgSkelControlSingleBone
{
public:
	float                                              m_nDepressDistance;                                       // 0x0144(0x0004)
	float                                              m_nReturnSpeed;                                           // 0x0148(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkelControlSingleBone_PistonBarrel");
		return ptr;
	}


	void Depress();
};


// Class TgGame.TgSkelControlSingleBone_Skinned
// 0x001C (0x0160 - 0x0144)
class UTgSkelControlSingleBone_Skinned : public UTgSkelControlSingleBone
{
public:
	float                                              DefaultStrength;                                          // 0x0144(0x0004) (Edit)
	TArray<struct FSkinStrengthOverride>               SkinOverrides;                                            // 0x0148(0x0010) (Edit, ExportObject, NeedCtorLink, EditInline)
	unsigned long                                      bInitializedStrength : 1;                                 // 0x0158(0x0004)
	float                                              fSkinStrength;                                            // 0x015C(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkelControlSingleBone_Skinned");
		return ptr;
	}

};


// Class TgGame.TgSkelControlTrail
// 0x001C (0x016C - 0x0150)
class UTgSkelControlTrail : public USkelControlTrail
{
public:
	struct FVector                                     m_vMaxTranslation;                                        // 0x0150(0x000C) (Edit)
	struct FVector                                     m_vMinTranslation;                                        // 0x015C(0x000C) (Edit)
	unsigned long                                      m_bLimitTranslation : 1;                                  // 0x0168(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkelControlTrail");
		return ptr;
	}

};


// Class TgGame.TgDevice
// 0x07F0 (0x0AEC - 0x02FC)
class ATgDevice : public AWeapon
{
public:
	struct FPointer                                    VfTable_ITgGameplayCurveOwner;                            // 0x02FC(0x0008) (Const, Native, NoExport)
	int                                                r_nDeviceId;                                              // 0x0304(0x0004) (Net)
	int                                                r_nDeviceInstanceId;                                      // 0x0308(0x0004) (Net)
	int                                                r_nInstanceCount;                                         // 0x030C(0x0004) (Net)
	TEnumAsByte<ETG_EQUIP_POINT>                       r_eEquippedAt;                                            // 0x0310(0x0001) (Net)
	unsigned char                                      CurrentFireMode;                                          // 0x0311(0x0001) (Net)
	unsigned char                                      m_PendingFireMode;                                        // 0x0312(0x0001)
	TEnumAsByte<ETargetingModeStatus>                  c_eTargetingModeStatus;                                   // 0x0313(0x0001)
	unsigned char                                      m_nDesiredFireMode;                                       // 0x0314(0x0001)
	TEnumAsByte<EDeviceFailType>                       m_eCachedDeviceFailType;                                  // 0x0315(0x0001)
	TEnumAsByte<ECastMode>                             m_eCastModeOverride;                                      // 0x0316(0x0001)
	TEnumAsByte<EReticuleType>                         m_ReticuleType;                                           // 0x0317(0x0001)
	TEnumAsByte<EReticuleType>                         m_ZoomedReticuleType;                                     // 0x0318(0x0001)
	TEnumAsByte<EDeviceEmoteAt>                        m_DeviceEmoteAt;                                          // 0x0319(0x0001)
	TEnumAsByte<EDeviceTimerBarType>                   m_DeviceTimerBarType;                                     // 0x031A(0x0001)
	TEnumAsByte<ETG_EQUIP_POINT>                       m_AmmoEquipPoint;                                         // 0x031B(0x0001)
	TEnumAsByte<EZoomState>                            m_ZoomState;                                              // 0x031C(0x0001)
	TEnumAsByte<ESCOPETYPE>                            m_eScopeType;                                             // 0x031D(0x0001)
	TEnumAsByte<EDeviceSubtype>                        m_eDeviceSubtype;                                         // 0x031E(0x0001)
	TEnumAsByte<EeMovementType>                        m_eMovementType;                                          // 0x031F(0x0001)
	TEnumAsByte<EDeviceAltFireType>                    m_eAltFireType;                                           // 0x0320(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0321(0x0003) MISSED OFFSET
	int                                                r_nPointsAllocated;                                       // 0x0324(0x0004) (Net)
	unsigned long                                      m_bSocketMaxCalculated : 1;                               // 0x0328(0x0004)
	unsigned long                                      r_bParentDeviceOwnedByOffhand : 1;                        // 0x0328(0x0004) (Net)
	unsigned long                                      bPendingFire : 1;                                         // 0x0328(0x0004)
	unsigned long                                      m_IsPendingSetFireMode : 1;                               // 0x0328(0x0004)
	unsigned long                                      m_bEquipEffectsApplied : 1;                               // 0x0328(0x0004)
	unsigned long                                      m_CachedMissedInstantFire : 1;                            // 0x0328(0x0004)
	unsigned long                                      c_bUsesTargetingReticle : 1;                              // 0x0328(0x0004)
	unsigned long                                      r_OverrideUsesTargetingModeAsFalse : 1;                   // 0x0328(0x0004) (Net)
	unsigned long                                      s_bIgnoreReceivedAim : 1;                                 // 0x0328(0x0004)
	unsigned long                                      m_bHandDevice : 1;                                        // 0x0328(0x0004)
	unsigned long                                      m_bProcAsIfHandDevice : 1;                                // 0x0328(0x0004)
	unsigned long                                      m_bLockInputDuringFire : 1;                               // 0x0328(0x0004)
	unsigned long                                      m_bLockCameraDuringFire : 1;                              // 0x0328(0x0004)
	unsigned long                                      m_bShouldCacheAim : 1;                                    // 0x0328(0x0004)
	unsigned long                                      r_bConsumedOnUse : 1;                                     // 0x0328(0x0004) (Net)
	unsigned long                                      r_bConsumedOnDeath : 1;                                   // 0x0328(0x0004) (Net)
	unsigned long                                      m_bCachedDeviceCanFire : 1;                               // 0x0328(0x0004)
	unsigned long                                      m_bCarryPreFireToPostFire : 1;                            // 0x0328(0x0004)
	unsigned long                                      m_bIsSecondaryFire : 1;                                   // 0x0328(0x0004)
	unsigned long                                      m_bIgnoreSecondaryFireLogic : 1;                          // 0x0328(0x0004)
	unsigned long                                      m_bConsumePowerPoolOnStartFire : 1;                       // 0x0328(0x0004)
	unsigned long                                      m_bAlwaysStartCooldown : 1;                               // 0x0328(0x0004)
	unsigned long                                      m_bInTargetingMode : 1;                                   // 0x0328(0x0004)
	unsigned long                                      m_IsBeingInterrupted : 1;                                 // 0x0328(0x0004)
	unsigned long                                      c_bServerFireFailed : 1;                                  // 0x0328(0x0004)
	unsigned long                                      HasAlreadyFiredOnce : 1;                                  // 0x0328(0x0004)
	unsigned long                                      m_bAllowADSWhileFiring : 1;                               // 0x0328(0x0004)
	unsigned long                                      m_bAllowADSToBeInterrupted : 1;                           // 0x0328(0x0004)
	unsigned long                                      m_bAllowWeaponSwappingWhileFiring : 1;                    // 0x0328(0x0004)
	unsigned long                                      m_bBuildupShouldInterruptStealth : 1;                     // 0x0328(0x0004)
	unsigned long                                      m_bPreFireShouldInterruptStealth : 1;                     // 0x0328(0x0004)
	unsigned long                                      m_bFireShouldInterruptStealth : 1;                        // 0x0328(0x0004)
	unsigned long                                      m_bPostFireShouldInterruptStealth : 1;                    // 0x032C(0x0004)
	unsigned long                                      m_bReloadingShouldInterruptStealth : 1;                   // 0x032C(0x0004)
	unsigned long                                      m_bCancelingShouldInterruptStealth : 1;                   // 0x032C(0x0004)
	unsigned long                                      m_bStartFireShouldEnterCombat : 1;                        // 0x032C(0x0004)
	unsigned long                                      m_bFireShouldEnterCombat : 1;                             // 0x032C(0x0004)
	unsigned long                                      m_bShouldUseInstigatorsTimeDilation : 1;                  // 0x032C(0x0004)
	unsigned long                                      m_bIsADS : 1;                                             // 0x032C(0x0004)
	unsigned long                                      m_bDamages : 1;                                           // 0x032C(0x0004)
	unsigned long                                      m_bStuns : 1;                                             // 0x032C(0x0004)
	unsigned long                                      m_bProjectileFollowOwnerYaw : 1;                          // 0x032C(0x0004)
	unsigned long                                      m_bAimThroughReticule : 1;                                // 0x032C(0x0004)
	unsigned long                                      m_bNoReticleBloom : 1;                                    // 0x032C(0x0004)
	unsigned long                                      m_bUseCustomCastMode : 1;                                 // 0x032C(0x0004)
	unsigned long                                      m_bIgnoredByBots : 1;                                     // 0x032C(0x0004)
	unsigned long                                      m_bUsesBurstFire : 1;                                     // 0x032C(0x0004)
	unsigned long                                      m_bIsFirstBurstShot : 1;                                  // 0x032C(0x0004)
	unsigned long                                      m_bOnlyFirstBurstCostsAmmo : 1;                           // 0x032C(0x0004)
	unsigned long                                      m_bBurstCanBeInterrupted : 1;                             // 0x032C(0x0004)
	unsigned long                                      m_bCanEndBurstEarly : 1;                                  // 0x032C(0x0004)
	unsigned long                                      c_bBurstPendingStopFire : 1;                              // 0x032C(0x0004)
	unsigned long                                      s_bInBurstRecovery : 1;                                   // 0x032C(0x0004)
	unsigned long                                      s_bIsStartingBurstFire : 1;                               // 0x032C(0x0004)
	unsigned long                                      m_bCanRegenAmmoWhileFiring : 1;                           // 0x032C(0x0004)
	unsigned long                                      m_bUsesSimulatedAmmo : 1;                                 // 0x032C(0x0004)
	unsigned long                                      m_bCanReloadEarly : 1;                                    // 0x032C(0x0004)
	unsigned long                                      m_bForce1pViewWhileFiring : 1;                            // 0x032C(0x0004)
	unsigned long                                      m_bForce3PViewWhileFiring : 1;                            // 0x032C(0x0004)
	unsigned long                                      m_bUseDefaultOffsetWhileIn3p : 1;                         // 0x032C(0x0004)
	unsigned long                                      m_bCanCancelWithJump : 1;                                 // 0x032C(0x0004)
	unsigned long                                      m_bEnterCombatOnFire : 1;                                 // 0x032C(0x0004)
	unsigned long                                      m_bDeployAtFeetOnFailure : 1;                             // 0x032C(0x0004) (Edit)
	unsigned long                                      m_bMustBeOnGroundToFire : 1;                              // 0x032C(0x0004)
	unsigned long                                      m_bHideTargeterWhenInvalid : 1;                           // 0x0330(0x0004)
	unsigned long                                      m_bParentAnimComponentHands : 1;                          // 0x0330(0x0004)
	unsigned long                                      m_bParentAnimComponent1PHead : 1;                         // 0x0330(0x0004)
	unsigned long                                      m_bAmmoWasGiven : 1;                                      // 0x0330(0x0004)
	unsigned long                                      m_bFirstAmmoWasGiven : 1;                                 // 0x0330(0x0004)
	unsigned long                                      m_bCooldownWasModified : 1;                               // 0x0330(0x0004)
	unsigned long                                      m_bDisableLagCompensation : 1;                            // 0x0330(0x0004)
	unsigned long                                      m_bUseSeparateVerticalFrictionKeyframes : 1;              // 0x0330(0x0004)
	unsigned long                                      m_bUseRangeFalloffCurve : 1;                              // 0x0330(0x0004)
	unsigned long                                      m_bUseDeviceMeshWhenTargeting : 1;                        // 0x0330(0x0004)
	unsigned long                                      m_bPlayPutAway : 1;                                       // 0x0330(0x0004)
	unsigned long                                      m_bCanToggleTargeting : 1;                                // 0x0330(0x0004)
	unsigned long                                      m_bDoNotAllowHeadShots : 1;                               // 0x0330(0x0004) (Const)
	unsigned long                                      m_bConsolidateMultipleShots : 1;                          // 0x0330(0x0004) (Const)
	unsigned long                                      m_bAllowFiringDuring3pTo1pTransition : 1;                 // 0x0330(0x0004)
	unsigned long                                      s_bLockFiringForRoundEnd : 1;                             // 0x0330(0x0004)
	unsigned long                                      m_bPreventInterrupt : 1;                                  // 0x0330(0x0004)
	unsigned long                                      m_bPreventCancel : 1;                                     // 0x0330(0x0004)
	unsigned long                                      m_bLogServerFireFailures : 1;                             // 0x0330(0x0004)
	unsigned long                                      m_bUsesOutroLockout : 1;                                  // 0x0330(0x0004)
	unsigned long                                      m_bIsFireHoldDevice : 1;                                  // 0x0330(0x0004)
	unsigned long                                      m_bForceReleaseFireHoldWhenCharged : 1;                   // 0x0330(0x0004)
	unsigned long                                      m_bFireHoldFull : 1;                                      // 0x0330(0x0004)
	unsigned long                                      m_bMustFullyHoldToFire : 1;                               // 0x0330(0x0004)
	unsigned long                                      m_DeviceTimerBarCountsUp : 1;                             // 0x0330(0x0004)
	unsigned long                                      m_bCooldownAfterDeployDeath : 1;                          // 0x0330(0x0004)
	unsigned long                                      m_bPostSprintFire : 1;                                    // 0x0330(0x0004)
	unsigned long                                      m_bCanZoom : 1;                                           // 0x0330(0x0004)
	unsigned long                                      m_bPendingZoom : 1;                                       // 0x0330(0x0004)
	unsigned long                                      m_bFullScreenScope : 1;                                   // 0x0330(0x0004)
	unsigned long                                      m_bUsesLoopingAnim : 1;                                   // 0x0330(0x0004)
	unsigned long                                      m_bCanPlayFireAnim : 1;                                   // 0x0330(0x0004)
	unsigned long                                      m_bRightHandThrow : 1;                                    // 0x0334(0x0004)
	unsigned long                                      m_bDisableTgSkelConLimbs : 1;                             // 0x0334(0x0004)
	unsigned long                                      m_bSkipGenerateNewSeed : 1;                               // 0x0334(0x0004)
	unsigned long                                      m_bAllowCrouchDuringFire : 1;                             // 0x0334(0x0004)
	unsigned long                                      m_bUncrouchBeforeFiring : 1;                              // 0x0334(0x0004)
	unsigned long                                      m_bSlowWhileInADS : 1;                                    // 0x0334(0x0004)
	int                                                m_nSocketIndex;                                           // 0x0338(0x0004)
	int                                                m_nSocketMax;                                             // 0x033C(0x0004)
	class ATgDevice*                                   s_ParentDevice;                                           // 0x0340(0x0008)
	TArray<class UTgDeviceFire*>                       m_FireMode;                                               // 0x0348(0x0010) (NeedCtorLink)
	int                                                r_nMeleeComboSeed;                                        // 0x0358(0x0004) (Net)
	class UTgDeviceForm*                               c_DeviceForm;                                             // 0x035C(0x0008)
	class UTgTimerManager*                             m_CooldownTimers;                                         // 0x0364(0x0008)
	TArray<struct FImpactInfo>                         PendingImpactList;                                        // 0x036C(0x0010) (Component, NeedCtorLink)
	struct FAimData                                    c_TargetingAim;                                           // 0x037C(0x0034)
	struct FAimData                                    m_CachedAim;                                              // 0x03B0(0x0034)
	float                                              m_fCachedFirePostHitDelay;                                // 0x03E4(0x0004)
	int                                                m_CachedFireRequestId;                                    // 0x03E8(0x0004)
	float                                              m_fCachedAttackSpeedPercChange;                           // 0x03EC(0x0004)
	struct FAimData                                    s_ReceivedAim;                                            // 0x03F0(0x0034)
	struct FPointer                                    m_pwzDeviceName;                                          // 0x0424(0x0008) (Native)
	int                                                m_nDeviceType;                                            // 0x042C(0x0004)
	float                                              EquipTime;                                                // 0x0430(0x0004)
	class UTgInventoryObject_Device*                   s_InventoryObject;                                        // 0x0434(0x0008)
	int                                                m_nSkillId;                                               // 0x043C(0x0004)
	int                                                r_nInventoryId;                                           // 0x0440(0x0004) (Net)
	int                                                m_nDeviceSubtype;                                         // 0x0444(0x0004)
	float                                              m_fLastDeviceCanFireTimeStamp;                            // 0x0448(0x0004)
	float                                              m_EndOfLastFireTimeStamp;                                 // 0x044C(0x0004)
	float                                              m_fFiringTimer;                                           // 0x0450(0x0004)
	float                                              m_fTimeAccountedFor;                                      // 0x0454(0x0004)
	float                                              m_fTimeStampAccountedFor;                                 // 0x0458(0x0004)
	float                                              m_IndividualOffhandCooldownTime;                          // 0x045C(0x0004)
	float                                              m_fTotalReloadTime;                                       // 0x0460(0x0004)
	float                                              r_fCooldownDelay;                                         // 0x0464(0x0004) (Net)
	float                                              c_fCachedManaAtStartFire;                                 // 0x0468(0x0004)
	class UTgDeviceFire*                               m_WhileFiringDeviceMode;                                  // 0x046C(0x0008)
	float                                              m_fCurrentTransitionPct;                                  // 0x0474(0x0004)
	float                                              m_fUnequipTime;                                           // 0x0478(0x0004)
	struct FVector                                     m_vMeshViewOffset;                                        // 0x047C(0x000C)
	float                                              m_fWeaponBob;                                             // 0x0488(0x0004)
	float                                              m_fMeshFOV;                                               // 0x048C(0x0004)
	struct FVector                                     m_vProjectileSpawnOffset;                                 // 0x0490(0x000C) (Edit)
	struct FVector                                     m_vADSProjectileSpawnOffset;                              // 0x049C(0x000C) (Edit)
	struct FVector                                     m_vCrouchProjectileSpawnOffset;                           // 0x04A8(0x000C) (Edit)
	struct FVector                                     m_vADSCrouchProjectileSpawnOffset;                        // 0x04B4(0x000C) (Edit)
	int                                                m_nBurstTotalShots;                                       // 0x04C0(0x0004)
	int                                                m_nBurstShotsRemaining;                                   // 0x04C4(0x0004)
	int                                                m_nFireLoopInstanceId;                                    // 0x04C8(0x0004)
	struct FAmmoCount                                  r_nAmmoCount;                                             // 0x04CC(0x0004) (Net)
	int                                                r_nCarriedAmmoCount;                                      // 0x04D0(0x0004) (Net)
	struct FAmmoCount                                  c_nSimLocalAmmoCount;                                     // 0x04D4(0x0004)
	int                                                r_nMaxAmmoClipCount;                                      // 0x04D8(0x0004) (Net)
	int                                                r_nMaxAmmoCarriedCount;                                   // 0x04DC(0x0004) (Net)
	int                                                r_nAmmoEfficiency;                                        // 0x04E0(0x0004) (Net)
	TArray<struct FAmmoTransaction>                    m_AmmoTransactions;                                       // 0x04E4(0x0010) (NeedCtorLink)
	TArray<struct FAmmoTransaction>                    m_DelayedAmmoTransactions;                                // 0x04F4(0x0010) (NeedCtorLink)
	TArray<struct FAmmoTransaction>                    s_RecievedUnverifiedDelayedAmmoTransactions;              // 0x0504(0x0010) (NeedCtorLink)
	TArray<struct FAmmoTransaction>                    m_DelayedAmmoTransactionRegen;                            // 0x0514(0x0010) (NeedCtorLink)
	int                                                m_nPendingRegenAmmoTransactionID;                         // 0x0524(0x0004)
	int                                                m_nPendingReloadAmmoTransactionID;                        // 0x0528(0x0004)
	struct FTrackedFiringAmmoConsumption               c_EligableRefundFiringIDs[0x1E];                          // 0x052C(0x0008)
	int                                                c_nEligableRefundFiringIDsIndexLast;                      // 0x061C(0x0004)
	int                                                c_nEligableRefundFiringIDsIndexFirst;                     // 0x0620(0x0004)
	int                                                m_nLastFiringIDToConsumeAmmo;                             // 0x0624(0x0004)
	int                                                m_UniqueAmmoValidationId;                                 // 0x0628(0x0004)
	float                                              m_fAmmoRegenPerSec;                                       // 0x062C(0x0004)
	float                                              m_fAmmoRegenCounter;                                      // 0x0630(0x0004)
	TArray<class ATgProjectile*>                       m_FiredProjectiles;                                       // 0x0634(0x0010) (NeedCtorLink)
	float                                              m_fForce3PPersistDuration;                                // 0x0644(0x0004)
	float                                              m_fForce3PPersistTimer;                                   // 0x0648(0x0004)
	float                                              m_fEnterCombatDuration;                                   // 0x064C(0x0004)
	class ATgDeployable*                               r_Deployable;                                             // 0x0650(0x0008) (Net)
	int                                                r_nProjectiles;                                           // 0x0658(0x0004) (Net)
	float                                              m_fDeployZForgiveness;                                    // 0x065C(0x0004) (Edit)
	float                                              m_fBottomlessPitCheck;                                    // 0x0660(0x0004)
	float                                              m_fDeployZOffset;                                         // 0x0664(0x0004) (Edit)
	TArray<int>                                        m_Abilities;                                              // 0x0668(0x0010) (NeedCtorLink)
	int                                                m_DisplayIcon;                                            // 0x0678(0x0004)
	struct FString                                     m_DisplayName;                                            // 0x067C(0x0010) (NeedCtorLink)
	float                                              m_fOnGroundAltitudeThreshold;                             // 0x068C(0x0004)
	class ATgDevice*                                   m_PrimaryWeaponParent;                                    // 0x0690(0x0008)
	class UClass*                                      m_WeaponMeshActorClass;                                   // 0x0698(0x0008) (Edit)
	class AActor*                                      m_LastKnownHitActor;                                      // 0x06A0(0x0008)
	TArray<struct FScriptDelegate>                     m_OnFiredDelegates;                                       // 0x06A8(0x0010) (NeedCtorLink)
	TArray<struct FScriptDelegate>                     m_OnReloadDelegates;                                      // 0x06B8(0x0010) (NeedCtorLink)
	TArray<struct FScriptDelegate>                     m_OnStartFireDelegates;                                   // 0x06C8(0x0010) (NeedCtorLink)
	TArray<struct FScriptDelegate>                     m_OnStopFireDelegates;                                    // 0x06D8(0x0010) (NeedCtorLink)
	TArray<struct FScriptDelegate>                     m_Generic1Delegates;                                      // 0x06E8(0x0010) (NeedCtorLink)
	TArray<struct FScriptDelegate>                     m_Generic2Delegates;                                      // 0x06F8(0x0010) (NeedCtorLink)
	TArray<struct FScriptDelegate>                     m_Generic3Delegates;                                      // 0x0708(0x0010) (NeedCtorLink)
	TArray<int>                                        m_nLinkedDeviceIDs;                                       // 0x0718(0x0010) (NeedCtorLink)
	TArray<int>                                        m_nLinkedDeviceTypes;                                     // 0x0728(0x0010) (NeedCtorLink)
	TArray<struct FTgQueuedSimulatedProjectileSpawn>   c_QueuedSimulatedProjectileSpawns;                        // 0x0738(0x0010) (NeedCtorLink)
	TArray<struct FTgQueuedSimulatedProjectileSpawn>   s_QueuedProjectileSpawnsFromServer;                       // 0x0748(0x0010) (NeedCtorLink)
	TArray<struct FTgQueuedSimulatedProjectileSpawn>   s_QueuedProjectileSpawnsFromClient;                       // 0x0758(0x0010) (NeedCtorLink)
	TArray<struct FTgQueuedProjectileExplosion>        s_QueuedProjectileExplosions;                             // 0x0768(0x0010) (NeedCtorLink)
	int                                                s_nNumServerRefires;                                      // 0x0778(0x0004)
	int                                                s_nNumClientRefires;                                      // 0x077C(0x0004)
	TArray<struct FTgQueuedRefire>                     s_QueuedRefireRequests;                                   // 0x0780(0x0010) (NeedCtorLink)
	TArray<struct FTgQueuedInstantFireShot>            s_QueuedInstantFireShotsFromServer;                       // 0x0790(0x0010) (Component, NeedCtorLink)
	TArray<struct FTgQueuedInstantFireShot>            s_QueuedInstantFireShotsFromClient;                       // 0x07A0(0x0010) (Component, NeedCtorLink)
	struct FPointer                                    m_RandomShotSpreadStream;                                 // 0x07B0(0x0008) (Const, Native, Transient)
	int                                                m_nLastSetShotSpreadSeed;                                 // 0x07B8(0x0004)
	struct FVector2D                                   m_AimAssistMagnetScale;                                   // 0x07BC(0x0008)
	struct FVector2D                                   m_AimAssistFrictionScale;                                 // 0x07C4(0x0008)
	struct FVector2D                                   m_AimAssistTrackingScale;                                 // 0x07CC(0x0008)
	struct FVector2D                                   m_AimAssistLockScale;                                     // 0x07D4(0x0008)
	float                                              m_fBulletMagnetismStrengthMultiplier;                     // 0x07DC(0x0004)
	TArray<struct FAimAssistKeyframeData>              m_AimAssistKeyframesMagnetVert;                           // 0x07E0(0x0010) (NeedCtorLink)
	TArray<struct FAimAssistKeyframeData>              m_AimAssistKeyframesMagnetHoriz;                          // 0x07F0(0x0010) (NeedCtorLink)
	TArray<struct FAimAssistKeyframeData>              m_AimAssistKeyframesFriction;                             // 0x0800(0x0010) (NeedCtorLink)
	TArray<struct FAimAssistKeyframeData>              m_AimAssistKeyframesTrackingAccHoriz;                     // 0x0810(0x0010) (NeedCtorLink)
	TArray<struct FAimAssistKeyframeData>              m_AimAssistKeyframesTrackingAngleHoriz;                   // 0x0820(0x0010) (NeedCtorLink)
	TArray<struct FAimAssistKeyframeData>              m_AimAssistKeyframesTrackingAccVert;                      // 0x0830(0x0010) (NeedCtorLink)
	TArray<struct FAimAssistKeyframeData>              m_AimAssistKeyframesTrackingAngleVert;                    // 0x0840(0x0010) (NeedCtorLink)
	TArray<struct FAimAssistKeyframeData>              m_AimAssistKeyframesFrictionVert;                         // 0x0850(0x0010) (NeedCtorLink)
	TArray<class ATgDevice*>                           m_GameplayCurveOverrideDevices;                           // 0x0860(0x0010) (NeedCtorLink)
	int                                                m_nServerControlledShotSpreadSeed;                        // 0x0870(0x0004)
	float                                              m_fOutroLockoutTime;                                      // 0x0874(0x0004)
	float                                              m_fMinTimeBetweenAmmoCharges;                             // 0x0878(0x0004) (Edit)
	TArray<class UForceFeedbackWaveform*>              m_ForceFeedbackStartHold;                                 // 0x087C(0x0010) (Edit, NeedCtorLink)
	TArray<class UForceFeedbackWaveform*>              m_ForceFeedbackFullHold;                                  // 0x088C(0x0010) (Edit, NeedCtorLink)
	TArray<class UForceFeedbackWaveform*>              m_ForceFeedbackStopHold;                                  // 0x089C(0x0010) (Edit, NeedCtorLink)
	TArray<class UForceFeedbackWaveform*>              m_ForceFeedbackStartFire;                                 // 0x08AC(0x0010) (Edit, NeedCtorLink)
	TArray<class UForceFeedbackWaveform*>              m_ForceFeedbackStartFireLoop;                             // 0x08BC(0x0010) (Edit, NeedCtorLink)
	TArray<class UForceFeedbackWaveform*>              m_ForceFeedbackStopFire;                                  // 0x08CC(0x0010) (Edit, NeedCtorLink)
	TArray<class UForceFeedbackWaveform*>              m_ForceFeedbackStartBuildup;                              // 0x08DC(0x0010) (Edit, NeedCtorLink)
	TArray<class UForceFeedbackWaveform*>              m_ForceFeedbackStopBuildup;                               // 0x08EC(0x0010) (Edit, NeedCtorLink)
	TArray<class UForceFeedbackWaveform*>              m_ForceFeedbackPostFire;                                  // 0x08FC(0x0010) (Edit, NeedCtorLink)
	TArray<class UForceFeedbackWaveform*>              m_ForceFeedbackStartReload;                               // 0x090C(0x0010) (Edit, NeedCtorLink)
	TArray<class UForceFeedbackWaveform*>              m_ForceFeedbackStopReload;                                // 0x091C(0x0010) (Edit, NeedCtorLink)
	TArray<class UForceFeedbackWaveform*>              m_ForceFeedbackStartCooldown;                             // 0x092C(0x0010) (Edit, NeedCtorLink)
	float                                              s_fForceReleaseFirHoldFUBARTime;                          // 0x093C(0x0004)
	int                                                s_nLastRequestedFireHoldReleaseID;                        // 0x0940(0x0004)
	struct FAccuracySettings                           m_AccuracySettings[0x5];                                  // 0x0944(0x001C) (Edit)
	float                                              m_fCurrentAdvancedAccuracy;                               // 0x09D0(0x0004)
	float                                              m_fLastShotTimestamp;                                     // 0x09D4(0x0004)
	int                                                m_nFreeShotsLeft;                                         // 0x09D8(0x0004)
	float                                              m_fLastMinAccuracy;                                       // 0x09DC(0x0004)
	float                                              m_fReticleBloomScale;                                     // 0x09E0(0x0004)
	struct FRecoilSettings                             m_RecoilSettings[0x5];                                    // 0x09E4(0x0010) (Edit)
	float                                              m_fStartFiringTimestamp;                                  // 0x0A34(0x0004)
	float                                              m_fAccumulatedFiringTime;                                 // 0x0A38(0x0004)
	int                                                m_nRandRecoilNum;                                         // 0x0A3C(0x0004) (Transient)
	int                                                r_nRecoilSeed;                                            // 0x0A40(0x0004) (Net, Transient)
	int                                                m_nAimAssistPriorityWhileFiring;                          // 0x0A44(0x0004)
	int                                                r_nAllowUseWhileFlags;                                    // 0x0A48(0x0004) (Net)
	float                                              m_fSprintRecoverTime;                                     // 0x0A4C(0x0004) (Edit)
	float                                              r_fAttackSpeedPercChange;                                 // 0x0A50(0x0004) (Net)
	float                                              m_fSimulatedAttackSpeedPercChange;                        // 0x0A54(0x0004)
	float                                              s_fAttackSpeedPercChangeLeniency;                         // 0x0A58(0x0004)
	TArray<struct FAttackSpeedModifier>                m_AttackSpeedModifiers;                                   // 0x0A5C(0x0010) (NeedCtorLink)
	class ATgDevice*                                   m_AmmoDevice;                                             // 0x0A6C(0x0008)
	int                                                r_nDeviceLevel;                                           // 0x0A74(0x0004) (Net)
	float                                              m_fZoomTime;                                              // 0x0A78(0x0004)
	float                                              m_fZoomOutTime;                                           // 0x0A7C(0x0004)
	float                                              m_fDesiredZoomFOV;                                        // 0x0A80(0x0004)
	float                                              m_fDesiredZoomMeshFOV;                                    // 0x0A84(0x0004)
	class UMaterialInstanceConstant*                   m_ZoomOverlayMaterial;                                    // 0x0A88(0x0008)
	struct FVector                                     m_vZoomMeshOffset;                                        // 0x0A90(0x000C)
	struct FVector                                     m_vZoomMeshOffsetWidescreen;                              // 0x0A9C(0x000C)
	float                                              m_fZoomWeaponBob;                                         // 0x0AA8(0x0004)
	int                                                m_AltFireMode;                                            // 0x0AAC(0x0004)
	float                                              m_fToggleMeshFOV;                                         // 0x0AB0(0x0004)
	float                                              m_fToggleScopeFOV;                                        // 0x0AB4(0x0004)
	struct FName                                       m_sAimOffsetProfile;                                      // 0x0AB8(0x0008)
	struct FName                                       m_sRecoilProfile;                                         // 0x0AC0(0x0008)
	float                                              m_fZCrouchProjectileOffset;                               // 0x0AC8(0x0004)
	struct FName                                       m_sSocketName;                                            // 0x0ACC(0x0008)
	class UClass*                                      m_MuzzleFlashLightClass;                                  // 0x0AD4(0x0008)
	struct FScriptDelegate                             __DeviceEvent__Delegate;                                  // 0x0ADC(0x000C) (NeedCtorLink)
	unsigned char                                      UnknownData01[0x4];                                       // 0x0ADC(0x0004) FIX WRONG TYPE SIZE OF PREVIOUS PROPERTY

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice");
		return ptr;
	}


	bool STATIC_IsInfiniteFireDevice();
	bool CanViewZoom();
	bool CanEnterCatapultEvenWhenFiring();
	bool SetPendingZoom(bool bNewPendingZoom);
	void ServerCancelReload();
	void STATIC_CancelReload();
	void STATIC_OnStartADS();
	void ServerNotifyDesiredTarget(class AActor* DesiredTarget);
	bool STATIC_IsHealthPackDevice();
	bool DeviceUsesAmmo();
	class ATgDevice* STATIC_GetAmmoDevice();
	void WeaponIsDown();
	void UnequipFast();
	bool CanAutoWeaponFireNow();
	void RecoverFromSprintTimer();
	void STATIC_OnEndSprint();
	float STATIC_GetAttackSpeedMod();
	void UpdateAttackSpeedMod(int nSourceId, float fPercChange, bool bFromServer, bool bAddPercChange, float fDuration);
	void STATIC_AddAttackSpeedMod(float fPercChange, float fDuration, bool bFromServer, int nSourceId);
	float STATIC_GetCustomTimerBarMaxTime();
	float STATIC_GetCustomTimerBarCurrentTime();
	float STATIC_GetIndividualOffhandCooldownTime();
	void STATIC_ApplyAllowUseWhileFlags(int nAllowUseWhileFlags);
	void UnregisterAsGameplayCurveOverrideDevice(class ATgDevice* Dev);
	void STATIC_RegisterAsGameplayCurveOverrideDevice(class ATgDevice* Dev);
	void UpdateOutroLockoutTime();
	bool RequireMovementForAimAssist();
	bool RequireLookForAimAssist();
	int STATIC_GetAimAssistPriority();
	void STATIC_PlayNextSimulatedForceFeedbackWaveform(class UForceFeedbackWaveform* Prev, class UForceFeedbackWaveform* Next, float fScaleMagnitude, float fScaleDuration, bool bFromPawnPosition);
	void StopSimulatedForceFeedbackWaveforms(TArray<class UForceFeedbackWaveform*> Waveforms);
	void STATIC_PlaySimulatedForceFeedbackWaveforms(TArray<class UForceFeedbackWaveform*> Waveforms, float fScaleMagnitude, float fScaleDuration, bool bFromPawnPosition);
	void StopSimulatedForceFeedbackWaveform(class UForceFeedbackWaveform* WaveForm);
	void STATIC_PlaySimulatedForceFeedbackWaveform(class UForceFeedbackWaveform* WaveForm, float fScaleMagnitude, float fScaleDuration, bool bFromPawnPosition);
	void STATIC_OnOwnerRespawn();
	bool ReleaseHoldOnRightMouseReleased();
	bool CanToggleTargetingOff();
	void ClientSetAimAssistValues(float MagnetScaleX, float MagnetScaleY, float FrictionScaleX, float FrictionScaleY, float TrackingScaleX, float TrackingScaleY);
	void DesyncAmmoTransactionID(int Amt);
	bool ShouldStopActionOnOffhandSlotReleased();
	bool STATIC_PlayHitReactionOverride();
	void STATIC_OnCanceledClient();
	void STATIC_OnCanceled();
	void STATIC_OnKnock();
	void STATIC_OnCripple();
	void STATIC_ClientDeviceFirePropertyChange(int nMode, int nPropertyId, float fNewValue);
	void STATIC_OnUnlinkDevice(class ATgPawn* TgP);
	void STATIC_OnLinkDevice(class ATgPawn* TgP);
	void STATIC_LinkedDeviceUnequipped(class ATgDevice* Dev);
	void STATIC_LinkedDeviceEquipped(class ATgDevice* Dev);
	void STATIC_NotifyDeviceEvent(TEnumAsByte<ENotifyDelegateEvents> ndeType);
	bool STATIC_UnregisterDelegate(TEnumAsByte<ENotifyDelegateEvents> ndeType, const struct FScriptDelegate& DeviceEventDelegate);
	bool RegisterDelegate(TEnumAsByte<ENotifyDelegateEvents> ndeType, const struct FScriptDelegate& DeviceEventDelegate);
	void UnequipDevice();
	bool ShouldStopWeaponSwapping();
	bool ShouldMountCancelFiring();
	struct FVector STATIC_GetProjectileSpawnOffset();
	float STATIC_GetRefireRate();
	float STATIC_GetRefirePercent();
	void STATIC_OnDeployableSpawned(class ATgDeployable* deployable);
	void STATIC_OnDeployableDestroyed(class ATgDeployable* deployable);
	void ClientInterruptReload(bool bAllowAmmoFill);
	void STATIC_InterruptReload();
	void PostReloadTimer();
	void PreReloadTimer();
	void FullReloadTimer();
	bool StartReload(bool bIgnoreCurrentAmmo);
	bool CanStartReloadNow(bool bIgnoreCurrentAmmo);
	bool CanBeCanceledByReload();
	int STATIC_GetReloadAmount();
	void ClientForceReload();
	void ServerStartReload();
	void STATIC_FlashUpdateAmmoOnPawn();
	void STATIC_ResetAmmoTransactions();
	void ServerSyncAmmoTransactionID(int nNewID);
	void ReloadAmmoWithSynchronization();
	void STATIC_ReloadAmmo(bool bToFull, bool bShouldValidate);
	void ClientSyncAmmoGivenFromServer(int Amount);
	void STATIC_GiveAmmoWithClientSync(int Amount);
	void STATIC_GiveAmmo(int Amount, bool bShouldValidate);
	void STATIC_ConsumeAmmo(int Amount, bool bShouldValidate);
	void STATIC_SetAmmo(int CarriedAmount, int ClipAmount, bool bShouldValidate, int ValidationIDOverride);
	bool UpdateDelayedAmmoTransactionRegen(int nTransactionID, int nAmmoCarriedCountAdded, int nAmmoClipCountAdded);
	int STATIC_GiveAmmoDelayedWithValidationRegen(int nAmmoCarriedCountAdded, int nAmmoClipCountAdded);
	void ClientValidateDelayedRegenAmmoResponse(int nTransactionID, int nCarriedAmmoChanged, int nClipAmmoChanged);
	void ServerValidateDelayedRegenAmmoTransaction(int nTransactionID, int nCarriedAmmoChanged, int nClipAmmoChanged, bool bInitiateNewTransactionForRegen);
	bool ValidateDelayedAmmoTransactionRegen(int nTransactionID, bool bInitiateNewTransactionForRegen);
	bool STATIC_SendImmediateSetAmmoDelayed(int nTransactionID);
	bool STATIC_CancelSetAmmoDelayed(int nTransactionID);
	int STATIC_SetAmmoDelayedWithValidation(int CarriedAmmoCount, int ClipAmmoCount, float DelayAmt);
	void ClientValidateAmmoResponse(int nTransactionID, int nCarriedAmmoChanged, int nClipAmmoChanged, bool bFubar);
	void STATIC_LogWarnDelayedAmmoTransactionOnClient(int nTransactionID, int nAmmoCarriedAmountChanged, int nAmmoClipAmountChanged, float fTimeDelayed, bool bLateServer, int nServerCurrentTransactionID);
	void ServerValidateAmmoTransaction(int nTransactionID, int nCarriedAmmoChanged, int nClipAmmoChanged);
	void VerifyAmmoTransaction(int nTransactionID, int nCarriedAmmoChanged, int nClipAmmoChanged, bool bFilledClip);
	bool UsesSimulatedAmmo();
	void ForceActivate();
	void STATIC_Activate();
	bool AllowSwitchTo(class AWeapon* NewWeapon);
	void CancelUnequip();
	void UnequipWeapon();
	bool STATIC_TryPutDown();
	bool STATIC_IsUnEquipping();
	void StopFiringLogic();
	void STATIC_ClientReconnected();
	void AdjustForNewDilation(float fPrevDilation, float fNewDilation);
	bool STATIC_IsFunctionallyToggleDevice();
	bool STATIC_IsToggleDevice();
	bool STATIC_ApplyGlobalOffhandCooldown();
	void Destroyed();
	void UpdateIndex();
	void STATIC_HandleDeviceFormStartFire(int nDeviceModeNum, float fRefireTime, struct FAimData* Aim);
	bool ShouldRefire(class UTgDeviceFire* FireMode, struct FAimData* Aim);
	void STATIC_OutroLockoutTime();
	void DeviceBuildupTimer();
	void RestartFireLoop(bool bRefire);
	void HandDeviceLockout();
	void FirePostHitDelay();
	void FirePreHitDelay();
	void RefireCheckTimer();
	void STATIC_LockRotation(bool bShouldLock);
	void STATIC_LockCamera(bool bShouldLock);
	void STATIC_LockInput(bool bShouldLock);
	bool AllowsPickup();
	void STATIC_OnProjectileShutdown(class ATgProjectile* Proj);
	void STATIC_OnTeleportNotify(class AActor* TeleportingActor);
	void ClientSetDesiredFireMode(int nDesiredFireMode);
	void SetDesiredFiremode(int nDesiredFireMode);
	void ChangeFireModeOnRefire();
	void UpdateDesiredFireMode();
	void STATIC_NotifySwitchMode();
	void STATIC_NotifyPutAway();
	void STATIC_ClientEndCooldown();
	void STATIC_ClientResetCooldown(int nMode, float fCooldownTime);
	void STATIC_ClientStartCooldown(int nMode, float fCooldownTime);
	void STATIC_EndCooldown();
	float STATIC_GetCooldownTime(int nMode);
	void STATIC_ResetCooldown(int nMode, float fCooldownTimeOverride);
	void AuthStartCooldown(int nMode, float fCooldownTimeOverride);
	void StartCooldown(int nMode, float fCooldownTimeOverride);
	void AlternateStartCooldown();
	void ClientCooldownTimerExpired(int nTimerId, TEnumAsByte<ETGT_EVENT> eEvent);
	void CooldownTimerExpired(int nTimerId, TEnumAsByte<ETGT_EVENT> eEvent, bool bNoBecomeActive);
	float STATIC_GetCooldownRemaining();
	float STATIC_GetAltFireDetonateDamagePct();
	bool AltFireDetonate();
	void UpdateActiveProjectiles(class ATgProjectile* Proj);
	float STATIC_GetMinAccuracy();
	void TriggerAccuracyOnFire();
	void FireAmmunition();
	void ConsumeAmmoFromFiring(int nAmmoConsumptionOverride, int nFireRequestIDOverride);
	bool ShouldConsumeAmmo(int nFireRequestID, TArray<struct FImpactToValidate> Impacts);
	int STATIC_GetAmmoToConsume();
	void TrackDeviceModeFired(class ATgPawn* PawnFiring);
	class AActor* STATIC_GetTrackingTarget();
	struct FVector STATIC_GetPhysicalFireStartLoc(const struct FVector& AimDir);
	int STATIC_GetProjectileIDOverride(int ProjectileIndex);
	class AProjectile* ProjectileFire(int ProjectileIndex);
	void ServerProjectileFire(float MovementTimeStamp, const struct FVector& MovementInAccel, const struct FVector& MovementClientLoc, unsigned char MovementNewFlags, unsigned char MovementClientRoll, int MovementView, int ClientFireRequestId, int ProjectileIndex, float ProjectileLocationX, float ProjectileLocationY, float ProjectileLocationZ, float ProjectileAimVectorX, float ProjectileAimVectorY, float ProjectileAimVectorZ, float ProjectileEndTraceX, float ProjectileEndTraceY, float ProjectileEndTraceZ);
	void AdjustSpawnedProjectile(class ATgProj_Simulated** SpawnedProjectile);
	class ATgProj_Simulated* SpawnSimulatedProjectile(bool bCanSpawnOnClientFirst, int FireRequestId, int ProjectileInstanceId, class UTgDeviceFire* FireMode, const struct FVector& ProjectileSpawnLocation, const struct FVector& ProjectileSpawnDir, int ProjectileIndex, int ProjectileIdOverride, float Range, class AActor* trackingTarget, const struct FVector& EndTrace);
	void SpawnQueuedSimulatedProjectile();
	class UTgDeviceFire* STATIC_GetFireModeForFiringProjectile();
	void CustomFire();
	void AOEArcingFlash(TArray<struct FImpactInfo> ImpactList, const struct FVector& StartLocation);
	void ServerInstantFireSingleImpact(float MovementTimeStamp, const struct FVector& MovementInAccel, const struct FVector& MovementClientLoc, unsigned char MovementNewFlags, unsigned char MovementClientRoll, int MovementView, int ClientFireRequestId, float StartTraceX, float StartTraceY, float StartTraceZ, float EndTraceX, float EndTraceY, float EndTraceZ, const struct FImpactToValidate& Impact);
	void ServerInstantFireThreeImpacts(float MovementTimeStamp, const struct FVector& MovementInAccel, const struct FVector& MovementClientLoc, unsigned char MovementNewFlags, unsigned char MovementClientRoll, int MovementView, int ClientFireRequestId, float StartTraceX, float StartTraceY, float StartTraceZ, float EndTraceX, float EndTraceY, float EndTraceZ, const struct FImpactToValidate& Impact, int NumImpacts, const struct FImpactToValidate& InImpactList);
	void ServerInstantFire(float MovementTimeStamp, const struct FVector& MovementInAccel, const struct FVector& MovementClientLoc, unsigned char MovementNewFlags, unsigned char MovementClientRoll, int MovementView, int ClientFireRequestId, float StartTraceX, float StartTraceY, float StartTraceZ, float EndTraceX, float EndTraceY, float EndTraceZ, const struct FImpactToValidate& Impact, int NumImpacts, const struct FImpactToValidate& InImpactList);
	void STATIC_HandleClientReportedInstantShot(const struct FAimData& InServerAim, const struct FAimData& InClientAim, const struct FImpactToValidate& InPrimaryImpact, TArray<struct FImpactToValidate> InClientImpacts);
	void STATIC_OnInstantShotRejected(const struct FImpactToValidate& RejectedPrimaryImpact);
	void STATIC_OnInstantShotVerified(const struct FImpactInfo& VerifiedPrimaryImpact);
	void SendImpactsForVerification(struct FAimData* baseaim, struct FImpactInfo* Impact, TArray<unsigned char>* nShotsToImpactIndex);
	void PerformOnInstantFireServerValidation(float AccuracyValue, float AccuracyRandomValue1, float AccuracyRandomValue2, struct FAimData* Aim);
	void STATIC_HandleInstantFireWithConsolidation(bool bSendForServerValidation, struct FAimData* baseaim, struct FAimData* Aim, struct FImpactInfo* Impact);
	void STATIC_InstantFire();
	void RemoveHitFromTarget(class ATgPawn_Character* Target, int nHitSpecialSituationalType);
	void ApplyHitToTarget(class ATgPawn_Character* Target, int nHitSpecialSituationalType, const struct FVector& vHitLocation, const struct FVector& vHitNormal);
	void STATIC_DeliverHit(const struct FImpactInfo& Impact);
	void STATIC_DeliverQueuedPendingHits();
	struct FImpactInfo CalcWeaponFire(const struct FAimData& Aim, TArray<struct FImpactInfo>* ImpactList);
	void ZoomOutFinished();
	void ZoomInFinished();
	void ServerForceStopFire();
	void STATIC_ForceStopFire();
	void STATIC_ServerStopFire();
	void STATIC_ServerStopFireAsEvent();
	void StopFireAsEvent();
	void StopAltFire();
	void StopFire();
	bool CanToggleDeviceStopFiring();
	void ServerStopAltFire();
	void ServerStartAltFire();
	void StartFiringOnServer(float MovementTimeStamp, const struct FVector& MovementInAccel, const struct FVector& MovementClientLoc, unsigned char MovementNewFlags, unsigned char MovementClientRoll, int MovementView, int ClientFireRequestId, unsigned char ClientFireMode, class AActor* HitActor, float StartTraceX, float StartTraceY, float StartTraceZ, float EndTraceX, float EndTraceY, float EndTraceZ, int nCompressedAimVector, bool bFirstBurstShot, float fAttackSpeedPercChange);
	void ServerStartFire(float MovementTimeStamp, const struct FVector& MovementInAccel, const struct FVector& MovementClientLoc, unsigned char MovementNewFlags, unsigned char MovementClientRoll, int MovementView, int ClientFireRequestId, unsigned char ClientFireMode, class AActor* HitActor, float StartTraceX, float StartTraceY, float StartTraceZ, float EndTraceX, float EndTraceY, float EndTraceZ, int nCompressedAimVector, bool bFirstBurstShot, float fAttackSpeedPercChange);
	void ServerRestartFireLoop(float MovementTimeStamp, const struct FVector& MovementInAccel, const struct FVector& MovementClientLoc, unsigned char MovementNewFlags, unsigned char MovementClientRoll, int MovementView, int ClientFireRequestId, unsigned char ClientFireMode, class AActor* HitActor, float StartTraceX, float StartTraceY, float StartTraceZ, float EndTraceX, float EndTraceY, float EndTraceZ, int nCompressedAimVector, bool bFirstBurstShot, float fAttackSpeedPercChange);
	void CallServerRestartFireLoop(const struct FAimData& Aim);
	void CallServerStartFire(const struct FAimData& Aim, bool bPendingUpdate);
	float STATIC_GetLastMoveTimeStamp(struct FVector* LastSentMoveAcceleration, int* LastSentMoveCompressedFlags, struct FVector* LastSentClientLoc, unsigned char* LastSentClientRoll, int* LastSentView);
	void ServerAckProjectileSpawn(int ClientFireRequestId);
	void STATIC_HandleQueuedProjectileExplosion(class ATgProj_Simulated* SimulatedProjectile, float ProjectileAliveTime, class AActor* Other, float MovementTimeStamp, float AoeRewindTimeStamp, const struct FVector& HitLocation, const struct FVector& HitNormal, float VelocityZ);
	void STATIC_HandleAllQueuedProjectileExplosions(class ATgProj_Simulated* Proj);
	void ServerQueueProjectileExplode(int ClientFireRequestId, float ProjectileAliveTime, class AActor* Other, float MovementTimeStamp, float HitLocationX, float HitLocationY, float HitLocationZ, float HitNormalX, float HitNormalY, float HitNormalZ, float VelocityZ);
	void STATIC_ServerStartFireAsEvent();
	void FireLockComplete();
	void STATIC_GlobalOffhandCooldownCompleteClient();
	void STATIC_GlobalOffhandCooldownCompleteServer();
	void SetFireLock();
	void STATIC_OnStartFireRequestSent();
	void STATIC_HandleFalseFireRecory();
	bool STATIC_StartFire();
	float STATIC_GetRemainingFiringTime();
	bool ShouldSwitchBackToBasicAttackTargeting(TEnumAsByte<ECastMode> CastMode);
	bool ShouldConsumePowerPoolAfterFire();
	bool ShouldConsumePowerPoolOnStartFire();
	bool ShouldCooldownAfterFire();
	bool CanEnterCombat();
	bool ShouldInterruptReloadOnBeginTargeting();
	bool ShouldInterruptReloadOnFire();
	bool DeviceSpawnsClientProjectilesFirst();
	bool SimulateStartFire();
	void STATIC_ClientSimulateStartFireFromServer();
	void ReleaseFireHoldInternal();
	void ServerReleaseFireHold(float fClientFireHoldPercent, int nClientFireRequestId);
	void STATIC_ReleaseFireHold(bool bClientReleasedButton);
	void SetFireHoldAmt(float fFireHoldTime);
	void STATIC_InterruptBurst();
	void STATIC_InterruptFireHold();
	void FireHoldForceReleaseFUBAR();
	void FireHoldValidationTimer();
	void FireHoldTimer();
	bool StartFireHold();
	bool STATIC_StartAltFire();
	bool UseAlt();
	bool Use();
	bool CanDeviceAltFireNow(class ATgPawn* InstigatorPawn, class ATgPlayerController* InstigatorController);
	bool STATIC_CanDeviceStartFiringNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDebugRelevant, TEnumAsByte<EDeviceFailType>* failType);
	void CacheDeviceCanFire(bool bDeviceCanFire, TEnumAsByte<EDeviceFailType> failType);
	bool STATIC_CanFireWithoutAimResult();
	bool STATIC_ShouldPreventJumping();
	bool ShouldLockFiring(class ATgDevice* Current);
	bool STATIC_IsInhandOverrideActive();
	float STATIC_GetLockoutExtensionTime();
	bool CanFireWhileHanging();
	void STATIC_ConsumeDevice();
	bool UsesEnergy();
	bool UsesMana();
	bool UsesHealth();
	void STATIC_DeviceConsumePowerPool(unsigned char FireModeNum);
	bool STATIC_DeviceCanUsePowerPool(int nPacingType, unsigned char FireModeNum);
	void PlayClientFireFx(const struct FVector& HitLocation, int nSocketIndex, bool bSuccessfulHit, float fRefireTime);
	void STATIC_ServerFlashEnterTargetingMode(bool bEnterTargeting);
	bool ShouldCancelSprint();
	bool ShouldCancelCrouch();
	bool ShouldCancelStealth();
	void STATIC_HandleBurstInterrupted();
	void STATIC_OnInterruptEvent();
	void ClientRemoveSpawnedProjectile(int nFiringID);
	void STATIC_ClientInterrupt(bool bServerFireFailed);
	void ClientRefundAmmo(int nRefundAmount, int nFireRequestID);
	void ClientInitiatedInterrupt();
	void AsynchronusInterrupt();
	void STATIC_InterruptFiringOnServerInternal(bool bSendClientInterrupt, bool bServerFireFailed);
	void STATIC_InterruptFiringServerOnly();
	void STATIC_InterruptFiring(bool bServerFireFailed);
	void ServerNotifyClientAckLockout();
	void StopFiringServerDeviceLockout();
	void DeviceRestart();
	void DeviceShutDown(bool bDeactiveMode, bool bResetCooldowns);
	void ServerDoRemoteDetonation(int nFireMode);
	void STATIC_SetActiveState();
	void STATIC_GetAdjustedAim(float AccuracyValueOverride, float RandomValueOverride1, float RandomValueOverride2, struct FAimData* Aim, float* UsedAccuracyValue, float* UsedRandomValue1, float* UsedRandomValue2);
	bool CanFireIfLeftMouseDown();
	void STATIC_InterruptOtherDevices(class ATgPawn* TgP);
	void PostBeginPlay();
	float STATIC_GetRecoilMultiplier();
	class UTgGameplayCurvesSet_RecoilSimple* STATIC_GetRecoilCurve();
	void AddRecoil();
	void STATIC_GenerateRecoilSeed();
	bool ShouldInterruptEmote();
	bool ShouldInterruptMount();
	bool ShouldInterruptInhand();
	bool STATIC_CanBeInterrupted();
	bool STATIC_CancelledByJumping();
	bool STATIC_CanJumpWhileFiring();
	bool STATIC_CanBeFiredWhileTweening();
	bool STATIC_CanFiringBeCanceledByReactivation();
	bool CheckReactivationToggleLogic(unsigned char* bSuccessfulCancel);
	bool STATIC_CanFiringBeCanceledByRightMouse();
	bool STATIC_CanFiringBeCanceledByLeftMouse();
	bool STATIC_CanBeCanceled(class ATgDevice* NewDevice);
	bool STATIC_InterceptSlotReleased(class ATgPlayerController* TgController);
	bool STATIC_InterceptSlotPressed(class ATgPlayerController* TgController);
	bool STATIC_InterceptRightMouseReleased(class ATgPlayerController* TgController);
	bool STATIC_InterceptRightMousePressed(class ATgPlayerController* TgController);
	bool STATIC_InterceptLeftMouseReleased(class ATgPlayerController* TgController);
	bool STATIC_InterceptLeftMousePressed(class ATgPlayerController* TgController);
	float STATIC_GetEffectiveRange();
	float GetRange();
	bool STATIC_IsEquipping();
	bool CanFiringBeLocked();
	bool CanFireWhileMounted();
	bool STATIC_MustBeOnGroundToFire();
	bool CanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, TEnumAsByte<EDeviceFailType>* failType);
	bool STATIC_IsDeviceFiringLockedForUI();
	bool STATIC_IsDeviceFiringForUI();
	bool NativeIsFiring();
	bool CanSpawnOnClientFirst(class UClass* ProjectileClass, bool bUsesTrackingTarget);
	void STATIC_ForceCooldownIfFiring();
	void DisplayMessage(const struct FString& sMessage);
	void DisplayDebug(class AHUD* HUD, float* out_YL, float* out_YPos);
	void WeaponLog(const struct FString& msg, const struct FString& FuncStr);
	void STATIC_ReplicatedEvent(const struct FName& VarName);
	void DeleteIfPending();
	bool ShouldInterruptADSDevices();
	void STATIC_GetExplosionFXParams(float EffectiveRadius, float DamageRadius, class AActor* pOwner, TEnumAsByte<ETG_EQUIP_POINT> eEquipSlot, TArray<struct FParticleSysParam>* Params);
	void UpdateAttackSpeedModifiers();
	int STATIC_GetCurrentRecoilSettingsIdx();
	int STATIC_GetCurrentAccuracySettingsIdx();
	bool ShouldForce3P(class UTgDeviceForm* DeviceForm, bool bOnlyCheckDeviceForm);
	bool ShouldForce1P(class UTgDeviceForm* DeviceForm, bool bOnlyCheckDeviceForm);
	bool UseRangeFalloffCurve();
	class UTgGameplayCurvesSet* STATIC_GetCurrentGameplayCurveSet(TEnumAsByte<ECurveSetTypes> Type);
	class UTgGameplayCurves* STATIC_GetCurrentGameplayCurves();
	void DeviceFailLog(bool bDeviceFailLog, const struct FString& S);
	bool ShouldAutoFire();
	float STATIC_GetFireHoldPct();
	float STATIC_GetFireHoldDamageLow();
	float STATIC_GetFireHoldAccuracyLow();
	float STATIC_GetFireHoldRate();
	float STATIC_GetFireHoldTime();
	class UTgGameplayCurvesSet* STATIC_GetShotSpreadTendencyCurvesSet();
	float STATIC_GetBaseDamageMultiplier(struct FImpactInfo* hitImpact);
	void ConsolidateImpacts(TArray<struct FImpactInfo>* ImpactsToConsolidate, TArray<float>* ShotRanges, TArray<unsigned char>* ShotToImpactIndex);
	bool ShouldBlockPickup();
	float STATIC_GetRequiredEnergyToFire();
	bool UpdateUltChargePercent();
	bool ShouldAltFireOnTick();
	bool STATIC_IsSuccessfulHitImpact(class AActor* ImpactedActor);
	float STATIC_GetHeadShotDamage(class UTgDeviceFire* FireMode);
	struct FString STATIC_GetProjectilePredictionStats();
	struct FString STATIC_GetInstantFirePredictionStats();
	struct FString STATIC_GetAimValidationStats();
	struct FString STATIC_GetLastUsedAimStats();
	void RecordUsedAim(struct FVector* InAim);
	void SetRandomShotSpreadSeed(int Seed);
	bool ValidateClientInstantHit(struct FImpactInfo* ValidPrimaryImpact, TArray<struct FImpactInfo>* OutValidImpacts, struct FAimData* InServerAim, struct FAimData* InClientAim, struct FImpactToValidate* InPrimaryImpact, TArray<struct FImpactToValidate>* InClientImpacts, TArray<float>* OutHitRanges);
	bool ValidateClientProjectileImpact(class ATgProj_Simulated* SimulatedProjectile, float ProjectileAliveTime, class AActor* Other, float MovementTimeStamp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	int STATIC_GenerateUniqueAmmoValidationId();
	int STATIC_GenerateUniqueFireRequestId();
	bool STATIC_HasRemoteOwner();
	void ReplicatePlayerDeviceAmmo();
	int STATIC_GetPetIDOverride(int PetIndex);
	void DeviceAdjustHeal(int nPropertyId, struct FImpactInfo* Impact, float* fHeal);
	void DeviceAdjustRadius(class ATgDevice* Dev, float* fRadius);
	void DeviceAdjustDamage(int nPropertyId, struct FImpactInfo* Impact, float* fDamage);
	void SetFireMode(int nFireModeNum, bool ForceSet);
	float STATIC_GetRandRecoil(float Min, float Max);
	float STATIC_GetAccuracy(int nMode);
	bool ReloadCancelADS();
	bool ShouldBlockReload(class ATgDevice* Dev, bool bIsAutoReload);
	bool STATIC_IsReloading();
	bool CanReload(bool bIsAutoReload);
	bool CheckAutoReload();
	float STATIC_GetCurrentReloadPct();
	void UpdateAmmoRegen(bool bUpdateCooldown, float fCooldownFloor);
	bool ShouldTreatAmmoAsCharges();
	struct FAmmoCount STATIC_GetCurrentAmmoAmount();
	bool RequiresAmmoToFire();
	bool ShouldShowAmmoCount();
	bool ShouldLiftInterrupt();
	bool ShouldInterruptLift();
	bool ShouldInterruptStealth();
	void SetInstanceCount(int nInstanceCount);
	void SetPointsAllocated(int nPoints);
	void ClientPtsAllocatedUpdated();
	bool STATIC_AllocateDevicePoint();
	int STATIC_GetAllocatedDevicePoints();
	int STATIC_GetTotalDevicePoints();
	void STATIC_ExitTargetingMode();
	void STATIC_EnterTargetingMode();
	bool STATIC_IsInTargetingMode();
	bool STATIC_IsTargetingModeReady(TEnumAsByte<EDeviceFailType>* failType);
	bool STATIC_IsActive(bool bIgnoreCooldown, bool bIngoreEquipped);
	void UpdateAimWhileFiring(struct FAimData* Aim);
	bool SupportsEffectSimulation();
	bool CanAllowLagCompensation();
	bool CanLockOnToTarget(class AActor* Target);
	void STATIC_GetWorldMapTargetAim(struct FAimData* Aim);
	void STATIC_GetSpawnPointTargetAim(struct FAimData* Aim);
	void STATIC_GetLockOnTargetAim(struct FAimData* Aim);
	void STATIC_GetGroundTargetAim(struct FAimData* Aim);
	void STATIC_GetLinearTargetAim(struct FAimData* Aim);
	void STATIC_GetSelfTargetAim(struct FAimData* Aim);
	void STATIC_GetAOETargetAim(struct FAimData* Aim);
	void STATIC_GetConeTargetAim(struct FAimData* Aim);
	void STATIC_GetReticleFindSpotAim(struct FAimData* Aim);
	void STATIC_GetReticleTargetAim(struct FAimData* Aim);
	void STATIC_GetTargetingAim(struct FAimData* Aim);
	void UpdateTargetingModeStatus(struct FAimData* Aim);
	struct FAimData ValidateReceivedAim(float ClientMovementTimeStamp, const struct FAimData& Aim);
	struct FAimData CacheAim();
	void STATIC_GetCachedAim(struct FAimData* Aim);
	bool UsesCachedAim();
	TEnumAsByte<ECastMode> DetermineCastMode(TEnumAsByte<ECastMode> desiredCastMode);
	bool ShouldAimThroughReticule();
	bool ForceDefaultCastMode();
	bool UsesTrackingTarget();
	bool UsesTargetingMode();
	TEnumAsByte<EDeviceTargetMode> STATIC_GetTargetingMode();
	float STATIC_GetCachedFiringPostHitDelay();
	float CacheFiringPostHitDelay();
	float STATIC_GetFiringPostHitDelay(int nMode);
	float STATIC_GetFiringPreHitDelay(int nMode);
	float STATIC_GetRefireTime(int nMode);
	float STATIC_GetBuildupTime();
	void STATIC_GetCombatLogEventLocation(int* LocationX, int* LocationY);
	void SendCombatLogEvent(TEnumAsByte<EITEM_EVENT_TYPE> Type);
	void SendDeviceChangeEvent(TEnumAsByte<EDeviceChangeEvent> Event);
	void CheckAndUpdateCooldown();
	class UTgTimerManager* STATIC_GetCooldownTimerManager();
	bool STATIC_IsDeviceRefiring();
	bool STATIC_IsInCooldownGracePeriod();
	bool STATIC_IsDeviceCoolingDown();
	bool STATIC_HasEnoughPowerPool(unsigned char FireModeNum);
	float STATIC_GetConePullbackDistance();
	bool STATIC_CanBeGrabbed();
	bool CanBeStasisLocked();
	bool CanBeCrippled();
	bool CanBeDisarmed();
	bool CanBeSilenced();
	bool CanBeStunned();
	bool STATIC_IsTestDevice();
	bool STATIC_IsBurnCard();
	bool STATIC_IsArmorCard();
	bool STATIC_IsTalent();
	bool STATIC_IsCard();
	bool STATIC_IsEmote();
	bool STATIC_IsMovementAbility();
	bool STATIC_IsAbility(bool bExcludeMovement);
	bool STATIC_IsPurchasedAbility();
	bool STATIC_IsOwnedByOffhand();
	bool STATIC_IsOffhand();
	int STATIC_GetModeRange(int nMode);
	bool CheckModeRange(int nMode, const struct FVector& vDelta);
	void STATIC_OnCeaseActive();
	void STATIC_OnBecomeActive();
	void CeaseActive(bool bSkipActiveEffects);
	void BecomeActive(bool bSkipActiveEffects);
	void STATIC_RemoveEquipEffects();
	void STATIC_ApplyEquipEffects();
	class UTgDeviceFire* STATIC_GetDeviceFire(int nMode);
	class UTgDeviceFire* STATIC_GetCurrentFire();
	void TickTargetingMode(float DeltaSeconds);
	bool STATIC_ServerDetonate(int nFireMode);
	bool STATIC_LogDebugInfo();
	void RemoveConsumableFromOwnerInventory();
	struct FString STATIC_GetDeviceName();
	void CalcFireSocketIndexMax();
	struct FName STATIC_GetFireSocketName();
	struct FName QueryDeployableClass(int nMode);
	struct FName QueryProjectileClass(int nMode);
	bool ApplyDeviceSetup();
	void STATIC_DeviceEvent();
};


// Class TgGame.TgDevice_2dAim
// 0x0000 (0x0AEC - 0x0AEC)
class ATgDevice_2dAim : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_2dAim");
		return ptr;
	}


	void STATIC_GetTargetingAim(struct FAimData* Aim);
};


// Class TgGame.TgDevice_DivineWrath
// 0x000C (0x0AF8 - 0x0AEC)
class ATgDevice_DivineWrath : public ATgDevice_2dAim
{
public:
	struct FVector                                     m_vLocalAimOffset;                                        // 0x0AEC(0x000C)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_DivineWrath");
		return ptr;
	}


	void AdjustSpawnedProjectile(class ATgProj_Simulated** SpawnedProjectile);
	bool CanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, TEnumAsByte<EDeviceFailType>* failType);
};


// Class TgGame.TgDevice_Ammo
// 0x0000 (0x0AEC - 0x0AEC)
class ATgDevice_Ammo : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Ammo");
		return ptr;
	}


	bool DeviceUsesAmmo();
};


// Class TgGame.TgDevice_ArcingBeam
// 0x0018 (0x0B04 - 0x0AEC)
class ATgDevice_ArcingBeam : public ATgDevice
{
public:
	TArray<struct FArcingInfo>                         m_ArcingList;                                             // 0x0AEC(0x0010) (NeedCtorLink)
	int                                                m_nMaxNumArcsPerTarget;                                   // 0x0AFC(0x0004)
	unsigned long                                      m_bCanTargetShields : 1;                                  // 0x0B00(0x0004)
	unsigned long                                      m_bIsArcing : 1;                                          // 0x0B00(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_ArcingBeam");
		return ptr;
	}


	void TriggerArc(int Index);
	void EndArcing(int Index);
	void STATIC_BeginArcing(class AActor* InitialTarget, class UTgDeviceFire* FireMode);
	int STATIC_GetNumArcJumps(class AActor* InitialTarget, class UTgDeviceFire* FireMode);
	void Tick(float DeltaTime);
	void TriggerArcsInArcingList(float DeltaTime);
	bool STATIC_IsValidArcTarget(class AActor* TestActor, const struct FArcingInfo& Info);
	class AActor* DetermineNextTarget(int Index);
};


// Class TgGame.TgDevice_Aura
// 0x0048 (0x0B34 - 0x0AEC)
class ATgDevice_Aura : public ATgDevice
{
public:
	float                                              r_fRadiusScale;                                           // 0x0AEC(0x0004) (Net)
	TArray<class AActor*>                              m_TouchingActors;                                         // 0x0AF0(0x0010) (NeedCtorLink)
	TArray<class AActor*>                              m_AffectedActors;                                         // 0x0B00(0x0010) (NeedCtorLink)
	unsigned long                                      m_bIsAuraActive : 1;                                      // 0x0B10(0x0004)
	float                                              m_fLastBlockedByBlockersTime;                             // 0x0B14(0x0004)
	float                                              m_fMinBlockedByBlockersTime;                              // 0x0B18(0x0004)
	TArray<class AActor*>                              m_BlockedActors;                                          // 0x0B1C(0x0010) (NeedCtorLink)
	class ATgCollisionProxy_Cylinder*                  m_CollisionProxy;                                         // 0x0B2C(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Aura");
		return ptr;
	}


	bool STATIC_CanJumpWhileFiring();
	void STATIC_DisableAura();
	void STATIC_EnableAura();
	void STATIC_ScaleCollisionProxy();
	void SpawnCollisionProxy();
	void Destroyed();
	void DeviceShutDown(bool bDeactiveMode, bool bResetCooldowns);
	void STATIC_ClearAllTouched();
	void STATIC_ClearAllAffected();
	void STATIC_OnProxyUnTouch(class AActor* Other);
	void STATIC_OnProxyTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	bool ShouldInterruptInhand();
	bool ShouldLockFiring(class ATgDevice* Current);
	float STATIC_GetDistanceToTarget(class AActor* Target);
	float STATIC_GetCurrentRadius();
	void RemoveEffects(class AActor* Target);
	void ApplyEffects(class AActor* Target);
	void SetFireMode(int nFireModeNum, bool ForceSet);
};


// Class TgGame.TgDevice_ActiveAura
// 0x0000 (0x0B34 - 0x0B34)
class ATgDevice_ActiveAura : public ATgDevice_Aura
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_ActiveAura");
		return ptr;
	}

};


// Class TgGame.TgDevice_PassiveAura
// 0x0000 (0x0B34 - 0x0B34)
class ATgDevice_PassiveAura : public ATgDevice_Aura
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_PassiveAura");
		return ptr;
	}


	bool ShouldAuraBeActive();
};


// Class TgGame.TgDevice_AuraPerTarget
// 0x0004 (0x0B38 - 0x0B34)
class ATgDevice_AuraPerTarget : public ATgDevice_PassiveAura
{
public:
	int                                                m_nAppliedStacks;                                         // 0x0B34(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_AuraPerTarget");
		return ptr;
	}

};


// Class TgGame.TgDevice_AutoHealing2
// 0x0014 (0x0B00 - 0x0AEC)
class ATgDevice_AutoHealing2 : public ATgDevice
{
public:
	unsigned long                                      m_bIsApplied : 1;                                         // 0x0AEC(0x0004)
	unsigned long                                      m_bForceRemoval : 1;                                      // 0x0AEC(0x0004)
	class ATgPawn*                                     m_CachedPawnOwner;                                        // 0x0AF0(0x0008)
	float                                              m_fLastLowHealthSoundTime;                                // 0x0AF8(0x0004)
	float                                              m_fPrevHealthPct;                                         // 0x0AFC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_AutoHealing2");
		return ptr;
	}


	void DeviceAdjustHeal(int nPropertyId, struct FImpactInfo* Impact, float* fHeal);
};


// Class TgGame.TgDevice_BurstRifle
// 0x0008 (0x0AF4 - 0x0AEC)
class ATgDevice_BurstRifle : public ATgDevice
{
public:
	float                                              m_fQueueFireTime;                                         // 0x0AEC(0x0004)
	float                                              m_fQueueFireTimeThreshold;                                // 0x0AF0(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_BurstRifle");
		return ptr;
	}


	bool STATIC_InterceptLeftMousePressed(class ATgPlayerController* TgController);
	bool CanFireIfLeftMouseDown();
};


// Class TgGame.TgDevice_ChainSequence
// 0x000C (0x0AF8 - 0x0AEC)
class ATgDevice_ChainSequence : public ATgDevice
{
public:
	int                                                m_nChainCount;                                            // 0x0AEC(0x0004)
	float                                              m_fChainResetTimer;                                       // 0x0AF0(0x0004)
	float                                              m_fChainResetDuration;                                    // 0x0AF4(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_ChainSequence");
		return ptr;
	}


	void STATIC_OnChainReset();
	void UpdateDesiredFireMode();
	void FireAmmunition();
	int STATIC_GetChainFireModeIndex();
	int STATIC_GetChainMax();
};


// Class TgGame.TgDevice_Charge
// 0x0068 (0x0B60 - 0x0AF8)
class ATgDevice_Charge : public ATgDevice_ChainSequence
{
public:
	TEnumAsByte<EChargeState>                          m_eChargeState;                                           // 0x0AF8(0x0001)
	TEnumAsByte<EChargeStopOnHitType>                  m_bStopOnHitType;                                         // 0x0AF9(0x0001)
	TEnumAsByte<EChargeFiringType>                     m_ChargeTimingType;                                       // 0x0AFA(0x0001)
	unsigned char                                      UnknownData00[0x1];                                       // 0x0AFB(0x0001) MISSED OFFSET
	unsigned long                                      m_bUsePhysFlying : 1;                                     // 0x0AFC(0x0004)
	unsigned long                                      m_bUseDamageRadiusForHitProxy : 1;                        // 0x0AFC(0x0004)
	unsigned long                                      m_bIgnoreHumanoids : 1;                                   // 0x0AFC(0x0004)
	unsigned long                                      m_bHitOnce : 1;                                           // 0x0AFC(0x0004)
	unsigned long                                      m_bApplyHitOnTouch : 1;                                   // 0x0AFC(0x0004)
	unsigned long                                      m_bApplyHitSpecialOnTouch : 1;                            // 0x0AFC(0x0004)
	unsigned long                                      m_bIgnoreRange : 1;                                       // 0x0AFC(0x0004)
	unsigned long                                      m_bCharging : 1;                                          // 0x0AFC(0x0004)
	unsigned long                                      m_bStopOnAttachedForcefield : 1;                          // 0x0AFC(0x0004)
	unsigned long                                      m_bInterruptDeviceIfChargeEnds : 1;                       // 0x0AFC(0x0004)
	unsigned long                                      m_bUseDirectHitSpecial : 1;                               // 0x0AFC(0x0004)
	unsigned long                                      m_bChargeBackward : 1;                                    // 0x0AFC(0x0004)
	unsigned long                                      m_bCanLeftClickCancel : 1;                                // 0x0AFC(0x0004)
	unsigned long                                      m_bIgnoreMovementCorrection : 1;                          // 0x0AFC(0x0004)
	class ATgCollisionProxy_Cylinder*                  m_HitProxy;                                               // 0x0B00(0x0008)
	struct FVector                                     m_vHitProxyRelativeLocation;                              // 0x0B08(0x000C)
	struct FVector                                     m_vHitProxySizeOffset;                                    // 0x0B14(0x000C)
	float                                              s_fServerValidationSizeMultiplier;                        // 0x0B20(0x0004)
	struct FRotator                                    m_rLastChargeDirection;                                   // 0x0B24(0x000C)
	TArray<class AActor*>                              s_AppliedList;                                            // 0x0B30(0x0010) (NeedCtorLink)
	TArray<class AActor*>                              s_HitActors;                                              // 0x0B40(0x0010) (NeedCtorLink)
	TArray<struct FChargeTouchData>                    s_TouchData;                                              // 0x0B50(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Charge");
		return ptr;
	}


	bool ShouldCancelCrouch();
	bool STATIC_CanFiringBeCanceledByLeftMouse();
	void ApplyTouchHit(class ATgPawn* InstigatorPawn, const struct FVector& vHitLocation, const struct FVector& vHitNormal, class AActor* Target);
	void ApplyCachedHits();
	void EnableCorrection();
	struct FRotator STATIC_GetChargeDirection();
	void STATIC_OnStoppedChargeOnHit(class AActor* Other);
	void STATIC_OnValidTargetTouched(class AActor* Other);
	void STATIC_ApplyDamageReduction(struct FImpactInfo* Impact);
	bool ShouldStopOnThisHit(class AActor* Other);
	float STATIC_GetChargeSpeed();
	float STATIC_GetChargeTime();
	float STATIC_GetChargeRange();
	bool STATIC_CanBeInterrupted();
	bool STATIC_CanBeCanceled(class ATgDevice* NewDevice);
	void STATIC_EndCharge();
	void StartCharge();
	void STATIC_ChargeUnTouch(class AActor* Other);
	void STATIC_ChargeTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	bool ServerValidateChargeHit(class AActor* Other);
	void STATIC_GetTargetingAim(struct FAimData* Aim);
	void SetFireMode(int nFireModeNum, bool ForceSet);
};


// Class TgGame.TgDevice_ChargeBackward
// 0x0000 (0x0B60 - 0x0B60)
class ATgDevice_ChargeBackward : public ATgDevice_Charge
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_ChargeBackward");
		return ptr;
	}

};


// Class TgGame.TgDevice_CoveredCharge
// 0x0008 (0x0B68 - 0x0B60)
class ATgDevice_CoveredCharge : public ATgDevice_Charge
{
public:
	unsigned long                                      m_bHasHitTarget : 1;                                      // 0x0B60(0x0004)
	float                                              m_fTimeToStop;                                            // 0x0B64(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_CoveredCharge");
		return ptr;
	}


	bool ShouldCancelCrouch();
	bool STATIC_CanBeCanceled(class ATgDevice* NewDevice);
	void CancelSafetyPeriodTimer();
	bool ShouldStopOnThisHit(class AActor* Other);
	void ApplyTouchHit(class ATgPawn* InstigatorPawn, const struct FVector& vHitLocation, const struct FVector& vHitNormal, class AActor* Target);
	void ValidateChargeHit(class AActor* Other);
	bool STATIC_IsFunctionallyToggleDevice();
};


// Class TgGame.TgDevice_DoubleCharge
// 0x000C (0x0B6C - 0x0B60)
class ATgDevice_DoubleCharge : public ATgDevice_Charge
{
public:
	int                                                m_nTotalNumShots;                                         // 0x0B60(0x0004)
	int                                                m_nShotsFired;                                            // 0x0B64(0x0004)
	unsigned long                                      m_bSetAsTargetingDeviceForMultiFire : 1;                  // 0x0B68(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_DoubleCharge");
		return ptr;
	}


	int STATIC_GetTotalNumberOfShots();
	void STATIC_DeviceConsumePowerPool(unsigned char FireModeNum);
	bool ServerRefireTimer(bool bRefire, const struct FAimData& ClientAim, float EndTraceX, float EndTraceY);
	bool RefireTimer(bool bRefire);
	bool Use();
	bool STATIC_CanBeCanceled(class ATgDevice* NewDevice);
	void UpdateTargetingModeStatus(struct FAimData* Aim);
};


// Class TgGame.TgDevice_HunterRoll
// 0x0004 (0x0B64 - 0x0B60)
class ATgDevice_HunterRoll : public ATgDevice_Charge
{
public:
	unsigned long                                      m_bRolledBackward : 1;                                    // 0x0B60(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_HunterRoll");
		return ptr;
	}


	struct FRotator STATIC_GetChargeDirection();
};


// Class TgGame.TgDevice_Melee
// 0x0000 (0x0AF8 - 0x0AF8)
class ATgDevice_Melee : public ATgDevice_ChainSequence
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Melee");
		return ptr;
	}


	int STATIC_GetChainMax();
	bool ShouldConsumeAmmo(int nFireRequestID, TArray<struct FImpactToValidate> Impacts);
	bool CanFiringBeLocked();
	bool DeviceUsesAmmo();
};


// Class TgGame.TgDevice_DeathFog
// 0x0000 (0x0AEC - 0x0AEC)
class ATgDevice_DeathFog : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_DeathFog");
		return ptr;
	}


	void DeviceAdjustDamage(int nPropertyId, struct FImpactInfo* Impact, float* fDamage);
};


// Class TgGame.TgDevice_DeployMod
// 0x0008 (0x0AF4 - 0x0AEC)
class ATgDevice_DeployMod : public ATgDevice
{
public:
	struct FPointer                                    VfTable_ITgDeviceInterface_DeployMod;                     // 0x0AEC(0x0008) (Const, Native, NoExport)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_DeployMod");
		return ptr;
	}


	void STATIC_ModifyDeployableFiremode(class UTgDeviceFire* pFireMode);
	float STATIC_GetAdditiveHealth();
	bool AffectsDeployable(int nDeployableId);
};


// Class TgGame.TgDevice_DeployMod_AddHealth
// 0x0000 (0x0AF4 - 0x0AF4)
class ATgDevice_DeployMod_AddHealth : public ATgDevice_DeployMod
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_DeployMod_AddHealth");
		return ptr;
	}


	float STATIC_GetAdditiveHealth();
};


// Class TgGame.TgDevice_DeployMod_PropertyMult
// 0x0000 (0x0AF4 - 0x0AF4)
class ATgDevice_DeployMod_PropertyMult : public ATgDevice_DeployMod
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_DeployMod_PropertyMult");
		return ptr;
	}


	void STATIC_ModifyDeployableFiremode(class UTgDeviceFire* pFireMode);
};


// Class TgGame.TgDevice_Dragon
// 0x0000 (0x0AEC - 0x0AEC)
class ATgDevice_Dragon : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Dragon");
		return ptr;
	}


	bool ShouldCancelSprint();
};


// Class TgGame.TgDevice_DualWield
// 0x0010 (0x0AFC - 0x0AEC)
class ATgDevice_DualWield : public ATgDevice
{
public:
	struct FVector                                     m_vProjectileSpawnOffset2;                                // 0x0AEC(0x000C) (Edit)
	unsigned long                                      m_bFireLeftWeapon : 1;                                    // 0x0AF8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_DualWield");
		return ptr;
	}


	void SetLeftFire(bool bLeftFire);
	void FireAmmunition();
	struct FVector STATIC_GetProjectileSpawnOffset();
};


// Class TgGame.TgDevice_Emote
// 0x0038 (0x0B24 - 0x0AEC)
class ATgDevice_Emote : public ATgDevice
{
public:
	class ATgPawn*                                     m_CachedPawnOwner;                                        // 0x0AEC(0x0008)
	unsigned long                                      m_bAccelerationInterruptsDevice : 1;                      // 0x0AF4(0x0004)
	unsigned long                                      m_bJumpingInterruptsDevice : 1;                           // 0x0AF4(0x0004)
	class UClass*                                      m_DefaultCameraModuleClass;                               // 0x0AF8(0x0008)
	class UClass*                                      m_FiringCameraModuleClass;                                // 0x0B00(0x0008)
	class UTgCameraModule*                             m_FiringCameraModule;                                     // 0x0B08(0x0008)
	float                                              m_fCameraTweenInTime;                                     // 0x0B10(0x0004)
	float                                              m_fCameraTweenOutTime;                                    // 0x0B14(0x0004)
	struct FVector                                     m_vFiringCameraOffset;                                    // 0x0B18(0x000C)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Emote");
		return ptr;
	}


	void ToggleSpecialBehavior(bool bEnable);
	void STATIC_OnInterruptEvent();
	void Tick(float DeltaSeconds);
	class ATgPawn* STATIC_GetCachedPawnOwner();
	void TurnOffSpecialCamera();
	void TurnOnSpecialCamera();
	bool STATIC_CanBeCanceled(class ATgDevice* NewDevice);
	bool STATIC_CanBeInterrupted();
	bool ShouldInterruptReloadOnFire();
	bool ShouldInterruptMount();
	bool STATIC_CanBeFiredWhileTweening();
	bool STATIC_CanFiringBeCanceledByReactivation();
	bool STATIC_CanFiringBeCanceledByRightMouse();
	bool STATIC_CanJumpWhileFiring();
	bool ShouldLockFiring(class ATgDevice* Current);
	bool CanFiringBeLocked();
	bool ShouldBlockReload(class ATgDevice* Dev, bool bIsAutoReload);
};


// Class TgGame.TgDevice_FireInAir
// 0x0000 (0x0AEC - 0x0AEC)
class ATgDevice_FireInAir : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_FireInAir");
		return ptr;
	}

};


// Class TgGame.TgDevice_Fortification
// 0x0000 (0x0AEC - 0x0AEC)
class ATgDevice_Fortification : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Fortification");
		return ptr;
	}


	bool ShouldCancelCrouch();
	bool STATIC_CanBeCanceled(class ATgDevice* NewDevice);
	bool STATIC_CanFiringBeCanceledByLeftMouse();
	void CancelSafetyPeriodTimer();
	bool STATIC_IsFunctionallyToggleDevice();
};


// Class TgGame.TgDevice_GhostWalk
// 0x0000 (0x0AEC - 0x0AEC)
class ATgDevice_GhostWalk : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_GhostWalk");
		return ptr;
	}


	bool ShouldCancelSprint();
	bool ShouldInterruptReloadOnFire();
	bool STATIC_CanBeCanceled(class ATgDevice* NewDevice);
};


// Class TgGame.TgDevice_HealthPack
// 0x000C (0x0AF8 - 0x0AEC)
class ATgDevice_HealthPack : public ATgDevice
{
public:
	int                                                m_nQueuedShots;                                           // 0x0AEC(0x0004)
	float                                              m_fQueueGracePeriod;                                      // 0x0AF0(0x0004)
	float                                              m_fLastFire;                                              // 0x0AF4(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_HealthPack");
		return ptr;
	}


	void ServerStartFire(float MovementTimeStamp, const struct FVector& MovementInAccel, const struct FVector& MovementClientLoc, unsigned char MovementNewFlags, unsigned char MovementClientRoll, int MovementView, int ClientFireRequestId, unsigned char ClientFireMode, class AActor* HitActor, float StartTraceX, float StartTraceY, float StartTraceZ, float EndTraceX, float EndTraceY, float EndTraceZ, int nCompressedAimVector, bool bFirstBurstShot, float fAttackSpeedPercChange);
	void STATIC_TryToQueueShot();
	void ClientTryToQueueShot();
	void CallTryToQueueShot();
	bool ShouldStopActionOnOffhandSlotReleased();
	bool ShouldLockFiring(class ATgDevice* Current);
	bool STATIC_IsHealthPackDevice();
};


// Class TgGame.TgDevice_HitPulse
// 0x0008 (0x0AF4 - 0x0AEC)
class ATgDevice_HitPulse : public ATgDevice
{
public:
	unsigned long                                      s_ShouldPayCostPerPulse : 1;                              // 0x0AEC(0x0004)
	unsigned long                                      s_bCostPaid : 1;                                          // 0x0AEC(0x0004)
	unsigned long                                      m_bConsumeAmmoOnEachPulse : 1;                            // 0x0AEC(0x0004)
	int                                                m_CurrentPulseIndex;                                      // 0x0AF0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_HitPulse");
		return ptr;
	}


	float STATIC_GetLockoutExtensionTime();
	int STATIC_GetAmmoToConsume();
	bool ShouldConsumePowerPoolAfterFire();
	bool ShouldConsumePowerPoolOnStartFire();
	void STATIC_ClientInterrupt(bool bServerFireFailed);
	void STATIC_InterruptFiring(bool bServerFireFailed);
	float STATIC_GetPersistPulseHitTime(int nMode);
	float STATIC_GetPersistTime(int nMode);
	void PulseHit();
	float STATIC_GetRefireTime(int nMode);
	void PersistTimer();
	bool STATIC_ApplyGlobalOffhandCooldown();
	bool CanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, TEnumAsByte<EDeviceFailType>* failType);
};


// Class TgGame.TgDevice_HolyAura
// 0x0000 (0x0AEC - 0x0AEC)
class ATgDevice_HolyAura : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_HolyAura");
		return ptr;
	}


	bool STATIC_CanFiringBeCanceledByLeftMouse();
	bool STATIC_CanBeCanceled(class ATgDevice* NewDevice);
};


// Class TgGame.TgDevice_HolyHammer
// 0x000C (0x0AF8 - 0x0AEC)
class ATgDevice_HolyHammer : public ATgDevice
{
public:
	int                                                m_nChainCount;                                            // 0x0AEC(0x0004)
	float                                              m_fChainResetTimer;                                       // 0x0AF0(0x0004)
	float                                              m_fChainResetDuration;                                    // 0x0AF4(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_HolyHammer");
		return ptr;
	}

};


// Class TgGame.TgDevice_Impasse
// 0x0008 (0x0AF4 - 0x0AEC)
class ATgDevice_Impasse : public ATgDevice
{
public:
	float                                              r_fTremorsCooldownReduction;                              // 0x0AEC(0x0004) (Net)
	float                                              m_fCachedWallHealthPercent;                               // 0x0AF0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Impasse");
		return ptr;
	}


	bool CanEnterCatapultEvenWhenFiring();
	bool ShouldCancelSprint();
	int STATIC_GetAimAssistPriority();
	bool ShouldMountCancelFiring();
	bool STATIC_CanBeCanceled(class ATgDevice* NewDevice);
	bool ShouldLockFiring(class ATgDevice* Current);
	void STATIC_OnDeployableDestroyed(class ATgDeployable* deployable);
	void STATIC_OnDeployableSpawned(class ATgDeployable* deployable);
	bool STATIC_CanFireWithoutAimResult();
	void ServerEndCustomTargeting();
	void STATIC_EndCustomTargeting();
	bool STATIC_InterceptLeftMousePressed(class ATgPlayerController* TgController);
	bool STATIC_InterceptSlotReleased(class ATgPlayerController* TgController);
	bool STATIC_InterceptSlotPressed(class ATgPlayerController* TgController);
	void UpdateTargetingModeStatus(struct FAimData* Aim);
	bool ShouldAltFireOnTick();
	void STATIC_GetGroundTargetAim(struct FAimData* Aim);
};


// Class TgGame.TgDevice_Leap
// 0x0004 (0x0AF0 - 0x0AEC)
class ATgDevice_Leap : public ATgDevice
{
public:
	unsigned long                                      m_bLeapInLookDirection : 1;                               // 0x0AEC(0x0004)
	unsigned long                                      m_bDidJustLeap : 1;                                       // 0x0AEC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Leap");
		return ptr;
	}


	void SetLeapParams(float* scaleLateral, float* scaleVertical, float* additiveLateral, float* additiveVertical);
	void STATIC_OnLeapEnded();
	void STATIC_OnLeapStarted();
	bool STATIC_CanBeCanceled(class ATgDevice* NewDevice);
	float STATIC_GetFiringPreHitDelay(int nMode);
};


// Class TgGame.TgDevice_Longbow
// 0x000C (0x0AF8 - 0x0AEC)
class ATgDevice_Longbow : public ATgDevice
{
public:
	float                                              s_fLastFireHoldPct;                                       // 0x0AEC(0x0004)
	float                                              m_fFireReleasePercent;                                    // 0x0AF0(0x0004)
	float                                              m_fReticleReleaseAnimationDuration;                       // 0x0AF4(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Longbow");
		return ptr;
	}


	bool STATIC_CanBeInterrupted();
	bool StartFireHold();
	void ReleaseFireHoldInternal();
	void AdjustSpawnedProjectile(class ATgProj_Simulated** SpawnedProjectile);
	void SetFireHoldAmt(float fFireHoldTime);
	bool STATIC_CanBeCanceled(class ATgDevice* NewDevice);
	bool CanFiringBeLocked();
	bool ShouldAutoFire();
};


// Class TgGame.TgDevice_Minigun
// 0x002C (0x0B18 - 0x0AEC)
class ATgDevice_Minigun : public ATgDevice
{
public:
	float                                              m_fFireReadiness;                                         // 0x0AEC(0x0004)
	int                                                r_nFireReadinessPercent;                                  // 0x0AF0(0x0004) (Net)
	int                                                m_nOldFireReadinessPercent;                               // 0x0AF4(0x0004)
	TArray<class UForceFeedbackWaveform*>              m_ForceFeedbackBarrelSpin;                                // 0x0AF8(0x0010) (NeedCtorLink)
	TArray<class UForceFeedbackWaveform*>              m_ForceFeedbackBarrelFiring;                              // 0x0B08(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Minigun");
		return ptr;
	}


	void STATIC_OnInterruptEvent();
	bool ShouldCancelSprint();
	void UnequipDevice();
	void STATIC_CheckSpinForceFeedback();
	void STATIC_ReplicatedEvent(const struct FName& VarName);
	float STATIC_GetBuildupTime();
};


// Class TgGame.TgDevice_Pet
// 0x0000 (0x0AEC - 0x0AEC)
class ATgDevice_Pet : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Pet");
		return ptr;
	}

};


// Class TgGame.TgDevice_PoisonPistol
// 0x0008 (0x0AF4 - 0x0AEC)
class ATgDevice_PoisonPistol : public ATgDevice
{
public:
	float                                              m_fQueueFireTime;                                         // 0x0AEC(0x0004)
	float                                              m_fQueueFireTimeThreshold;                                // 0x0AF0(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_PoisonPistol");
		return ptr;
	}


	bool STATIC_InterceptLeftMousePressed(class ATgPlayerController* TgController);
	void FireAmmunition();
	bool CanFireIfLeftMouseDown();
};


// Class TgGame.TgDevice_ShieldBounce
// 0x0008 (0x0AF4 - 0x0AEC)
class ATgDevice_ShieldBounce : public ATgDevice
{
public:
	int                                                m_nLastFiringInstance;                                    // 0x0AEC(0x0004)
	int                                                m_nNumJumps;                                              // 0x0AF0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_ShieldBounce");
		return ptr;
	}


	float STATIC_GetBaseDamageMultiplier(struct FImpactInfo* hitImpact);
	void STATIC_HandleJump(class AActor* HitTarget, const struct FVector& HitLocation, const struct FVector& HitNormal, const struct FVector& HitVelocity, class ATgProj_TargetedBounceBase* sourceProj);
	bool CanShotJump();
	bool STATIC_StartFire();
	bool CanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, TEnumAsByte<EDeviceFailType>* failType);
	bool STATIC_IsDeviceFiringForUI();
};


// Class TgGame.TgDevice_SideArm
// 0x0008 (0x0AF4 - 0x0AEC)
class ATgDevice_SideArm : public ATgDevice
{
public:
	float                                              m_fQueueFireTime;                                         // 0x0AEC(0x0004)
	float                                              m_fQueueFireTimeThreshold;                                // 0x0AF0(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_SideArm");
		return ptr;
	}


	bool STATIC_IsInfiniteFireDevice();
	bool CanEnterCombat();
	void StopFire();
	bool STATIC_InterceptLeftMousePressed(class ATgPlayerController* TgController);
	bool CanFireIfLeftMouseDown();
	void STATIC_EnterTargetingMode();
};


// Class TgGame.TgDevice_SiegeShield
// 0x0000 (0x0AEC - 0x0AEC)
class ATgDevice_SiegeShield : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_SiegeShield");
		return ptr;
	}


	void STATIC_OnDeployableDestroyed(class ATgDeployable* deployable);
	bool ShouldInterruptInhand();
	bool ShouldCooldownAfterFire();
	bool ShouldLockFiring(class ATgDevice* Current);
};


// Class TgGame.TgDevice_Soar
// 0x0004 (0x0AF0 - 0x0AEC)
class ATgDevice_Soar : public ATgDevice
{
public:
	float                                              m_fPrevCollisionHeight;                                   // 0x0AEC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Soar");
		return ptr;
	}


	bool ShouldCancelCrouch();
	bool ShouldLockFiring(class ATgDevice* Current);
	bool ShouldMountCancelFiring();
	bool STATIC_CanBeInterrupted();
	bool STATIC_CanFiringBeCanceledByLeftMouse();
	bool STATIC_CanBeCanceled(class ATgDevice* NewDevice);
	void FireAmmunition();
	float STATIC_GetFiringPostHitDelay(int nMode);
};


// Class TgGame.TgDevice_SoulGust
// 0x0000 (0x0AEC - 0x0AEC)
class ATgDevice_SoulGust : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_SoulGust");
		return ptr;
	}


	bool CanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, TEnumAsByte<EDeviceFailType>* failType);
	bool STATIC_IsDeviceFiringForUI();
};


// Class TgGame.TgDevice_Stim
// 0x0000 (0x0AEC - 0x0AEC)
class ATgDevice_Stim : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Stim");
		return ptr;
	}


	bool ShouldInterruptInhand();
	bool ShouldInterruptReloadOnFire();
	bool ShouldLockFiring(class ATgDevice* Current);
};


// Class TgGame.TgDevice_ToggleWithLockout
// 0x0008 (0x0AF4 - 0x0AEC)
class ATgDevice_ToggleWithLockout : public ATgDevice_Stim
{
public:
	class ATgPawn*                                     m_CachedTgP;                                              // 0x0AEC(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_ToggleWithLockout");
		return ptr;
	}


	void CustomFire();
	void STATIC_LinkedDeviceUnequipped(class ATgDevice* Dev);
	void STATIC_LinkedDeviceEquipped(class ATgDevice* Dev);
	void CompleteInterrupt();
	void StopFire();
	void STATIC_ClientInterrupt(bool bServerFireFailed);
	void STATIC_InterruptFiring(bool bServerFireFailed);
	void SetTransitionPct();
	void FiringEndTransition();
	bool STATIC_IsToggleDevice();
	bool STATIC_CanBeInterrupted();
	bool STATIC_CanBeCanceled(class ATgDevice* NewDevice);
	bool ShouldLockFiring(class ATgDevice* Current);
	class ATgPawn* STATIC_GetCachedTgP();
	bool CanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, TEnumAsByte<EDeviceFailType>* failType);
};


// Class TgGame.TgDevice_ToggleModeWithLockout
// 0x0008 (0x0AFC - 0x0AF4)
class ATgDevice_ToggleModeWithLockout : public ATgDevice_ToggleWithLockout
{
public:
	class ATgDevice*                                   m_CachedInhand;                                           // 0x0AF4(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_ToggleModeWithLockout");
		return ptr;
	}


	void STATIC_LinkedDeviceEquipped(class ATgDevice* Dev);
};


// Class TgGame.TgDevice_WeaponZoom
// 0x0014 (0x0B08 - 0x0AF4)
class ATgDevice_WeaponZoom : public ATgDevice_ToggleWithLockout
{
public:
	struct FPointer                                    VfTable_ITgDeviceInterface_MoveSpeedMultiplier;           // 0x0AF4(0x0008) (Const, Native, NoExport)
	class ATgDevice*                                   m_CachedInhand;                                           // 0x0AFC(0x0008)
	unsigned long                                      m_bDelayMoveSpeedPenalty : 1;                             // 0x0B04(0x0004)
	unsigned long                                      m_bIsZoomed : 1;                                          // 0x0B04(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_WeaponZoom");
		return ptr;
	}


	bool ShouldStopActionOnOffhandSlotReleased();
	bool STATIC_IsFunctionallyToggleDevice();
	bool STATIC_InterceptSlotReleased(class ATgPlayerController* TgController);
	void CompleteInterrupt();
	bool STATIC_IsPlayerToggleZoomSet();
	void STATIC_LinkedDeviceUnequipped(class ATgDevice* Dev);
	void STATIC_LinkedDeviceEquipped(class ATgDevice* Dev);
	bool ShouldLockFiring(class ATgDevice* Current);
	bool CanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, TEnumAsByte<EDeviceFailType>* failType);
	float STATIC_GetMoveSpeedMultiplier();
};


// Class TgGame.TgDevice_TeamDevice
// 0x0000 (0x0AEC - 0x0AEC)
class ATgDevice_TeamDevice : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_TeamDevice");
		return ptr;
	}


	void TeamFlashCooldown(unsigned char nMode);
	void TeamGotoState(const struct FName& NewState);
	void TeamCooldownEnd();
	void TeamCooldownReset(int nMode, float fCooldownTime);
	void TeamCooldownStart(int nMode, float fCooldownTime);
	void TeamCooldownTimerExpired(int nTimerId, TEnumAsByte<ETGT_EVENT> eEvent);
	void STATIC_EndCooldown();
	void STATIC_ResetCooldown(int nMode, float fCooldownTimeOverride);
	void AuthStartCooldown(int nMode, float fCooldownTimeOverride);
	void ToggleCooldownEffects(bool bOnCooldown);
	void FlashCooldown(unsigned char nMode);
	void CheckAndUpdateCooldown();
	class ATgRepInfo_TaskForce* STATIC_GetTaskForce();
	class UTgTimerManager* STATIC_GetCooldownTimerManager();
};


// Class TgGame.TgDevice_ItemStoreBeacon
// 0x0000 (0x0AEC - 0x0AEC)
class ATgDevice_ItemStoreBeacon : public ATgDevice_TeamDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_ItemStoreBeacon");
		return ptr;
	}


	void CustomFire();
	bool CanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, TEnumAsByte<EDeviceFailType>* failType);
	bool STATIC_IsTargetingModeReady(TEnumAsByte<EDeviceFailType>* failType);
	bool STATIC_IsTeamBeaconActive();
	bool STATIC_IsBeaconEnabled();
	class ATgRespawnBeaconExit* STATIC_GetBeaconExit();
};


// Class TgGame.TgDevice_Throw
// 0x0000 (0x0AEC - 0x0AEC)
class ATgDevice_Throw : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Throw");
		return ptr;
	}

};


// Class TgGame.TgDevice_Toggle
// 0x0004 (0x0AF0 - 0x0AEC)
class ATgDevice_Toggle : public ATgDevice
{
public:
	unsigned long                                      m_bIsToggle : 1;                                          // 0x0AEC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Toggle");
		return ptr;
	}


	bool ShouldInterruptReload();
	bool STATIC_IsToggleDevice();
	void ConsumeAmmoFromFiring(int nAmmoConsumptionOverride, int nFireRequestIDOverride);
	bool STATIC_StartFire();
	void FireAmmunition();
	bool CanDeviceFireInTargetingMode();
	bool CanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, TEnumAsByte<EDeviceFailType>* failType);
	void UpdateUIToggleState();
};


// Class TgGame.TgDevice_Mount
// 0x001C (0x0B0C - 0x0AF0)
class ATgDevice_Mount : public ATgDevice_Toggle
{
public:
	unsigned long                                      m_bForceFireDueToRespawn : 1;                             // 0x0AF0(0x0004)
	unsigned long                                      m_bDismountProtection : 1;                                // 0x0AF0(0x0004)
	float                                              m_fZoomDurationOverride;                                  // 0x0AF4(0x0004) (Edit)
	int                                                s_nMountHealthRemaining;                                  // 0x0AF8(0x0004)
	int                                                m_nAutoReloadTransactionID;                               // 0x0AFC(0x0004)
	class ATgDevice*                                   m_CachedInhand;                                           // 0x0B00(0x0008)
	float                                              m_fAutoMountDismountProtectionDuration;                   // 0x0B08(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Mount");
		return ptr;
	}


	bool ShouldCooldownAfterFire();
	void STATIC_LinkedDeviceEquipped(class ATgDevice* Dev);
	bool ShouldInterruptReloadOnFire();
	bool ShouldLockFiring(class ATgDevice* Current);
	void STATIC_InterruptOtherDevices(class ATgPawn* TgP);
	void EndEnteringMount(bool bEndingFireLoop);
	void SetMountedCollision(bool IsActive);
	void STATIC_OutroLockoutTime();
	void AutoDismount();
	void AuthStartCooldown(int nMode, float fCooldownTimeOverride);
	bool STATIC_IsOwnerOnGround();
	void STATIC_OnInterruptEvent();
	void FireAmmunition();
	void SpawnMountMesh();
	bool ShouldMountCancelFiring();
	bool STATIC_CanFiringBeCanceledByRightMouse();
	bool STATIC_IsItemShopVolumeBlockingDismounting();
	bool STATIC_CanBeInterrupted();
	bool STATIC_CanFiringBeCanceledByReactivation();
	bool STATIC_CanBeCanceled(class ATgDevice* NewDevice);
	void EndDismountProtection();
	void DismountOnDamage(int DamageAmt);
	void STATIC_ServerForceMount();
	void ClientStartMount();
	void AllowMountServer();
	void SetAllowMountServerTimer();
	void STATIC_OnOwnerRespawn();
	bool ShouldInterruptADSDevices();
	bool STATIC_IsAnyDeviceOverridingDismount(int DamageAmt);
	bool CanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, TEnumAsByte<EDeviceFailType>* failType);
	bool RequiresAmmoToFire();
	bool STATIC_MustBeOnGroundToFire();
	bool STATIC_IsDeviceFiringLockedForUI();
	float STATIC_GetFiringPreHitDelay(int nMode);
};


// Class TgGame.TgDevice_ToggleInhand
// 0x0010 (0x0AFC - 0x0AEC)
class ATgDevice_ToggleInhand : public ATgDevice
{
public:
	class ATgPawn*                                     m_CachedTgP;                                              // 0x0AEC(0x0008)
	int                                                m_nProjectilesFired;                                      // 0x0AF4(0x0004)
	unsigned long                                      m_bWaitForOutro : 1;                                      // 0x0AF8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_ToggleInhand");
		return ptr;
	}


	void UpdateTransitionPct(float fDefaultPct);
	void StopFire();
	void STATIC_ClientInterrupt(bool bServerFireFailed);
	void STATIC_InterruptFiring(bool bServerFireFailed);
	void STATIC_InitialFirePreHitDelay();
	void STATIC_OutroTimer();
	void STATIC_IntroTimer();
	void StartOutroTimer(float fDuration);
	void StartIntroTimer(float fDuration);
	void FireAmmunition();
	bool STATIC_IsToggleDevice();
	bool STATIC_CanDeviceStartFiringNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDebugRelevant, TEnumAsByte<EDeviceFailType>* failType);
	bool CanToggleDeviceStopFiring();
	bool STATIC_CanBeInterrupted();
	bool STATIC_CanBeCanceled(class ATgDevice* NewDevice);
	float STATIC_GetBaseBuildupTime();
	float STATIC_GetFiringPostHitDelay(int nMode);
	float STATIC_GetFiringPreHitDelay(int nMode);
	float STATIC_GetBuildupTime();
	class ATgPawn* STATIC_GetCachedTgP();
};


// Class TgGame.TgDeviceFire
// 0x0210 (0x0270 - 0x0060)
class UTgDeviceFire : public UObject
{
public:
	class AActor*                                      m_Owner;                                                  // 0x0060(0x0008)
	TEnumAsByte<EWeaponFireType>                       m_nFireType;                                              // 0x0068(0x0001)
	TEnumAsByte<EDeviceTargetMode>                     m_eTargetingMode;                                         // 0x0069(0x0001)
	TEnumAsByte<EDeviceTargeterType>                   m_eTargeterType;                                          // 0x006A(0x0001)
	TEnumAsByte<ETargetSelectionType>                  m_eTargetSelectionTypeOverride;                           // 0x006B(0x0001)
	unsigned long                                      m_bIsAOE : 1;                                             // 0x006C(0x0004)
	unsigned long                                      m_bIsCone : 1;                                            // 0x006C(0x0004)
	unsigned long                                      m_bIsLinear : 1;                                          // 0x006C(0x0004)
	unsigned long                                      m_bContinuousFire : 1;                                    // 0x006C(0x0004)
	unsigned long                                      m_bRequireLOS : 1;                                        // 0x006C(0x0004)
	unsigned long                                      m_bVerifyTargetPlacement : 1;                             // 0x006C(0x0004)
	unsigned long                                      m_bAllowMultiplePets : 1;                                 // 0x006C(0x0004)
	unsigned long                                      m_bUseAccurateEncroachment : 1;                           // 0x006C(0x0004) (Const)
	unsigned long                                      m_bUseTargetingEncroachmentActor : 1;                     // 0x006C(0x0004) (Const)
	unsigned long                                      m_bScaleEncroachmentWithRangeMod : 1;                     // 0x006C(0x0004) (Const)
	unsigned long                                      m_bPassThroughShield : 1;                                 // 0x006C(0x0004) (Const)
	unsigned long                                      m_bPassThroughDeployWalls : 1;                            // 0x006C(0x0004) (Const)
	unsigned long                                      m_bIgnoreDeployablesForBlocking : 1;                      // 0x006C(0x0004) (Const)
	unsigned long                                      m_bAdjustDeployHeightToExtent : 1;                        // 0x006C(0x0004)
	unsigned long                                      m_bDeployOnOwnerLocation : 1;                             // 0x006C(0x0004)
	unsigned long                                      m_bAdjustToGround : 1;                                    // 0x006C(0x0004)
	unsigned long                                      m_bSpawnPetOnOwnerLocation : 1;                           // 0x006C(0x0004)
	unsigned long                                      m_bCanTriggerCounter : 1;                                 // 0x006C(0x0004)
	unsigned long                                      m_bEnchroachmentFireLOSCheck : 1;                         // 0x006C(0x0004)
	unsigned long                                      m_bEnchroachmentIgnorePitch : 1;                          // 0x006C(0x0004)
	unsigned long                                      m_bEncroachmentDebug : 1;                                 // 0x006C(0x0004)
	unsigned long                                      m_bTreatAmmoAsCharges : 1;                                // 0x006C(0x0004)
	unsigned long                                      m_bMaintainBurstTarget : 1;                               // 0x006C(0x0004)
	unsigned long                                      m_bCanTargetStealthedTargets : 1;                         // 0x006C(0x0004)
	TArray<class UTgEffectGroup*>                      m_EffectGroupList;                                        // 0x0070(0x0010) (NeedCtorLink)
	TArray<struct FTgPropertyInstance>                 m_Properties;                                             // 0x0080(0x0010) (NeedCtorLink)
	struct FPointer                                    m_pAmSetup;                                               // 0x0090(0x0008) (Native)
	struct FPointer                                    m_pFireModeSetup;                                         // 0x0098(0x0008) (Native)
	int                                                m_nId;                                                    // 0x00A0(0x0004)
	int                                                m_nAttackType;                                            // 0x00A4(0x0004)
	int                                                m_nMovementType;                                          // 0x00A8(0x0004)
	struct FName                                       m_nmOffhandAnimationType;                                 // 0x00AC(0x0008)
	int                                                m_nTargetAffectsType;                                     // 0x00B4(0x0004)
	int                                                m_nAllowUseWhileFlags;                                    // 0x00B8(0x0004)
	int                                                m_nDamageType;                                            // 0x00BC(0x0004)
	int                                                m_nArcingJumps;                                           // 0x00C0(0x0004)
	struct FMap_Mirror                                 m_PropertyIndexMap;                                       // 0x00C4(0x0048) (Native)
	float                                              m_fHealthCost;                                            // 0x010C(0x0004)
	float                                              m_fManaCost;                                              // 0x0110(0x0004)
	float                                              m_fEnergyCost;                                            // 0x0114(0x0004)
	float                                              m_fFireTime;                                              // 0x0118(0x0004)
	float                                              m_fBuildupTime;                                           // 0x011C(0x0004)
	float                                              m_fFirePreHitDelay;                                       // 0x0120(0x0004)
	float                                              m_fFirePostHitDelay;                                      // 0x0124(0x0004)
	int                                                m_nShotsPerFire;                                          // 0x0128(0x0004)
	struct FName                                       m_nmDamageTypeClass;                                      // 0x012C(0x0008)
	class UClass*                                      m_DamageTypeClass;                                        // 0x0134(0x0008)
	int                                                m_nMaxTargetCount;                                        // 0x013C(0x0004)
	float                                              m_fFireLockTime;                                          // 0x0140(0x0004)
	float                                              m_fZoomTime;                                              // 0x0144(0x0004)
	float                                              m_fZoomFOV;                                               // 0x0148(0x0004)
	int                                                m_nAmmoCarriedSize;                                       // 0x014C(0x0004)
	int                                                m_nAmmoClipSize;                                          // 0x0150(0x0004)
	float                                              m_fAmmoClipPreReloadTime;                                 // 0x0154(0x0004)
	float                                              m_fAmmoClipPostReloadTime;                                // 0x0158(0x0004)
	int                                                m_nAmmoCostPerShot;                                       // 0x015C(0x0004)
	int                                                m_nAmmoEfficiency;                                        // 0x0160(0x0004)
	float                                              m_fEncroachmentRayCastVerticalOffset;                     // 0x0164(0x0004) (Const)
	int                                                m_nTargetingEncroachmentActorOverride;                    // 0x0168(0x0004) (Const)
	class AActor*                                      m_TargetingEncroachmentActor;                             // 0x016C(0x0008) (Transient)
	struct FVector                                     m_vActorEncroachmentBaseScale;                            // 0x0174(0x000C) (Const)
	struct FName                                       m_nmWhileFiringCameraAnim;                                // 0x0180(0x0008)
	struct FRotator                                    m_AdjustToGroundRotationOffset;                           // 0x0188(0x000C)
	TArray<class UTgEffect*>                           m_CachedRechargeBonusFlatAdditive;                        // 0x0194(0x0010) (NeedCtorLink)
	TArray<class UTgEffect*>                           m_CachedRechargeBonusFlatSubtractive;                     // 0x01A4(0x0010) (NeedCtorLink)
	TArray<class UTgEffect*>                           m_CachedRechargeBonusPercentAdditive;                     // 0x01B4(0x0010) (NeedCtorLink)
	TArray<class UTgEffect*>                           m_CachedRechargeBonusPercentSubtractive;                  // 0x01C4(0x0010) (NeedCtorLink)
	TArray<class UTgEffect*>                           m_ModifiedEffects;                                        // 0x01D4(0x0010) (NeedCtorLink)
	TArray<float>                                      m_BaseValues;                                             // 0x01E4(0x0010) (NeedCtorLink)
	TArray<class UTgEffectGroup*>                      m_ModifiedEGLifetimes;                                    // 0x01F4(0x0010) (NeedCtorLink)
	TArray<float>                                      m_BaseLifetimes;                                          // 0x0204(0x0010) (NeedCtorLink)
	TArray<class UTgEffectGroup*>                      m_ModifiedEGAppValues;                                    // 0x0214(0x0010) (NeedCtorLink)
	TArray<float>                                      m_BaseAppValues;                                          // 0x0224(0x0010) (NeedCtorLink)
	TArray<class UTgEffectGroup*>                      m_ModifiedEGMaxStacks;                                    // 0x0234(0x0010) (NeedCtorLink)
	TArray<float>                                      m_BaseMaxStacks;                                          // 0x0244(0x0010) (NeedCtorLink)
	TArray<class AActor*>                              m_CachedTargetList;                                       // 0x0254(0x0010) (NeedCtorLink)
	float                                              m_fSelectTargetsExtent;                                   // 0x0264(0x0004)
	class UTgGameplayCurves*                           m_GameplayCurves;                                         // 0x0268(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire");
		return ptr;
	}


	bool STATIC_HandleCustomPlayerKnockbackHit(class AActor* TargetPrimary, const struct FImpactInfo& ImpactPrimary, class AActor* TargetSecondary, const struct FImpactInfo& ImpactSecondary);
	bool STATIC_HandleCustomWallKnockbackHit(class AActor* Target, const struct FImpactInfo& Impact);
	bool CanSimulateTeleportFire();
	int STATIC_GetNumArcJumps();
	float STATIC_GetConeAttackAngleOffset();
	float STATIC_GetSignedConeAttackAngle();
	float STATIC_GetConeAttackAngle();
	float STATIC_GetContagiousRadius();
	float STATIC_GetMinCooldownTime();
	float STATIC_GetCooldownTime();
	float STATIC_GetFireLockTime();
	float STATIC_GetPostHitDelay();
	float STATIC_GetPreHitDelay();
	float STATIC_GetBuildupTime();
	float STATIC_GetRefireTime();
	void SubmitWhileDeadEffects(class AActor* DamageInstigator, const struct FImpactInfo& Impact);
	void SubmitFinalBlowEffects(class AActor* DamageInstigator, const struct FImpactInfo& Impact);
	void SubmitHitEffects(class AActor* DamageInstigator, const struct FImpactInfo& Impact, int nType);
	void STATIC_HandleSuccessfulHit(class AActor* DamageInstigator, class APawn* OwnerInstigator, const struct FImpactInfo& Impact);
	void STATIC_HandleMiss();
	bool STATIC_ApplyHit(const struct FImpactInfo& Impact, class AActor* DamageInstigator);
	void TrackDeviceModeHit(class ATgPawn* Hitter, float fDistance, bool bHitPlayer);
	void STATIC_RemoveHitSpecial(class AActor* Target, bool bForceRemove, int nHitSpecialSituationalType, int StackCount);
	void STATIC_ApplyHitSpecial(class AActor* Target, const struct FImpactInfo& Impact, int nHitSpecialSituationalType, int StackCount);
	void STATIC_RemoveEffectType(class AActor* Target, bool bForceRemove, int nEffectGroupType, int StackCount);
	void STATIC_ApplyEffectType(class AActor* Target, int nEffectGroupType, const struct FImpactInfo& Impact, int StackCount);
	void DisplayMessage(const struct FString& sMessage);
	void RemoveModifyEffects();
	void ApplyModifyEffects(class UTgEffectGroup* effectGroup);
	void SubmitEffect(const struct FImpactInfo& Impact, class UTgEffectGroup* effectGroup, bool bRemove, int StackCount, class AActor* InstigatorOverride);
	void STATIC_RemoveEquipEffects();
	void STATIC_ApplyEquipEffects();
	float STATIC_GetBasePropertyValueById(int nPropertyId);
	float STATIC_GetScaledPropertyValueByRef(int nDeviceLevel, struct FTgPropertyInstance* PropInst);
	float STATIC_GetScaledPropertyValueById(int nPropertyId, int nDeviceLevel);
	class UTgGameplayCurves* STATIC_GetCurrentGameplayCurves();
	struct FVector STATIC_GetAlternateAOEStartTrace(class AActor* DamageInstigator, float Radius, struct FVector* Center);
	struct FWeaponFireResults CalcActorEncroachmentTargetingFire(class AActor* DamageInstigator, const struct FAimData& Aim, bool bPredicting, float RewindTime, TArray<struct FImpactInfo>* ImpactList, TArray<struct FImpactToValidate>* ImpactsToValidate);
	struct FImpactInfo CalcChargeTargetingFire(class AActor* DamageInstigator, const struct FAimData& Aim, bool bPredicting, TArray<struct FImpactInfo>* ImpactList);
	struct FImpactInfo CalcDeployableTargetingFire(class AActor* DamageInstigator, const struct FAimData& Aim, int nDeployableId, bool bPredicting, TArray<struct FImpactInfo>* ImpactList);
	struct FImpactInfo CalcLinearFire(class AActor* DamageInstigator, const struct FAimData& Aim, bool bPredicting, TArray<struct FImpactInfo>* ImpactList);
	struct FImpactInfo CalcArcingFire(class AActor* DamageInstigator, const struct FAimData& Aim, bool bPredicting, TArray<struct FImpactInfo>* ImpactList);
	struct FWeaponFireResults CalcInstantFire(class AActor* DamageInstigator, const struct FAimData& Aim, bool bPredicting, bool bNoBodyShotCheck, float RewindTime, TArray<struct FImpactInfo>* ImpactList, TArray<struct FImpactToValidate>* ImpactsToValidate);
	struct FImpactInfo CalcAoeFire(class AActor* DamageInstigator, const struct FAimData& Aim, bool bPredicting, float RewindTime, TArray<struct FImpactInfo>* ImpactList);
	struct FImpactInfo CalcSliceFire(class AActor* DamageInstigator, const struct FAimData& Aim, bool bUseRange, bool bPredicting, TArray<struct FImpactInfo>* ImpactList);
	struct FImpactInfo CalcConeFire(class AActor* DamageInstigator, const struct FAimData& Aim, bool bUseRange, bool bPredicting, TArray<struct FImpactInfo>* ImpactList);
	struct FWeaponFireResults CalcWeaponModeFire(class AActor* DamageInstigator, const struct FAimData& Aim, bool bPredicting, bool bNoBodyShotCheck, float RewindTime, TArray<struct FImpactInfo>* ImpactList, TArray<struct FImpactToValidate>* ImpactsToValidate);
	bool CheckValidTarget(class AActor* Target, bool bPredicting);
	bool STATIC_IsInCone(class AActor* SourceActor, class AActor* TargetActor, const struct FVector& StartCone, const struct FVector& ConeDir, float ConeAngle);
	bool STATIC_IsInSlice(class AActor* SourceActor, class AActor* TargetActor, const struct FVector& StartCone, const struct FVector& ConeDir, float ConeAngle, float ConeRadius);
	bool ShouldAddToImpactList(class AActor* HitActor, TArray<struct FImpactInfo> ImpactList);
	struct FVector STATIC_GetHitLocationToCenter(struct FVector* StartTrace, struct FVector* TargetLocation, struct FVector* targetExtent);
	struct FVector STATIC_GetHitLocationFlat(struct FVector* StartTrace, struct FVector* TargetLocation, struct FVector* targetExtent);
	bool STATIC_IgnoreTargetForBlocking(class AActor* Target);
	class AActor* STATIC_IsBlockedByBlocker(class AActor* DamageInstigator, class AActor* Target, const struct FVector& OriginLocation, const struct FVector& TargetLocation);
	TEnumAsByte<EDeviceTargetMode> STATIC_GetTargetingMode();
	void AddEffectiveRangeReduction(class AActor* DamageInstigator, const struct FVector& OriginLocation, bool bUseRadius, struct FImpactInfo* Impact);
	float STATIC_GetShotPowerCost(int nPacingType);
	bool UsesActorEncroachmentForCalcTargetingFire();
	bool STATIC_IsArcingAttack();
	struct FImpactInfo STATIC_GetTraceImpact(const struct FVector& StartTrace, const struct FVector& EndTrace, const struct FVector& Extent, bool bIgnoreWorld, bool bCheckLockOn, bool bForceNoBodyShotCheck, float RewindTime, int nShotIndex, TArray<struct FImpactToValidate>* ImpactsToValidate);
	bool IsEnemy(class AActor* TargetActor);
	bool STATIC_IsSelfOrOwner(class AActor* Target);
	bool STATIC_IsValidTarget(class AActor* P, TEnumAsByte<EDeviceTargeterType> eTargeterType, bool bIgnoreHealth, bool bInvertTeam);
	bool STATIC_CheckTeamPassThrough(class AActor* HitActor, const struct FVector& aimDirection);
	float STATIC_GetCustomValue5();
	float STATIC_GetCustomValue4();
	float STATIC_GetCustomValue3();
	float STATIC_GetCustomValue2();
	float STATIC_GetCustomValue1();
	bool STATIC_IsWithinEffectiveRange(float fDistance);
	bool STATIC_IsWithinRange(float fDistance);
	float STATIC_GetBonusShieldDamagePerc();
	float STATIC_GetHeadShotDamage();
	float STATIC_GetMaxDeployableCount();
	float STATIC_GetMinimumRadius();
	float STATIC_GetEffectiveRange();
	float STATIC_GetMinRange();
	float GetRange();
	float STATIC_GetProximityDistance();
	float STATIC_GetVisionRange();
	float STATIC_GetProjectileSpeed();
	float STATIC_GetDeployTime();
	float STATIC_GetFireAngle();
	float STATIC_GetPetLifeSpan();
	float STATIC_GetPersistPulse();
	float STATIC_GetPersistTime();
	float STATIC_GetEffectiveRadius();
	float STATIC_GetPostLandDuration();
	float STATIC_GetRemoteActivationTime();
	float STATIC_GetAIRadius();
	float STATIC_GetAIRange();
	float STATIC_GetDamageRadius();
	bool STATIC_LogDebugInfo();
	void VerifyProjectile();
	bool STATIC_IsBlockedByGeometry(class AActor* SourceActor, class AActor* TargetActor);
	struct FName QueryClass(int nMode);
	class UTgEffectGroup* STATIC_GetEffectGroup(int nType, int* nIndex);
	bool SupportsEffectSimulation();
	float STATIC_GetPropertyValueById(int nPropertyId, int nPropertyIndex);
	float STATIC_GetPropertyValue(int nPropertyId);
	void SetPropertyInstance(struct FTgPropertyInstance* prop);
	void SetProperty(int nPropertyId, float fNewValue);
	struct FTgPropertyInstance STATIC_GetProperty(int nPropertyId);
	void TeleportFire();
	void CustomFire();
	bool STATIC_GetPetLocationAndRotation(const struct FPointer& botSetup, struct FVector* OutLocation, struct FRotator* OutRotation);
	class ATgPawn* SpawnPet(bool bPet);
	class AActor* STATIC_GetDeployableBase();
	bool STATIC_GetDeployLocationAndRotation(struct FVector* OutLocation, struct FRotator* OutRotation);
	class ATgDeployable* Deploy();
	class ATgDeployable* DeployAtLocation(const struct FVector& SpawnLocation, const struct FRotator& SpawnRotation);
	class ATgDeployable* DeployAtActor(class AActor* TargetActor);
	void STATIC_InitializeProjectile(class AProjectile* Proj);
	class UClass* STATIC_GetProjectileClass();
	void SpecialShieldDestroyed();
};


// Class TgGame.TgDeviceFire_BonusShieldDamage
// 0x0000 (0x0270 - 0x0270)
class UTgDeviceFire_BonusShieldDamage : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_BonusShieldDamage");
		return ptr;
	}


	float STATIC_GetBonusShieldDamagePerc();
};


// Class TgGame.TgDeviceFire_Cylinder
// 0x0000 (0x0270 - 0x0270)
class UTgDeviceFire_Cylinder : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Cylinder");
		return ptr;
	}


	struct FImpactInfo CalcAoeFire(class AActor* DamageInstigator, const struct FAimData& Aim, bool bPredicting, float RewindTime, TArray<struct FImpactInfo>* ImpactList);
};


// Class TgGame.TgDeviceFire_DeployablesOnly
// 0x0000 (0x0270 - 0x0270)
class UTgDeviceFire_DeployablesOnly : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_DeployablesOnly");
		return ptr;
	}


	bool STATIC_IsValidTarget(class AActor* P, TEnumAsByte<EDeviceTargeterType> eTargeterType, bool bIgnoreHealth, bool bInvertTeam);
};


// Class TgGame.TgDeviceFire_DeployOnLocation
// 0x000C (0x027C - 0x0270)
class UTgDeviceFire_DeployOnLocation : public UTgDeviceFire
{
public:
	struct FVector                                     m_TargetLocation;                                         // 0x0270(0x000C)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_DeployOnLocation");
		return ptr;
	}


	bool STATIC_GetDeployLocationAndRotation(struct FVector* OutLocation, struct FRotator* OutRotation);
};


// Class TgGame.TgDeviceFire_DeployOnTarget
// 0x000C (0x027C - 0x0270)
class UTgDeviceFire_DeployOnTarget : public UTgDeviceFire
{
public:
	class AActor*                                      m_TargetHit;                                              // 0x0270(0x0008)
	unsigned long                                      m_bDeployAtFeet : 1;                                      // 0x0278(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_DeployOnTarget");
		return ptr;
	}


	class AActor* STATIC_GetDeployableBase();
	bool STATIC_GetDeployLocationAndRotation(struct FVector* OutLocation, struct FRotator* OutRotation);
};


// Class TgGame.TgDeviceFire_DragonBlast
// 0x0000 (0x0270 - 0x0270)
class UTgDeviceFire_DragonBlast : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_DragonBlast");
		return ptr;
	}

};


// Class TgGame.TgDeviceFire_DragonBreath
// 0x0000 (0x0270 - 0x0270)
class UTgDeviceFire_DragonBreath : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_DragonBreath");
		return ptr;
	}

};


// Class TgGame.TgDeviceFire_HolyHammer
// 0x0000 (0x0270 - 0x0270)
class UTgDeviceFire_HolyHammer : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_HolyHammer");
		return ptr;
	}

};


// Class TgGame.TgDeviceFire_IgnoreCounter
// 0x0000 (0x0270 - 0x0270)
class UTgDeviceFire_IgnoreCounter : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_IgnoreCounter");
		return ptr;
	}

};


// Class TgGame.TgDeviceFire_IgnorePets
// 0x0000 (0x0270 - 0x0270)
class UTgDeviceFire_IgnorePets : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_IgnorePets");
		return ptr;
	}


	bool STATIC_IsValidTarget(class AActor* P, TEnumAsByte<EDeviceTargeterType> eTargeterType, bool bIgnoreHealth, bool bInvertTeam);
};


// Class TgGame.TgDeviceFire_IgnoreReversal
// 0x0000 (0x0270 - 0x0270)
class UTgDeviceFire_IgnoreReversal : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_IgnoreReversal");
		return ptr;
	}


	bool STATIC_IgnoreTargetForBlocking(class AActor* Target);
};


// Class TgGame.TgDeviceFire_Melee
// 0x0000 (0x0270 - 0x0270)
class UTgDeviceFire_Melee : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Melee");
		return ptr;
	}


	bool ShouldAddToImpactList(class AActor* HitActor, TArray<struct FImpactInfo> ImpactList);
	bool STATIC_IgnoreTargetForBlocking(class AActor* Target);
};


// Class TgGame.TgDeviceFire_MirrorDamageToHeal
// 0x0004 (0x0274 - 0x0270)
class UTgDeviceFire_MirrorDamageToHeal : public UTgDeviceFire
{
public:
	float                                              m_fHealAmount;                                            // 0x0270(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_MirrorDamageToHeal");
		return ptr;
	}


	void SubmitEffect(const struct FImpactInfo& Impact, class UTgEffectGroup* effectGroup, bool bRemove, int StackCount, class AActor* InstigatorOverride);
};


// Class TgGame.TgDeviceFire_MirrorDamageToHealBlock
// 0x0004 (0x0274 - 0x0270)
class UTgDeviceFire_MirrorDamageToHealBlock : public UTgDeviceFire
{
public:
	float                                              m_fHealBlockAmount;                                       // 0x0270(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_MirrorDamageToHealBlock");
		return ptr;
	}


	void SubmitEffect(const struct FImpactInfo& Impact, class UTgEffectGroup* effectGroup, bool bRemove, int StackCount, class AActor* InstigatorOverride);
};


// Class TgGame.TgDeviceFire_PetsOnly
// 0x0000 (0x0270 - 0x0270)
class UTgDeviceFire_PetsOnly : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_PetsOnly");
		return ptr;
	}


	bool STATIC_IsValidTarget(class AActor* P, TEnumAsByte<EDeviceTargeterType> eTargeterType, bool bIgnoreHealth, bool bInvertTeam);
};


// Class TgGame.TgDeviceFire_ShieldsOnly
// 0x0000 (0x0270 - 0x0270)
class UTgDeviceFire_ShieldsOnly : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_ShieldsOnly");
		return ptr;
	}


	bool STATIC_IsValidTarget(class AActor* P, TEnumAsByte<EDeviceTargeterType> eTargeterType, bool bIgnoreHealth, bool bInvertTeam);
};


// Class TgGame.TgDeviceFire_Spray
// 0x0000 (0x0270 - 0x0270)
class UTgDeviceFire_Spray : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Spray");
		return ptr;
	}


	struct FWeaponFireResults CalcWeaponModeFire(class AActor* DamageInstigator, const struct FAimData& Aim, bool bPredicting, bool bNoBodyShotCheck, float RewindTime, TArray<struct FImpactInfo>* ImpactList, TArray<struct FImpactToValidate>* ImpactsToValidate);
};


// Class TgGame.TgDeviceFire_WorldLOSOnly
// 0x0000 (0x0270 - 0x0270)
class UTgDeviceFire_WorldLOSOnly : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_WorldLOSOnly");
		return ptr;
	}


	bool STATIC_IgnoreTargetForBlocking(class AActor* Target);
};


// Class TgGame.TgDeviceForm
// 0x025C (0x02BC - 0x0060)
class UTgDeviceForm : public UObject
{
public:
	struct FPointer                                    VfTable_FCallbackEventDevice;                             // 0x0060(0x0008) (Const, Native, NoExport)
	class ATgPawn*                                     PawnOwner;                                                // 0x0068(0x0008)
	struct FEquipDeviceInfo                            c_EquipDeviceInfo;                                        // 0x0070(0x0014)
	int                                                m_nDeviceType;                                            // 0x0084(0x0004)
	int                                                m_nDeviceSubtype;                                         // 0x0088(0x0004)
	TEnumAsByte<EDeviceTargetMode>                     m_eTargetingMode;                                         // 0x008C(0x0001)
	TEnumAsByte<EDeviceSubtype>                        c_eDeviceSubtype;                                         // 0x008D(0x0001)
	TEnumAsByte<EeMovementType>                        c_eMovementType;                                          // 0x008E(0x0001)
	TEnumAsByte<ETargetingModeStatus>                  c_eTargetingModeStatus;                                   // 0x008F(0x0001)
	TEnumAsByte<ESCOPETYPE>                            c_eScopeType;                                             // 0x0090(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0091(0x0003) MISSED OFFSET
	unsigned long                                      c_bDeployed : 1;                                          // 0x0094(0x0004)
	unsigned long                                      c_bHandDevice : 1;                                        // 0x0094(0x0004)
	unsigned long                                      c_bDisableDefaultTimelapseRecovery : 1;                   // 0x0094(0x0004)
	unsigned long                                      c_bIsTransitioningToNewMode : 1;                          // 0x0094(0x0004)
	unsigned long                                      c_bTargetingModeEnabled : 1;                              // 0x0094(0x0004)
	unsigned long                                      c_bTargeterInitializedThisTick : 1;                       // 0x0094(0x0004)
	unsigned long                                      c_bTargeterIsInWorldDPG : 1;                              // 0x0094(0x0004)
	unsigned long                                      c_bUseInstigatorMesh : 1;                                 // 0x0094(0x0004)
	unsigned long                                      c_bIsInHand : 1;                                          // 0x0094(0x0004)
	unsigned long                                      m_bInitializingAssets : 1;                                // 0x0094(0x0004)
	unsigned long                                      m_bLoopWhileFiringCameraAnim : 1;                         // 0x0094(0x0004)
	unsigned long                                      m_bUseImpactFXOverride : 1;                               // 0x0094(0x0004)
	unsigned long                                      m_bRecoilTimerActive : 1;                                 // 0x0094(0x0004)
	unsigned long                                      m_bForceBlendOutOnAnimEnd : 1;                            // 0x0094(0x0004)
	TArray<class UAnimSet*>                            c_PawnAnimSetOverrideList;                                // 0x0098(0x0010) (NeedCtorLink)
	TArray<struct FModeData>                           ModeDatas;                                                // 0x00A8(0x0010) (NeedCtorLink)
	struct FPointer                                    m_pAmSetup;                                               // 0x00B8(0x0008) (Native)
	class UMeshComponent*                              c_Mesh;                                                   // 0x00C0(0x0008) (ExportObject, Component, EditInline)
	class UMeshComponent*                              c_AttachedMesh;                                           // 0x00C8(0x0008) (ExportObject, Component, EditInline)
	class UMeshComponent*                              c_ThirdPersonMesh;                                        // 0x00D0(0x0008) (ExportObject, Component, EditInline)
	class UTgSkeletalMeshComponent*                    c_FirstPersonMesh;                                        // 0x00D8(0x0008) (ExportObject, Component, EditInline)
	struct FName                                       c_nmMountPoint;                                           // 0x00E0(0x0008)
	struct FName                                       FormState;                                                // 0x00E8(0x0008)
	int                                                c_nFireMode;                                              // 0x00F0(0x0004)
	int                                                c_nEquipSlot;                                             // 0x00F4(0x0004)
	float                                              c_fLastReceivedRefireTime;                                // 0x00F8(0x0004)
	int                                                c_nLastFxMode;                                            // 0x00FC(0x0004)
	class ATgSkeletalMeshActor*                        c_TargetingModeMeshIndicator;                             // 0x0100(0x0008)
	class UTgSpecialFx*                                c_TargetingModeFx;                                        // 0x0108(0x0008)
	struct FAimData                                    c_TargetingAim;                                           // 0x0110(0x0034)
	int                                                c_nTargetingModeFxId;                                     // 0x0144(0x0004)
	float                                              c_fRemainingTransitionTime;                               // 0x0148(0x0004)
	float                                              c_fTotalTransitionTime;                                   // 0x014C(0x0004)
	class AActor*                                      m_LockedTarget;                                           // 0x0150(0x0008)
	float                                              m_fCachedZoomedFOV;                                       // 0x0158(0x0004)
	class UObjectReferencer*                           m_AssetReference;                                         // 0x015C(0x0008)
	class AActor*                                      m_OwnerActor;                                             // 0x0164(0x0008)
	TArray<class UTgAnimNodeBlendByAbilitySimple*>     m_AbilityBlendList1P;                                     // 0x016C(0x0010) (NeedCtorLink)
	TArray<class UTgAnimNodeBlendByAbilitySimple*>     m_AbilityBlendList3P;                                     // 0x017C(0x0010) (NeedCtorLink)
	TArray<class UTgAnimNodeChannelFire*>              m_ChannelFireBlendList1P;                                 // 0x018C(0x0010) (NeedCtorLink)
	TArray<class UTgAnimNodeChannelFire*>              m_ChannelFireBlendList3P;                                 // 0x019C(0x0010) (NeedCtorLink)
	TArray<class UTgAnimNodeTargeting*>                m_TargetingBlendList1P;                                   // 0x01AC(0x0010) (NeedCtorLink)
	TArray<class UTgAnimNodeTargeting*>                m_TargetingBlendList3P;                                   // 0x01BC(0x0010) (NeedCtorLink)
	TArray<class UTgAnimNodeToggleWithTransition*>     m_ToggleTransitionNodes1P;                                // 0x01CC(0x0010) (NeedCtorLink)
	TArray<class UTgAnimNodeToggleWithTransition*>     m_ToggleTransitionNodes3P;                                // 0x01DC(0x0010) (NeedCtorLink)
	TArray<class UTgAnimBlendByAmmo*>                  m_AmmoBlendList1P;                                        // 0x01EC(0x0010) (NeedCtorLink)
	TArray<class UTgAnimBlendByAmmo*>                  m_AmmoBlendList3P;                                        // 0x01FC(0x0010) (NeedCtorLink)
	TArray<class UTgAnimNodeSequence_SyncToCooldown*>  m_CooldownSyncNode1P;                                     // 0x020C(0x0010) (NeedCtorLink)
	TArray<class UTgAnimNodeSequence_SyncToCooldown*>  m_CooldownSyncNode3P;                                     // 0x021C(0x0010) (NeedCtorLink)
	TArray<class UTgAnimNodeBlendByDeviceEquipped*>    m_DeviceEquippedNode1P;                                   // 0x022C(0x0010) (NeedCtorLink)
	TArray<class UTgAnimNodeBlendByDeviceEquipped*>    m_DeviceEquippedNode3P;                                   // 0x023C(0x0010) (NeedCtorLink)
	TArray<class UTgAnimBlendByRecoilTime*>            m_BlendByRecoilTimeNodes;                                 // 0x024C(0x0010) (NeedCtorLink)
	class UCameraAnimInst*                             m_WhileFiringCameraAnimInst;                              // 0x025C(0x0008)
	float                                              m_fWhileFiringCameraAnimBlendInTime;                      // 0x0264(0x0004)
	float                                              m_fWhileFiringCameraAnimBlendOutTime;                     // 0x0268(0x0004)
	struct FPointer                                    m_RandomShotSpreadStream;                                 // 0x026C(0x0008) (Const, Native, Transient)
	int                                                m_nLastSetShotSpreadSeed;                                 // 0x0274(0x0004)
	class UTgGameplayCurves*                           m_GameplayCurves;                                         // 0x0278(0x0008)
	float                                              m_fRecoilTimer;                                           // 0x0280(0x0004)
	float                                              m_fTransitionAmount;                                      // 0x0284(0x0004)
	float                                              m_fTransitionPerSec;                                      // 0x0288(0x0004)
	float                                              m_fLastSetWorldFOVInterp;                                 // 0x028C(0x0004)
	class UAnimSet*                                    m_pWeaponAnimSet;                                         // 0x0290(0x0008)
	class UAnimSet*                                    m_pPutAwayAnimSet;                                        // 0x0298(0x0008)
	class UAnimSet*                                    m_pBucketAnimSet;                                         // 0x02A0(0x0008)
	struct FVector                                     m_vZoomCameraOffset;                                      // 0x02A8(0x000C)
	float                                              m_fSimulatedDeviceCooldown;                               // 0x02B4(0x0004)
	int                                                m_nLastAmmoAmount;                                        // 0x02B8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm");
		return ptr;
	}


	void STATIC_OnDestroyed();
	void STATIC_OnRetrieveAnimDone();
	void RecoverDeviceState(TEnumAsByte<ETG_REP_DEVICE_STATE> DesiredState);
	void SetToggleState(bool IsActive);
	void STATIC_OnHoldTimerFinished();
	void StartFireHoldAnimation(float fFireHoldTime);
	void STATIC_PlayToggleTransitionAnimations(float transitionPercent, float totalTransitionTime, bool transitionToActive);
	void STATIC_GotoFormState(const struct FName& NewState);
	void EndCurrentState();
	void STATIC_AttachAndDeploy_DA();
	void STATIC_DeviceAnimNotify();
	void STATIC_DoInterrupt();
	void STATIC_CooldownComplete();
	void STATIC_Cooldown(int nFireModeNum, float fCooldownTime);
	void STATIC_Hit(int nFireMode, class AActor* Target, float fDamageAmount, const struct FVector& HitLocation, const struct FVector& HitNormal, struct FExtraDamageInfo* ExtraInfo);
	void RecoverFireMultiHitLocations(float fDistUnit, int nSeed, float fSpreadAngle, int nNumShots, TArray<struct FVector>* vHitLocations, struct FVector* vAimStart, struct FVector* vAimDir, unsigned char* hitRanges);
	void STATIC_FireMultiUnpacked(TArray<struct FVector> vHitLocations, int nFireMode, int nEquipSlot, int nSocketIndex, bool bSuccessfulHit, float fRefireTime, float fPackedDistanceUnit);
	void STATIC_FireMulti(const struct FVector& vAimStart, const struct FVector& vAimDir, int nFireMode, float fMaxRange, int nSeed, float fSpreadAngle, int nNumShots, int nEquipSlot, int nSocketIndex, bool bSuccessfulHit, float fRefireTime, unsigned char* hitRanges);
	void STATIC_Fire(const struct FVector& HitLocation, int nFireMode, int nEquipSlot, int nSocketIndex, bool bSuccessfulHit, float fRefireTime);
	void StopFire(int nFireModeNum);
	void STATIC_OnEndViewTarget(class APlayerController* PC);
	void StopWhileFiringCameraAnim(class APlayerController* PC, bool bImmediate);
	void StartWhileFiringCameraAnim(class APlayerController* PC, int nFireMode);
	void STATIC_StartFire(int nFireMode, float fRefireTime, class AActor* Target, int nAmmoRemaining);
	bool STATIC_IsCurrentInHandWeapon();
	class UTgDeviceForm* STATIC_InHandWeaponForm();
	void STATIC_BuildUp(int nFireMode, int nEquipSlot, int nSocketIndex, float fBuildupTime);
	void STATIC_FireHoldFull(bool bIsFull);
	void STATIC_InterruptTargeting();
	void STATIC_EnterTargeting();
	void STATIC_ExitTargetingMode();
	void STATIC_NotifyTargetingModeStatusChange();
	void STATIC_NotifyEnterTargetingMode();
	void STATIC_NotifyExitTargetingMode(bool bDeployed);
	void STATIC_EnterTargetingMode();
	void STATIC_InitializeTargetingModeFX();
	void EndDevicePuttingDown();
	void STATIC_BeginDeviceTakingOut(bool PlayEquipAnim);
	void STATIC_BeginActive();
	void STATIC_ParticleSystemDone(class UParticleSystemComponent* PSC);
	void STATIC_PlayImpactEffects(const struct FVector& HitLocation, int nEquipSlot, int nSocketIndex, bool bSuccessfulHit, const struct FVector& FireOrigin, float fHitTraceDistOverride, bool bGenerateUpdatedHitLocation);
	void SetTargetArcingBeamEffect(class AActor* Target);
	void SetSourceArcingBeamEffect(class AActor* Source);
	void STATIC_OnCreated();
	void STATIC_Generic5(unsigned char byExtraData);
	void STATIC_Generic4(unsigned char byExtraData);
	void STATIC_Generic3(unsigned char byExtraData);
	void STATIC_Generic2(unsigned char byExtraData);
	void STATIC_Generic1(unsigned char byExtraData);
	void DisableChannelFireBlendNodes(bool bIsCooldownEnd);
	void SetAbilityBlendNodesActive(bool bActive, bool bOnFire, bool bIsInterrupted);
	void STATIC_SetAmmoBlendNodesAmount(int nAmmoAmt, bool bTickOnly);
	void STATIC_OnReload(float fReloadTime);
	void CacheWeaponAnimNodes(class UTgSkeletalMeshComponent* SkelComp);
	void Cache3PAnimNodes(class UTgSkeletalMeshComponent* SkelComp);
	void Cache1PAnimNodes(class UTgSkeletalMeshComponent* SkelComp);
	void CacheAnimNode3P(class UAnimNode* Node);
	void CacheAnimNode1P(class UAnimNode* Node);
	void ClearAnimNodes3P();
	void ClearAnimNodes1P();
	bool CanPlayBasicHitFx(class ATgPawn* Target);
	bool UsesTargetingMode();
	void UpdateFirstPersonWeaponFOV(const struct FVector2D& Resolution);
	void STATIC_LoadWeaponAnimSets();
	void STATIC_RecalculateMaterial();
	void UpdateTargetingList(TArray<struct FImpactInfo>* ImpactList);
	void UpdateTargetingModeLocation(const struct FVector& NewLocation, const struct FRotator& NewRotation, float DistanceScale);
	void UpdateTargetingModeStatusForFX(class UTgSpecialFx* Fx, TEnumAsByte<ETargetingModeStatus> Status, struct FAimData* Aim);
	void UpdateTargetingModeStatus(TEnumAsByte<ETargetingModeStatus> Status, struct FAimData* Aim);
	class UTgSpecialFx* SpawnSpecialFxIndependent(int nSpecialFxId, const struct FParticleChannelContainer& PSysChannels, bool bUseEmitterPool);
	void ResetAfterRagDoll();
	void Destruct(const struct FVector& vLocation);
	int STATIC_GetFormIndex();
	void DeactivateFxGroup(const struct FName& nmGroup);
	class UTgSpecialFx* ActivateFxIndependent(const struct FName& nmGroup, bool bSkipActivate, const struct FParticleChannelContainer& PSysChannels);
	void ActivateFxGroup(const struct FName& nmGroup);
	bool STATIC_LogDebugInfo();
	void STATIC_InitCameraViewpoint();
	void DetachInHandDevice_DA();
	void DetachDevice_DA(class USkeletalMeshComponent* ParentMesh, class UMeshComponent* AttachedMesh);
	bool AttachInHandDevice_DA(bool bFirstPerson);
	void AttachDevice_DA(class USkeletalMeshComponent* ParentMesh, class UMeshComponent* AttachedMesh, const struct FName& nmSocket);
	void SetFireMode(int nMode);
};


// Class TgGame.TgDeviceForm_DragonSlam
// 0x0024 (0x02E0 - 0x02BC)
class UTgDeviceForm_DragonSlam : public UTgDeviceForm
{
public:
	unsigned long                                      m_bStartFireInAir : 1;                                    // 0x02BC(0x0004)
	TArray<class UTgAnimNodeBlendByAbilityDragonSlam*> m_DragonSlamBlendList1P;                                  // 0x02C0(0x0010) (NeedCtorLink)
	TArray<class UTgAnimNodeBlendByAbilityDragonSlam*> m_DragonSlamBlendList3P;                                  // 0x02D0(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_DragonSlam");
		return ptr;
	}


	void STATIC_Cleanup();
	void STATIC_DoInterrupt();
	void StopFire(int nFireModeNum);
	void STATIC_Hit(int nFireMode, class AActor* Target, float fDamageAmount, const struct FVector& HitLocation, const struct FVector& HitNormal, struct FExtraDamageInfo* ExtraInfo);
	void STATIC_Fire(const struct FVector& HitLocation, int nFireMode, int nEquipSlot, int nSocketIndex, bool bSuccessfulHit, float fRefireTime);
	void STATIC_StartFire(int nFireMode, float fRefireTime, class AActor* Target, int nAmmoRemaining);
	void STATIC_BuildUp(int nFireMode, int nEquipSlot, int nSocketIndex, float fBuildupTime);
	void CacheAnimNode3P(class UAnimNode* Node);
	void ClearAnimNodes3P();
};


// Class TgGame.TgDeviceForm_Emote
// 0x0014 (0x02D0 - 0x02BC)
class UTgDeviceForm_Emote : public UTgDeviceForm
{
public:
	TArray<class UTgAnimNodeBlendByEmoteType*>         m_BlendByEmoteTypeNodes;                                  // 0x02BC(0x0010) (NeedCtorLink)
	unsigned long                                      m_bIsLooping : 1;                                         // 0x02CC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Emote");
		return ptr;
	}


	void StopFire(int nFireModeNum);
	void STATIC_StartFire(int nFireMode, float fRefireTime, class AActor* Target, int nAmmoRemaining);
	void CacheAnimNode3P(class UAnimNode* Node);
	void ClearAnimNodes3P();
	void STATIC_LoadWeaponAnimSets();
	void SetWeaponScale(float Scale);
};


// Class TgGame.TgDeviceForm_FragGrenade
// 0x0020 (0x02DC - 0x02BC)
class UTgDeviceForm_FragGrenade : public UTgDeviceForm
{
public:
	TArray<class UTgAnimNodeBlendByAbilityFragGrenade*> m_FragGrenadeBlendList1P;                                 // 0x02BC(0x0010) (NeedCtorLink)
	TArray<class UTgAnimNodeBlendByAbilityFragGrenade*> m_FragGrenadeBlendList3P;                                 // 0x02CC(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_FragGrenade");
		return ptr;
	}


	void STATIC_DoInterrupt();
	void STATIC_Generic1(unsigned char byExtraData);
	void CacheAnimNode3P(class UAnimNode* Node);
	void ClearAnimNodes3P();
};


// Class TgGame.TgDeviceForm_GrapplingHook
// 0x0038 (0x02F4 - 0x02BC)
class UTgDeviceForm_GrapplingHook : public UTgDeviceForm
{
public:
	unsigned long                                      m_bBeamActive : 1;                                        // 0x02BC(0x0004)
	unsigned long                                      m_bHookInterrupted : 1;                                   // 0x02BC(0x0004)
	class AActor*                                      m_BeamTarget;                                             // 0x02C0(0x0008)
	struct FVector                                     m_vBeamTargetLocation;                                    // 0x02C8(0x000C)
	TArray<class UTgAnimNodeBlendByGrapplingHook*>     m_HookBlendList1P;                                        // 0x02D4(0x0010) (NeedCtorLink)
	TArray<class UTgAnimNodeBlendByGrapplingHook*>     m_HookBlendList3P;                                        // 0x02E4(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_GrapplingHook");
		return ptr;
	}


	void STATIC_Generic1(unsigned char byExtraData);
	void StopFire(int nFireModeNum);
	void STATIC_StartFire(int nFireMode, float fRefireTime, class AActor* Target, int nAmmoRemaining);
	void DisconnectBeam();
	void ConnectBeamToTarget(class AActor* Target, const struct FVector& Location);
	void CacheAnimNode3P(class UAnimNode* Node);
	void ClearAnimNodes3P();
};


// Class TgGame.TgDeviceForm_HexaFire
// 0x0024 (0x02E0 - 0x02BC)
class UTgDeviceForm_HexaFire : public UTgDeviceForm
{
public:
	class UTgAnimNodeBlendList*                        m_LeftRocket1p;                                           // 0x02BC(0x0008)
	class UTgAnimNodeBlendList*                        m_LeftRocket3p;                                           // 0x02C4(0x0008)
	class UTgAnimNodeBlendList*                        m_RightRocket1p;                                          // 0x02CC(0x0008)
	class UTgAnimNodeBlendList*                        m_RightRocket3p;                                          // 0x02D4(0x0008)
	unsigned long                                      m_bFiringRightRocket : 1;                                 // 0x02DC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_HexaFire");
		return ptr;
	}


	void StopFire(int nFireModeNum);
	void STATIC_StartFire(int nFireMode, float fRefireTime, class AActor* Target, int nAmmoRemaining);
	void STATIC_DoInterrupt();
	void SetAllInactive();
	void STATIC_Fire(const struct FVector& HitLocation, int nFireMode, int nEquipSlot, int nSocketIndex, bool bSuccessfulHit, float fRefireTime);
	void CacheAnimNode3P(class UAnimNode* Node);
	void ClearAnimNodes3P();
};


// Class TgGame.TgDeviceForm_HexaFireGuns
// 0x0074 (0x0330 - 0x02BC)
class UTgDeviceForm_HexaFireGuns : public UTgDeviceForm
{
public:
	class UTgSkelCon_Spinner*                          m_SpinnerSkelControl1P;                                   // 0x02BC(0x0008)
	class UTgSkelCon_Spinner*                          m_SpinnerSkelControl3P;                                   // 0x02C4(0x0008)
	int                                                m_nNextGunFired;                                          // 0x02CC(0x0004)
	struct FName                                       c_nmSocket1;                                              // 0x02D0(0x0008)
	struct FName                                       c_nmSocket2;                                              // 0x02D8(0x0008)
	struct FName                                       c_nmSocket3;                                              // 0x02E0(0x0008)
	struct FName                                       c_nmSocket4;                                              // 0x02E8(0x0008)
	class UTgSkelControlSingleBone_PistonBarrel*       m_LowerRightBarrel1P;                                     // 0x02F0(0x0008)
	class UTgSkelControlSingleBone_PistonBarrel*       m_UpperRightBarrel1P;                                     // 0x02F8(0x0008)
	class UTgSkelControlSingleBone_PistonBarrel*       m_LowerLeftBarrel1P;                                      // 0x0300(0x0008)
	class UTgSkelControlSingleBone_PistonBarrel*       m_UpperLeftBarrel1P;                                      // 0x0308(0x0008)
	class UTgSkelControlSingleBone_PistonBarrel*       m_LowerRightBarrel3P;                                     // 0x0310(0x0008)
	class UTgSkelControlSingleBone_PistonBarrel*       m_UpperRightBarrel3P;                                     // 0x0318(0x0008)
	class UTgSkelControlSingleBone_PistonBarrel*       m_LowerLeftBarrel3P;                                      // 0x0320(0x0008)
	class UTgSkelControlSingleBone_PistonBarrel*       m_UpperLeftBarrel3P;                                      // 0x0328(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_HexaFireGuns");
		return ptr;
	}


	struct FVector STATIC_GetTracerSocketLocation();
	void STATIC_Fire(const struct FVector& HitLocation, int nFireMode, int nEquipSlot, int nSocketIndex, bool bSuccessfulHit, float fRefireTime);
	void StopFire(int nFireModeNum);
	void STATIC_StartFire(int nFireMode, float fRefireTime, class AActor* Target, int nAmmoRemaining);
	void Cache3PAnimNodes(class UTgSkeletalMeshComponent* SkelComp);
	void Cache1PAnimNodes(class UTgSkeletalMeshComponent* SkelComp);
};


// Class TgGame.TgDeviceForm_Impasse
// 0x0000 (0x02BC - 0x02BC)
class UTgDeviceForm_Impasse : public UTgDeviceForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Impasse");
		return ptr;
	}


	void UpdateTargetingModeStatusForFX(class UTgSpecialFx* Fx, TEnumAsByte<ETargetingModeStatus> Status, struct FAimData* Aim);
	void UpdateTargetingModeLocation(const struct FVector& NewLocation, const struct FRotator& NewRotation, float DistanceScale);
};


// Class TgGame.TgDeviceForm_Inhand
// 0x0010 (0x02CC - 0x02BC)
class UTgDeviceForm_Inhand : public UTgDeviceForm
{
public:
	int                                                m_nAmmoCount;                                             // 0x02BC(0x0004)
	int                                                m_nMaxAmmoCount;                                          // 0x02C0(0x0004)
	float                                              m_fPreviousAmmoPerc;                                      // 0x02C4(0x0004)
	float                                              m_fCurrentAmmoPerc;                                       // 0x02C8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Inhand");
		return ptr;
	}


	void STATIC_OnWeaponMeshUpdated();
	void UpdateAmmoCountFx(float fPreviousPerc, float fCurrentPerc);
	void STATIC_OnAmmoCountUpdated(int nAmmoCount, int nMaxAmmoCount);
};


// Class TgGame.TgDeviceForm_Mount
// 0x0020 (0x02DC - 0x02BC)
class UTgDeviceForm_Mount : public UTgDeviceForm
{
public:
	TArray<class UAnimSet*>                            m_LoadedAnimSets;                                         // 0x02BC(0x0010) (NeedCtorLink)
	TArray<class UTgSkelCon_WheelSpinner*>             m_pWheelSpinnerSkelCons;                                  // 0x02CC(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Mount");
		return ptr;
	}


	void StopFire(int nFireModeNum);
	void STATIC_StartFire(int nFireMode, float fRefireTime, class AActor* Target, int nAmmoRemaining);
	void STATIC_GetAnimSetStringsForBot(int PlayerBotId, TArray<struct FString>* sPaths);
	TEnumAsByte<EMountType> STATIC_GetMountType();
	void STATIC_SetSpinnerVelocity(float fVelocity);
	void CacheSkeletalControls(class USkeletalMeshComponent* pSkelComponent);
};


// Class TgGame.TgDeviceForm_PeckAttack
// 0x0010 (0x02CC - 0x02BC)
class UTgDeviceForm_PeckAttack : public UTgDeviceForm
{
public:
	class UTgSkelCon_RotateToAim*                      m_AimSkelControl3P;                                       // 0x02BC(0x0008)
	class UTgSkelCon_RotateToVelocity*                 m_VelocitySkelControl3P;                                  // 0x02C4(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_PeckAttack");
		return ptr;
	}


	void StopFire(int nFireModeNum);
	void STATIC_StartFire(int nFireMode, float fRefireTime, class AActor* Target, int nAmmoRemaining);
	void Cache3PAnimNodes(class UTgSkeletalMeshComponent* SkelComp);
};


// Class TgGame.TgDeviceForm_Pursuit
// 0x004C (0x0308 - 0x02BC)
class UTgDeviceForm_Pursuit : public UTgDeviceForm
{
public:
	struct FName                                       m_LeftSlideSkelControlName1P;                             // 0x02BC(0x0008)
	struct FName                                       m_RightSlideSkelControlName1P;                            // 0x02C4(0x0008)
	struct FName                                       m_LeftSlideSkelControlName3P;                             // 0x02CC(0x0008)
	struct FName                                       m_RightSlideSkelControlName3P;                            // 0x02D4(0x0008)
	class USkelControlBase*                            m_LeftSlideSkelControl1P;                                 // 0x02DC(0x0008)
	class USkelControlBase*                            m_RightSlideSkelControl1P;                                // 0x02E4(0x0008)
	class USkelControlBase*                            m_LeftSlideSkelControl3P;                                 // 0x02EC(0x0008)
	class USkelControlBase*                            m_RightSlideSkelControl3P;                                // 0x02F4(0x0008)
	float                                              c_fPreviousLeftSlideStrength;                             // 0x02FC(0x0004)
	float                                              c_fPreviousRightSlideStrength;                            // 0x0300(0x0004)
	unsigned long                                      m_bCachedDualFireParity : 1;                              // 0x0304(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Pursuit");
		return ptr;
	}


	void StopFire(int nFireModeNum);
	void STATIC_StartFire(int nFireMode, float fRefireTime, class AActor* Target, int nAmmoRemaining);
	void Cache3PAnimNodes(class UTgSkeletalMeshComponent* SkelComp);
	void Cache1PAnimNodes(class UTgSkeletalMeshComponent* SkelComp);
	bool STATIC_HasCachedLex();
};


// Class TgGame.TgDeviceForm_Scout
// 0x0008 (0x02C4 - 0x02BC)
class UTgDeviceForm_Scout : public UTgDeviceForm
{
public:
	class USkelControlBase*                            m_SKCBirdScale;                                           // 0x02BC(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Scout");
		return ptr;
	}


	void StopFire(int nFireModeNum);
	void STATIC_StartFire(int nFireMode, float fRefireTime, class AActor* Target, int nAmmoRemaining);
	void Cache3PAnimNodes(class UTgSkeletalMeshComponent* SkelComp);
};


// Class TgGame.TgDeviceForm_Smash
// 0x0020 (0x02DC - 0x02BC)
class UTgDeviceForm_Smash : public UTgDeviceForm
{
public:
	TArray<class UTgAnimNodeBlendByAbilitySmash*>      m_SmashBlendList1P;                                       // 0x02BC(0x0010) (NeedCtorLink)
	TArray<class UTgAnimNodeBlendByAbilitySmash*>      m_SmashBlendList3P;                                       // 0x02CC(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Smash");
		return ptr;
	}


	void STATIC_Fire(const struct FVector& HitLocation, int nFireMode, int nEquipSlot, int nSocketIndex, bool bSuccessfulHit, float fRefireTime);
	void STATIC_StartFire(int nFireMode, float fRefireTime, class AActor* Target, int nAmmoRemaining);
	void CacheAnimNode3P(class UAnimNode* Node);
	void ClearAnimNodes3P();
};


// Class TgGame.TgDeviceForm_SpinnerWhileFiring
// 0x002C (0x02E8 - 0x02BC)
class UTgDeviceForm_SpinnerWhileFiring : public UTgDeviceForm
{
public:
	struct FName                                       m_SpinnerName;                                            // 0x02BC(0x0008) (Const)
	unsigned long                                      m_bShouldSpinOnFire : 1;                                  // 0x02C4(0x0004) (Const)
	TArray<class UTgSkelCon_Spinner*>                  m_SpinnerSkelControls1p;                                  // 0x02C8(0x0010) (NeedCtorLink)
	TArray<class UTgSkelCon_Spinner*>                  m_SpinnerSkelControls3p;                                  // 0x02D8(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_SpinnerWhileFiring");
		return ptr;
	}


	bool STATIC_IsSpinning3P();
	bool STATIC_IsSpinningDown3P();
	bool STATIC_IsSpinningUp3P();
	void SetSpinnersRotationSpeedState(int nState);
	void SetSpinnersActive(bool bActive);
	void StopFire(int nFireModeNum);
	void STATIC_StartFire(int nFireMode, float fRefireTime, class AActor* Target, int nAmmoRemaining);
	void CacheWeaponAnimNodes(class UTgSkeletalMeshComponent* SkelComp);
	void CacheSkelControls(class UAnimTree* pAnimTree, TArray<class UTgSkelCon_Spinner*>* SpinnerSkelControls);
};


// Class TgGame.TgDeviceForm_Dragon
// 0x0000 (0x02E8 - 0x02E8)
class UTgDeviceForm_Dragon : public UTgDeviceForm_SpinnerWhileFiring
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Dragon");
		return ptr;
	}

};


// Class TgGame.TgDeviceForm_Minigun
// 0x0010 (0x02F8 - 0x02E8)
class UTgDeviceForm_Minigun : public UTgDeviceForm_SpinnerWhileFiring
{
public:
	unsigned long                                      m_bIsADS : 1;                                             // 0x02E8(0x0004)
	int                                                m_nDisplayGroupState;                                     // 0x02EC(0x0004)
	class UTgSkeletalMeshComponent*                    m_WeaponMesh;                                             // 0x02F0(0x0008) (ExportObject, Component, EditInline)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Minigun");
		return ptr;
	}


	void STATIC_OnDestroyed();
	void STATIC_RemoveSpinCallbacks();
	void AddSpinCallbacks();
	void STATIC_SpinDownFinished();
	void STATIC_SpinUpFinished();
	void STATIC_ManageDisplayGroups();
	void STATIC_PlayToggleTransitionAnimations(float transitionPercent, float totalTransitionTime, bool transitionToActive);
	void StopFire(int nFireModeNum);
	void STATIC_BuildUp(int nFireMode, int nEquipSlot, int nSocketIndex, float fBuildupTime);
	void STATIC_OnNodesCached();
	bool STATIC_ShouldSpinBarrel();
	void CacheWeaponAnimNodes(class UTgSkeletalMeshComponent* SkelComp);
};


// Class TgGame.TgDeviceForm_Spray
// 0x0048 (0x0304 - 0x02BC)
class UTgDeviceForm_Spray : public UTgDeviceForm
{
public:
	class UMaterialInstanceConstant*                   m_SprayMIC;                                               // 0x02BC(0x0008)
	int                                                m_nRandAlphaMaskMax;                                      // 0x02C4(0x0004)
	int                                                m_nPrevAlphaMask;                                         // 0x02C8(0x0004)
	class UDecalComponent*                             c_SpawnedDecal;                                           // 0x02CC(0x0008) (ExportObject, Component, EditInline)
	float                                              m_fAccurateTraceLength;                                   // 0x02D4(0x0004)
	float                                              m_fWidth;                                                 // 0x02D8(0x0004)
	float                                              m_fHeight;                                                // 0x02DC(0x0004)
	float                                              m_fDepth;                                                 // 0x02E0(0x0004)
	TEnumAsByte<ESprayDisplayBehavior>                 m_SprayBehavior;                                          // 0x02E4(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x02E5(0x0003) MISSED OFFSET
	unsigned long                                      m_bInitializedSprayParams : 1;                            // 0x02E8(0x0004)
	int                                                m_nSprayHitFXId;                                          // 0x02EC(0x0004)
	int                                                m_nSprayMissedFXId;                                       // 0x02F0(0x0004)
	class UTgSpecialFx*                                c_SprayHitFX;                                             // 0x02F4(0x0008)
	class UTgSpecialFx*                                c_SprayMissedFX;                                          // 0x02FC(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Spray");
		return ptr;
	}


	void STATIC_OnDestroyed();
	void STATIC_PlayImpactEffects(const struct FVector& HitLocation, int nEquipSlot, int nSocketIndex, bool bSuccessfulHit, const struct FVector& FireOrigin, float fHitTraceDistOverride, bool bGenerateUpdatedHitLocation);
	int STATIC_GetWinsPerRole();
	int STATIC_GetCharacterMastery();
	void SetRandomSprayAlpha();
	void SetSprayBehaviorParams();
	void PlaySprayFX(bool bSuccessfulSpray);
};


// Class TgGame.TgDeviceForm_ToggleWithLockout
// 0x0000 (0x02BC - 0x02BC)
class UTgDeviceForm_ToggleWithLockout : public UTgDeviceForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_ToggleWithLockout");
		return ptr;
	}


	void STATIC_Generic2(unsigned char byExtraData);
	void STATIC_Fire(const struct FVector& HitLocation, int nFireMode, int nEquipSlot, int nSocketIndex, bool bSuccessfulHit, float fRefireTime);
	void STATIC_Generic1(unsigned char byExtraData);
};


// Class TgGame.TgDeviceForm_WeaponZoom
// 0x0018 (0x02D4 - 0x02BC)
class UTgDeviceForm_WeaponZoom : public UTgDeviceForm_ToggleWithLockout
{
public:
	float                                              m_fCameraFOVInterpolationTime;                            // 0x02BC(0x0004)
	float                                              m_fMaxCameraFOVInteprolationTime;                         // 0x02C0(0x0004) (Edit)
	float                                              m_fCameraFOVInterpolationTarget;                          // 0x02C4(0x0004)
	float                                              m_fActiveFOV;                                             // 0x02C8(0x0004)
	unsigned long                                      m_fHasStartedInterpolation : 1;                           // 0x02CC(0x0004)
	float                                              m_fDesiredStartInterpolationTimestamp;                    // 0x02D0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_WeaponZoom");
		return ptr;
	}


	void StartCameraInterpolation();
	void STATIC_PlayToggleTransitionAnimations(float transitionPercent, float totalTransitionTime, bool transitionToActive);
	void ClearPendingFOVInterpolation();
	void STATIC_Generic2(unsigned char byExtraData);
	void StopFire(int nFireModeNum);
	void STATIC_Fire(const struct FVector& HitLocation, int nFireMode, int nEquipSlot, int nSocketIndex, bool bSuccessfulHit, float fRefireTime);
	void STATIC_Generic1(unsigned char byExtraData);
};


// Class TgGame.TgDeviceForm_Turret
// 0x0008 (0x02C4 - 0x02BC)
class UTgDeviceForm_Turret : public UTgDeviceForm
{
public:
	class USkelControlBase*                            m_SKCTurretScale;                                         // 0x02BC(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Turret");
		return ptr;
	}


	void STATIC_CooldownComplete();
	void STATIC_StartFire(int nFireMode, float fRefireTime, class AActor* Target, int nAmmoRemaining);
	void Cache3PAnimNodes(class UTgSkeletalMeshComponent* SkelComp);
};


// Class TgGame.TgDeviceInterface_AccelMultiplier
// 0x0000 (0x0060 - 0x0060)
class UTgDeviceInterface_AccelMultiplier : public UInterface
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceInterface_AccelMultiplier");
		return ptr;
	}


	float STATIC_GetAccelMultiplier();
};


// Class TgGame.TgDeviceInterface_DeployMod
// 0x0000 (0x0060 - 0x0060)
class UTgDeviceInterface_DeployMod : public UInterface
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceInterface_DeployMod");
		return ptr;
	}


	void STATIC_ModifyDeployableFiremode(class UTgDeviceFire* pFireMode);
	float STATIC_GetAdditiveHealth();
	bool AffectsDeployable(int nDeployableId);
};


// Class TgGame.TgDeviceInterface_ListenConsumeMarks
// 0x0000 (0x0060 - 0x0060)
class UTgDeviceInterface_ListenConsumeMarks : public UInterface
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceInterface_ListenConsumeMarks");
		return ptr;
	}


	void STATIC_OnMarksConsumed(class AActor* Target, class ATgDevice* instigatingDevice, float fNumMarks, float fBaseDamage, float fBonusDamage);
};


// Class TgGame.TgDeviceInterface_MoveSpeedMultiplier
// 0x0000 (0x0060 - 0x0060)
class UTgDeviceInterface_MoveSpeedMultiplier : public UInterface
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceInterface_MoveSpeedMultiplier");
		return ptr;
	}


	float STATIC_GetMoveSpeedMultiplier();
};


// Class TgGame.TgDeployable
// 0x01C8 (0x0448 - 0x0280)
class ATgDeployable : public AActor
{
public:
	struct FPointer                                    VfTable_ITgSkinnableInterface;                            // 0x0280(0x0008) (Const, Native, NoExport)
	struct FPointer                                    VfTable_ITgCombatActor;                                   // 0x0288(0x0008) (Const, Native, NoExport)
	struct FPointer                                    VfTable_ITgObserver_ViewTargetChanged;                    // 0x0290(0x0008) (Const, Native, NoExport)
	struct FPointer                                    VfTable_ITgInteractiveAudio;                              // 0x0298(0x0008) (Const, Native, NoExport)
	struct FPointer                                    VfTable_ITgGameplayCurveOwner;                            // 0x02A0(0x0008) (Const, Native, NoExport)
	int                                                r_nDeployableId;                                          // 0x02A8(0x0004) (Net)
	int                                                r_nUniqueDeployableId;                                    // 0x02AC(0x0004) (Net)
	int                                                r_nSkinId;                                                // 0x02B0(0x0004) (Net)
	int                                                r_nWeaponSkinId;                                          // 0x02B4(0x0004)
	unsigned long                                      c_bInitialized : 1;                                       // 0x02B8(0x0004)
	unsigned long                                      m_bConsumedOnFire : 1;                                    // 0x02B8(0x0004)
	unsigned long                                      m_bFireOnDeploy : 1;                                      // 0x02B8(0x0004)
	unsigned long                                      m_bHasAlreadyFiredOnce : 1;                               // 0x02B8(0x0004)
	unsigned long                                      m_bInstantFire : 1;                                       // 0x02B8(0x0004)
	unsigned long                                      m_bRequiresEffectManager : 1;                             // 0x02B8(0x0004)
	unsigned long                                      c_bMinimapOnlyOwnerSee : 1;                               // 0x02B8(0x0004)
	unsigned long                                      r_bTakeDamage : 1;                                        // 0x02B8(0x0004) (Net)
	unsigned long                                      m_bInDestroyedState : 1;                                  // 0x02B8(0x0004)
	unsigned long                                      s_bDestroyedThisTick : 1;                                 // 0x02B8(0x0004)
	unsigned long                                      m_bIsDeployed : 1;                                        // 0x02B8(0x0004)
	unsigned long                                      c_bEnemyMatLoaded : 1;                                    // 0x02B8(0x0004)
	unsigned long                                      s_bAlwaysRelevantExceptRoyale : 1;                        // 0x02B8(0x0004)
	unsigned long                                      m_bProtectedFromGameModeDestroy : 1;                      // 0x02B8(0x0004)
	unsigned long                                      m_bProtectedFromOwnerDisconnectDestroy : 1;               // 0x02B8(0x0004)
	unsigned long                                      m_bDestroyOnOwnerDeathFlag : 1;                           // 0x02B8(0x0004)
	unsigned long                                      m_bAdjustMeshToGround : 1;                                // 0x02B8(0x0004)
	unsigned long                                      m_bIsVisionBlocker : 1;                                   // 0x02B8(0x0004) (Const)
	unsigned long                                      m_bIsAIVisionBlocker : 1;                                 // 0x02B8(0x0004) (Const)
	unsigned long                                      m_bMovableProjBlocker : 1;                                // 0x02B8(0x0004) (Const)
	unsigned long                                      m_bShouldRagdoll : 1;                                     // 0x02B8(0x0004)
	unsigned long                                      m_bDeviceUsedIsHandDevice : 1;                            // 0x02B8(0x0004) (Const)
	unsigned long                                      m_bUseSilhouettesOverride : 1;                            // 0x02B8(0x0004)
	unsigned long                                      m_bOverrideTargetComponentHeight : 1;                     // 0x02B8(0x0004) (Edit)
	unsigned long                                      r_bInitialIsEnemy : 1;                                    // 0x02B8(0x0004) (Net)
	unsigned long                                      c_bIsSpectateToggleActive : 1;                            // 0x02B8(0x0004) (Transient)
	unsigned long                                      m_bUseRangeFalloffCurve : 1;                              // 0x02B8(0x0004)
	unsigned long                                      m_bAllowDisenchant : 1;                                   // 0x02B8(0x0004)
	int                                                m_nDeployableType;                                        // 0x02BC(0x0004)
	int                                                r_nPhysicalType;                                          // 0x02C0(0x0004) (Net)
	int                                                r_nHealth;                                                // 0x02C4(0x0004) (Net)
	class ATgEffectManager*                            r_EffectManager;                                          // 0x02C8(0x0008) (Net)
	TArray<class UTgEffectGroup*>                      m_EquipEffects;                                           // 0x02D0(0x0010) (NeedCtorLink)
	TArray<struct FTgPropertyInstance>                 s_Properties;                                             // 0x02E0(0x0010) (NeedCtorLink)
	class UTgDeviceForm*                               c_Form;                                                   // 0x02F0(0x0008)
	class UTgSpecialFx*                                c_FireFx;                                                 // 0x02F8(0x0008)
	class UMeshComponent*                              c_Mesh;                                                   // 0x0300(0x0008) (ExportObject, Component, EditInline)
	struct FVector                                     r_vFlashLocation;                                         // 0x0308(0x000C) (Net)
	unsigned char                                      r_nFlashCount;                                            // 0x0314(0x0001) (Net)
	unsigned char                                      r_nFlashFireCount;                                        // 0x0315(0x0001) (Net)
	unsigned char                                      c_nPreviousFlashFireCount;                                // 0x0316(0x0001)
	TEnumAsByte<EDeployableOverlayIcon>                m_InitHUDOverlayIcon;                                     // 0x0317(0x0001) (Const)
	TEnumAsByte<EDeployableOverlayState>               m_InitHUDOverlayState;                                    // 0x0318(0x0001) (Const)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0319(0x0003) MISSED OFFSET
	class UTgDeviceFire*                               m_FireMode;                                               // 0x031C(0x0008)
	float                                              m_fStateTime;                                             // 0x0324(0x0004)
	class ATgActorFactory*                             s_DeployFactory;                                          // 0x0328(0x0008)
	int                                                m_TimeCreated;                                            // 0x0330(0x0004)
	class UMeshComponent*                              m_DestroyedMesh;                                          // 0x0334(0x0008) (ExportObject, Component, EditInline)
	float                                              m_fLifeAfterDeathSecs;                                    // 0x033C(0x0004)
	int                                                r_nReplicateDestroyIt;                                    // 0x0340(0x0004) (Net)
	TScriptInterface<class UTgInteractiveAudio>        m_AsInteractiveAudio;                                     // 0x0344(0x0010)
	float                                              s_fPersistTime;                                           // 0x0354(0x0004)
	class UDynamicLightEnvironmentComponent*           LightEnvironment;                                         // 0x0358(0x0008) (Const, ExportObject, Component, EditInline)
	float                                              r_fTimeToDeploySecs;                                      // 0x0360(0x0004) (Net)
	float                                              r_fInitDeployTime;                                        // 0x0364(0x0004) (Net)
	float                                              m_fCurrentDeployPercentage;                               // 0x0368(0x0004)
	float                                              r_fCurrentDeployTime;                                     // 0x036C(0x0004) (Net)
	float                                              m_fDamagedDuringDeploy;                                   // 0x0370(0x0004)
	class UTgDeviceFire*                               s_SpawnerDeviceMode;                                      // 0x0374(0x0008)
	class ATgDevice*                                   r_Owner;                                                  // 0x037C(0x0008) (Net)
	int                                                r_nOwnerFireMode;                                         // 0x0384(0x0004) (Net)
	float                                              AlwaysRelevantDistanceSquared;                            // 0x0388(0x0004)
	float                                              s_fMaxRelevancyDistanceSquared;                           // 0x038C(0x0004)
	float                                              m_fMaxAimAssistStacks;                                    // 0x0390(0x0004)
	TArray<class UTgAnimBlendByDeployable*>            m_DeployableAnimNodes;                                    // 0x0394(0x0010) (NeedCtorLink)
	struct FVector                                     r_vRagdollDir;                                            // 0x03A4(0x000C) (Net)
	int                                                m_nShardCost;                                             // 0x03B0(0x0004)
	struct FCollisionSettingsDeployable                m_CollisionSettings;                                      // 0x03B4(0x0010)
	TArray<class ATgPawn*>                             m_PawnsBasedOnMe;                                         // 0x03C4(0x0010) (NeedCtorLink)
	class ATgSilhouetteManager*                        m_SilhouetteManager;                                      // 0x03D4(0x0008)
	int                                                m_nInitHUDOverlayDisplayMask;                             // 0x03DC(0x0004) (Const)
	float                                              m_InitHUDOverlayEnemyViewDist;                            // 0x03E0(0x0004) (Const)
	float                                              m_fHUDOverlayZOffset;                                     // 0x03E4(0x0004) (Edit)
	struct FPointer                                    m_pAmSkin;                                                // 0x03E8(0x0008) (Const, Native)
	struct FPointer                                    m_pAmWeaponSkin;                                          // 0x03F0(0x0008) (Const, Native)
	class UCylinderComponent*                          m_TargetComponent;                                        // 0x03F8(0x0008) (Edit, ExportObject, Component, EditInline)
	float                                              m_TargetCollisionTraceDistance;                           // 0x0400(0x0004) (Edit)
	float                                              m_fOverriddenTargetComponentHeight;                       // 0x0404(0x0004) (Edit)
	class ATgPawn*                                     m_LastDamager;                                            // 0x0408(0x0008)
	int                                                m_LastDamagerTimeStamp;                                   // 0x0410(0x0004)
	class ATgRepInfo_Deployable*                       r_DRI;                                                    // 0x0414(0x0008) (Net)
	class ATgPlayerController*                         c_LocalPC;                                                // 0x041C(0x0008)
	class UClass*                                      m_DRIClass;                                               // 0x0424(0x0008)
	float                                              m_fDisableSpectatorFxTime;                                // 0x042C(0x0004)
	float                                              m_fDisableSpectatorFxTimeRemaining;                       // 0x0430(0x0004) (Transient)
	class ATgAkActorUnoccluded*                        m_AkActorUnoccluded;                                      // 0x0434(0x0008)
	float                                              m_fHazardDistance;                                        // 0x043C(0x0004)
	float                                              m_fHazardRating;                                          // 0x0440(0x0004)
	float                                              m_fInteractMaxDistance;                                   // 0x0444(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable");
		return ptr;
	}


	void STATIC_DeployedAtCombatTarget(class AActor* CombatTarget);
	float STATIC_GetMaxAimAssistStacks();
	void SetHUDOverlayEnemyViewDist(float enemyViewDist);
	void SetHUDOverlayState(TEnumAsByte<EDeployableOverlayState> dos);
	void SetHUDOverlayIcon(TEnumAsByte<EDeployableOverlayIcon> doi);
	void STATIC_AddHUDOverlayDisplayMask(int dodm);
	void SetHUDOverlayDisplayMask(int dodm);
	void STATIC_CollisionChanged();
	void UpdateDecalScale(class UTgSpecialFx* Fx, float radiusScale);
	bool STATIC_GetDefaultDecalDimensions(int nDecalId, int nSpecialFxId, float* Height, float* Width);
	void PlayGenericTakeHit(const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_DeactivateSpectatorFxTimer();
	void ToggleSpectateFx(bool bForceDisable);
	bool STATIC_IsBoxExtentInRange(const struct FVector& BoxCenter, const struct FVector& BoxExtent);
	void STATIC_InitReplicationInfo();
	bool STATIC_DamageShouldEnterCombat();
	bool STATIC_CanApplyEffects();
	struct FString STATIC_GetDeployableNameById(int DeployableId);
	void STATIC_OnHealthUpdated();
	void STATIC_TakeDamage(int Damage, class AController* EventInstigator, const struct FVector& HitLocation, const struct FVector& Momentum, class UClass* DamageType, const struct FTraceHitInfo& HitInfo, class AActor* DamageCauser);
	void Destroyed();
	void Tick(float DeltaSeconds);
	void ClearBasedPawnList();
	void STATIC_RemoveBasedPawn(class ATgPawn* basedPawn);
	void STATIC_AddBasedPawn(class ATgPawn* basedPawn);
	void STATIC_DestroyIt(bool bSkipFx);
	void STATIC_ReplacedByNewDeployable();
	void SpawningDeviceToggledOff();
	void STATIC_ReplicatedEvent(const struct FName& VarName);
	void STATIC_ActivateOnWhenDeployedFx(bool bOn);
	void STATIC_ActivateWhileAliveFx(bool bOn);
	struct FName STATIC_GetDestroyedDisplayGroup();
	struct FName STATIC_GetWhileAliveDisplayGroup();
	void TickDeploy(float DeltaSeconds);
	void UpdateTimeToDeploySecs(float fValue);
	void STATIC_NotifyDeployed();
	void DeployComplete();
	void STATIC_ResetPersistTime();
	void STATIC_OnPersistTimerExpire();
	void CalcDeployPercentage();
	void STATIC_OnSetTaskforce(class UTgSeqAct_SetTaskforce* Action);
	void RefireCheckTimer();
	void StartDeploy();
	void TimeDeviceFiring();
	bool STATIC_IsFiring();
	void FlashFireCountUpdated();
	void FlashLocationUpdated();
	void FlashCountUpdated();
	void STATIC_PlayFireFx();
	void STATIC_ClearFlashLocation();
	void SetFlashLocation(const struct FVector& NewLoc);
	void STATIC_ClearFlashCount();
	void IncrementFlashCount();
	void FireAmmunitionDeployable();
	struct FVector STATIC_GetPhysicalFireAimDirection(const struct FVector& fireLoc, const struct FVector& TargetLocation);
	struct FVector STATIC_GetPhysicalFireStartLoc();
	class AProjectile* ProjectileFireDeployable();
	void STATIC_ApplyHit(TArray<struct FImpactInfo>* ImpactList);
	void STATIC_InstantFireDeployable();
	struct FImpactInfo CalcDeviceFire(const struct FVector& StartTrace, const struct FVector& EndTrace, TArray<struct FImpactInfo>* ImpactList);
	void DeviceFired();
	void StopFire();
	void STATIC_StartFire();
	void STATIC_OnGetTaskForceNumber(class UTgSeqAct_GetTaskForceNumber* Action);
	void STATIC_PostInitAnimTree(class USkeletalMeshComponent* SkelComp);
	void STATIC_GetAimAssistBounds(struct FVector* ObserverLocation, float* Width, float* Height, struct FVector* Center);
	int STATIC_GetDeployableUniqueId();
	void NotifyLocalPlayerTeamReceived();
	void PostBeginPlay();
	bool DeductShardCost(class ATgPawn* pPawn);
	bool CanAfford(class ATgPawn* pPawn);
	void STATIC_InitializeEquipEffects(int nDeviceId);
	bool UseRangeFalloffCurve();
	class UTgGameplayCurvesSet* STATIC_GetCurrentGameplayCurveSet(TEnumAsByte<ECurveSetTypes> Type);
	class AActor* STATIC_GetActorFromCombatActor();
	class AActor* STATIC_GetPetOwner();
	bool STATIC_IsPet();
	TEnumAsByte<EGameplayDesignType> STATIC_GetDesignType();
	class ATgEffectManager* STATIC_GetEffectManager();
	void DelayedRagdollConstraintBreak();
	void InitRagdoll();
	void STATIC_OnViewTargetChanged(class AActor* aNewViewTarget);
	float STATIC_GetMarkedPercentInhand(class AActor* InstigatorPawn);
	float STATIC_GetMarkedPercent(class AActor* InstigatorPawn);
	int STATIC_GetPropIndex(int nPropId);
	float STATIC_GetPropCurrentValue(int nPropIndex);
	float STATIC_GetPropBaseValue(int nPropIndex);
	struct FVector STATIC_GetLocation();
	bool STATIC_LocalPlayerHasLOS();
	void STATIC_HandleNotificationsForAI(float fStatChange, class ATgPawn* InstigatorPawn);
	float STATIC_GetDamageToLeaveStealth();
	void TakeStealthDamage(float fDamage);
	int TakePersonalArmorDamage(float fDamage, class AController* InstigatedBy, class UClass* DamageType, const struct FImpactInfo& Impact, class AActor* DamageCauser, struct FExtraDamageInfo* ExtraInfo);
	bool ShieldDamageAppliesToHealth();
	int TakePersonalShieldDamage(float fDamage, class AController* InstigatedBy, class UClass* DamageType, const struct FImpactInfo& Impact, class AActor* DamageCauser, struct FExtraDamageInfo* ExtraInfo);
	bool CanUsePersonalShield();
	bool CanTakeShieldDamage();
	void TakeManaDamage(float fDamage, class AController* InstigatedBy, class UClass* DamageType, const struct FImpactInfo& Impact, const struct FExtraDamageInfo& ExtraInfo, class AActor* DamageCauser);
	bool CanTakeManaDamage();
	bool CanBeLifestealTarget();
	bool CanBeLifestealInstigator();
	void TakeHealthDamage(float fDamage, class AController* InstigatedBy, class UClass* DamageType, const struct FImpactInfo& Impact, const struct FExtraDamageInfo& ExtraInfo, class AActor* DamageCauser);
	void STATIC_MitigateHealthDamage(class ATgPawn* pInstigator, class UTgEffectDamage* Effect, const struct FImpactInfo& Impact, bool bIsHeadshot, float* NewValue, float* fPercReduction);
	float STATIC_GetSpecialDamageTakenPercentAI();
	float STATIC_GetSpecialDamageDealtPercentAI();
	void BuffDamage(class AActor* Target, class UTgEffectDamage* Effect, const struct FImpactInfo& Impact, float fBaseDamage, float* fProratedAmount, struct FExtraDamageInfo* ExtraInfo);
	bool STATIC_IsImmuneToHealing();
	bool CanBeExecuted();
	bool STATIC_IsImmuneToDamage();
	bool STATIC_OnlyTakeHeadShots();
	bool CanTakeHeadShots();
	bool CanDealHeadShots();
	bool CanTakeHealthDamage();
	float STATIC_GetDiminishedGroundSpeed();
	void STATIC_GetAdditionalLifestealMultipliers(struct FDiminishedEffectInfo* DiminishingInfo, struct FImpactInfo* Impact);
	void STATIC_GetAdditionalDamageTakenMultipliers(class ATgDevice* damagingDevice, struct FDiminishedEffectInfo* DiminishingInfo, struct FImpactInfo* Impact);
	float STATIC_GetMaxShield();
	float STATIC_GetShieldHealth();
	float STATIC_GetMaxMana();
	float STATIC_GetMana();
	float STATIC_GetHealthPercent();
	float STATIC_GetMaxHealth();
	float STATIC_GetHealth();
	void STATIC_UnRegisterObstacle();
	void STATIC_RegisterObstacle();
	void PostAkEvent(class UAkEvent* InAkEvent);
	void AdjustHeal(int nPropertyId, struct FImpactInfo* Impact, float* fHeal);
	struct FVector STATIC_GetHudOverlayLocation(bool bCentered);
	bool STATIC_IsHittable();
	bool IsInvisibleToAI(class AActor* TestActor);
	void UpdateHealth();
	bool STATIC_IsFriendlyWithLocalPawn();
	int STATIC_GetSpawnerDeviceId();
	int STATIC_GetSpawnerDeviceInstanceId();
	void SetTaskForceNumber(int nTaskForceId);
	int STATIC_GetTaskForceNumber();
	class ATgRepInfo_TaskForce* STATIC_GetTaskForce();
	void SetInitialHealthPercent(float fPercent);
	void UpdateDamagers(class ATgPawn* Damager);
	void UpdateTargetCylinder();
	float CalcMeshOffset();
	void AdjustMeshToGround();
	void STATIC_RecalculateMaterial(bool bIsFriendlyWithLocalPawn, bool bForce);
	void ForceRecalculateMaterial();
	void STATIC_NotifyGroupChanged();
	int STATIC_GetMaxDeployHealth();
	void DeployableDestroyed();
	void SwapMeshToDestroyed();
	void ResetProperties();
	void SetProperty(int nPropertyId, float fNewValue);
	struct FTgPropertyInstance STATIC_GetProperty(int nPropertyId);
	void AddProperty(int nPropId, float fBase, float fRaw, float FMin, float FMax);
	void STATIC_InitializeDefaultProps();
	bool ApplyDeployableSetup();
};


// Class TgGame.TgDeploy_BlackHole
// 0x003C (0x0484 - 0x0448)
class ATgDeploy_BlackHole : public ATgDeployable
{
public:
	float                                              r_fRadiusScale;                                           // 0x0448(0x0004) (Net)
	float                                              m_fMaxPullSpeed;                                          // 0x044C(0x0004)
	float                                              m_fMinPullSpeed;                                          // 0x0450(0x0004)
	float                                              m_fDistanceWithMaxSpeed;                                  // 0x0454(0x0004)
	float                                              m_fEventHorizonDistance;                                  // 0x0458(0x0004)
	float                                              m_fInnerRadius;                                           // 0x045C(0x0004)
	TArray<class AActor*>                              m_ActorsInRange;                                          // 0x0460(0x0010) (NeedCtorLink)
	class ATgPawn*                                     m_CachedPawnOwner;                                        // 0x0470(0x0008)
	class ATgRepInfo_TaskForce*                        m_CachedEnemyTaskForce;                                   // 0x0478(0x0008)
	unsigned long                                      r_bPullActive : 1;                                        // 0x0480(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_BlackHole");
		return ptr;
	}


	void Destroyed();
	void STATIC_ClearAllTouched();
	void STATIC_ReplicatedEvent(const struct FName& VarName);
	void ApplyPullEffects(class ATgPawn* Target, float DeltaTime);
};


// Class TgGame.TgDeploy_Bomb
// 0x0018 (0x0460 - 0x0448)
class ATgDeploy_Bomb : public ATgDeployable
{
public:
	float                                              r_fPersistTime;                                           // 0x0448(0x0004) (Net)
	class UStaticMeshComponent*                        m_CountdownIndicator;                                     // 0x044C(0x0008) (Edit, ExportObject, Component, EditInline)
	class UMaterialInstanceConstant*                   m_CountdownIndicatorMIC;                                  // 0x0454(0x0008) (Transient)
	float                                              r_fRadiusScale;                                           // 0x045C(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_Bomb");
		return ptr;
	}


	void STATIC_ScaleAbilityFX();
	void STATIC_ScaleAbilityRadius();
	void STATIC_DestroyIt(bool bSkipFx);
	void Tick(float DeltaSeconds);
	int STATIC_GetNumEnemyPlayersInList(TArray<struct FImpactInfo>* ImpactList);
	void STATIC_ApplyHit(TArray<struct FImpactInfo>* ImpactList);
	void STATIC_OnPersistTimerExpire();
	void PostBeginPlay();
	void STATIC_ReplicatedEvent(const struct FName& VarName);
};


// Class TgGame.TgDeploy_BoobyTrap
// 0x0018 (0x0460 - 0x0448)
class ATgDeploy_BoobyTrap : public ATgDeployable
{
public:
	class ATgCollisionProxy_Cylinder*                  m_CollisionProxy;                                         // 0x0448(0x0008)
	TArray<class AActor*>                              m_TouchingActors;                                         // 0x0450(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_BoobyTrap");
		return ptr;
	}


	void STATIC_DeployedAtCombatTarget(class AActor* CombatTarget);
	void SpawnCollisionProxy();
	void DeployComplete();
	void STATIC_FireAndDestroy();
	bool STATIC_DamageShouldEnterCombat();
	void DeviceFired();
	void STATIC_OnProxyUnTouch(class AActor* Other);
	void STATIC_OnProxyTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
};


// Class TgGame.TgDeploy_Forge
// 0x002C (0x0474 - 0x0448)
class ATgDeploy_Forge : public ATgDeployable
{
public:
	unsigned long                                      m_bBroadcast : 1;                                         // 0x0448(0x0004)
	unsigned long                                      m_bDestroyOnDeath : 1;                                    // 0x0448(0x0004)
	float                                              s_fDuration;                                              // 0x044C(0x0004)
	int                                                s_nTeam;                                                  // 0x0450(0x0004)
	float                                              s_fLockTime;                                              // 0x0454(0x0004)
	struct FString                                     s_sLockName;                                              // 0x0458(0x0010) (NeedCtorLink)
	int                                                r_nDeviceId;                                              // 0x0468(0x0004) (Net)
	int                                                r_nDuration;                                              // 0x046C(0x0004) (Net)
	int                                                r_nLockPlayer;                                            // 0x0470(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_Forge");
		return ptr;
	}


	void STATIC_DestroyIt(bool bSkipFx);
	void STATIC_ReplicatedEvent(const struct FName& VarName);
	void STATIC_Broadcast(bool bActive);
	void SpawnItem();
};


// Class TgGame.TgDeploy_ForgeResurrection
// 0x0000 (0x0474 - 0x0474)
class ATgDeploy_ForgeResurrection : public ATgDeploy_Forge
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_ForgeResurrection");
		return ptr;
	}


	void STATIC_DestroyIt(bool bSkipFx);
	void SpawnItem();
};


// Class TgGame.TgDeploy_Geometry
// 0x0028 (0x0470 - 0x0448)
class ATgDeploy_Geometry : public ATgDeployable
{
public:
	TArray<class AActor*>                              m_OverlappingActors;                                      // 0x0448(0x0010) (NeedCtorLink)
	TArray<struct FVector>                             m_DesiredPushDirection;                                   // 0x0458(0x0010) (NeedCtorLink)
	unsigned long                                      m_bPushOverlappingActors : 1;                             // 0x0468(0x0004)
	unsigned long                                      m_bAllyPassthrough : 1;                                   // 0x0468(0x0004)
	unsigned long                                      m_bEnemyPassthrough : 1;                                  // 0x0468(0x0004)
	float                                              m_fPushFactor;                                            // 0x046C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_Geometry");
		return ptr;
	}


	void PushOverlappingActors(float DeltaSeconds);
	struct FVector CalcPushDirection(const struct FVector& HitLocation, const struct FVector& HitNormal);
	void FindOverlappingActors();
	bool ShouldSelfDestructWhenTouchedBy(class AActor* Other);
	bool STATIC_IsPushable(class AActor* Other);
};


// Class TgGame.TgDeploy_Wall
// 0x00E4 (0x0554 - 0x0470)
class ATgDeploy_Wall : public ATgDeploy_Geometry
{
public:
	struct FVector                                     m_vSegmentExtent;                                         // 0x0470(0x000C) (Const)
	struct FVector                                     m_vOpenSpotExtent;                                        // 0x047C(0x000C) (Const)
	float                                              m_fWallOpenSpotTolerance;                                 // 0x0488(0x0004) (Const)
	float                                              m_fWallTraceDownDistance;                                 // 0x048C(0x0004) (Const)
	struct FWallSpawnInfo                              m_WallPlacementInfos[0x7];                                // 0x0490(0x0010)
	class UTgDeviceForm_Impasse*                       m_pImpasseForm;                                           // 0x0500(0x0008)
	class UMeshComponent*                              m_CenterMesh;                                             // 0x0508(0x0008) (ExportObject, Component, EditInline)
	class UMeshComponent*                              m_LeftMeshes[0x3];                                        // 0x0510(0x0008) (ExportObject, Component, EditInline)
	class UMeshComponent*                              m_RightMeshes[0x3];                                       // 0x0528(0x0008) (ExportObject, Component, EditInline)
	int                                                m_WallMeshIDCenter;                                       // 0x0540(0x0004)
	int                                                m_WallMeshIDEndCap;                                       // 0x0544(0x0004)
	unsigned long                                      r_bGrowthModeActivationSignal : 1;                        // 0x0548(0x0004) (Net)
	unsigned long                                      m_bInGrowthMode : 1;                                      // 0x0548(0x0004)
	unsigned long                                      m_bDidInitialHit : 1;                                     // 0x0548(0x0004)
	unsigned long                                      r_bEarthenGuardActive : 1;                                // 0x0548(0x0004) (Net)
	unsigned long                                      r_bHasAlpine : 1;                                         // 0x0548(0x0004) (Net)
	float                                              m_fGrowStartTime;                                         // 0x054C(0x0004)
	float                                              m_fInitialWallScaleZ;                                     // 0x0550(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_Wall");
		return ptr;
	}


	void STATIC_DestroyIt(bool bSkipFx);
	void DeployComplete();
	void STATIC_ActivateDisplayGroups(const struct FName& DisplayGroup, bool bActivateIndependent, bool bTurnOn);
	void STATIC_RemoveBasedPawn(class ATgPawn* basedPawn);
	void STATIC_AddBasedPawn(class ATgPawn* basedPawn);
	void STATIC_ReplicatedEvent(const struct FName& VarName);
	struct FVector STATIC_GetSegmentWorldLocation(const struct FVector& vLocalLocation);
	void PushOverlappingActors(float DeltaSeconds);
	void DoInitialHit();
	void PushBasedActors();
	void ToggleGrowthMode(bool bTurnOn);
	void SignalGrowthModeStart();
	void STATIC_InitializeMeshSegment(class UMeshComponent* Mesh, float fOffset);
	void SpawnMeshSegments();
	void UpdateWallPlacementInfos(const struct FVector& OriginLocation, const struct FRotator& originRotation);
};


// Class TgGame.TgDeploy_HealthNugget
// 0x0024 (0x046C - 0x0448)
class ATgDeploy_HealthNugget : public ATgDeployable
{
public:
	unsigned long                                      m_bRenderAsActive : 1;                                    // 0x0448(0x0004)
	unsigned long                                      m_bIsActiveRendered : 1;                                  // 0x0448(0x0004)
	unsigned long                                      m_bCountTowardsHealingStats : 1;                          // 0x0448(0x0004)
	class ATgHelpTipActor*                             c_HelpTipActor;                                           // 0x044C(0x0008)
	float                                              m_fHealOverride;                                          // 0x0454(0x0004)
	float                                              m_fHoTOverride;                                           // 0x0458(0x0004)
	TArray<class AActor*>                              m_PendingTouches;                                         // 0x045C(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_HealthNugget");
		return ptr;
	}


	void Destroyed();
	void STATIC_DestroyIt(bool bSkipFx);
	void UnTouch(class AActor* Other);
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void PostBeginPlay();
	void AdjustHeal(int nPropertyId, struct FImpactInfo* Impact, float* fHeal);
	void DeployAllyHealAOE(class ATgPawn_Character* TgP);
};


// Class TgGame.TgDeploy_HealthNugget_TeamOnly
// 0x000C (0x0478 - 0x046C)
class ATgDeploy_HealthNugget_TeamOnly : public ATgDeploy_HealthNugget
{
public:
	int                                                r_nTaskForceAlignment;                                    // 0x046C(0x0004) (Net)
	float                                              m_fNuggetSpawnTime;                                       // 0x0470(0x0004)
	float                                              m_fNuggetGracePeriod;                                     // 0x0474(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_HealthNugget_TeamOnly");
		return ptr;
	}


	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
};


// Class TgGame.TgDeploy_LootCrate
// 0x006C (0x04B4 - 0x0448)
class ATgDeploy_LootCrate : public ATgDeployable
{
public:
	int                                                m_nAssemblyId;                                            // 0x0448(0x0004)
	float                                              m_fLockTime;                                              // 0x044C(0x0004) (Config)
	TArray<struct FLootCrateInfo>                      m_LootInfo;                                               // 0x0450(0x0010) (Config, NeedCtorLink)
	TArray<struct FLootCrateInfo>                      m_OverrideLootInfo;                                       // 0x0460(0x0010) (Config, NeedCtorLink)
	float                                              s_fCloseTimer;                                            // 0x0470(0x0004)
	float                                              m_SecondaryCylinderHeight;                                // 0x0474(0x0004)
	float                                              m_SecondaryCylinderRadius;                                // 0x0478(0x0004)
	class ATgCollisionProxy_Cylinder*                  m_TouchCollisionProxy;                                    // 0x047C(0x0008)
	class UClass*                                      m_CollisionProxyClass;                                    // 0x0484(0x0008)
	int                                                c_LootPickupResponseCounter;                              // 0x048C(0x0004)
	unsigned long                                      c_bInitializing : 1;                                      // 0x0490(0x0004)
	float                                              m_fLootSpawnAngleDegrees;                                 // 0x0494(0x0004)
	float                                              m_fLootSpawnMinDist;                                      // 0x0498(0x0004)
	float                                              m_fLootSpawnMaxDist;                                      // 0x049C(0x0004)
	float                                              m_fOpenAnimBlendTime;                                     // 0x04A0(0x0004)
	TArray<class ATgAIController_BehaviorRoyale*>      BotsViewedBy;                                             // 0x04A4(0x0010) (Transient, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_LootCrate");
		return ptr;
	}


	void STATIC_OnItemsUpdated();
	void STATIC_PlayChestOpenEffects(bool bOpen);
	void STATIC_CloseChest();
	void STATIC_OnPickedUp(class APlayerReplicationInfo* PRI);
	void Destroyed();
	void STATIC_CollisionProxyOnUnTouch(class AActor* Other);
	void STATIC_CollisionProxyOnTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void SpawnCollisionProxy();
	void PostBeginPlay();
	void STATIC_ReplicatedEvent(const struct FName& VarName);
	void STATIC_TriggerSequenceEvent(class ATgPawn* pPawn);
	struct FVector STATIC_GetLocation();
	bool STATIC_SeenAsOpenByBot(class ATgAIController_BehaviorRoyale* pBR);
	void BroadcastSpawn(bool bSpawned);
	void STATIC_NativeInit();
	void UpdateTargetCylinder();
	bool STATIC_IsEmpty(class ATgPawn* pPawn);
	bool AttemptOpen(class ATgPawn* pPawn);
};


// Class TgGame.TgDeploy_LootCrateBasic
// 0x0004 (0x04B8 - 0x04B4)
class ATgDeploy_LootCrateBasic : public ATgDeploy_LootCrate
{
public:
	unsigned long                                      r_bIsChestOpened : 1;                                     // 0x04B4(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_LootCrateBasic");
		return ptr;
	}


	void STATIC_CloseChest();
	void STATIC_ReplicatedEvent(const struct FName& VarName);
	bool STATIC_IsEmpty(class ATgPawn* pPawn);
	bool AttemptOpen(class ATgPawn* pPawn);
};


// Class TgGame.TgDeploy_CardShrine
// 0x0000 (0x04B8 - 0x04B8)
class ATgDeploy_CardShrine : public ATgDeploy_LootCrateBasic
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_CardShrine");
		return ptr;
	}


	void UpdateLocalFX();
	void STATIC_PlayChestOpenEffects(bool bOpen);
	void STATIC_OnPickedUp(class APlayerReplicationInfo* PRI);
	void StartDeploy();
	void PostBeginPlay();
};


// Class TgGame.TgDeploy_LootCrateDevice
// 0x0010 (0x04C8 - 0x04B8)
class ATgDeploy_LootCrateDevice : public ATgDeploy_LootCrateBasic
{
public:
	TArray<int>                                        m_nDeviceIds;                                             // 0x04B8(0x0010) (Edit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_LootCrateDevice");
		return ptr;
	}


	bool AttemptOpen(class ATgPawn* pPawn);
};


// Class TgGame.TgDeploy_LootCrateEncounter
// 0x0004 (0x04BC - 0x04B8)
class ATgDeploy_LootCrateEncounter : public ATgDeploy_LootCrateBasic
{
public:
	unsigned long                                      r_bIsLocked : 1;                                          // 0x04B8(0x0004) (Net)
	unsigned long                                      r_bEncounterActive : 1;                                   // 0x04B8(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_LootCrateEncounter");
		return ptr;
	}


	void STATIC_Unlock();
	bool AttemptOpen(class ATgPawn* pPawn);
};


// Class TgGame.TgDeploy_RuneShrine
// 0x0000 (0x04B8 - 0x04B8)
class ATgDeploy_RuneShrine : public ATgDeploy_LootCrateBasic
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_RuneShrine");
		return ptr;
	}


	void UpdateLocalFX();
	void STATIC_PlayChestOpenEffects(bool bOpen);
	void STATIC_OnPickedUp(class APlayerReplicationInfo* PRI);
	void StartDeploy();
	void PostBeginPlay();
};


// Class TgGame.TgDeploy_LootCrateMagic
// 0x0018 (0x04CC - 0x04B4)
class ATgDeploy_LootCrateMagic : public ATgDeploy_LootCrate
{
public:
	int                                                r_nChestInstigatorId;                                     // 0x04B4(0x0004) (Net)
	unsigned long                                      r_bIsChestOpened : 1;                                     // 0x04B8(0x0004) (Net)
	TArray<int>                                        m_nOpenedPawnIds;                                         // 0x04BC(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_LootCrateMagic");
		return ptr;
	}


	void STATIC_CloseChest();
	void STATIC_ToggleChestVFX(bool bShow);
	void CloseChestEffects();
	void STATIC_ReplicatedEvent(const struct FName& VarName);
	bool STATIC_IsEmpty(class ATgPawn* pPawn);
	bool AttemptOpen(class ATgPawn* pPawn);
};


// Class TgGame.TgDeploy_MatchParentFireMode
// 0x0000 (0x0448 - 0x0448)
class ATgDeploy_MatchParentFireMode : public ATgDeployable
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_MatchParentFireMode");
		return ptr;
	}

};


// Class TgGame.TgDeploy_DeployableLinked
// 0x0008 (0x0450 - 0x0448)
class ATgDeploy_DeployableLinked : public ATgDeploy_MatchParentFireMode
{
public:
	class ATgDeployable*                               m_ParentDeployable;                                       // 0x0448(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_DeployableLinked");
		return ptr;
	}

};


// Class TgGame.TgDeploy_EffectAura
// 0x0044 (0x048C - 0x0448)
class ATgDeploy_EffectAura : public ATgDeploy_MatchParentFireMode
{
public:
	float                                              r_fRadiusScale;                                           // 0x0448(0x0004) (Net)
	TArray<class AActor*>                              m_TouchingActors;                                         // 0x044C(0x0010) (NeedCtorLink)
	TArray<class AActor*>                              m_AffectedActors;                                         // 0x045C(0x0010) (NeedCtorLink)
	float                                              m_fLastBlockedByBlockersTime;                             // 0x046C(0x0004)
	float                                              m_fMinBlockedByBlockersTime;                              // 0x0470(0x0004)
	TArray<class AActor*>                              m_BlockedActors;                                          // 0x0474(0x0010) (NeedCtorLink)
	class ATgCollisionProxy_Cylinder*                  m_CollisionProxy;                                         // 0x0484(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_EffectAura");
		return ptr;
	}


	void STATIC_ScaleFX();
	void STATIC_ScaleCollisionProxy();
	void SpawnCollisionProxy();
	void Destroyed();
	void STATIC_DestroyIt(bool bSkipFx);
	void STATIC_ClearAllTouched();
	float STATIC_GetCurrentRadius();
	void STATIC_OnProxyUnTouch(class AActor* Other);
	void STATIC_OnProxyTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_ReplicatedEvent(const struct FName& VarName);
	float STATIC_GetDistanceToTarget(class AActor* Target);
	void RemoveEffects(class AActor* Target);
	void ApplyEffects(class AActor* Target);
};


// Class TgGame.TgDeploy_Explosion
// 0x0000 (0x048C - 0x048C)
class ATgDeploy_Explosion : public ATgDeploy_EffectAura
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_Explosion");
		return ptr;
	}


	void STATIC_ScaleFX();
	void STATIC_DestroyIt(bool bSkipFx);
};


// Class TgGame.TgDeploy_EffectField
// 0x0034 (0x047C - 0x0448)
class ATgDeploy_EffectField : public ATgDeploy_MatchParentFireMode
{
public:
	float                                              m_fEffectFieldHeight;                                     // 0x0448(0x0004)
	float                                              r_fRadiusScale;                                           // 0x044C(0x0004) (Net)
	TArray<class AActor*>                              m_TouchingPawns;                                          // 0x0450(0x0010) (NeedCtorLink)
	TArray<class AActor*>                              m_HitActors;                                              // 0x0460(0x0010) (NeedCtorLink)
	unsigned long                                      m_bOnlyHitOnce : 1;                                       // 0x0470(0x0004)
	class ATgCollisionProxy_Cylinder*                  m_CollisionProxy;                                         // 0x0474(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_EffectField");
		return ptr;
	}


	void STATIC_ScaleCollisionProxy();
	void SpawnCollisionProxy();
	void Destroyed();
	void STATIC_DestroyIt(bool bSkipFx);
	void STATIC_ClearAllTouched();
	float STATIC_GetCurrentRadius();
	void ProxyUnTouchHit(class AActor* Other);
	void ProxyTouchHit(class AActor* Other);
	void ApplyLingeringTouch(class AActor* Other);
	void STATIC_OnProxyUnTouch(class AActor* Other);
	void STATIC_OnProxyTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
};


// Class TgGame.TgDeploy_DeployableLinkedEffectField
// 0x0008 (0x0484 - 0x047C)
class ATgDeploy_DeployableLinkedEffectField : public ATgDeploy_EffectField
{
public:
	class ATgDeployable*                               m_ParentDeployable;                                       // 0x047C(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_DeployableLinkedEffectField");
		return ptr;
	}

};


// Class TgGame.TgDeploy_EffectSpots
// 0x161C (0x1A64 - 0x0448)
class ATgDeploy_EffectSpots : public ATgDeploy_MatchParentFireMode
{
public:
	struct FEffectSpotInfo                             r_EffectSpots[0x64];                                      // 0x0448(0x002C) (Net)
	int                                                m_nNewSpotIndex;                                          // 0x1578(0x0004)
	class ATgCollisionProxy_Cylinder*                  m_CollisionProxy;                                         // 0x157C(0x0008)
	float                                              m_fFirstPassRadius;                                       // 0x1584(0x0004)
	TArray<class AActor*>                              m_TouchingActors;                                         // 0x1588(0x0010) (NeedCtorLink)
	TArray<struct FEffectSpotTarget>                   m_AffectedActors;                                         // 0x1598(0x0010) (NeedCtorLink)
	unsigned long                                      m_bUsesEffectRefresh : 1;                                 // 0x15A8(0x0004)
	float                                              m_fLastRefreshTime;                                       // 0x15AC(0x0004)
	float                                              m_fMinRefreshTime;                                        // 0x15B0(0x0004)
	struct FEffectSpotFXInfo                           c_SpotFX[0x64];                                           // 0x15B4(0x000C)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_EffectSpots");
		return ptr;
	}


	void Destroyed();
	void STATIC_DestroyIt(bool bSkipFx);
	void STATIC_ClearAllTouched();
	void ClearEffectSpots();
	void UpdateParticleParams(int spotIndex);
	void UpdateSpotFX(int spotIndex);
	void STATIC_ScaleCollisionProxy();
	void SpawnCollisionProxy();
	void UpdateEffectSpots();
	int SpawnNewSpot(const struct FVector& vLocation, const struct FRotator& rRotation, float fRadius, float fHeight, int nFXIndex, int nIntensityLevel);
	void STATIC_OnProxyUnTouch(class AActor* Other);
	void STATIC_OnProxyTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void Tick(float DeltaSeconds);
	void STATIC_ReplicatedEvent(const struct FName& VarName);
	void STATIC_InitializeSpecialFX(int spotIndex);
	void RemoveEffects(class AActor* Target);
	void ApplyEffects(class AActor* Target);
};


// Class TgGame.TgDeploy_EffectTrail
// 0x0398 (0x07E0 - 0x0448)
class ATgDeploy_EffectTrail : public ATgDeploy_MatchParentFireMode
{
public:
	class ATgPawn*                                     r_TrailPawn;                                              // 0x0448(0x0008) (Net)
	int                                                m_TrailEffectID;                                          // 0x0450(0x0004)
	class UTgSpecialFx*                                m_TrailEffects;                                           // 0x0454(0x0008)
	unsigned long                                      m_bHasInitialPoint : 1;                                   // 0x045C(0x0004)
	unsigned long                                      r_bInDeployMode : 1;                                      // 0x045C(0x0004) (Net)
	float                                              m_fPointDistance;                                         // 0x0460(0x0004)
	float                                              m_fPointLifetime;                                         // 0x0464(0x0004)
	int                                                m_nNextPointIndex;                                        // 0x0468(0x0004)
	int                                                m_nTailPointIndex;                                        // 0x046C(0x0004)
	struct FVector                                     m_TrailPoints[0x14];                                      // 0x0470(0x000C)
	struct FVector                                     m_ParticleSystemOffsets[0x14];                            // 0x0560(0x000C)
	float                                              m_TrailTimes[0x14];                                       // 0x0650(0x0004)
	class ATgCollisionProxy_Cylinder*                  m_CollisionProxies[0x14];                                 // 0x06A0(0x0008)
	class UDecalComponent*                             m_Decals[0x14];                                           // 0x0740(0x0008) (ExportObject, Component, EditInline)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_EffectTrail");
		return ptr;
	}


	void Destroyed();
	void ShutdownDeployMode();
	void STATIC_OnPersistTimerExpire();
	bool SpawnNewTrailFX(const struct FVector& trailLocation, const struct FVector& particleOffset);
	void STATIC_ConsumeTailPiece();
	void STATIC_OnProxyTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	bool CalculateAndSpawnNextPiece();
};


// Class TgGame.TgDeploy_Pickup
// 0x0098 (0x04E0 - 0x0448)
class ATgDeploy_Pickup : public ATgDeployable
{
public:
	int                                                r_nDeviceId;                                              // 0x0448(0x0004) (Net)
	int                                                r_nAmmoCount;                                             // 0x044C(0x0004) (Net)
	unsigned long                                      r_bAmmoOverridden : 1;                                    // 0x0450(0x0004) (Net)
	unsigned long                                      m_bDestroyOnPickup : 1;                                   // 0x0450(0x0004)
	unsigned long                                      m_bPickedUp : 1;                                          // 0x0450(0x0004)
	unsigned long                                      m_bCanAutoPickup : 1;                                     // 0x0450(0x0004)
	unsigned long                                      c_bPendingDisenchant : 1;                                 // 0x0450(0x0004)
	unsigned long                                      r_bIsDisenchanted : 1;                                    // 0x0450(0x0004) (Net)
	float                                              m_fAliveTime;                                             // 0x0454(0x0004)
	int                                                m_nNumBounces;                                            // 0x0458(0x0004)
	struct FRotator                                    m_rTargetRotation;                                        // 0x045C(0x000C)
	float                                              m_fTargetRotationInterpSpeed;                             // 0x0468(0x0004)
	int                                                r_nLockTime;                                              // 0x046C(0x0004) (Net)
	int                                                r_nLockPlayer;                                            // 0x0470(0x0004) (Net)
	int                                                r_nLockTaskForce;                                         // 0x0474(0x0004) (Net)
	float                                              s_fLockTime;                                              // 0x0478(0x0004)
	struct FString                                     r_sLockName;                                              // 0x047C(0x0010) (Net, NeedCtorLink)
	float                                              m_fAutoPickupSquareDistance;                              // 0x048C(0x0004)
	struct FName                                       m_nmPlayerPickupDisplayGroupName;                         // 0x0490(0x0008)
	int                                                c_LootPickupResponseCounter;                              // 0x0498(0x0004)
	class ATgPawn*                                     m_PendingTargetPickupPawn;                                // 0x049C(0x0008)
	float                                              m_fTimeToAutoPickup;                                      // 0x04A4(0x0004)
	float                                              m_fRemainingTimeTillAutoPickup;                           // 0x04A8(0x0004)
	class ATgPawn*                                     r_TargetPickupPawn;                                       // 0x04AC(0x0008) (Net)
	float                                              m_fAccelRate;                                             // 0x04B4(0x0004)
	float                                              m_fFlyToPlayerDeltaTime;                                  // 0x04B8(0x0004)
	float                                              m_fFlyToPlayerCutoffTime;                                 // 0x04BC(0x0004)
	class UTgSilhouetteComponent*                      m_Silhouette;                                             // 0x04C0(0x0008) (Edit, ExportObject, Component, EditInline)
	int                                                m_nUpgradeFXId;                                           // 0x04C8(0x0004)
	int                                                m_nDisableFXId;                                           // 0x04CC(0x0004)
	class UTgSpecialFx*                                m_UpgradeFX;                                              // 0x04D0(0x0008)
	class UTgSpecialFx*                                m_DisableFX;                                              // 0x04D8(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_Pickup");
		return ptr;
	}


	void STATIC_OnFlyToPlayerComplete();
	void FlyToPlayer(class ATgPawn* pPawn);
	void RecalculateGlows();
	void PlayPickupFX();
	void STATIC_DestroyIt(bool bSkipFx);
	void STATIC_OnDisenchanted();
	void HitWall(const struct FVector& HitNormal, class AActor* Wall, class UPrimitiveComponent* WallComp);
	void UnTouch(class AActor* Other);
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_OnPickedUp();
	void Destroyed();
	void PostBeginPlay();
	void STATIC_ReplicatedEvent(const struct FName& VarName);
	unsigned char STATIC_GetDeviceInventorySlot();
	void STATIC_RecalculateMaterial(bool bIsFriendlyWithLocalPawn, bool bForce);
	bool STATIC_IsValidPickup(class ATgPawn* pPawn);
	void STATIC_Broadcast(bool bActive);
};


// Class TgGame.TgDeploy_AutoPickup
// 0x0000 (0x04E0 - 0x04E0)
class ATgDeploy_AutoPickup : public ATgDeploy_Pickup
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_AutoPickup");
		return ptr;
	}

};


// Class TgGame.TgDeploy_Shard
// 0x000C (0x04EC - 0x04E0)
class ATgDeploy_Shard : public ATgDeploy_AutoPickup
{
public:
	float                                              m_fDelayedPickupTime;                                     // 0x04E0(0x0004)
	class ATgPawn*                                     m_DelayedPickupPawn;                                      // 0x04E4(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_Shard");
		return ptr;
	}


	void STATIC_OnFlyToPlayerComplete();
	void FinishDelayedPickup();
	void StartDelayedPickup(class ATgPawn* TargetPawn);
};


// Class TgGame.TgDeploy_InstantEffectPickup
// 0x0000 (0x04EC - 0x04EC)
class ATgDeploy_InstantEffectPickup : public ATgDeploy_Shard
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_InstantEffectPickup");
		return ptr;
	}


	void STATIC_OnFlyToPlayerComplete();
};


// Class TgGame.TgDeploy_XP
// 0x0010 (0x04F0 - 0x04E0)
class ATgDeploy_XP : public ATgDeploy_AutoPickup
{
public:
	unsigned long                                      m_bPreAwardXP : 1;                                        // 0x04E0(0x0004)
	float                                              m_fDelayedPickupTime;                                     // 0x04E4(0x0004)
	class ATgPawn*                                     m_DelayedPickupPawn;                                      // 0x04E8(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_XP");
		return ptr;
	}


	void STATIC_OnFlyToPlayerComplete();
	void FinishDelayedPickup();
	void StartDelayedPickup(class ATgPawn* TargetPawn);
};


// Class TgGame.TgDeploy_Nugget
// 0x0000 (0x04E0 - 0x04E0)
class ATgDeploy_Nugget : public ATgDeploy_Pickup
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_Nugget");
		return ptr;
	}

};


// Class TgGame.TgDeploy_Rune
// 0x000C (0x04EC - 0x04E0)
class ATgDeploy_Rune : public ATgDeploy_Pickup
{
public:
	int                                                r_nRunes[0x3];                                            // 0x04E0(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_Rune");
		return ptr;
	}

};


// Class TgGame.TgDeployable_Ammo
// 0x0000 (0x04E0 - 0x04E0)
class ATgDeployable_Ammo : public ATgDeploy_Pickup
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_Ammo");
		return ptr;
	}

};


// Class TgGame.TgDeploy_Shield
// 0x0004 (0x044C - 0x0448)
class ATgDeploy_Shield : public ATgDeployable
{
public:
	unsigned long                                      bBasedOnPawn : 1;                                         // 0x0448(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_Shield");
		return ptr;
	}


	void Destroyed();
	void BaseChange();
};


// Class TgGame.TgDeploy_SiegeShield
// 0x0024 (0x046C - 0x0448)
class ATgDeploy_SiegeShield : public ATgDeployable
{
public:
	struct FRotator                                    m_InitRotation;                                           // 0x0448(0x000C)
	class UMeshComponent*                              m_VFXCollisionMesh;                                       // 0x0454(0x0008) (ExportObject, Component, EditInline)
	class ATgCollisionProxy_Cylinder*                  m_CollisionProxy;                                         // 0x045C(0x0008)
	float                                              r_GroundSpeed;                                            // 0x0464(0x0004) (Net)
	unsigned long                                      m_bOnlyHitOnce : 1;                                       // 0x0468(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_SiegeShield");
		return ptr;
	}


	void STATIC_DestroyIt(bool bSkipFx);
	void Landed(const struct FVector& HitNormal, class AActor* FloorActor);
	void STATIC_OnHealthUpdated();
};


// Class TgGame.TgProjectile
// 0x0174 (0x0450 - 0x02DC)
class ATgProjectile : public AProjectile
{
public:
	struct FPointer                                    VfTable_ITgSkinnableInterface;                            // 0x02DC(0x0008) (Const, Native, NoExport)
	struct FPointer                                    VfTable_ITgObserver_ViewTargetChanged;                    // 0x02E4(0x0008) (Const, Native, NoExport)
	class UTgDeviceFire*                               s_LastDefaultMode;                                        // 0x02EC(0x0008)
	int                                                r_nProjectileId;                                          // 0x02F4(0x0004) (Net)
	int                                                m_nFiringInstance;                                        // 0x02F8(0x0004)
	float                                              r_fDuration;                                              // 0x02FC(0x0004) (Net)
	float                                              m_fPostLandDuration;                                      // 0x0300(0x0004)
	float                                              m_fLandZThreshold;                                        // 0x0304(0x0004)
	float                                              m_fPersistTime;                                           // 0x0308(0x0004)
	float                                              m_fPersistHitPulse;                                       // 0x030C(0x0004)
	int                                                m_nTargetPhysicalType;                                    // 0x0310(0x0004)
	class UMeshComponent*                              c_Mesh;                                                   // 0x0314(0x0008) (ExportObject, Component, EditInline)
	class UTgSpecialFx*                                c_ExplosionFx;                                            // 0x031C(0x0008)
	class UTgImpactFx*                                 c_ImpactFx;                                               // 0x0324(0x0008)
	unsigned long                                      c_bRotationFollowsVelocity : 1;                           // 0x032C(0x0004)
	unsigned long                                      m_bExplodeAtMaxRange : 1;                                 // 0x032C(0x0004)
	unsigned long                                      m_bDeployOnCharacter : 1;                                 // 0x032C(0x0004)
	unsigned long                                      m_bDeployOnTarget : 1;                                    // 0x032C(0x0004)
	unsigned long                                      m_bDeployOnGround : 1;                                    // 0x032C(0x0004)
	unsigned long                                      m_bAlwaysDeployUpwards : 1;                               // 0x032C(0x0004)
	unsigned long                                      m_bStickToWalls : 1;                                      // 0x032C(0x0004)
	unsigned long                                      c_bIsAOE : 1;                                             // 0x032C(0x0004)
	unsigned long                                      m_bCountDirectHitForAOE : 1;                              // 0x032C(0x0004)
	unsigned long                                      m_bUseAOEDirectHit : 1;                                   // 0x032C(0x0004)
	unsigned long                                      m_bHasExploded : 1;                                       // 0x032C(0x0004)
	unsigned long                                      m_bHitValidTarget : 1;                                    // 0x032C(0x0004)
	unsigned long                                      m_bIngoreBehindProjCollisions : 1;                        // 0x032C(0x0004)
	unsigned long                                      m_bIsInitialized : 1;                                     // 0x032C(0x0004)
	unsigned long                                      m_bIsShutDown : 1;                                        // 0x032C(0x0004)
	unsigned long                                      m_bPIEInitialized : 1;                                    // 0x032C(0x0004)
	unsigned long                                      m_bHasPlayedFizzleFX : 1;                                 // 0x032C(0x0004)
	unsigned long                                      m_bHasPlayedHitWallFX : 1;                                // 0x032C(0x0004)
	unsigned long                                      m_bHasPlayedHitTargetFX : 1;                              // 0x032C(0x0004)
	unsigned long                                      m_bSuppressDeployableSpawn : 1;                           // 0x032C(0x0004)
	unsigned long                                      m_bAltFireHit : 1;                                        // 0x032C(0x0004)
	unsigned long                                      m_bInvertTeam : 1;                                        // 0x032C(0x0004)
	unsigned long                                      m_bFirstShotAfterMovementAbility : 1;                     // 0x032C(0x0004)
	unsigned long                                      m_bCanSpawnOnClientFirst : 1;                             // 0x032C(0x0004)
	unsigned long                                      s_bIsClientTouch : 1;                                     // 0x032C(0x0004)
	unsigned long                                      m_bTrackToWorldLocation : 1;                              // 0x032C(0x0004)
	float                                              r_fAccelRate;                                             // 0x0330(0x0004) (Net)
	float                                              m_fTossZ;                                                 // 0x0334(0x0004)
	float                                              m_fFireAngle;                                             // 0x0338(0x0004)
	class AActor*                                      r_Owner;                                                  // 0x033C(0x0008) (Net)
	int                                                r_nOwnerFireModeId;                                       // 0x0344(0x0004) (Net)
	class UTgDeviceFire*                               m_OwnerFireMode;                                          // 0x0348(0x0008)
	TArray<class UTgDeviceFire*>                       m_ExtraFireModes;                                         // 0x0350(0x0010) (NeedCtorLink)
	float                                              r_fRange;                                                 // 0x0360(0x0004) (Net)
	float                                              m_fProximityDistance;                                     // 0x0364(0x0004)
	class ATgCollisionProxy*                           m_CollisionProxy;                                         // 0x0368(0x0008)
	int                                                s_nSpawnBotId;                                            // 0x0370(0x0004)
	int                                                s_nSpawnDeployableId;                                     // 0x0374(0x0004)
	TEnumAsByte<ESpawnDeployableOrientation>           m_DeployableSpawnOrientation;                             // 0x0378(0x0001)
	TEnumAsByte<ETG_EQUIP_POINT>                       r_eEquippedAt;                                            // 0x0379(0x0001) (Net)
	unsigned char                                      UnknownData00[0x2];                                       // 0x037A(0x0002) MISSED OFFSET
	float                                              m_fDamageRadius;                                          // 0x037C(0x0004)
	struct FVector                                     r_vSpawnLocation;                                         // 0x0380(0x000C) (Net)
	struct FVector                                     m_vSpawnRotation;                                         // 0x038C(0x000C)
	struct FVector                                     m_vLocationLastTick;                                      // 0x0398(0x000C)
	float                                              m_fMinTravelRange;                                        // 0x03A4(0x0004)
	float                                              s_fSpawnTime;                                             // 0x03A8(0x0004)
	int                                                m_nPostRenderIcon;                                        // 0x03AC(0x0004)
	int                                                m_nUniqueId;                                              // 0x03B0(0x0004)
	float                                              m_fBaseDamageMultiplier;                                  // 0x03B4(0x0004)
	struct FVector                                     c_vHitWallVelocity;                                       // 0x03B8(0x000C)
	class UDynamicLightEnvironmentComponent*           LightEnvironment;                                         // 0x03C4(0x0008) (Edit, Const, ExportObject, EditConst, Component, EditInline)
	struct FVector                                     m_vSpawnPosition;                                         // 0x03CC(0x000C)
	class UParticleSystemComponent*                    m_DebugProximityDistancePSC;                              // 0x03D8(0x0008) (ExportObject, Component, EditInline)
	float                                              m_fStandingStillPercent;                                  // 0x03E0(0x0004)
	int                                                m_nTargetsHitCount;                                       // 0x03E4(0x0004)
	struct FCollisionSettingsProjectile                m_CollisionSettings;                                      // 0x03E8(0x0004)
	TArray<class AActor*>                              m_PassThroughTargets;                                     // 0x03EC(0x0010) (NeedCtorLink)
	struct FTrackingSettings                           m_TrackingSettings;                                       // 0x03FC(0x0018)
	float                                              m_fDelayTrackSeconds;                                     // 0x0414(0x0004)
	float                                              m_fExplosionOffsetDistance;                               // 0x0418(0x0004)
	struct FTraceHitInfo                               m_BodyTraceResult;                                        // 0x041C(0x0028) (Component)
	float                                              s_fAoeRewindTime;                                         // 0x0444(0x0004)
	class ATgAkActorUnoccluded*                        m_AkActorUnoccluded;                                      // 0x0448(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProjectile");
		return ptr;
	}


	float STATIC_CheckOcclusion();
	struct FRotator STATIC_AlignDeployableByMyRotation(const struct FVector& HitNormal);
	void AltFireDetonate();
	void STATIC_GetExplosionFXParams(TArray<struct FParticleSysParam>* Params);
	void PlayAdditionalHitFX(bool bSuccessfulHit, const struct FVector& FXLocation, const struct FVector& HitNormal, const struct FVector& ProjDir, TArray<struct FParticleSysParam>* ExplosionParams);
	bool SuppressHitTargetFX(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal, bool bExploded);
	void PlayHitTargetFX(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal, bool bExploded);
	struct FName STATIC_GetExplodeInAirFxGroup();
	struct FName STATIC_GetHitWallFxGroup();
	struct FName STATIC_GetHitTargetFxGroup();
	void STATIC_PlayHitWallExplosionFX(const struct FVector& HitNormal, const struct FVector& HitLocation);
	class UPhysicalMaterial* TraceWorldPhysicalGeometry(const struct FVector& StartLoc, const struct FVector& EndLoc, struct FVector* TraceHitLocation);
	void PlayFizzleFX(const struct FVector& HitNormal, bool bIsExplosionFizzle);
	void STATIC_ReplicatedEvent(const struct FName& VarName);
	void STATIC_ServerFizzle();
	void STATIC_ServerDetonate();
	bool ProjectileCalcCamera(float fDeltaTime, struct FVector* out_CamLoc, struct FRotator* out_CamRot, float* out_FOV);
	void STATIC_MyOnParticleSystemFinished(class UParticleSystemComponent* PSC);
	void Destroyed();
	void STATIC_HideProjectile();
	void STATIC_TornOff();
	bool STATIC_IsFinished();
	void STATIC_ShutDown();
	void SpawnExplosionEffects(const struct FVector& HitLocation, const struct FVector& HitNormal, const struct FIMPACT_FX& ImpactFx);
	void SpawnFlightEffects();
	class UParticleSystemComponent* SpawnDebugProximityDistancePSC();
	void STATIC_Fizzle();
	void STATIC_ExplodeOnTarget(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_Explode(const struct FVector& HitLocation, const struct FVector& HitNormal);
	class AActor* CalculateHitActor(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal, struct FTraceHitInfo* HitInfo);
	bool STATIC_ApplyHit(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal, int HitItem);
	bool ApplyTheHit(class UTgDeviceFire* FireMode, const struct FImpactInfo& Impact, class AActor* DamageInstigator);
	bool STATIC_CheckTeamPassThrough(class AActor* Other);
	void Tick(float DeltaSeconds);
	void STATIC_ProxyUnTouch(class AActor* Other);
	void STATIC_ProxyTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_HitPassThroughTarget(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal);
	bool ShouldExplodeOnTouching(class AActor* Other);
	bool ForcefieldExclusionCheck(class AActor* Other);
	bool CheckHitAgainstBody(class ATgPawn* VictimPawn, const struct FVector& HitLocation, const struct FVector& HitNormal, float VelocityZ);
	void STATIC_ProcessTouch(class AActor* Other, const struct FVector& HitLocation, const struct FVector& HitNormal, float VelocityZ);
	void STATIC_ProcessTouchFromClient(class AActor* Other, const struct FVector& HitLocation, const struct FVector& HitNormal, float VelocityZ, float fAoeRewindTime);
	bool CanHitInstigator();
	bool STATIC_HandleOnProjectileHitTarget(class AActor* Other, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void ShutdownAndNotifyClient();
	void STATIC_ProcessTouchAsEvent(class AActor* Other, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_FellOutOfWorld(class UClass* dmgType);
	void HitWall(const struct FVector& HitNormal, class AActor* Wall, class UPrimitiveComponent* WallComp);
	bool STATIC_IsOutsideMinRange(const struct FVector& HitLocation);
	void SetAcceleration();
	bool ProximityReached(class AActor* A, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_GetHitLocationForProximityTouch(class AActor* Target, struct FVector* HitLocation, struct FVector* HitNormal);
	bool STATIC_IsValidTarget(class AActor* A);
	void SetTarget(class AActor* TargetActor, const struct FVector& TargetLocation);
	struct FVector STATIC_GetSeekLocation();
	void UpdateSeekingDirection(float fDeltaTime);
	void RangeReached();
	bool ShouldExplodeAtMaxRange();
	bool CheckProjectileRange(const struct FVector& vLocOverride);
	struct FVector CalculateInitialVelocity(const struct FVector& vAimDirection, bool bPlayerControlled);
	void Init(const struct FVector& Direction);
	void Landed(const struct FVector& HitNormal, class AActor* FloorActor);
	void TimerExplode();
	void TimerPulse();
	void STATIC_ClientSetExplode();
	void StartPulse();
	void STATIC_PostProjectileInitialize();
	void PostBeginPlay();
	bool UseAOE();
	float GetTerminalVelocity();
	void PostAkEvent(class UAkEvent* InAkEvent);
	void STATIC_OnViewTargetChanged(class AActor* aNewViewTarget);
	bool STATIC_GetDeployLocationAndRotation(const struct FVector& vLocation, class AActor* TargetActor, const struct FVector& vNormal, struct FVector* OutLocation, struct FRotator* OutRotation);
	class ATgDeployable* SpawnDeployable(const struct FVector& vLocation, class AActor* TargetActor, const struct FVector& vNormal);
	bool STATIC_GetBotSpawnLocationAndRotation(const struct FVector& vLocation, const struct FPointer& botSetup, struct FVector* OutLocation, struct FRotator* OutRotation);
	class ATgPawn* SpawnBot(const struct FVector& vLocation, bool bPet);
	void NativePostRenderFor(class APlayerController* PC, class UCanvas* Canvas, const struct FVector& CameraPosition, const struct FVector& CameraDir);
	void CompleteInitialization();
	bool CheckPhysicality(int nPawnType);
	float STATIC_GetBuffedRange();
};


// Class TgGame.TgProj_Simulated
// 0x00CC (0x051C - 0x0450)
class ATgProj_Simulated : public ATgProjectile
{
public:
	unsigned long                                      m_bHasFlashedShutdown : 1;                                // 0x0450(0x0004)
	unsigned long                                      m_bHasFlashExploded : 1;                                  // 0x0450(0x0004)
	unsigned long                                      m_bIgnoreClientHits : 1;                                  // 0x0450(0x0004)
	unsigned long                                      m_bShouldQueueServerHits : 1;                             // 0x0450(0x0004)
	unsigned long                                      m_bHasQueuedServerHit : 1;                                // 0x0450(0x0004)
	unsigned long                                      m_bNeedsFrictionOverride : 1;                             // 0x0450(0x0004)
	unsigned long                                      m_bFlashSpecialExplosion : 1;                             // 0x0450(0x0004)
	unsigned long                                      m_bTrackProjectileForTimelapse : 1;                       // 0x0450(0x0004)
	unsigned long                                      s_bTrackingInitialized : 1;                               // 0x0450(0x0004)
	unsigned long                                      m_bRequireAccurateTicksForPrediction : 1;                 // 0x0450(0x0004) (Const)
	int                                                m_nProjectileInstanceId;                                  // 0x0454(0x0004)
	int                                                m_nClientFireRequestId;                                   // 0x0458(0x0004)
	int                                                m_nFireLoopInstanceId;                                    // 0x045C(0x0004)
	struct FVector                                     m_LerpFromClientOffset;                                   // 0x0460(0x000C)
	float                                              m_LerpTimeRemaining;                                      // 0x046C(0x0004)
	class AActor*                                      m_QueuedExplodeTarget;                                    // 0x0470(0x0008)
	struct FVector                                     m_QueuedExplodeLocation;                                  // 0x0478(0x000C)
	struct FVector                                     m_QueuedExplodeNormal;                                    // 0x0484(0x000C)
	struct FVector                                     m_vSpawnVelocity;                                         // 0x0490(0x000C)
	struct FVector                                     m_vSpawnAcceleration;                                     // 0x049C(0x000C)
	struct FRotator                                    m_rSpawnRotator;                                          // 0x04A8(0x000C)
	float                                              m_fAllowedClientMovementTime;                             // 0x04B4(0x0004)
	float                                              m_fSpawnTimeStamp;                                        // 0x04B8(0x0004)
	float                                              m_fGravityScale;                                          // 0x04BC(0x0004)
	float                                              m_fFrictionOverride;                                      // 0x04C0(0x0004)
	TArray<class ATgPlayerController*>                 s_InterestedPlayers;                                      // 0x04C4(0x0010) (NeedCtorLink)
	int                                                m_nShadowFXID;                                            // 0x04D4(0x0004)
	class UTgSpecialFx*                                m_ShadowFX;                                               // 0x04D8(0x0008)
	class UDecalComponent*                             m_ShadowDecal;                                            // 0x04E0(0x0008) (ExportObject, Component, EditInline)
	float                                              m_fShadowBaseWidth;                                       // 0x04E8(0x0004)
	float                                              m_fMaxDecalHeight;                                        // 0x04EC(0x0004)
	struct FRotator                                    m_CachedRotation;                                         // 0x04F0(0x000C)
	float                                              m_fTrackingUpdateRate;                                    // 0x04FC(0x0004)
	float                                              s_fTrackingUpdateTimer;                                   // 0x0500(0x0004)
	class UTgGameplayCurves*                           m_GameplayCurves;                                         // 0x0504(0x0008)
	int                                                m_nDeployableOverlayDisplayMask;                          // 0x050C(0x0004)
	TEnumAsByte<EDeployableOverlayIcon>                m_eDeployableOverlayIcon;                                 // 0x0510(0x0001)
	TEnumAsByte<EDeployableOverlayState>               m_eDeployableOverlayState;                                // 0x0511(0x0001)
	unsigned char                                      UnknownData00[0x2];                                       // 0x0512(0x0002) MISSED OFFSET
	float                                              m_fDeployableOverlayEnemyViewDist;                        // 0x0514(0x0004)
	float                                              m_fDeployableActiveLifeTime;                              // 0x0518(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Simulated");
		return ptr;
	}


	void STATIC_ProcessRemoteSpawnVelocity(const struct FVector& SpawnVelocity);
	void TickAhead(float tickAmount);
	class UDecalComponent* SpawnShadowDecal();
	void SetTarget(class AActor* TargetActor, const struct FVector& TargetLocation);
	void STATIC_ClientTargetUpdate(class AActor* TargetActor, const struct FVector& TargetLocation);
	void HitWall(const struct FVector& HitNormal, class AActor* Wall, class UPrimitiveComponent* WallComp);
	bool STATIC_ApplyHit(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal, int HitItem);
	bool CheckProjectileRange(const struct FVector& vLocOverride);
	void CheckShieldPassthrough();
	void Tick(float DeltaSeconds);
	void Destroyed();
	void STATIC_Fizzle();
	void STATIC_ShutDown();
	void STATIC_ClientSyncServerBounce(const struct FVector& HitLocation, const struct FVector& BounceVelocity);
	void STATIC_ClientHitUpdate(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_ExplodeOnTarget(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void FudgeProjectileHitLocationForShields(class AActor* Other, struct FVector* HitLocation, struct FVector* HitNormal);
	void SetShouldQueueServerHits(bool bShouldQueue);
	void STATIC_ClientExplodeSpecial(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_ClientExplode(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_Explode(const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_SendSpawnAckToServer();
	void SendExplodeToServer(class AActor* Other, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_HitPassThroughTarget(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_ProcessTouch(class AActor* Other, const struct FVector& HitLocation, const struct FVector& HitNormal, float VelocityZ);
	void STATIC_ProcessTouchFromClient(class AActor* Other, const struct FVector& HitLocation, const struct FVector& HitNormal, float VelocityZ, float fAoeRewindTime);
	void STATIC_HandleQueuedFirstWorldExplosion();
	void ApplySpawnParams(float fDamageRadius, float fGeneric2);
	void ShutDownTrackingForTimelapse();
	void STATIC_InitTrackingForTimelapse();
	int STATIC_GetIndexForTimelapseTracking();
	void PredictStartLocationBasedOnPing(float Ping);
	float GetGravityZ();
	void SetLocationFromServer(const struct FVector& InLocation);
	void FlashNotifyTarget(class AActor* TargetActor, const struct FVector& TargetLocation);
	void STATIC_FlashNotifyBounce(const struct FVector& BounceLocation, const struct FVector& BounceVelocity);
	void FlashNotifyHitWall(class AActor* Wall, const struct FVector& HitNormal, const struct FVector& HitLocation);
	void FlashNotifyHit(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void FlashNotifyExplodedSpecial(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void FlashNotifyExploded(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void FlashNotifyFizzle();
	void FlashNotifyShutdown();
	void FlashNotifySpawn();
	void CompleteInitialization();
};


// Class TgGame.TgProj_ColumnBeam
// 0x0008 (0x0524 - 0x051C)
class ATgProj_ColumnBeam : public ATgProj_Simulated
{
public:
	float                                              m_fFloorCheckHeight;                                      // 0x051C(0x0004)
	unsigned long                                      m_bUseFloorAdjustment : 1;                                // 0x0520(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_ColumnBeam");
		return ptr;
	}


	float STATIC_GetRemainingTime();
	float STATIC_CheckOcclusion();
};


// Class TgGame.TgProj_FreeGrenade
// 0x0050 (0x056C - 0x051C)
class ATgProj_FreeGrenade : public ATgProj_Simulated
{
public:
	unsigned long                                      m_bShieldTouched : 1;                                     // 0x051C(0x0004)
	unsigned long                                      m_bExplodeOnTouch : 1;                                    // 0x051C(0x0004)
	unsigned long                                      m_bExplodeOnGeometry : 1;                                 // 0x051C(0x0004)
	unsigned long                                      m_bExplodeOnFloor : 1;                                    // 0x051C(0x0004)
	unsigned long                                      m_bUseBilinearInterpolationForBounceDamping : 1;          // 0x051C(0x0004)
	unsigned long                                      m_bUseGravityZOverride : 1;                               // 0x051C(0x0004)
	class ATgDeployable*                               m_TouchedShield;                                          // 0x0520(0x0008)
	float                                              m_fToleranceZ;                                            // 0x0528(0x0004)
	float                                              m_fBounceDampingVertMin;                                  // 0x052C(0x0004)
	float                                              m_fBounceDampingVertMax;                                  // 0x0530(0x0004)
	float                                              m_fBounceDampingHorizMin;                                 // 0x0534(0x0004)
	float                                              m_fBounceDampingHorizMax;                                 // 0x0538(0x0004)
	float                                              m_fBounceDamping;                                         // 0x053C(0x0004)
	float                                              m_fSpeedToActivateBounceFX;                               // 0x0540(0x0004)
	float                                              m_fGravityZOverride;                                      // 0x0544(0x0004)
	int                                                m_nBounceCount;                                           // 0x0548(0x0004)
	int                                                m_nBouncesToExplode;                                      // 0x054C(0x0004)
	float                                              m_fBounceDistinctionDuration;                             // 0x0550(0x0004)
	float                                              m_fLastBounceTime;                                        // 0x0554(0x0004)
	struct FVector                                     m_vRecentHitNormal;                                       // 0x0558(0x000C)
	float                                              m_fRecentHitTime;                                         // 0x0564(0x0004)
	float                                              m_fBounceFlashThreshold;                                  // 0x0568(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_FreeGrenade");
		return ptr;
	}


	void Destroyed();
	void Landed(const struct FVector& HitNormal, class AActor* FloorActor);
	void STATIC_ProcessTouch(class AActor* Other, const struct FVector& HitLocation, const struct FVector& HitNormal, float VelocityZ);
	void PlayBounceSound();
	void STATIC_ApplyBounce(const struct FVector& HitLocation, const struct FVector& HitNormal, class AActor* Wall, class UPrimitiveComponent* WallComp);
	bool ShouldHitBounce(class AActor* Target, const struct FVector& HitNormal);
	void HitWall(const struct FVector& HitNormal, class AActor* Wall, class UPrimitiveComponent* WallComp);
	void STATIC_ClientSyncServerBounce(const struct FVector& HitLocation, const struct FVector& BounceVelocity);
	void STATIC_HandleBounceReaction(const struct FVector& HitLocation, const struct FVector& VelocityBefore, const struct FVector& VelocityAfter);
	void STATIC_OnLand();
	void STATIC_LandTimerExplode();
	void StartLandExplodeTimer();
	float STATIC_GetPostLandDuration();
	void PlayHitTargetFX(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal, bool bExploded);
	void STATIC_PlayHitWallExplosionFX(const struct FVector& HitNormal, const struct FVector& HitLocation);
	void Timer();
	void STATIC_ShutDown();
	void PostBeginPlay();
	float GetGravityZ();
};


// Class TgGame.TgProj_TargetedBounceBase
// 0x0018 (0x0584 - 0x056C)
class ATgProj_TargetedBounceBase : public ATgProj_FreeGrenade
{
public:
	class AActor*                                      m_LastBounceTarget;                                       // 0x056C(0x0008)
	class AActor*                                      m_NextBounceTarget;                                       // 0x0574(0x0008)
	unsigned long                                      m_bCanTargetShields : 1;                                  // 0x057C(0x0004)
	float                                              m_fMaxBounceRange;                                        // 0x0580(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_TargetedBounceBase");
		return ptr;
	}


	bool STATIC_IsValidBounceTarget(class AActor* TestActor, const struct FTargetedBounceInfo& Info);
	class AActor* DetermineNextTarget(const struct FVector& BounceNormal);
};


// Class TgGame.TgProj_SkullBounceSecondary
// 0x0000 (0x0584 - 0x0584)
class ATgProj_SkullBounceSecondary : public ATgProj_TargetedBounceBase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_SkullBounceSecondary");
		return ptr;
	}


	void STATIC_ProcessRemoteSpawnVelocity(const struct FVector& SpawnVelocity);
	void STATIC_ExplodeOnTarget(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal);
	bool STATIC_HandleOnProjectileHitTarget(class AActor* Other, const struct FVector& HitLocation, const struct FVector& HitNormal);
	bool STATIC_IsValidTarget(class AActor* A);
	bool ShouldExplodeOnTouching(class AActor* Other);
};


// Class TgGame.TgProj_TargetedBounce
// 0x0000 (0x0584 - 0x0584)
class ATgProj_TargetedBounce : public ATgProj_TargetedBounceBase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_TargetedBounce");
		return ptr;
	}


	bool ShouldHitBounce(class AActor* Target, const struct FVector& HitNormal);
	void STATIC_ApplyBounce(const struct FVector& HitLocation, const struct FVector& HitNormal, class AActor* Wall, class UPrimitiveComponent* WallComp);
	void STATIC_ProcessTouch(class AActor* Other, const struct FVector& HitLocation, const struct FVector& HitNormal, float VelocityZ);
};


// Class TgGame.TgProj_SkullBounce
// 0x0000 (0x0584 - 0x0584)
class ATgProj_SkullBounce : public ATgProj_TargetedBounce
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_SkullBounce");
		return ptr;
	}


	void STATIC_ExplodeOnTarget(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_ApplyBounce(const struct FVector& HitLocation, const struct FVector& HitNormal, class AActor* Wall, class UPrimitiveComponent* WallComp);
};


// Class TgGame.TgProj_SniperProjectile
// 0x0000 (0x051C - 0x051C)
class ATgProj_SniperProjectile : public ATgProj_Simulated
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_SniperProjectile");
		return ptr;
	}


	void ApplySpawnParams(float fProjectileSpeed, float fGravityScale);
};


// Class TgGame.TgProj_SpeedOverTime
// 0x0000 (0x051C - 0x051C)
class ATgProj_SpeedOverTime : public ATgProj_Simulated
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_SpeedOverTime");
		return ptr;
	}

};


// Class TgGame.TgProj_SpeedOverRange
// 0x0000 (0x051C - 0x051C)
class ATgProj_SpeedOverRange : public ATgProj_SpeedOverTime
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_SpeedOverRange");
		return ptr;
	}

};


// Class TgGame.TgProj_ExtraColliders
// 0x0030 (0x054C - 0x051C)
class ATgProj_ExtraColliders : public ATgProj_SpeedOverRange
{
public:
	class ATgCollisionProxy_Cylinder*                  m_SecondaryCollisionProxies[0x2];                         // 0x051C(0x0008)
	class UParticleSystemComponent*                    m_SecondaryDebugProximityDistancePSC[0x2];                // 0x052C(0x0008) (ExportObject, Component, EditInline)
	TArray<struct FTrackedCollision>                   m_TrackedCollisions;                                      // 0x053C(0x0010) (Component, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_ExtraColliders");
		return ptr;
	}


	void STATIC_PlayHitWallExplosionFX(const struct FVector& HitNormal, const struct FVector& HitLocation);
	void PlayHitTargetFX(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal, bool bExploded);
	float STATIC_GetDecalRotationOffset();
	void STATIC_HideProjectile();
	void Destroyed();
	void SpawnSecondaryCollisionProxies();
	float STATIC_GetCollistionOffsetDistance();
	struct FVector STATIC_GetCollisionOffsetDir();
	void STATIC_HandleSecondaryProxyUntouch(class AActor* Other);
	void STATIC_HandleSecondaryProxyTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_ProxyUnTouch(class AActor* Other);
	void STATIC_ProxyTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_ForwardProxyUntouch(class AActor* Other);
	void STATIC_ForwardProxyTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_OnSecondaryProxyUnTouch(class AActor* Other);
	void STATIC_OnSecondaryProxyTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	bool CheckHitAgainstBody(class ATgPawn* VictimPawn, const struct FVector& HitLocation, const struct FVector& HitNormal, float VelocityZ);
	void CompleteInitialization();
};


// Class TgGame.TgAudioComponent
// 0x0010 (0x02DC - 0x02CC)
class UTgAudioComponent : public UAudioComponent
{
public:
	unsigned long                                      m_bCanBeHeardDuringStealth : 1;                           // 0x02CC(0x0004)
	float                                              m_fStealthFadeInTime;                                     // 0x02D0(0x0004)
	float                                              m_fStealthFadeOutTime;                                    // 0x02D4(0x0004)
	float                                              m_fStealthVolumeMultiplier;                               // 0x02D8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAudioComponent");
		return ptr;
	}


	void OcclusionChanged(bool bNowOccluded);
	void STATIC_ApplyAdditionalPriority();
};


// Class TgGame.TgAudioComponent_ModByVelocity
// 0x0000 (0x02DC - 0x02DC)
class UTgAudioComponent_ModByVelocity : public UTgAudioComponent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAudioComponent_ModByVelocity");
		return ptr;
	}

};


// Class TgGame.TgDecalManager
// 0x0000 (0x02BC - 0x02BC)
class ATgDecalManager : public ADecalManager
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDecalManager");
		return ptr;
	}


	void SpawnDecalNative(bool bUsePool, class UMaterialInterface* DecalMaterial, const struct FVector& DecalLocation, const struct FRotator& DecalOrientation, float Width, float Height, float Thickness, bool bNoClip);
};


// Class TgGame.TgEmitter
// 0x0008 (0x029C - 0x0294)
class ATgEmitter : public AEmitter
{
public:
	struct FName                                       BoneName;                                                 // 0x0294(0x0008) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEmitter");
		return ptr;
	}


	void ScaleEmitter(float ScaleFactor);
	void AttachTo(class APawn* P, const struct FName& NewBoneName);
	void STATIC_ReplicatedEvent(const struct FName& VarName);
};


// Class TgGame.TgEmitter_CameraEffect
// 0x0018 (0x02B4 - 0x029C)
class ATgEmitter_CameraEffect : public ATgEmitter
{
public:
	float                                              m_fDistFromCamera;                                        // 0x029C(0x0004) (Edit)
	unsigned long                                      m_bShowOnlyIn1P : 1;                                      // 0x02A0(0x0004) (Edit)
	unsigned long                                      m_bShowOnlyIn3P : 1;                                      // 0x02A0(0x0004) (Edit)
	unsigned long                                      m_bIsIn1P : 1;                                            // 0x02A0(0x0004)
	unsigned long                                      m_bIsCameraEffectActive : 1;                              // 0x02A0(0x0004)
	TArray<struct FFx_Sound>                           m_SoundList;                                              // 0x02A4(0x0010) (Component, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEmitter_CameraEffect");
		return ptr;
	}


	void STATIC_UpdateLocation(float CamFOVDeg, struct FVector* CamLoc, struct FRotator* CamRot);
	void StopSounds();
	void PlaySounds();
	void SetSoundList(TArray<struct FFx_Sound> SoundList);
	void STATIC_SetCameraEffectActive(bool bActive);
	void STATIC_Reactivate();
	void Deactivate();
	void STATIC_Activate();
	void Destroyed();
};


// Class TgGame.TgEmitter_CameraEffect_DamageBase
// 0x0001 (0x02B5 - 0x02B4)
class ATgEmitter_CameraEffect_DamageBase : public ATgEmitter_CameraEffect
{
public:
	TEnumAsByte<EDamageEffectScreenLocation>           ScreenLocation;                                           // 0x02B4(0x0001) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEmitter_CameraEffect_DamageBase");
		return ptr;
	}


	void STATIC_UpdateLocation(float CamFOVDeg, struct FVector* CamLoc, struct FRotator* CamRot);
	void STATIC_Activate();
	void SetDamageIntensity(float fDamageIntensity, bool bCritical);
};


// Class TgGame.TgEmitter_CameraEffect_LowHealth
// 0x0004 (0x02B8 - 0x02B4)
class ATgEmitter_CameraEffect_LowHealth : public ATgEmitter_CameraEffect
{
public:
	float                                              m_fFade;                                                  // 0x02B4(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEmitter_CameraEffect_LowHealth");
		return ptr;
	}


	void UpdateFOV(float fFOV);
	void SetDeathProximity(float fCloseToDeath);
};


// Class TgGame.TgEmitter_TeamColor
// 0x0008 (0x029C - 0x0294)
class ATgEmitter_TeamColor : public AEmitter
{
public:
	int                                                nTaskForce;                                               // 0x0294(0x0004) (Edit)
	struct FParticleChannelContainer                   DefaultParticleChannels;                                  // 0x0298(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEmitter_TeamColor");
		return ptr;
	}


	void NotifyLocalPlayerTeamReceived();
	void SetPSCChannels();
};


// Class TgGame.TgEmitterSpawnable
// 0x0000 (0x0294 - 0x0294)
class ATgEmitterSpawnable : public AEmitter
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEmitterSpawnable");
		return ptr;
	}

};


// Class TgGame.TgImpactFx
// 0x004C (0x00AC - 0x0060)
class UTgImpactFx : public UObject
{
public:
	float                                              c_fMaxFxDistance;                                         // 0x0060(0x0004)
	unsigned long                                      c_bAlignToSurfaceNormal : 1;                              // 0x0064(0x0004)
	struct FIMPACT_FX                                  c_EmptyImpact;                                            // 0x0068(0x0034)
	TArray<struct FIMPACT_FX>                          c_Impacts;                                                // 0x009C(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgImpactFx");
		return ptr;
	}


	void ApplyImpact(class AActor* Instigator, class AActor* HitActor, const struct FVector& HitLocation, const struct FVector& HitNormal, const struct FIMPACT_FX& Impact);
	struct FIMPACT_FX STATIC_GetImpactFx(class UPhysicalMaterial* HitMaterial);
	bool STATIC_IsEffectRelevant(class AActor* Viewer, const struct FVector& HitLocation);
};


// Class TgGame.TgParticleModuleTypeDataLight
// 0x0010 (0x0078 - 0x0068)
class UTgParticleModuleTypeDataLight : public UParticleModuleTypeDataBase
{
public:
	class UPointLightComponent*                        m_PointLightComponent;                                    // 0x0068(0x0008) (Edit, ExportObject, Component, EditInline)
	class UPointLightComponent*                        m_PLCDuplicate;                                           // 0x0070(0x0008) (ExportObject, Component, EditInline)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgParticleModuleTypeDataLight");
		return ptr;
	}

};


// Class TgGame.TgPhysicalMaterialProperty
// 0x0008 (0x0068 - 0x0060)
class UTgPhysicalMaterialProperty : public UPhysicalMaterialPropertyBase
{
public:
	struct FName                                       MaterialType;                                             // 0x0060(0x0008) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPhysicalMaterialProperty");
		return ptr;
	}

};


// Class TgGame.TgSilhouetteComponentPaladins
// 0x0060 (0x02FC - 0x029C)
class UTgSilhouetteComponentPaladins : public UTgSilhouetteComponent
{
public:
	struct FSilhouetteColorSettings                    m_ColorSettings;                                          // 0x029C(0x0020) (Edit)
	struct FSilhouetteFadeSettings                     m_FadeSettings;                                           // 0x02BC(0x0014) (Edit)
	struct FSilhouettePulseSettings                    m_PulseSettings;                                          // 0x02D0(0x002C) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSilhouetteComponentPaladins");
		return ptr;
	}

};


// Class TgGame.TgSilhouetteComponentPaladinsDeployable
// 0x0000 (0x02FC - 0x02FC)
class UTgSilhouetteComponentPaladinsDeployable : public UTgSilhouetteComponentPaladins
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSilhouetteComponentPaladinsDeployable");
		return ptr;
	}

};


// Class TgGame.TgSilhouetteComponentPaladinsPawn
// 0x0000 (0x02FC - 0x02FC)
class UTgSilhouetteComponentPaladinsPawn : public UTgSilhouetteComponentPaladins
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSilhouetteComponentPaladinsPawn");
		return ptr;
	}

};


// Class TgGame.TgSilhouetteComponentPayload
// 0x0000 (0x02FC - 0x02FC)
class UTgSilhouetteComponentPayload : public UTgSilhouetteComponentPaladins
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSilhouetteComponentPayload");
		return ptr;
	}

};


// Class TgGame.TgSilhouetteManager
// 0x0024 (0x02A4 - 0x0280)
class ATgSilhouetteManager : public AActor
{
public:
	class AActor*                                      m_Owner;                                                  // 0x0280(0x0008)
	unsigned long                                      m_bSilhouettesEnabled : 1;                                // 0x0288(0x0004)
	unsigned long                                      m_bForceSilhouetteVisible : 1;                            // 0x0288(0x0004) (Edit, Const)
	TArray<struct FTgSilhouetteInfo>                   m_SilhouetteInfos;                                        // 0x028C(0x0010) (Transient, Component, NeedCtorLink)
	class UClass*                                      m_SilhouetteClass;                                        // 0x029C(0x0008) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSilhouetteManager");
		return ptr;
	}


	void TickSilhouettes(float DeltaSeconds);
	bool ShouldAnySilhouettesBeVisible();
	void UpdateSilhouetteVisibility();
	void ClearAllSilhouetteInfos();
	bool RemoveSilhouetteInfo(class UMeshComponent* ParentMesh);
	int FindSilhouetteInfo(class UMeshComponent* ParentMesh);
	int STATIC_InitializeSilhouetteComponent(class UMeshComponent* InMesh, float fLifeAfterDeath);
};


// Class TgGame.TgSoundGroup
// 0x0020 (0x0080 - 0x0060)
class UTgSoundGroup : public UObject
{
public:
	TArray<class USoundCue*>                           c_SoundCues;                                              // 0x0060(0x0010) (Const, NeedCtorLink)
	TArray<struct FFootstepSoundInfo>                  c_FootstepSounds;                                         // 0x0070(0x0010) (Const, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSoundGroup");
		return ptr;
	}


	void STATIC_PlayFootStepSound(class APawn* P, int FootDown, const struct FName& MaterialType);
	void PlaySound(TEnumAsByte<EeTG_SOUNDS> eSound, class APawn* P);
};


// Class TgGame.TgSpecialFx
// 0x00D0 (0x0130 - 0x0060)
class UTgSpecialFx : public UObject
{
public:
	int                                                c_nFxId;                                                  // 0x0060(0x0004)
	class UMeshComponent*                              c_OwnerMesh;                                              // 0x0064(0x0008) (ExportObject, Component, EditInline)
	class AActor*                                      c_Owner;                                                  // 0x006C(0x0008)
	unsigned long                                      c_bAttached : 1;                                          // 0x0074(0x0004)
	unsigned long                                      c_bAppliesToAllModes : 1;                                 // 0x0074(0x0004)
	unsigned long                                      c_bSelfManage : 1;                                        // 0x0074(0x0004)
	unsigned long                                      c_bFromEffectForm : 1;                                    // 0x0074(0x0004)
	unsigned long                                      c_bVisualComplete : 1;                                    // 0x0074(0x0004)
	unsigned long                                      c_bAudioComplete : 1;                                     // 0x0074(0x0004)
	unsigned long                                      c_bMuteSound : 1;                                         // 0x0074(0x0004)
	unsigned long                                      c_bIsDebuff : 1;                                          // 0x0074(0x0004)
	unsigned long                                      c_bHasTeamMaterials : 1;                                  // 0x0074(0x0004)
	unsigned long                                      c_bActive : 1;                                            // 0x0074(0x0004)
	unsigned long                                      c_bIsSpawnFx : 1;                                         // 0x0074(0x0004)
	unsigned long                                      c_bUseBeam : 1;                                           // 0x0074(0x0004)
	unsigned long                                      c_bLifetimeManagedExternally : 1;                         // 0x0074(0x0004)
	unsigned long                                      c_bLocalPawnIsOwner : 1;                                  // 0x0074(0x0004) (AlwaysInit)
	unsigned long                                      m_bMatLoaded : 1;                                         // 0x0074(0x0004)
	unsigned long                                      m_bMatLoadedFriendly : 1;                                 // 0x0074(0x0004)
	unsigned long                                      m_bMatLoadedLocal : 1;                                    // 0x0074(0x0004)
	unsigned long                                      m_bDecalMatLoaded : 1;                                    // 0x0074(0x0004)
	unsigned long                                      m_bDecalMatLoadedFriendly : 1;                            // 0x0074(0x0004)
	unsigned long                                      m_bDecalMatLoadedLocal : 1;                               // 0x0074(0x0004)
	int                                                c_nPriorityType;                                          // 0x0078(0x0004)
	int                                                c_nPrioritySort;                                          // 0x007C(0x0004)
	struct FName                                       c_nmSocket;                                               // 0x0080(0x0008)
	struct FName                                       c_nmDisplayGroup;                                         // 0x0088(0x0008)
	int                                                c_nDisplayMode;                                           // 0x0090(0x0004)
	int                                                c_nIndex;                                                 // 0x0094(0x0004)
	int                                                c_nEquipSlot;                                             // 0x0098(0x0004)
	class UMaterialInstance*                           c_MaterialInstance;                                       // 0x009C(0x0008)
	float                                              c_fTransition;                                            // 0x00A4(0x0004)
	int                                                c_nHitEffectBase;                                         // 0x00A8(0x0004)
	float                                              c_fMaxEffectDistance;                                     // 0x00AC(0x0004)
	struct FParticleChannelContainer                   c_ParticleChannelOverride;                                // 0x00B0(0x0004)
	int                                                c_nSortPriorityOverride;                                  // 0x00B4(0x0004)
	int                                                c_bSortPriorityOverridden;                                // 0x00B8(0x0004)
	TEnumAsByte<ELightFxState>                         c_LightComponentState;                                    // 0x00BC(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x00BD(0x0003) MISSED OFFSET
	class ULightComponent*                             c_LightComponent;                                         // 0x00C0(0x0008) (ExportObject, Component, AlwaysInit, EditInline)
	struct FPointer                                    c_ManagedLightEmitter;                                    // 0x00C8(0x0008) (AlwaysInit)
	TArray<struct FFx_Sound>                           c_SoundList;                                              // 0x00D0(0x0010) (Component, AlwaysInit, NeedCtorLink)
	TArray<struct FFx_PSC>                             c_PSCList;                                                // 0x00E0(0x0010) (Component, AlwaysInit, NeedCtorLink)
	TArray<struct FFx_Material>                        c_MaterialList;                                           // 0x00F0(0x0010) (AlwaysInit, NeedCtorLink)
	TArray<struct FFx_Decal>                           c_DecalList;                                              // 0x0100(0x0010) (Component, AlwaysInit, NeedCtorLink)
	class UTgCameraShake*                              c_CameraShake;                                            // 0x0110(0x0008)
	class UTgTimerManager*                             c_ActiveTimer;                                            // 0x0118(0x0008)
	TArray<struct FAppliedMaterialHandle>              m_AppliedMaterials;                                       // 0x0120(0x0010) (Component, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSpecialFx");
		return ptr;
	}


	bool STATIC_IsLocal();
	bool STATIC_IsFriendly();
	float CalculateOrientedDecalRotation(const struct FVector& HitLocation, const struct FVector& HitNormal, const struct FVector& DecalOrientationDirection);
	void SetDepthPriorityGroup(TEnumAsByte<ESceneDepthPriorityGroup> NewDepthPriorityGroup);
	void STATIC_SetKillOnDeactivate();
	void STATIC_ListSounds();
	void UpdateBeamFx(const struct FVector& HitLocation, const struct FVector& HitOrigin, class AActor* targetOverride);
	class UDecalComponent* SpawnDecal(class AWorldInfo* WorldInfo, bool bUsePool, const struct FVector& SpawnLocation, const struct FRotator& SpawnRotation, float DecalRotation, float Scale, struct FFx_Decal* Decal);
	void SpawnTracer(const struct FVector& HitLocation, const struct FVector& HitOrigin);
	class AActor* STATIC_GetHitActor(const struct FVector& EffectLocation, const struct FVector& HitLocation);
	bool STATIC_HasSoundCue();
	void RemoveMICFxFromOwningPawn();
	void ApplyMICFxToOwningPawn(int nMatTypeCodeOverride, int nMaterialPriority);
	class USkeletalMeshComponent* FindMeshWithSocket(const struct FName& nmSocket, class USkeletalMeshComponent* first, class AActor* Second, struct FName* BoneName, struct FVector* RelativeLocation, struct FRotator* RelativeRotation, struct FVector* RelativeScale);
	void STATIC_OverridePSCChannels(const struct FParticleChannelContainer& PSysChannels);
	struct FParticleChannelContainer STATIC_GetLocalPlayerPSCChannels(class UParticleSystemComponent* ActivePSC, class UParticleSystem* Template);
	void UpdateHiddenDecals(bool bClearAll);
	bool STATIC_InitDecalFadeOut(struct FFx_Decal* Decal);
	void DeactivateDecal(struct FFx_Decal* Decal);
	void ActivateDecal(struct FFx_Decal* Decal);
	void StopSound();
	void PlaySound();
	void CheckDeactivate();
	void OnAudioFinishedFX(class UAudioComponent* FinishedComponent);
	void OnParticleSystemFinished(class UParticleSystemComponent* FinishedComponent);
	void Deactivate(bool bForceDeactivate);
	float STATIC_Activate(const struct FVector& HitLocation, bool bSkipRelevantChecking);
	void AdjustEffectFOV(float NewFOV);
	void AdjustEffectScale(int nPSCIndex, float fScale);
	void AdjustFxScaleByRadius(float fScale);
	void AdjustEffectRadius(int nPSCIndex, float fScale);
	class ATgPawn* FindLocalPlayerPawn();
	class ATgPlayerController* FindLocalPlayerController();
	bool STATIC_IsFxRelevant(const struct FVector& SpawnLocation);
	void SetHitEffectScaleBasedOnDamage(int nHealthChange);
	void PlayCameraShake(const struct FVector& Epicenter);
	void SpawnDecalAt(const struct FVector& HitLocation, const struct FVector& HitNormal, float DecalRotation, float Scale);
	void STATIC_SpawnSound(const struct FVector& Location);
	void STATIC_SpawnEmitter(const struct FVector& HitLocation, const struct FVector& HitNormal, float fScale, TArray<struct FParticleSysParam> Params);
	void UpdateSoundPlaying(class UAudioComponent* pacSound);
	bool AreAnySoundsPlaying();
	void SetPSCRunning(class UParticleSystemComponent* pPSC, bool bOn);
	bool AreAnyPSCRunning();
	void ResetParticles(bool bResetInstances);
	void PlaySoundAt(const struct FVector& Location);
	bool ShouldShowWhenStealthed();
	void STATIC_SetHidden(bool bNewHidden);
	void AdjustHidden(bool bHidden);
	void STATIC_OnActiveTimeExpired();
	void SetActiveTime(float Duration, class ATgPawn* Owner);
	class AActor* SpawnActor(class UClass* InClass, const struct FVector& Location, const struct FRotator& Rotation);
	void SetPSCChannels(class UParticleSystemComponent* PSC, bool bOnlyAllowNonZeroMask, class UParticleSystem* Template);
	void ActivateLocalPlayerFx(class UParticleSystemComponent* ActivePSC);
	class UMeshComponent* STATIC_GetOwnerMesh(class AActor* pOwner);
	struct FVector STATIC_GetEffectLocation();
	void Detach();
	void AttachToOwner(class AActor* pOwner);
};


// Class TgGame.TgSpecialFxEmitterPool
// 0x0000 (0x02F4 - 0x02F4)
class ATgSpecialFxEmitterPool : public AEmitterPool
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSpecialFxEmitterPool");
		return ptr;
	}

};


// Class TgGame.TgSpecialFxLightManager
// 0x0034 (0x0094 - 0x0060)
class UTgSpecialFxLightManager : public UObject
{
public:
	unsigned long                                      c_FxLightsEnabled : 1;                                    // 0x0060(0x0004) (Config)
	unsigned long                                      c_FxLightsUnconstrained : 1;                              // 0x0060(0x0004) (Config)
	int                                                c_FxLightsMaxActive;                                      // 0x0064(0x0004) (Config)
	int                                                c_FxLightsMaxDying;                                       // 0x0068(0x0004) (Config)
	TArray<struct FPointer>                            m_ActiveEmitters;                                         // 0x006C(0x0010) (AlwaysInit, NeedCtorLink)
	TArray<struct FPointer>                            m_DyingEmitters;                                          // 0x007C(0x0010) (AlwaysInit, NeedCtorLink)
	class ATgPawn*                                     c_LocalPawn;                                              // 0x008C(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSpecialFxLightManager");
		return ptr;
	}


	void UserSetLevel(int LightLevel);
	void SetLevelInternal(int LightLevel);
	void STATIC_LightKilledElsewhere(const struct FPointer& FxEmitterKilled);
	void SetLightState(const struct FPointer& ExtantFxEmitter, TEnumAsByte<ESpecialFxLightState> NewFxLightState);
	void AddLight(const struct FPointer& NewFxEmitter);
	void STATIC_InitializeFxLightManager();
};


// Class TgGame.TgEffect
// 0x0040 (0x00A0 - 0x0060)
class UTgEffect : public UObject
{
public:
	class UTgEffectGroup*                              m_EffectGroup;                                            // 0x0060(0x0008)
	int                                                m_nEffectID;                                              // 0x0068(0x0004)
	int                                                m_nPropertyId;                                            // 0x006C(0x0004)
	int                                                m_nCalcMethodCode;                                        // 0x0070(0x0004)
	unsigned long                                      m_bUseOnInterval : 1;                                     // 0x0074(0x0004)
	unsigned long                                      m_bRemovable : 1;                                         // 0x0074(0x0004)
	unsigned long                                      m_bAllowStacking : 1;                                     // 0x0074(0x0004)
	unsigned long                                      m_bApplyToProperty : 1;                                   // 0x0074(0x0004)
	int                                                m_nPropertyValueId;                                       // 0x0078(0x0004)
	float                                              m_fCurrent;                                               // 0x007C(0x0004)
	float                                              m_fBase;                                                  // 0x0080(0x0004)
	float                                              m_fMinimum;                                               // 0x0084(0x0004)
	float                                              m_fMaximum;                                               // 0x0088(0x0004)
	float                                              m_fScalingFactor;                                         // 0x008C(0x0004)
	float                                              m_fStaticValueOffset;                                     // 0x0090(0x0004)
	float                                              m_MaxKnockbackZ;                                          // 0x0094(0x0004)
	float                                              m_MinKnockbackZ;                                          // 0x0098(0x0004)
	float                                              m_KnockbackZMultiplier;                                   // 0x009C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffect");
		return ptr;
	}


	int STATIC_GetDeviceIdFromMode(class UTgDeviceFire* DeviceFireMode);
	void ApplyEnterCombatRules(class AActor* Instigator, class AActor* Target);
	int STATIC_GetTopMostDevice(class UTgDeviceFire* devFire);
	void TrackStats(class ATgPawn* Instigator, class AActor* Target, const struct FImpactInfo& Impact, float fDamage, int iTargetDeviceModeId, bool bIsEnemy, float fMissingHealth, float fMitigatedDamage);
	void Remove(class AActor* Target, bool bForce);
	void Reapply(class AActor* Target);
	float STATIC_GetScaledBaseValue();
	float STATIC_GetProratedValue();
	void ApplyToProperty(class AActor* Target, int nPropertyId, float fProratedAmount, bool bRemove);
	bool RemoveStacks(class AActor* Target, int nNumStacks);
	bool ApplyStacks(class AActor* Target, int nNumStacks);
	bool ApplyEffect(class AActor* Target, const struct FImpactInfo& Impact, bool bLatent);
	void SetProperty(class AActor* Target, int nPropertyId, float fNewValue);
	bool CanBeApplied(class AActor* Target);
	class UTgEffect* CloneEffect();
};


// Class TgGame.TgEffect_Lift
// 0x0008 (0x00A8 - 0x00A0)
class UTgEffect_Lift : public UTgEffect
{
public:
	unsigned long                                      m_bApplyKnockup : 1;                                      // 0x00A0(0x0004)
	unsigned long                                      m_bRemoveCripple : 1;                                     // 0x00A0(0x0004)
	unsigned long                                      m_bRemoveRoot : 1;                                        // 0x00A0(0x0004)
	float                                              m_fZHeight;                                               // 0x00A4(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffect_Lift");
		return ptr;
	}


	void Remove(class AActor* Target, bool bForce);
	class UTgEffect* CloneEffect();
	bool ApplyEffect(class AActor* Target, const struct FImpactInfo& Impact, bool bLatent);
};


// Class TgGame.TgEffectDamage
// 0x0028 (0x00C8 - 0x00A0)
class UTgEffectDamage : public UTgEffect
{
public:
	int                                                m_nSimplifiedPropertyId;                                  // 0x00A0(0x0004)
	class UClass*                                      m_DamageTypeClass;                                        // 0x00A4(0x0008)
	class UClass*                                      m_DefaultDamageTypeClass;                                 // 0x00AC(0x0008)
	class UClass*                                      m_ArmorHitDamageTypeClass;                                // 0x00B4(0x0008)
	float                                              m_fDamageInitial;                                         // 0x00BC(0x0004)
	float                                              m_fBonusDamageToShields;                                  // 0x00C0(0x0004)
	unsigned long                                      m_bAllowLifeSteal : 1;                                    // 0x00C4(0x0004)
	unsigned long                                      m_bCanBeBuffed : 1;                                       // 0x00C4(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectDamage");
		return ptr;
	}


	float STATIC_GetProratedValue();
	bool ApplyOnThisInterval();
	bool RemoveStacks(class AActor* Target, int nNumStacks);
	bool ApplyStacks(class AActor* Target, int nNumStacks);
	void PerformLifeSteal(class ATgPawn* InstigatorPawn, const struct FImpactInfo& Impact, float fDamageAmount);
	bool ApplyEffect(class AActor* Target, const struct FImpactInfo& Impact, bool bLatent);
	bool CanBeApplied(class AActor* Target);
	void SendDamageMessages(class AActor* Source, class AActor* Target, float fTotalDamage, float fArmorDamage, float fShieldDamge, const struct FImpactInfo& thisImpact, struct FExtraDamageInfo* ExtraInfo);
	void PostDamageHandler(class AActor* pTarget, class ATgPawn* pInstigator, const struct FImpactInfo& Impact, float fPrevHealth, float fHealthChange, float fBuffedDamage, float fMitigatedDamage, float fShieldDamage, struct FExtraDamageInfo* ExtraInfo);
	void SetDamageTypeClass();
	class UTgEffect* CloneEffect();
};


// Class TgGame.TgEffectDamage_AstroDOT
// 0x0028 (0x00F0 - 0x00C8)
class UTgEffectDamage_AstroDOT : public UTgEffectDamage
{
public:
	TArray<float>                                      m_EffectTimeStamps;                                       // 0x00C8(0x0010) (NeedCtorLink)
	TArray<float>                                      m_EffectDamageValues;                                     // 0x00D8(0x0010) (NeedCtorLink)
	struct FPointer                                    m_EffectInfo;                                             // 0x00E8(0x0008) (Native)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectDamage_AstroDOT");
		return ptr;
	}


	void STATIC_InitializeEffectInfo();
	class UTgEffect* CloneEffect();
	void AddDamageStamp(float Damage);
	bool ApplyEffect(class AActor* Target, const struct FImpactInfo& Impact, bool bLatent);
};


// Class TgGame.TgEffectDamage_Execute
// 0x0004 (0x00CC - 0x00C8)
class UTgEffectDamage_Execute : public UTgEffectDamage
{
public:
	unsigned long                                      m_bApplied : 1;                                           // 0x00C8(0x0004)
	unsigned long                                      m_bExecute : 1;                                           // 0x00C8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectDamage_Execute");
		return ptr;
	}


	float STATIC_GetProratedValue();
	bool ApplyEffect(class AActor* Target, const struct FImpactInfo& Impact, bool bLatent);
};


// Class TgGame.TgEffectDamage_LootGoblinNormalizer
// 0x0000 (0x00C8 - 0x00C8)
class UTgEffectDamage_LootGoblinNormalizer : public UTgEffectDamage
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectDamage_LootGoblinNormalizer");
		return ptr;
	}


	bool CanBeApplied(class AActor* Target);
};


// Class TgGame.TgEffectDamage_PresenceDoT
// 0x0028 (0x00F0 - 0x00C8)
class UTgEffectDamage_PresenceDoT : public UTgEffectDamage
{
public:
	TArray<float>                                      m_EffectTimeStamps;                                       // 0x00C8(0x0010) (NeedCtorLink)
	TArray<float>                                      m_EffectDamageValues;                                     // 0x00D8(0x0010) (NeedCtorLink)
	struct FPointer                                    m_DamageInstances;                                        // 0x00E8(0x0008) (Native)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectDamage_PresenceDoT");
		return ptr;
	}


	class UTgEffect* CloneEffect();
	bool ApplyEffect(class AActor* Target, const struct FImpactInfo& Impact, bool bLatent);
};


// Class TgGame.TgEffectHeal
// 0x000C (0x00AC - 0x00A0)
class UTgEffectHeal : public UTgEffect
{
public:
	float                                              m_fMissingHealthInitial;                                  // 0x00A0(0x0004)
	int                                                m_nIntervalCount;                                         // 0x00A4(0x0004)
	int                                                m_nSimplifiedPropertyId;                                  // 0x00A8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectHeal");
		return ptr;
	}


	class UTgEffect* CloneEffect();
	void PostHealHandler(class AActor* pTarget, class ATgPawn* pInstigator, const struct FImpactInfo& Impact, float fHealthChange, float fHealAmount);
	bool RemoveStacks(class AActor* Target, int nNumStacks);
	bool ApplyStacks(class AActor* Target, int nNumStacks);
	bool ApplyEffect(class AActor* Target, const struct FImpactInfo& Impact, bool bLatent);
	bool CanBeApplied(class AActor* Target);
};


// Class TgGame.TgEffectModifyDeployable
// 0x0000 (0x00A0 - 0x00A0)
class UTgEffectModifyDeployable : public UTgEffect
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectModifyDeployable");
		return ptr;
	}


	void Remove(class AActor* Target, bool bForce);
	float STATIC_GetProratedValue();
	void ApplyToProperty(class AActor* Target, int nPropertyId, float fProratedAmount, bool bRemove);
	bool ApplyEffect(class AActor* Target, const struct FImpactInfo& Impact, bool bLatent);
	void SetProperty(class AActor* Target, int nPropertyId, float fNewValue);
	bool CanBeApplied(class AActor* Target);
};


// Class TgGame.TgEffectModifyEffect
// 0x0000 (0x00A0 - 0x00A0)
class UTgEffectModifyEffect : public UTgEffect
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectModifyEffect");
		return ptr;
	}


	void Remove(class AActor* Target, bool bForce);
	float STATIC_GetProratedValue();
	void ApplyToProperty(class AActor* Target, int nPropertyId, float fProratedAmount, bool bRemove);
	bool ApplyEffect(class AActor* Target, const struct FImpactInfo& Impact, bool bLatent);
	void SetProperty(class AActor* Target, int nPropertyId, float fNewValue);
	bool CanBeApplied(class AActor* Target);
};


// Class TgGame.TgEffectModifyProperty
// 0x001C (0x00BC - 0x00A0)
class UTgEffectModifyProperty : public UTgEffect
{
public:
	class UTgDeviceFire*                               m_TargetDeviceFire;                                       // 0x00A0(0x0008)
	int                                                m_eEquipPointTarget;                                      // 0x00A8(0x0004)
	TArray<float>                                      m_fStaticValueOffsets;                                    // 0x00AC(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectModifyProperty");
		return ptr;
	}


	void Remove(class AActor* Target, bool bForce);
	void ApplyToProperty(class AActor* Target, int nPropertyId, float fProratedAmount, bool bRemove);
	bool ApplyEffect(class AActor* Target, const struct FImpactInfo& Impact, bool bLatent);
	void SetProperty(class AActor* Target, int nPropertyId, float fNewValue);
	bool CanBeApplied(class AActor* Target);
};


// Class TgGame.TgEffectModifyProperty_AltFire
// 0x0000 (0x00BC - 0x00BC)
class UTgEffectModifyProperty_AltFire : public UTgEffectModifyProperty
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectModifyProperty_AltFire");
		return ptr;
	}

};


// Class TgGame.TgEffectModifyProperty_Child
// 0x0000 (0x00BC - 0x00BC)
class UTgEffectModifyProperty_Child : public UTgEffectModifyProperty
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectModifyProperty_Child");
		return ptr;
	}

};


// Class TgGame.TgEffectModifyProperty_Child_FireMode1
// 0x0000 (0x00BC - 0x00BC)
class UTgEffectModifyProperty_Child_FireMode1 : public UTgEffectModifyProperty_Child
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectModifyProperty_Child_FireMode1");
		return ptr;
	}

};


// Class TgGame.TgEffectModifyProperty_Child_FireMode2
// 0x0000 (0x00BC - 0x00BC)
class UTgEffectModifyProperty_Child_FireMode2 : public UTgEffectModifyProperty_Child
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectModifyProperty_Child_FireMode2");
		return ptr;
	}

};


// Class TgGame.TgEffectModifyProperty_Child_FireMode3
// 0x0000 (0x00BC - 0x00BC)
class UTgEffectModifyProperty_Child_FireMode3 : public UTgEffectModifyProperty_Child
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectModifyProperty_Child_FireMode3");
		return ptr;
	}

};


// Class TgGame.TgEffectModifyProperty_ItemSubtype
// 0x0000 (0x00BC - 0x00BC)
class UTgEffectModifyProperty_ItemSubtype : public UTgEffectModifyProperty
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectModifyProperty_ItemSubtype");
		return ptr;
	}


	void ApplyToProperty(class AActor* Target, int nPropertyId, float fProratedAmount, bool bRemove);
};


// Class TgGame.TgEffectPermanent
// 0x0000 (0x00A0 - 0x00A0)
class UTgEffectPermanent : public UTgEffect
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectPermanent");
		return ptr;
	}


	void ForcedRemove(class AActor* Target);
	void Remove(class AActor* Target, bool bForce);
	bool ApplyEffect(class AActor* Target, const struct FImpactInfo& Impact, bool bLatent);
};


// Class TgGame.TgEffectForm
// 0x009C (0x00FC - 0x0060)
class UTgEffectForm : public UObject
{
public:
	int                                                c_nEffectGroupId;                                         // 0x0060(0x0004)
	int                                                c_nInstigatorID;                                          // 0x0064(0x0004)
	int                                                c_nType;                                                  // 0x0068(0x0004)
	class AActor*                                      c_Owner;                                                  // 0x006C(0x0008)
	struct FPointer                                    c_pwzEffectName;                                          // 0x0074(0x0008) (Native)
	struct FPointer                                    c_pwzDescription;                                         // 0x007C(0x0008) (Native)
	int                                                c_nEffectIconId;                                          // 0x0084(0x0004)
	TArray<class UTgSpecialFx*>                        c_AppliedFxArray;                                         // 0x0088(0x0010) (NeedCtorLink)
	unsigned long                                      c_bHiddenDueToStealth : 1;                                // 0x0098(0x0004)
	unsigned long                                      c_bHiddenDueToFirstPerson : 1;                            // 0x0098(0x0004)
	unsigned long                                      c_bMICApplied : 1;                                        // 0x0098(0x0004)
	unsigned long                                      m_bSpawnAtHitLocation : 1;                                // 0x0098(0x0004)
	unsigned long                                      c_bIsDebuff : 1;                                          // 0x0098(0x0004)
	unsigned long                                      c_bIsCrit : 1;                                            // 0x0098(0x0004)
	unsigned long                                      c_bLocal : 1;                                             // 0x0098(0x0004)
	TEnumAsByte<ETG_POSTURE>                           c_Posture;                                                // 0x009C(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x009D(0x0003) MISSED OFFSET
	int                                                c_PostureID;                                              // 0x00A0(0x0004)
	class UMaterialInstanceConstant*                   m_MaterialInstanceConstant;                               // 0x00A4(0x0008)
	class ATgPawn*                                     m_OwnerPawn;                                              // 0x00AC(0x0008)
	struct FVector                                     m_HitLocation;                                            // 0x00B4(0x000C)
	struct FVector                                     m_HitNormal;                                              // 0x00C0(0x000C)
	int                                                c_nSkinId;                                                // 0x00CC(0x0004)
	int                                                c_nWeaponSkinId;                                          // 0x00D0(0x0004)
	class ATgEmitter_CameraEffect*                     c_CameraEffect;                                           // 0x00D4(0x0008)
	int                                                c_nStackCount;                                            // 0x00DC(0x0004)
	int                                                c_nBodyMeshMaterialHandle;                                // 0x00E0(0x0004)
	int                                                c_nMountMeshMaterialHandle;                               // 0x00E4(0x0004)
	int                                                c_nHeadMeshMaterialHandle;                                // 0x00E8(0x0004)
	int                                                c_nWeaponMesh1PMaterialHandle;                            // 0x00EC(0x0004)
	int                                                c_nHandsMeshMaterialHandle;                               // 0x00F0(0x0004)
	int                                                c_nHeadMesh1PMaterialHandle;                              // 0x00F4(0x0004)
	int                                                c_nWeaponMesh3PMaterialHandle;                            // 0x00F8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectForm");
		return ptr;
	}


	void SetEffectFormVisibility(bool bVisible);
	bool ShouldShowEffectForm();
	void AdjustHidden();
	void Detach();
	void Reattach();
	void Attach(class AActor* pOwner);
	void STATIC_HideEffectForm();
	void ShowEffectForm(bool bLocal);
	void STATIC_RecalculateFx();
};


// Class TgGame.TgEffectForm_BuffBelt
// 0x0018 (0x0114 - 0x00FC)
class UTgEffectForm_BuffBelt : public UTgEffectForm
{
public:
	struct FPointer                                    VfTable_FTickableObject;                                  // 0x00FC(0x0008) (Const, Native, NoExport)
	float                                              m_OrbitAngleYawOffset;                                    // 0x0104(0x0004)
	float                                              m_OrbitHeightOffset;                                      // 0x0108(0x0004)
	unsigned long                                      m_bFirstUpdate : 1;                                       // 0x010C(0x0004)
	float                                              m_OrbitRotationSpeed;                                     // 0x0110(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectForm_BuffBelt");
		return ptr;
	}

};


// Class TgGame.TgEffectForm_DisablePawn
// 0x0004 (0x0100 - 0x00FC)
class UTgEffectForm_DisablePawn : public UTgEffectForm
{
public:
	unsigned long                                      m_bPauseAnims : 1;                                        // 0x00FC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectForm_DisablePawn");
		return ptr;
	}


	void STATIC_HideEffectForm();
	void ShowEffectForm(bool bLocal);
};


// Class TgGame.TgEffectForm_Freeze
// 0x0004 (0x0104 - 0x0100)
class UTgEffectForm_Freeze : public UTgEffectForm_DisablePawn
{
public:
	int                                                m_BurstingIceFXId;                                        // 0x0100(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectForm_Freeze");
		return ptr;
	}


	void STATIC_HideEffectForm();
};


// Class TgGame.TgEffectForm_WithMeshes
// 0x0010 (0x010C - 0x00FC)
class UTgEffectForm_WithMeshes : public UTgEffectForm
{
public:
	TArray<struct FEffectMeshInfo>                     m_EffectMeshInfos;                                        // 0x00FC(0x0010) (Component, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectForm_WithMeshes");
		return ptr;
	}


	void DetachMeshes();
	void AttachMeshes(class AActor* pOwner);
	void AdjustHidden();
	void Detach();
	void Reattach();
	void Attach(class AActor* pOwner);
	void STATIC_HideEffectForm();
	void ShowEffectForm(bool bLocal);
	void STATIC_RecalculateFx();
};


// Class TgGame.TgEffectGroup
// 0x0180 (0x01E0 - 0x0060)
class UTgEffectGroup : public UObject
{
public:
	int                                                m_nType;                                                  // 0x0060(0x0004)
	class AActor*                                      m_Target;                                                 // 0x0064(0x0008)
	class AActor*                                      m_Instigator;                                             // 0x006C(0x0008)
	int                                                m_nEffectGroupId;                                         // 0x0074(0x0004)
	float                                              m_fLifeTime;                                              // 0x0078(0x0004)
	float                                              m_fModLifeTime;                                           // 0x007C(0x0004)
	float                                              m_fLifeTimeIncreaseFromInstigator;                        // 0x0080(0x0004)
	float                                              m_fApplyInterval;                                         // 0x0084(0x0004)
	TArray<class UTgEffect*>                           m_Effects;                                                // 0x0088(0x0010) (NeedCtorLink)
	int                                                m_nDamageType;                                            // 0x0098(0x0004)
	TEnumAsByte<EAttackType>                           m_eAttackType;                                            // 0x009C(0x0001)
	TEnumAsByte<EStunType>                             m_StunType;                                               // 0x009D(0x0001)
	unsigned char                                      UnknownData00[0x2];                                       // 0x009E(0x0002) MISSED OFFSET
	unsigned long                                      m_bIsManaged : 1;                                         // 0x00A0(0x0004)
	unsigned long                                      m_bHasStealthEffect : 1;                                  // 0x00A0(0x0004)
	unsigned long                                      m_bDoesDamage : 1;                                        // 0x00A0(0x0004)
	unsigned long                                      m_bDoesDamageOverTime : 1;                                // 0x00A0(0x0004)
	unsigned long                                      m_bContagious : 1;                                        // 0x00A0(0x0004)
	unsigned long                                      s_bActiveFlag : 1;                                        // 0x00A0(0x0004)
	unsigned long                                      s_bCriticalHitFlag : 1;                                   // 0x00A0(0x0004)
	unsigned long                                      m_bDeviceSpecificFlag : 1;                                // 0x00A0(0x0004)
	unsigned long                                      m_bHasVisual : 1;                                         // 0x00A0(0x0004)
	unsigned long                                      m_bSupportsEffectSimulation : 1;                          // 0x00A0(0x0004)
	float                                              m_fPercAbsorbedDamage;                                    // 0x00A4(0x0004)
	int                                                m_nApplicationType;                                       // 0x00A8(0x0004)
	float                                              m_fApplicationValue;                                      // 0x00AC(0x0004)
	float                                              m_fApplicationChance;                                     // 0x00B0(0x0004)
	int                                                m_nApplicationCategoryCode;                               // 0x00B4(0x0004)
	int                                                m_nBehaviorCategoryCode;                                  // 0x00B8(0x0004)
	int                                                m_nReqDeviceInstanceId;                                   // 0x00BC(0x0004)
	float                                              m_fBuffValue;                                             // 0x00C0(0x0004)
	float                                              m_fPhysicalPowerScaling;                                  // 0x00C4(0x0004)
	float                                              m_fMagicalPowerScaling;                                   // 0x00C8(0x0004)
	float                                              m_fLifetimeScaling;                                       // 0x00CC(0x0004)
	float                                              m_fLifetimeMax;                                           // 0x00D0(0x0004)
	int                                                m_nScalingType;                                           // 0x00D4(0x0004)
	int                                                m_nTargetType;                                            // 0x00D8(0x0004)
	int                                                m_nTargetAffectsType;                                     // 0x00DC(0x0004)
	int                                                m_nHitSpecialSituationalType;                             // 0x00E0(0x0004)
	int                                                m_nNumStacks;                                             // 0x00E4(0x0004)
	int                                                m_nNumMaxStacks;                                          // 0x00E8(0x0004)
	class UTgEffectGroup*                              s_NonContagiousEffectGroup;                               // 0x00EC(0x0008)
	struct FImpactInfo                                 m_Impact;                                                 // 0x00F4(0x0080) (Component)
	int                                                m_nPosture;                                               // 0x0174(0x0004)
	int                                                m_nFxAppliedId;                                           // 0x0178(0x0004)
	struct FName                                       m_nmDisplayGroup;                                         // 0x017C(0x0008)
	int                                                s_ManagedEffectListIndex;                                 // 0x0184(0x0004)
	class ATgEffectManager*                            s_OwnerEffectManager;                                     // 0x0188(0x0008)
	struct FName                                       m_nmDamageTypeClass;                                      // 0x0190(0x0008)
	int                                                m_nSourceDeviceInstId;                                    // 0x0198(0x0004)
	int                                                m_nSourceItemId;                                          // 0x019C(0x0004)
	float                                              s_fEGArmorHealth;                                         // 0x01A0(0x0004)
	float                                              s_fEGArmorHealthMax;                                      // 0x01A4(0x0004)
	float                                              s_fEGShieldHealth;                                        // 0x01A8(0x0004)
	float                                              s_fEGShieldHealthMax;                                     // 0x01AC(0x0004)
	class UForceFeedbackWaveform*                      m_Waveform;                                               // 0x01B0(0x0008)
	struct FPointer                                    m_pEffectGroupSetup;                                      // 0x01B8(0x0008) (Native)
	struct FLifeTimeCalcInfo                           m_LastLifeTimeCalcInfo;                                   // 0x01C0(0x0020)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectGroup");
		return ptr;
	}


	bool SupportsEffectSimulation();
	void RemoveArmor();
	bool STATIC_InitializeArmor(float fMaxHealth);
	float DamageArmor(float fDamage);
	float STATIC_HealArmor(float fHeal);
	float STATIC_GetArmorMaxHealth();
	float STATIC_GetArmorHealth();
	bool STATIC_HasArmor();
	float STATIC_HealShield(float fHeal);
	float DamageShield(float fDamage);
	float STATIC_GetShieldMaxHealth();
	float STATIC_GetShieldHealth();
	bool STATIC_HasShield();
	void ExtendLifeTime(float fAmount);
	void QueueRemovalOnManagerTick();
	float STATIC_GetUtilityPower();
	float GetLifeTime(bool bModifiers, struct FLifeTimeCalcInfo* CalcInfo);
	float STATIC_GetScaledBaseLifeTime();
	int STATIC_GetScalingLevel();
	void LifeDone();
	void ApplyInterval();
	bool ApplyEffects();
	float STATIC_GetIntervalTimeRemaining();
	float STATIC_GetPercentTimeRemaining();
	float STATIC_GetTimeRemaining();
	float STATIC_GetTimeElapsed();
	void STATIC_HandleStatusEffects(bool bRemoving);
	void STATIC_SetActive(bool bActive, bool bRemoving, bool bForceRemove);
	bool STATIC_IsActive();
	bool STATIC_HasCategoryCode(int nCategoryCode, bool bBehaviorOnly);
	bool DoesDamage();
	bool ReceivesDiminishingReturns();
	bool AppliesDiminishingReturns();
	bool STATIC_IsCrowdControl();
	bool STATIC_IsSuperiorCrowdControl();
	bool STATIC_IsDebuff();
	bool STATIC_IsDot();
	bool STATIC_IsCrit();
	bool STATIC_IsStealth();
	bool STATIC_IsSlow();
	bool STATIC_IsInstantaneous();
	bool PersistsThroughDeath();
	bool STATIC_IsBuff();
	float CalcDoTLifeTimeProtection(class AActor* Target, float fValue, float* fDirectReduction, float* fPercReduction);
	float CalcCategoryProtection(class AActor* Target, float fValue, float* fPercReduction);
	bool EffectExists(int nPropId);
	float QueryFxTransitionTime();
	float TotalPropertyEffectAmt(int nPropertyId);
	void RemoveEffects(bool bClearTimers, bool bForce);
	class UTgEffectGroup* CloneEffectGroup(bool bCloneAllEffects);
};


// Class TgGame.TgEffectManager
// 0x05D0 (0x0850 - 0x0280)
class ATgEffectManager : public AActor
{
public:
	struct FDiminishedEffectInfo                       r_GroundSpeedMods;                                        // 0x0280(0x0010) (Net)
	struct FEffectListEntry                            r_ManagedEffectList[0x10];                                // 0x0290(0x0010) (Net)
	unsigned char                                      c_byCounterList[0x10];                                    // 0x0390(0x0001)
	unsigned char                                      c_InstanceCounts[0x10];                                   // 0x03A0(0x0001)
	TEnumAsByte<EStunType>                             s_eCachedStunType;                                        // 0x03B0(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x03B1(0x0003) MISSED OFFSET
	float                                              m_fTimeRemaining[0x10];                                   // 0x03B4(0x0004)
	class UTgEffectForm*                               c_Forms[0x10];                                            // 0x03F4(0x0008)
	unsigned long                                      c_ActiveTimers : 1;                                       // 0x0474(0x0004)
	unsigned long                                      r_bRelevancyNotify : 1;                                   // 0x0474(0x0004) (Net)
	struct FEffectQueueEntry                           r_EventQueue[0x10];                                       // 0x0478(0x0020) (Net)
	int                                                r_nNextQueueIndex;                                        // 0x0678(0x0004) (Net)
	int                                                r_nFirstValidQueueIndex;                                  // 0x067C(0x0004) (Net)
	int                                                c_nLastQueueIndex;                                        // 0x0680(0x0004)
	TArray<class UTgEffectGroup*>                      s_AppliedEffectGroups;                                    // 0x0684(0x0010) (NeedCtorLink)
	TArray<class UTgEffect*>                           s_AppliedPermanentEffects;                                // 0x0694(0x0010) (NeedCtorLink)
	class AActor*                                      r_Owner;                                                  // 0x06A4(0x0008) (Net)
	class UTgEffectGroup*                              m_ApplyDamageEffectGroup;                                 // 0x06AC(0x0008)
	class UTgEffect*                                   m_ApplyDamageEffect;                                      // 0x06B4(0x0008)
	class UTgEffectGroup*                              m_ApplyHealthEffectGroup;                                 // 0x06BC(0x0008)
	class UTgEffect*                                   m_ApplyHealthEffect;                                      // 0x06C4(0x0008)
	class UTgEffectGroup*                              m_ApplyManaEffectGroup;                                   // 0x06CC(0x0008)
	class UTgEffect*                                   m_ApplyManaEffect;                                        // 0x06D4(0x0008)
	class UTgEffectGroup*                              m_ApplyEnergyEffectGroup;                                 // 0x06DC(0x0008)
	class UTgEffect*                                   m_ApplyEnergyEffect;                                      // 0x06E4(0x0008)
	TArray<struct FStunStackEntry>                     s_StunStack;                                              // 0x06EC(0x0010) (NeedCtorLink)
	TArray<struct FEnergyStunStackEntry>               s_EnergyStunStack;                                        // 0x06FC(0x0010) (NeedCtorLink)
	TArray<struct FReduceActiveCooldownEntry>          s_ReduceActiveCooldownEffects;                            // 0x070C(0x0010) (NeedCtorLink)
	float                                              m_fMaxReduceActiveCooldownDelay;                          // 0x071C(0x0004)
	int                                                s_nSilenceCount;                                          // 0x0720(0x0004)
	int                                                s_nDisarmCount;                                           // 0x0724(0x0004)
	int                                                s_nCrippleCount;                                          // 0x0728(0x0004)
	int                                                s_nStealthCount;                                          // 0x072C(0x0004)
	int                                                s_nDazeCount;                                             // 0x0730(0x0004)
	int                                                s_nMarkedCount;                                           // 0x0734(0x0004)
	int                                                s_nSlowCount;                                             // 0x0738(0x0004)
	int                                                s_bStealthDisabledCount;                                  // 0x073C(0x0004)
	int                                                s_nOnFireCount;                                           // 0x0740(0x0004)
	int                                                s_nCCImmuneCount;                                         // 0x0744(0x0004)
	int                                                s_nBleedingCount;                                         // 0x0748(0x0004)
	int                                                s_nKnockbackCount;                                        // 0x074C(0x0004)
	int                                                s_nRootCount;                                             // 0x0750(0x0004)
	int                                                s_nPoisonedCount;                                         // 0x0754(0x0004)
	int                                                s_nBoostCount;                                            // 0x0758(0x0004)
	int                                                s_nStealthInCombatCount;                                  // 0x075C(0x0004)
	int                                                s_nWallHackCount;                                         // 0x0760(0x0004)
	int                                                s_nForceOutOfCombatCount;                                 // 0x0764(0x0004)
	int                                                s_nPolymorphCount;                                        // 0x0768(0x0004)
	int                                                s_nRevealedCount;                                         // 0x076C(0x0004)
	int                                                s_nFlashCount;                                            // 0x0770(0x0004)
	float                                              s_fSpawnGuardTime;                                        // 0x0774(0x0004)
	TArray<class AActor*>                              s_InstigatorWallReveals;                                  // 0x0778(0x0010) (NeedCtorLink)
	TArray<int>                                        s_nInstigatorWallRevealCount;                             // 0x0788(0x0010) (NeedCtorLink)
	TArray<class AActor*>                              s_InstigatorStealthReveals;                               // 0x0798(0x0010) (NeedCtorLink)
	TArray<int>                                        s_nInstigatorStealthRevealCount;                          // 0x07A8(0x0010) (NeedCtorLink)
	TArray<class UTgEffect*>                           s_SlowCaps;                                               // 0x07B8(0x0010) (NeedCtorLink)
	TArray<class UTgEffect*>                           s_MaxHPDamageCaps;                                        // 0x07C8(0x0010) (NeedCtorLink)
	TArray<class UTgEffect*>                           s_CurHPDamageCaps;                                        // 0x07D8(0x0010) (NeedCtorLink)
	int                                                s_FreezeBehaviorCount;                                    // 0x07E8(0x0004)
	TArray<struct FDiminishingReturnsStackInfo>        s_DiminishingReturnsStacks;                               // 0x07EC(0x0010) (NeedCtorLink)
	int                                                m_nDiminishingReturnMaxStacks;                            // 0x07FC(0x0004) (Const)
	TArray<class UTgEffectGroup*>                      s_ActiveDamageDeviceIntercepts;                           // 0x0800(0x0010) (NeedCtorLink)
	TArray<class UTgEffectGroup*>                      s_ActiveDamageMitigationIntercepts;                       // 0x0810(0x0010) (NeedCtorLink)
	TArray<class UTgEffectGroup*>                      s_ActiveOnLandedIntercepts;                               // 0x0820(0x0010) (NeedCtorLink)
	TArray<class UTgEffectGroup*>                      s_ActiveWallKnockbackHits;                                // 0x0830(0x0010) (NeedCtorLink)
	TArray<class UTgEffectGroup*>                      s_ActivePlayerKnockbackHits;                              // 0x0840(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectManager");
		return ptr;
	}


	int STATIC_HealArmor(int nHeal);
	int ArmorTakeDamage(int nDamage);
	int ShieldTakeDamage(int nDamage);
	void STATIC_PostDemoRewind();
	void UpdateFirstValidQueueIndex();
	void STATIC_ReplicatedEvent(const struct FName& VarName);
	void PostBeginPlay();
	bool CheckStacksForDisplay(class UTgEffectGroup* pEffect);
	int STATIC_GetStackCountFromEffectGroupId(int nEffectGroupID, class AActor* aInstigator);
	class UTgEffectGroup* ProcessEffect(class UTgEffectGroup* effectGroup, class AActor* aInstigator, int nNumStacks, const struct FImpactInfo& Impact, bool bCloneAllEffects);
	void RemoveProperty(class UTgEffectGroup* effectGroup);
	class UTgEffectGroup* ApplyProperty(float nValue, int nPropId, class AActor* aInstigator, const struct FImpactInfo& Impact, int nCategory, bool bApplyAsPercent);
	void ProcessReduceActiveCooldownEffects();
	void RemoveDelayedReduceActiveCooldownEffect(const struct FReduceActiveCooldownEntry& effectEntry);
	void AddDelayedReduceActiveCooldownEffect(const struct FReduceActiveCooldownEntry& effectEntry);
	void ReduceActiveCooldown(const struct FReduceActiveCooldownEntry& effectEntry, bool bInitialApplication);
	void ApplyStasis(int nValue, class AActor* aInstigator, int nAttackType, int nDamageType, const struct FImpactInfo& Impact, int nEffectGroupCategory);
	void RemoveSpawnGuard();
	void ApplySpawnGuard();
	void ApplyStun(float fDuration, class AActor* aInstigator, int nAttackType, int nDamageType, const struct FImpactInfo& Impact, TEnumAsByte<EStunType> StunType);
	void ApplyEnergy(int nEnergy, class AActor* aInstigator, int nAttackType, int nDamageType, const struct FImpactInfo& Impact, int nEffectGroupCategory);
	void ApplyMana(int nMana, class AActor* aInstigator, int nAttackType, int nDamageType, const struct FImpactInfo& Impact, int nEffectGroupCategory);
	void ApplyHealth(int nHealth, class AActor* aInstigator, int nAttackType, int nDamageType, const struct FImpactInfo& Impact, int nEffectGroupCategory);
	void ApplyDamage(int nDamage, class AActor* aInstigator, int nAttackType, int nDamageType, const struct FImpactInfo& Impact, int nEffectGroupCategory);
	int CountApplicationOfPermanentEffect(class UTgEffect* pEffect);
	void UnregisterPermanentEffect(class UTgEffect* pEffect);
	void RegisterPermanentEffect(class UTgEffect* pEffect);
	void STATIC_HandleOnLandedIntercepts();
	void RecalculateBeltFx();
	void STATIC_RecalculateFx();
	bool STATIC_IsDazed();
	bool STATIC_IsSlowed();
	bool STATIC_IsStunned();
	bool STATIC_IsSpawnGuarded();
	void ClearAllClientEffectForms();
	void UpdateEffectFormVisibility();
	class UTgEffectGroup* STATIC_GetEffectGroupByCategory(int nCategoryCode, class AActor* theInstigator);
	class UTgEffectGroup* STATIC_GetEffectGroup(int nEffectGroupID, class AActor* theInstigator);
	void RemoveAllPermanentEffects();
	void RemoveAllMesmerizeEffects();
	void RemoveAllStealthEffects();
	void RemoveAllWhileDeadEffects();
	void RemoveAllEffectsOnDeath();
	void RemoveAllEffects(bool bForce);
	class UTgEffectGroup* STATIC_GetNextStrongest(class UTgEffectGroup* eg);
	bool STATIC_IsStrongest(class UTgEffectGroup* eg, bool bConsiderLifetime, class UTgEffectGroup** prevStrongest);
	void RemoveAllCrowdControl();
	void RemoveAllSuperiorCrowdControl();
	void RemoveAllDebuff();
	bool ResetEffectGroupLifeTimeByCategory(int nCategoryCode, float Lifetime);
	bool ResetEffectGroupLifeTimeById(int nEffectGroupID, float Lifetime);
	bool RemoveAllEffectGroups(class UTgEffectGroup* eg);
	int RemoveEffectGroupsByCategory(int nCategoryCode, int nNumStacks, class AActor* theInstigator);
	bool RemoveEffectGroupById(int nEffectGroupID, int nNumStacks, class AActor* theInstigator);
	void UpdateManagedEffectForms(bool bFromServer);
	void UpdateQueueEffectForms();
	void UpdateEffectForms();
	void ClearEffectRep(class UTgEffectGroup* Group);
	void UpdateEffectRep(class UTgEffectGroup* eg);
	int SetEffectRep(class UTgEffectGroup* eg, int nSkinId);
};


// Class TgGame.TgActorFactory
// 0x0040 (0x02C0 - 0x0280)
class ATgActorFactory : public AActor
{
public:
	int                                                m_nMapObjectId;                                           // 0x0280(0x0004) (Edit, EditConst)
	unsigned long                                      s_bAutoSpawn : 1;                                         // 0x0284(0x0004) (Edit)
	int                                                s_nTeamNumber;                                            // 0x0288(0x0004) (EditConst)
	unsigned char                                      s_nTaskForce;                                             // 0x028C(0x0001) (Edit)
	TEnumAsByte<EMinimapFactoryType>                   m_MinimapType;                                            // 0x028D(0x0001) (Edit)
	TEnumAsByte<EeSelectionMethod>                     s_eSelectionMethod;                                       // 0x028E(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x1];                                       // 0x028F(0x0001) MISSED OFFSET
	int                                                s_nSelectionListId;                                       // 0x0290(0x0004)
	int                                                s_nSelectedObjectId;                                      // 0x0294(0x0004)
	int                                                m_nSelectionListPropId;                                   // 0x0298(0x0004)
	int                                                s_nNameId;                                                // 0x029C(0x0004)
	int                                                s_nFactoryId;                                             // 0x02A0(0x0004) (Transient)
	class ATgRepInfo_Factory*                          m_FRI;                                                    // 0x02A4(0x0008) (Transient)
	class UClass*                                      m_FRIClass;                                               // 0x02AC(0x0008)
	int                                                s_nCurListIndex;                                          // 0x02B4(0x0004)
	class USpriteComponent*                            m_WorldIconSprite;                                        // 0x02B8(0x0008) (Edit, ExportObject, Component, EditInline)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgActorFactory");
		return ptr;
	}


	void Destroyed();
	void PostBeginPlay();
	void PreBeginPlay();
	void SetTaskForceNumber(int nNewTaskForce);
	void CalcFactoryPlacement(const struct FVector& Extent, bool bCenterOnGround, struct FVector* OutLocation, struct FRotator* OutRotation);
	void SpawnObject();
	void STATIC_LoadObjectConfig();
};


// Class TgGame.TgBotFactory
// 0x00C4 (0x0384 - 0x02C0)
class ATgBotFactory : public ATgActorFactory
{
public:
	TEnumAsByte<EeBotSelection>                        LocationSelection;                                        // 0x02C0(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x02C1(0x0003) MISSED OFFSET
	TArray<class ANavigationPoint*>                    LocationList;                                             // 0x02C4(0x0010) (Edit, Const, NeedCtorLink)
	int                                                s_nCurLocationIndex;                                      // 0x02D4(0x0004)
	class ANavigationPoint*                            SafetyLocation;                                           // 0x02D8(0x0008) (Edit)
	unsigned long                                      ShouldTraceSpawnLocationToFloor : 1;                      // 0x02E0(0x0004) (Edit)
	unsigned long                                      bUseSmiteStaggerSpawning : 1;                             // 0x02E0(0x0004) (Edit)
	unsigned long                                      bSpawnAsSquad : 1;                                        // 0x02E0(0x0004) (Edit)
	unsigned long                                      bAutoSpawn : 1;                                           // 0x02E0(0x0004)
	unsigned long                                      m_bFirstSpawn : 1;                                        // 0x02E0(0x0004)
	unsigned long                                      bBulkSpawn : 1;                                           // 0x02E0(0x0004) (Edit)
	unsigned long                                      bRespawn : 1;                                             // 0x02E0(0x0004) (Edit)
	unsigned long                                      bStartBotsInIntroState : 1;                               // 0x02E0(0x0004) (Edit)
	unsigned long                                      bHasDifferentInitialIntro : 1;                            // 0x02E0(0x0004) (Edit)
	unsigned long                                      m_bFirstSpawnWave : 1;                                    // 0x02E0(0x0004)
	unsigned long                                      m_bIgnoreCollisionOnSpawn : 1;                            // 0x02E0(0x0004) (Edit)
	unsigned long                                      m_bUseCollisionHeightForSpawnPlacement : 1;               // 0x02E0(0x0004) (Edit)
	int                                                nBotCount;                                                // 0x02E4(0x0004)
	int                                                nCurrentCount;                                            // 0x02E8(0x0004)
	int                                                nActiveCount;                                             // 0x02EC(0x0004) (Edit)
	int                                                nTotalSpawns;                                             // 0x02F0(0x0004)
	TArray<struct FBotSpawnCounter>                    CurrentBotSpawnCount;                                     // 0x02F4(0x0010) (NeedCtorLink)
	int                                                nLane;                                                    // 0x0304(0x0004) (Edit)
	int                                                nNavPointsToSkipForPathing;                               // 0x0308(0x0004) (Edit)
	float                                              fStaggerSpawnDelay;                                       // 0x030C(0x0004) (Edit)
	class UTgAISquad*                                  s_CurrentSquad;                                           // 0x0310(0x0008) (Transient)
	class UClass*                                      m_SquadClass;                                             // 0x0318(0x0008)
	int                                                m_nLocationId;                                            // 0x0320(0x0004) (Edit)
	int                                                nSpawnTableId;                                            // 0x0324(0x0004) (Edit)
	int                                                nDefaultSpawnTableId;                                     // 0x0328(0x0004) (Edit)
	float                                              fSpawnDelay;                                              // 0x032C(0x0004) (Edit)
	TArray<struct FSpawnQueueEntry>                    m_SpawnQueue;                                             // 0x0330(0x0010) (NeedCtorLink)
	class ATgBotEncounterVolume*                       m_SpawnVolume;                                            // 0x0340(0x0008)
	int                                                m_nLastGroup;                                             // 0x0348(0x0004)
	float                                              fSpawnHealthPercent;                                      // 0x034C(0x0004) (Edit)
	float                                              m_fEncounterDespawnTime;                                  // 0x0350(0x0004) (Edit)
	float                                              fIntroductionDuration;                                    // 0x0354(0x0004) (Edit)
	float                                              fInitialIntroductionDuration;                             // 0x0358(0x0004) (Edit)
	class ATgSplineActor*                              m_StartingSpline;                                         // 0x035C(0x0008) (Edit)
	class UStaticMeshComponent*                        m_RespawnIndicator;                                       // 0x0364(0x0008) (Edit, ExportObject, Component, EditInline)
	class UMaterialInstanceConstant*                   m_RespawnIndicatorMIC;                                    // 0x036C(0x0008) (Transient)
	class UTexture2D*                                  m_TextureNormal;                                          // 0x0374(0x0008)
	float                                              fLastKillTime;                                            // 0x037C(0x0004)
	float                                              fRespawnDelay;                                            // 0x0380(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgBotFactory");
		return ptr;
	}


	void STATIC_OnKillCurrentSquad(class UTgSeqAct_KillCurrentSquad* killSquadAction);
	void UpdateRespawnTimeIndicator(float fPct);
	void STATIC_OnBotDamaged(class ATgPawn* Bot, class AController* DamageInstigator, class UClass* DamageType, int DamageAmount);
	void STATIC_OnGetBot(class UTgSeqAct_GetBot* inAction);
	void STATIC_OnSetTaskforce(class UTgSeqAct_SetTaskforce* Action);
	void STATIC_OnTriggerBots(class UTgSeqAct_TriggerBots* Action);
	void STATIC_KillBots(bool bDespawn);
	void STATIC_Despawn();
	void StartEncounter(class ATgBotEncounterVolume* Volume);
	void STATIC_ContinueEncounter();
	void STATIC_EndEncounter();
	void STATIC_OnDespawnBots(class UTgSeqAct_DespawnBots* inAction);
	void STATIC_OnKillBots(class UTgSeqAct_KillBots* inAction);
	void OnToggle(class USeqAct_Toggle* Action);
	void PostBeginPlay();
	float STATIC_GetStaggerSpawnTime();
	int STATIC_GetRemainingTotalSpawns();
	void STATIC_KillCurrentSquad();
	void SquadDied(class UTgAISquad* squad);
	void BotDied(class ATgPawn* Pawn, class ATgAIController* aic);
	class AActor* UseSpawnTable();
	void CalcFactoryPlacement(const struct FVector& Extent, bool bCenterOnGround, struct FVector* OutLocation, struct FRotator* OutRotation);
	class AActor* SpawnBotAdjusted(const struct FSpawnQueueEntry& Entry);
	class AActor* SpawnBotId(int nBotId, int nSkinId);
	class AActor* SpawnNextBot();
	class AActor* SpawnBot();
	void STATIC_ClearQueue();
	void BuildQueue(bool bRefill);
	void ResetQueue();
	void STATIC_LoadObjectConfig();
};


// Class TgGame.TgBotFactory_BonusTrigger
// 0x0000 (0x0384 - 0x0384)
class ATgBotFactory_BonusTrigger : public ATgBotFactory
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgBotFactory_BonusTrigger");
		return ptr;
	}

};


// Class TgGame.TgBotFactory_Leashed
// 0x0018 (0x039C - 0x0384)
class ATgBotFactory_Leashed : public ATgBotFactory
{
public:
	struct FVector                                     LeashLocation;                                            // 0x0384(0x000C) (Edit)
	float                                              LeashRange;                                               // 0x0390(0x0004) (Edit)
	class AVolume*                                     LeashVolume;                                              // 0x0394(0x0008) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgBotFactory_Leashed");
		return ptr;
	}


	class AActor* SpawnBotAdjusted(const struct FSpawnQueueEntry& Entry);
};


// Class TgGame.TgBotFactory_PointCapture
// 0x0008 (0x03A4 - 0x039C)
class ATgBotFactory_PointCapture : public ATgBotFactory_Leashed
{
public:
	class ATgCapturePoint*                             m_CapturePoint;                                           // 0x039C(0x0008) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgBotFactory_PointCapture");
		return ptr;
	}


	void BotDied(class ATgPawn* Pawn, class ATgAIController* aic);
};


// Class TgGame.TgBotFactory_Minions
// 0x001C (0x03A0 - 0x0384)
class ATgBotFactory_Minions : public ATgBotFactory
{
public:
	TEnumAsByte<EMinionFactoryType>                    m_eFactoryType;                                           // 0x0384(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0385(0x0003) MISSED OFFSET
	unsigned long                                      m_OverrideShouldSpawnSuperMinions : 1;                    // 0x0388(0x0004) (Transient)
	int                                                m_nWaveNumber;                                            // 0x038C(0x0004) (Transient)
	int                                                m_nLastBonusWave;                                         // 0x0390(0x0004) (Transient)
	int                                                m_nLanePushersInQueue;                                    // 0x0394(0x0004) (Transient)
	float                                              m_fLastBonusActivationTime;                               // 0x0398(0x0004) (Transient)
	float                                              m_fSuperMinionEndTime;                                    // 0x039C(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgBotFactory_Minions");
		return ptr;
	}


	void BotDied(class ATgPawn* Pawn, class ATgAIController* aic);
	void BuildQueue(bool bRefill);
	bool ShouldSpawnBonusMinions();
	bool ShouldSpawnSuperMinions();
	void SetSuperMinionsActive(float fSeconds);
};


// Class TgGame.TgBotFactory_Realm
// 0x000C (0x0390 - 0x0384)
class ATgBotFactory_Realm : public ATgBotFactory
{
public:
	float                                              m_fRefillInterval;                                        // 0x0384(0x0004) (Edit)
	float                                              m_fSpawnMinDist;                                          // 0x0388(0x0004) (Edit)
	float                                              m_fSpawnMaxViewAlignment;                                 // 0x038C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgBotFactory_Realm");
		return ptr;
	}


	void CheckRefill();
	void PostBeginPlay();
	class AActor* SpawnBot();
};


// Class TgGame.TgBotFactorySpawnable
// 0x0000 (0x0384 - 0x0384)
class ATgBotFactorySpawnable : public ATgBotFactory
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgBotFactorySpawnable");
		return ptr;
	}

};


// Class TgGame.TgDeployableFactory
// 0x001C (0x02DC - 0x02C0)
class ATgDeployableFactory : public ATgActorFactory
{
public:
	int                                                nCurrentCount;                                            // 0x02C0(0x0004)
	float                                              s_fLastSpawnTime;                                         // 0x02C4(0x0004)
	unsigned long                                      s_bSpawnOnce : 1;                                         // 0x02C8(0x0004) (Edit)
	unsigned long                                      bForcePreventDisenchant : 1;                              // 0x02C8(0x0004) (Edit)
	int                                                s_nDeployableId;                                          // 0x02CC(0x0004) (Edit)
	int                                                s_SpawnGroupNum;                                          // 0x02D0(0x0004) (Edit)
	int                                                nShardCost;                                               // 0x02D4(0x0004) (Edit)
	float                                              s_fDeployableLifeSpan;                                    // 0x02D8(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployableFactory");
		return ptr;
	}


	void STATIC_OnSetTaskforce(class UTgSeqAct_SetTaskforce* Action);
	void STATIC_OnKillBots(class UTgSeqAct_KillBots* inAction);
	void OnToggle(class USeqAct_Toggle* Action);
	void DeployableDied();
	void PostBeginPlay();
	void SpawnObject();
};


// Class TgGame.TgDeployableFactory_DeviceChest
// 0x0010 (0x02EC - 0x02DC)
class ATgDeployableFactory_DeviceChest : public ATgDeployableFactory
{
public:
	TArray<int>                                        m_nDeviceIds;                                             // 0x02DC(0x0010) (Edit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployableFactory_DeviceChest");
		return ptr;
	}

};


// Class TgGame.TgDestructibleFactory
// 0x0008 (0x02C8 - 0x02C0)
class ATgDestructibleFactory : public ATgActorFactory
{
public:
	class ULightEnvironmentComponent*                  LightEnvironment;                                         // 0x02C0(0x0008) (Edit, Const, ExportObject, EditConst, Component, EditInline)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDestructibleFactory");
		return ptr;
	}


	void SpawnObject();
};


// Class TgGame.TgBotFactoryComponent
// 0x0000 (0x024C - 0x024C)
class UTgBotFactoryComponent : public UPrimitiveComponent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgBotFactoryComponent");
		return ptr;
	}

};


// Class TgGame.TgAkAudioManagement
// 0x0114 (0x0174 - 0x0060)
class UTgAkAudioManagement : public UObject
{
public:
	struct FAkMeterCallbackState                       m_MeterCallbackSlots[0x10];                               // 0x0060(0x0010)
	TArray<struct Fdword>                              dwAllBusses;                                              // 0x0160(0x0010) (NeedCtorLink)
	unsigned long                                      m_bInitialized : 1;                                       // 0x0170(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAkAudioManagement");
		return ptr;
	}


	struct Fdword STATIC_GetBusUID(const struct FString& sBusName);
	void Initialize();
};


// Class TgGame.TgInteractiveAudio
// 0x0000 (0x0060 - 0x0060)
class UTgInteractiveAudio : public UInterface
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInteractiveAudio");
		return ptr;
	}

};


// Class TgGame.TgDroppedItem
// 0x002C (0x02AC - 0x0280)
class ATgDroppedItem : public AActor
{
public:
	float                                              m_fLifeSpan;                                              // 0x0280(0x0004)
	unsigned long                                      m_bFadeOut : 1;                                           // 0x0284(0x0004)
	struct FName                                       m_nmPickUpState;                                          // 0x0288(0x0008)
	int                                                r_nItemId;                                                // 0x0290(0x0004) (Net)
	class UMeshComponent*                              c_Mesh;                                                   // 0x0294(0x0008) (ExportObject, Component, EditInline)
	TArray<class UTgEffectGroup*>                      s_EffectGroupList;                                        // 0x029C(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDroppedItem");
		return ptr;
	}


	void GiveTo(class ATgPawn* P);
	void STATIC_ReplicatedEvent(const struct FName& VarName);
	bool ApplyItemSetup();
	class UTgEffectGroup* STATIC_GetEffectGroup(int nType, int* nIndex);
};


// Class TgGame.TgInventoryManager
// 0x0104 (0x03B0 - 0x02AC)
class ATgInventoryManager : public AInventoryManager
{
public:
	int                                                r_ItemCount;                                              // 0x02AC(0x0004) (Net)
	int                                                m_nPreviousDeviceInstanceId;                              // 0x02B0(0x0004)
	unsigned long                                      m_bNeedsInvUpdate : 1;                                    // 0x02B4(0x0004)
	class ATgDevice*                                   m_PreviousWeapon;                                         // 0x02B8(0x0008)
	unsigned char                                      UnknownData00[0x48];                                      // 0x02C0(0x0048) UNKNOWN PROPERTY: MapProperty TgGame.TgInventoryManager.m_InventoryMap
	unsigned char                                      UnknownData01[0x48];                                      // 0x0308(0x0048) UNKNOWN PROPERTY: MapProperty TgGame.TgInventoryManager.s_ReplicateMap
	unsigned char                                      UnknownData02[0x48];                                      // 0x0350(0x0048) UNKNOWN PROPERTY: MapProperty TgGame.TgInventoryManager.s_DeletionMap
	class ATgDevice*                                   m_PostAutoFireDevice;                                     // 0x0398(0x0008)
	TArray<class UTgInventoryObject_Device*>           m_pPendingDeletedDevices;                                 // 0x03A0(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryManager");
		return ptr;
	}


	void STATIC_ChangedWeapon();
	void ServerImmediatelySetWeapon(class ATgDevice* DesiredWeapon);
	void STATIC_ImmediatelySetWeapon(class ATgDevice* DesiredWeapon, class ATgPawn* pPawn);
	void STATIC_ServerDeleteInventory(const struct FQWord& nInventoryId);
	void STATIC_ServerSetCurrentWeapon(class ATgDevice* NewWeapon);
	void SetCurrentWeapon(class ATgDevice* DesiredWeapon);
	void STATIC_SetPendingWeapon(class AWeapon* DesiredWeapon);
	void STATIC_ServerSetInventoryDirty();
	void STATIC_ServerTestShowInventory();
	void Destroyed();
	void PostBeginPlay();
	void STATIC_ForwardDeviceOnHeld(class ATgDevice* pDevPrevious, class ATgDevice* pDevNext);
	void ForwardPawnOnEnergyGiven(float fEnergy);
	void STATIC_InventoryCleanup();
	void TestShowInventory();
	void ApplyAllPassiveItemEffects(bool bRemove);
	void SetInventoryDirty();
	bool STATIC_IsValid();
	class UTgInventoryObject* STATIC_GetInventoryByName(const struct FString& sName);
	class UTgInventoryObject* STATIC_GetInventoryByDeviceId(int nDeviceId);
	class UTgInventoryObject* STATIC_GetInventoryByEquipPoint(TEnumAsByte<ETG_EQUIP_POINT> ePoint, int nItemType);
	class UTgInventoryObject* STATIC_GetInventoryById(const struct FQWord& qwInventoryId);
	class ATgDevice* STATIC_GetDeviceByInstanceId(int nDeviceInstanceId);
	void SwapDevices(class UTgInventoryObject_Device* pInv, int nEquipPoint);
	void RemoveDevice(class UTgInventoryObject_Device* pInv, bool bForceRemove);
	class ATgDevice* AddDevice(int nDeviceId, int nEquipPoint, class ATgDevice* parentDevice, bool bReplaceIfOccupied, int nLevel, int nPower, bool bForceRemove);
	void RequestInventory();
};


// Class TgGame.TgInventoryManager_Player
// 0x0048 (0x03F8 - 0x03B0)
class ATgInventoryManager_Player : public ATgInventoryManager
{
public:
	unsigned char                                      UnknownData00[0x48];                                      // 0x03B0(0x0048) UNKNOWN PROPERTY: MapProperty TgGame.TgInventoryManager_Player.s_DynamicCardsMap

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryManager_Player");
		return ptr;
	}


	void ChangeDeviceLevel(int nEquipPoint, int nLevel);
	void RemoveDevice(class UTgInventoryObject_Device* pInv, bool bForceRemove);
	class ATgDevice* AddDevice(int nDeviceId, int nEquipPoint, class ATgDevice* parentDevice, bool bReplaceIfOccupied, int nLevel, int nPower, bool bForceRemove);
	int CountFilledBurnCardSlots();
	void RemoveBurnCards();
};


// Class TgGame.TgInventoryObject
// 0x004C (0x00AC - 0x0060)
class UTgInventoryObject : public UObject
{
public:
	struct FInventoryData                              m_InventoryData;                                          // 0x0060(0x0028)
	int                                                m_nRefData;                                               // 0x0088(0x0004)
	class ATgInventoryManager*                         m_InvManager;                                             // 0x008C(0x0008)
	unsigned long                                      m_bTemporary : 1;                                         // 0x0094(0x0004)
	TEnumAsByte<EReplicatedState>                      s_ReplicatedState;                                        // 0x0098(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0099(0x0003) MISSED OFFSET
	struct FPointer                                    m_pAmItem;                                                // 0x009C(0x0008) (Const, Native)
	int                                                c_nNbrAcquired;                                           // 0x00A4(0x0004)
	float                                              c_fTimeAcquired;                                          // 0x00A8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject");
		return ptr;
	}


	int STATIC_GetInstanceCount();
	void SetInstanceCount(int nInstanceCount);
	struct FInventoryData STATIC_GetInventoryData();
	bool STATIC_IsEquippableType();
	bool STATIC_IsUsableType();
};


// Class TgGame.TgInventoryObject_Device
// 0x001C (0x00C8 - 0x00AC)
class UTgInventoryObject_Device : public UTgInventoryObject
{
public:
	class ATgDevice*                                   s_Device;                                                 // 0x00AC(0x0008)
	int                                                m_nDeviceInstanceId;                                      // 0x00B4(0x0004)
	int                                                c_nNumFindDeviceFails;                                    // 0x00B8(0x0004)
	int                                                m_nStackCount;                                            // 0x00BC(0x0004)
	struct FPointer                                    m_pAmDevice;                                              // 0x00C0(0x0008) (Const, Native)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Device");
		return ptr;
	}


	bool STATIC_IsCard();
	void SetInstanceCount(int nInstanceCount);
};


// Class TgGame.TgInvListener
// 0x0000 (0x00C8 - 0x00C8)
class UTgInvListener : public UTgInventoryObject_Device
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_AbilityProcBase
// 0x0008 (0x00D0 - 0x00C8)
class UTgInventoryObject_Listen_AbilityProcBase : public UTgInvListener
{
public:
	int                                                m_nAbilitySlotRestriction;                                // 0x00C8(0x0004) (Const)
	int                                                m_nAbilityTypeRestriction;                                // 0x00CC(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_AbilityProcBase");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_AbilityInstant
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_AbilityInstant : public UTgInventoryObject_Listen_AbilityProcBase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_AbilityInstant");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Ability
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_Ability : public UTgInventoryObject_Listen_AbilityInstant
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Ability");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_UseWhileCCed
// 0x0004 (0x00D4 - 0x00D0)
class UTgInventoryObject_Listen_UseWhileCCed : public UTgInventoryObject_Listen_Ability
{
public:
	unsigned long                                      m_bIsActive : 1;                                          // 0x00D0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_UseWhileCCed");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_AbilityEnd
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_AbilityEnd : public UTgInventoryObject_Listen_AbilityInstant
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_AbilityEnd");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_AbilityEndTargetFiremodeOnly
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_AbilityEndTargetFiremodeOnly : public UTgInventoryObject_Listen_AbilityEnd
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_AbilityEndTargetFiremodeOnly");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_ReduceOtherCooldownOnStopFire
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_ReduceOtherCooldownOnStopFire : public UTgInventoryObject_Listen_AbilityEnd
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_ReduceOtherCooldownOnStopFire");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_AbilityStart
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_AbilityStart : public UTgInventoryObject_Listen_AbilityInstant
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_AbilityStart");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_AbilityStart_LowHealth
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_AbilityStart_LowHealth : public UTgInventoryObject_Listen_AbilityStart
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_AbilityStart_LowHealth");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Kindling
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_Kindling : public UTgInventoryObject_Listen_AbilityStart
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Kindling");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_ReduceOtherCooldownOnStartFire
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_ReduceOtherCooldownOnStartFire : public UTgInventoryObject_Listen_AbilityStart
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_ReduceOtherCooldownOnStartFire");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_CooldownDelayer
// 0x0005 (0x00D5 - 0x00D0)
class UTgInventoryObject_Listen_CooldownDelayer : public UTgInventoryObject_Listen_AbilityInstant
{
public:
	float                                              m_fDelayTime;                                             // 0x00D0(0x0004)
	TEnumAsByte<ETG_FIRE_FX_DUMMY_ON>                  m_FireFxDummyOn;                                          // 0x00D4(0x0001)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_CooldownDelayer");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_AbilityProcDeployables
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_AbilityProcDeployables : public UTgInventoryObject_Listen_AbilityProcBase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_AbilityProcDeployables");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_AddShieldDamage
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_AddShieldDamage : public UTgInventoryObject_Listen_AbilityProcBase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_AddShieldDamage");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Combo
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_Combo : public UTgInventoryObject_Listen_AbilityProcBase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Combo");
		return ptr;
	}


	void STATIC_RemoveUIMarks(class AActor* Target, int nNumMarks);
	void STATIC_AddUIMarks(class AActor* Target, int nNumMarks);
};


// Class TgGame.TgInventoryObject_Listen_Combo_Barik
// 0x0030 (0x0100 - 0x00D0)
class UTgInventoryObject_Listen_Combo_Barik : public UTgInventoryObject_Listen_Combo
{
public:
	TArray<struct FComboInfo>                          m_ComboInfoList;                                          // 0x00D0(0x0010) (NeedCtorLink)
	TArray<struct FUIMarkInfo>                         m_UIMarkInfoList;                                         // 0x00E0(0x0010) (NeedCtorLink)
	TArray<struct FBurningMarkInfo>                    m_BurningMarks;                                           // 0x00F0(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Combo_Barik");
		return ptr;
	}


	void TriggerBurningMarks(class AActor* Target);
	void UpdateUIMarks();
	void UpdateExpiredComboInfos();
	void TouchedBarricade(class AActor* Target, class AActor* barricade);
};


// Class TgGame.TgInventoryObject_Listen_Combo_BombKing
// 0x0010 (0x00E0 - 0x00D0)
class UTgInventoryObject_Listen_Combo_BombKing : public UTgInventoryObject_Listen_Combo
{
public:
	TArray<struct FStickyHitInfo>                      m_HitActors;                                              // 0x00D0(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Combo_BombKing");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Combo_Buck
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_Combo_Buck : public UTgInventoryObject_Listen_Combo
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Combo_Buck");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Combo_Cassie
// 0x0010 (0x00E0 - 0x00D0)
class UTgInventoryObject_Listen_Combo_Cassie : public UTgInventoryObject_Listen_Combo
{
public:
	float                                              m_fDodgeRollFireTime;                                     // 0x00D0(0x0004)
	float                                              m_fDisengageHitTime;                                      // 0x00D4(0x0004)
	class ATgPawn*                                     m_DisengageHitPawn;                                       // 0x00D8(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Combo_Cassie");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Combo_Drogoz
// 0x0004 (0x00D4 - 0x00D0)
class UTgInventoryObject_Listen_Combo_Drogoz : public UTgInventoryObject_Listen_Combo
{
public:
	float                                              m_fLastThrustTime;                                        // 0x00D0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Combo_Drogoz");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Combo_Evie
// 0x0018 (0x00E8 - 0x00D0)
class UTgInventoryObject_Listen_Combo_Evie : public UTgInventoryObject_Listen_Combo
{
public:
	TArray<class AActor*>                              m_MarkedTargets;                                          // 0x00D0(0x0010) (NeedCtorLink)
	float                                              m_fBlinkTimestamp;                                        // 0x00E0(0x0004)
	float                                              m_fIceBlockTimestamp;                                     // 0x00E4(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Combo_Evie");
		return ptr;
	}


	void STATIC_MarksExpired();
};


// Class TgGame.TgInventoryObject_Listen_Combo_Fernando
// 0x0004 (0x00D4 - 0x00D0)
class UTgInventoryObject_Listen_Combo_Fernando : public UTgInventoryObject_Listen_Combo
{
public:
	int                                                m_nNumContacts;                                           // 0x00D0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Combo_Fernando");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Combo_Grohk
// 0x000C (0x00DC - 0x00D0)
class UTgInventoryObject_Listen_Combo_Grohk : public UTgInventoryObject_Listen_Combo
{
public:
	float                                              m_fFirstHitThisTickTimestamp;                             // 0x00D0(0x0004)
	int                                                m_nHitsThisChain;                                         // 0x00D4(0x0004)
	unsigned long                                      m_bBonusActive : 1;                                       // 0x00D8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Combo_Grohk");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Combo_Grover
// 0x000C (0x00DC - 0x00D0)
class UTgInventoryObject_Listen_Combo_Grover : public UTgInventoryObject_Listen_Combo
{
public:
	struct FVector                                     m_vAxeStartingLocation;                                   // 0x00D0(0x000C)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Combo_Grover");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Combo_Kinessa
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_Combo_Kinessa : public UTgInventoryObject_Listen_Combo
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Combo_Kinessa");
		return ptr;
	}


	bool STATIC_IsOppressorMineTarget(class AActor* TgP);
};


// Class TgGame.TgInventoryObject_Listen_Combo_Makoa
// 0x0010 (0x00E0 - 0x00D0)
class UTgInventoryObject_Listen_Combo_Makoa : public UTgInventoryObject_Listen_Combo
{
public:
	TArray<struct FMarkedTargetHook>                   m_MarkedTargets;                                          // 0x00D0(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Combo_Makoa");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Combo_Pip
// 0x0040 (0x0110 - 0x00D0)
class UTgInventoryObject_Listen_Combo_Pip : public UTgInventoryObject_Listen_Combo
{
public:
	TArray<class ATgProjectile*>                       m_Projectiles;                                            // 0x00D0(0x0010) (NeedCtorLink)
	TArray<struct FVector>                             m_SpawnLocations;                                         // 0x00E0(0x0010) (NeedCtorLink)
	TArray<class AActor*>                              m_MarkedTargetsFlask;                                     // 0x00F0(0x0010) (NeedCtorLink)
	TArray<float>                                      m_fMarkedTimesFlask;                                      // 0x0100(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Combo_Pip");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Combo_Ruckus
// 0x0018 (0x00E8 - 0x00D0)
class UTgInventoryObject_Listen_Combo_Ruckus : public UTgInventoryObject_Listen_Combo
{
public:
	int                                                m_nDamageReductionStacks;                                 // 0x00D0(0x0004)
	int                                                m_nBonusDamageStacks;                                     // 0x00D4(0x0004)
	float                                              m_fDamageReductionStackTime;                              // 0x00D8(0x0004)
	float                                              m_fBonusDamageStackTime;                                  // 0x00DC(0x0004)
	unsigned long                                      m_bEmitterActive : 1;                                     // 0x00E0(0x0004)
	unsigned long                                      m_bComboEffectsOn : 1;                                    // 0x00E0(0x0004)
	float                                              m_fComboBonusTime;                                        // 0x00E4(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Combo_Ruckus");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Combo_Skye
// 0x000C (0x00DC - 0x00D0)
class UTgInventoryObject_Listen_Combo_Skye : public UTgInventoryObject_Listen_Combo
{
public:
	float                                              m_fLastStealthTime;                                       // 0x00D0(0x0004)
	unsigned long                                      m_bComboActive : 1;                                       // 0x00D4(0x0004)
	unsigned long                                      m_bCanTriggerCombo : 1;                                   // 0x00D4(0x0004)
	int                                                m_nHitStacks;                                             // 0x00D8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Combo_Skye");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Combo_Viktor
// 0x0010 (0x00E0 - 0x00D0)
class UTgInventoryObject_Listen_Combo_Viktor : public UTgInventoryObject_Listen_Combo
{
public:
	TArray<struct FTimedMarkedTarget>                  m_MarkedTargets;                                          // 0x00D0(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Combo_Viktor");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Combo_Ying
// 0x003C (0x010C - 0x00D0)
class UTgInventoryObject_Listen_Combo_Ying : public UTgInventoryObject_Listen_Combo
{
public:
	float                                              m_fCombo1MaxDuration;                                     // 0x00D0(0x0004)
	float                                              m_fCombo1BonusDamagePercent;                              // 0x00D4(0x0004)
	float                                              m_fCombo2BonusDamage;                                     // 0x00D8(0x0004)
	TArray<class AActor*>                              m_MarkedTargets;                                          // 0x00DC(0x0010) (NeedCtorLink)
	TArray<float>                                      m_fMarkTimes;                                             // 0x00EC(0x0010) (NeedCtorLink)
	class AActor*                                      m_InhandTarget;                                           // 0x00FC(0x0008)
	int                                                m_nInhandHits;                                            // 0x0104(0x0004)
	int                                                m_nCombo1DeviceId;                                        // 0x0108(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Combo_Ying");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_DeployOnAbility
// 0x0001 (0x00D1 - 0x00D0)
class UTgInventoryObject_Listen_DeployOnAbility : public UTgInventoryObject_Listen_AbilityProcBase
{
public:
	TEnumAsByte<EDeployOnAbilityType>                  m_eDeployType;                                            // 0x00D0(0x0001) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_DeployOnAbility");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_DeployWithProjectile
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_DeployWithProjectile : public UTgInventoryObject_Listen_AbilityProcBase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_DeployWithProjectile");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_DirectHit
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_DirectHit : public UTgInventoryObject_Listen_AbilityProcBase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_DirectHit");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_DuringAbility
// 0x0005 (0x00D5 - 0x00D0)
class UTgInventoryObject_Listen_DuringAbility : public UTgInventoryObject_Listen_AbilityProcBase
{
public:
	unsigned long                                      m_bAbilityInActiveState : 1;                              // 0x00D0(0x0004)
	unsigned long                                      m_bIsActive : 1;                                          // 0x00D0(0x0004)
	TEnumAsByte<EDuringAbilityType>                    m_eDuringType;                                            // 0x00D4(0x0001) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_DuringAbility");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_ActiveDuringAbility
// 0x0003 (0x00D8 - 0x00D5)
class UTgInventoryObject_Listen_ActiveDuringAbility : public UTgInventoryObject_Listen_DuringAbility
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x00D5(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_ActiveDuringAbility");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_ActiveDuringAbility_NotFiringInhand
// 0x0000 (0x00D8 - 0x00D8)
class UTgInventoryObject_Listen_ActiveDuringAbility_NotFiringInhand : public UTgInventoryObject_Listen_ActiveDuringAbility
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_ActiveDuringAbility_NotFiringInhand");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_ActiveDuringAbility_WhileOutOfCombat
// 0x0004 (0x00DC - 0x00D8)
class UTgInventoryObject_Listen_ActiveDuringAbility_WhileOutOfCombat : public UTgInventoryObject_Listen_ActiveDuringAbility
{
public:
	unsigned long                                      m_bPawnInCombat : 1;                                      // 0x00D8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_ActiveDuringAbility_WhileOutOfCombat");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_ActiveMovementHit
// 0x0000 (0x00D8 - 0x00D8)
class UTgInventoryObject_Listen_ActiveMovementHit : public UTgInventoryObject_Listen_ActiveDuringAbility
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_ActiveMovementHit");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_BowlingBall
// 0x0008 (0x00E0 - 0x00D8)
class UTgInventoryObject_Listen_BowlingBall : public UTgInventoryObject_Listen_ActiveDuringAbility
{
public:
	float                                              m_fRocketBootsEndTime;                                    // 0x00D8(0x0004)
	float                                              m_fPostRocketBootsTime;                                   // 0x00DC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_BowlingBall");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_LastStand
// 0x0004 (0x00DC - 0x00D8)
class UTgInventoryObject_Listen_LastStand : public UTgInventoryObject_Listen_ActiveDuringAbility
{
public:
	unsigned long                                      m_bHealthInActiveRange : 1;                               // 0x00D8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_LastStand");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Mount
// 0x0000 (0x00D8 - 0x00D8)
class UTgInventoryObject_Listen_Mount : public UTgInventoryObject_Listen_ActiveDuringAbility
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Mount");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_MountShield
// 0x0008 (0x00E0 - 0x00D8)
class UTgInventoryObject_Listen_MountShield : public UTgInventoryObject_Listen_Mount
{
public:
	float                                              m_fNextMountShieldTime;                                   // 0x00D8(0x0004)
	float                                              m_fMinMountShieldTime;                                    // 0x00DC(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_MountShield");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Proximity
// 0x0000 (0x00D8 - 0x00D8)
class UTgInventoryObject_Listen_Proximity : public UTgInventoryObject_Listen_ActiveDuringAbility
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Proximity");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Undying
// 0x0000 (0x00D8 - 0x00D8)
class UTgInventoryObject_Listen_Undying : public UTgInventoryObject_Listen_ActiveDuringAbility
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Undying");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_DeployedDuringAbility
// 0x0003 (0x00D8 - 0x00D5)
class UTgInventoryObject_Listen_DeployedDuringAbility : public UTgInventoryObject_Listen_DuringAbility
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x00D5(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_DeployedDuringAbility");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_EmitterEffect
// 0x0003 (0x00D8 - 0x00D5)
class UTgInventoryObject_Listen_EmitterEffect : public UTgInventoryObject_Listen_DuringAbility
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x00D5(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_EmitterEffect");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_FiringDuringAbility
// 0x0003 (0x00D8 - 0x00D5)
class UTgInventoryObject_Listen_FiringDuringAbility : public UTgInventoryObject_Listen_DuringAbility
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x00D5(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_FiringDuringAbility");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_FiringDuringAbilityAltMode
// 0x0000 (0x00D8 - 0x00D8)
class UTgInventoryObject_Listen_FiringDuringAbilityAltMode : public UTgInventoryObject_Listen_FiringDuringAbility
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_FiringDuringAbilityAltMode");
		return ptr;
	}

};


// Class TgGame.TgInvListener_OnDamagedDuringAbility
// 0x0003 (0x00D8 - 0x00D5)
class UTgInvListener_OnDamagedDuringAbility : public UTgInventoryObject_Listen_DuringAbility
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x00D5(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_OnDamagedDuringAbility");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Exhilarate
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_Exhilarate : public UTgInventoryObject_Listen_AbilityProcBase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Exhilarate");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_FireOnKillWithChildDevice
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_FireOnKillWithChildDevice : public UTgInventoryObject_Listen_AbilityProcBase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_FireOnKillWithChildDevice");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_FireOnMiss
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_FireOnMiss : public UTgInventoryObject_Listen_AbilityProcBase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_FireOnMiss");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_FireWithProjectile
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_FireWithProjectile : public UTgInventoryObject_Listen_AbilityProcBase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_FireWithProjectile");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_FullBurstHit
// 0x0018 (0x00E8 - 0x00D0)
class UTgInventoryObject_Listen_FullBurstHit : public UTgInventoryObject_Listen_AbilityProcBase
{
public:
	int                                                m_nCurrentFireLoopInstanceId;                             // 0x00D0(0x0004)
	int                                                m_nCurrentHits;                                           // 0x00D4(0x0004)
	int                                                m_nTargetHits;                                            // 0x00D8(0x0004)
	unsigned long                                      m_bBonusActive : 1;                                       // 0x00DC(0x0004)
	class AActor*                                      m_pLastTargetHit;                                         // 0x00E0(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_FullBurstHit");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_GiftGiver
// 0x0004 (0x00D4 - 0x00D0)
class UTgInventoryObject_Listen_GiftGiver : public UTgInventoryObject_Listen_AbilityProcBase
{
public:
	unsigned long                                      m_bHasActivated : 1;                                      // 0x00D0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_GiftGiver");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_HitStealthTarget
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_HitStealthTarget : public UTgInventoryObject_Listen_AbilityProcBase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_HitStealthTarget");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_HitWithDevice
// 0x0004 (0x00D4 - 0x00D0)
class UTgInventoryObject_Listen_HitWithDevice : public UTgInventoryObject_Listen_AbilityProcBase
{
public:
	unsigned long                                      m_bIgnoreChildDevice : 1;                                 // 0x00D0(0x0004)
	unsigned long                                      m_bAutoProcOnInhand : 1;                                  // 0x00D0(0x0004)
	unsigned long                                      m_bAutoProcOnAsIfInhand : 1;                              // 0x00D0(0x0004)
	unsigned long                                      m_bSkipActiveCheck : 1;                                   // 0x00D0(0x0004)
	unsigned long                                      m_bSkipStartCooldown : 1;                                 // 0x00D0(0x0004)
	unsigned long                                      m_bUseAllyTargets : 1;                                    // 0x00D0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_HitWithDevice");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_HitWithDeviceOrChildItems
// 0x0000 (0x00D4 - 0x00D4)
class UTgInventoryObject_Listen_HitWithDeviceOrChildItems : public UTgInventoryObject_Listen_HitWithDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_HitWithDeviceOrChildItems");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_HitWithInhandWhileDeviceFiring
// 0x0000 (0x00D4 - 0x00D4)
class UTgInventoryObject_Listen_HitWithInhandWhileDeviceFiring : public UTgInventoryObject_Listen_HitWithDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_HitWithInhandWhileDeviceFiring");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_ReduceOtherCooldownOnHit
// 0x0000 (0x00D4 - 0x00D4)
class UTgInventoryObject_Listen_ReduceOtherCooldownOnHit : public UTgInventoryObject_Listen_HitWithDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_ReduceOtherCooldownOnHit");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Weaken
// 0x0004 (0x00D8 - 0x00D4)
class UTgInventoryObject_Listen_Weaken : public UTgInventoryObject_Listen_HitWithDevice
{
public:
	int                                                m_nAppliedCategoryCodeToCheck;                            // 0x00D4(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Weaken");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_HitWithDeviceSpecial
// 0x0004 (0x00D4 - 0x00D0)
class UTgInventoryObject_Listen_HitWithDeviceSpecial : public UTgInventoryObject_Listen_AbilityProcBase
{
public:
	unsigned long                                      m_bSkipActiveCheck : 1;                                   // 0x00D0(0x0004)
	unsigned long                                      m_bSkipStartCooldown : 1;                                 // 0x00D0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_HitWithDeviceSpecial");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_HitWithPetDevice
// 0x0004 (0x00D4 - 0x00D0)
class UTgInventoryObject_Listen_HitWithPetDevice : public UTgInventoryObject_Listen_AbilityProcBase
{
public:
	unsigned long                                      m_bSkipActiveCheck : 1;                                   // 0x00D0(0x0004)
	unsigned long                                      m_bSkipStartCooldown : 1;                                 // 0x00D0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_HitWithPetDevice");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_ImpalerArrowHit
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_ImpalerArrowHit : public UTgInventoryObject_Listen_AbilityProcBase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_ImpalerArrowHit");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_LoogieExplodedHit
// 0x0004 (0x00D4 - 0x00D0)
class UTgInventoryObject_Listen_LoogieExplodedHit : public UTgInventoryObject_Listen_AbilityProcBase
{
public:
	unsigned long                                      m_bNeedToApplyCooldown : 1;                               // 0x00D0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_LoogieExplodedHit");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_LoogieHit
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_LoogieHit : public UTgInventoryObject_Listen_AbilityProcBase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_LoogieHit");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_MendingSpiritsActive
// 0x0014 (0x00E4 - 0x00D0)
class UTgInventoryObject_Listen_MendingSpiritsActive : public UTgInventoryObject_Listen_AbilityProcBase
{
public:
	TArray<class ATgPawn*>                             m_PawnTargets;                                            // 0x00D0(0x0010) (NeedCtorLink)
	unsigned long                                      m_bEffectsAreActive : 1;                                  // 0x00E0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_MendingSpiritsActive");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_MirrorDamageToHeal
// 0x0008 (0x00D8 - 0x00D0)
class UTgInventoryObject_Listen_MirrorDamageToHeal : public UTgInventoryObject_Listen_AbilityProcBase
{
public:
	class UTgDeviceFire_MirrorDamageToHeal*            m_CachedFiremode;                                         // 0x00D0(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_MirrorDamageToHeal");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_MirrorInhandDamageToHeal
// 0x0000 (0x00D8 - 0x00D8)
class UTgInventoryObject_Listen_MirrorInhandDamageToHeal : public UTgInventoryObject_Listen_MirrorDamageToHeal
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_MirrorInhandDamageToHeal");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_MirrorPetDamageToHeal
// 0x0008 (0x00D8 - 0x00D0)
class UTgInventoryObject_Listen_MirrorPetDamageToHeal : public UTgInventoryObject_Listen_AbilityProcBase
{
public:
	class UTgDeviceFire_MirrorDamageToHeal*            m_CachedFiremode;                                         // 0x00D0(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_MirrorPetDamageToHeal");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_PoisonBolts
// 0x0014 (0x00E4 - 0x00D0)
class UTgInventoryObject_Listen_PoisonBolts : public UTgInventoryObject_Listen_AbilityProcBase
{
public:
	TArray<struct FPoisonBoltInfo>                     m_PoisonBoltTargets;                                      // 0x00D0(0x0010) (NeedCtorLink)
	int                                                m_EffectGroupID;                                          // 0x00E0(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_PoisonBolts");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_ReduceSelfDamageDeployable
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_ReduceSelfDamageDeployable : public UTgInventoryObject_Listen_AbilityProcBase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_ReduceSelfDamageDeployable");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_ReduceSelfDamageProjectile
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_ReduceSelfDamageProjectile : public UTgInventoryObject_Listen_AbilityProcBase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_ReduceSelfDamageProjectile");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_ReloadCard
// 0x0004 (0x00D4 - 0x00D0)
class UTgInventoryObject_Listen_ReloadCard : public UTgInventoryObject_Listen_AbilityProcBase
{
public:
	int                                                m_nPendingHitCounter;                                     // 0x00D0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_ReloadCard");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_TagForLifesteal
// 0x0028 (0x00F8 - 0x00D0)
class UTgInventoryObject_Listen_TagForLifesteal : public UTgInventoryObject_Listen_AbilityProcBase
{
public:
	TArray<class AActor*>                              m_TagActors;                                              // 0x00D0(0x0010) (NeedCtorLink)
	TArray<float>                                      m_TagTimes;                                               // 0x00E0(0x0010) (NeedCtorLink)
	class UTgDeviceFire_MirrorDamageToHeal*            m_CachedFiremode;                                         // 0x00F0(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_TagForLifesteal");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Thunderstruck
// 0x0014 (0x00E4 - 0x00D0)
class UTgInventoryObject_Listen_Thunderstruck : public UTgInventoryObject_Listen_AbilityProcBase
{
public:
	TArray<class AActor*>                              m_UniqueTargets;                                          // 0x00D0(0x0010) (NeedCtorLink)
	unsigned long                                      m_bCachedIsArcing : 1;                                    // 0x00E0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Thunderstruck");
		return ptr;
	}

};


// Class TgGame.TgInvListener_DeathAfterHit
// 0x0014 (0x00E4 - 0x00D0)
class UTgInvListener_DeathAfterHit : public UTgInventoryObject_Listen_AbilityProcBase
{
public:
	float                                              m_fResetTimer;                                            // 0x00D0(0x0004)
	TArray<class AActor*>                              m_pLastTargetsHit;                                        // 0x00D4(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_DeathAfterHit");
		return ptr;
	}

};


// Class TgGame.TgInvListener_HeadshotBonusDamage
// 0x0000 (0x00D0 - 0x00D0)
class UTgInvListener_HeadshotBonusDamage : public UTgInventoryObject_Listen_AbilityProcBase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_HeadshotBonusDamage");
		return ptr;
	}

};


// Class TgGame.TgInvListener_HitSelfOnDamageOrHeal
// 0x0000 (0x00D0 - 0x00D0)
class UTgInvListener_HitSelfOnDamageOrHeal : public UTgInventoryObject_Listen_AbilityProcBase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_HitSelfOnDamageOrHeal");
		return ptr;
	}

};


// Class TgGame.TgInvListener_SetInhandFiremodeAfterDeviceFired
// 0x0008 (0x00D8 - 0x00D0)
class UTgInvListener_SetInhandFiremodeAfterDeviceFired : public UTgInventoryObject_Listen_AbilityProcBase
{
public:
	int                                                m_nRemainingShots;                                        // 0x00D0(0x0004)
	float                                              m_fRemainingTime;                                         // 0x00D4(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_SetInhandFiremodeAfterDeviceFired");
		return ptr;
	}

};


// Class TgGame.TgInvListener_TargetOverHealed
// 0x0010 (0x00E0 - 0x00D0)
class UTgInvListener_TargetOverHealed : public UTgInventoryObject_Listen_AbilityProcBase
{
public:
	TArray<struct FTOHInfo>                            s_stacks;                                                 // 0x00D0(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_TargetOverHealed");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_AbilityShieldDamage
// 0x0000 (0x00C8 - 0x00C8)
class UTgInventoryObject_Listen_AbilityShieldDamage : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_AbilityShieldDamage");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_ActiveWhileInGrass
// 0x0008 (0x00D0 - 0x00C8)
class UTgInventoryObject_Listen_ActiveWhileInGrass : public UTgInvListener
{
public:
	unsigned long                                      m_bCachedIsInGrass : 1;                                   // 0x00C8(0x0004)
	float                                              s_fExitTimestamp;                                         // 0x00CC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_ActiveWhileInGrass");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_ActiveWhileOffCooldown
// 0x0004 (0x00CC - 0x00C8)
class UTgInventoryObject_Listen_ActiveWhileOffCooldown : public UTgInvListener
{
public:
	unsigned long                                      m_bIsActive : 1;                                          // 0x00C8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_ActiveWhileOffCooldown");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Accelerant
// 0x0000 (0x00CC - 0x00CC)
class UTgInventoryObject_Listen_Accelerant : public UTgInventoryObject_Listen_ActiveWhileOffCooldown
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Accelerant");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_ActiveWhileDeployableActive
// 0x0004 (0x00D0 - 0x00CC)
class UTgInventoryObject_Listen_ActiveWhileDeployableActive : public UTgInventoryObject_Listen_ActiveWhileOffCooldown
{
public:
	int                                                m_nActiveDeployableCount;                                 // 0x00CC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_ActiveWhileDeployableActive");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_ActiveWhileDeployableInactive
// 0x0004 (0x00D0 - 0x00CC)
class UTgInventoryObject_Listen_ActiveWhileDeployableInactive : public UTgInventoryObject_Listen_ActiveWhileOffCooldown
{
public:
	int                                                m_nActiveDeployableCount;                                 // 0x00CC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_ActiveWhileDeployableInactive");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_AtTheReady
// 0x0000 (0x00CC - 0x00CC)
class UTgInventoryObject_Listen_AtTheReady : public UTgInventoryObject_Listen_ActiveWhileOffCooldown
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_AtTheReady");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Compensate
// 0x0000 (0x00CC - 0x00CC)
class UTgInventoryObject_Listen_Compensate : public UTgInventoryObject_Listen_ActiveWhileOffCooldown
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Compensate");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Featherweight
// 0x0000 (0x00CC - 0x00CC)
class UTgInventoryObject_Listen_Featherweight : public UTgInventoryObject_Listen_ActiveWhileOffCooldown
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Featherweight");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_LiftOff
// 0x0000 (0x00CC - 0x00CC)
class UTgInventoryObject_Listen_LiftOff : public UTgInventoryObject_Listen_ActiveWhileOffCooldown
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_LiftOff");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_MoraleBoost
// 0x0000 (0x00CC - 0x00CC)
class UTgInventoryObject_Listen_MoraleBoost : public UTgInventoryObject_Listen_ActiveWhileOffCooldown
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_MoraleBoost");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_ReduceInhandSelfDamage
// 0x0008 (0x00D4 - 0x00CC)
class UTgInventoryObject_Listen_ReduceInhandSelfDamage : public UTgInventoryObject_Listen_ActiveWhileOffCooldown
{
public:
	float                                              m_fCachedBaseDamage;                                      // 0x00CC(0x0004)
	float                                              m_fCachedBaseKnockback;                                   // 0x00D0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_ReduceInhandSelfDamage");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Sprint
// 0x0000 (0x00CC - 0x00CC)
class UTgInventoryObject_Listen_Sprint : public UTgInventoryObject_Listen_ActiveWhileOffCooldown
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Sprint");
		return ptr;
	}

};


// Class TgGame.TgInvListener_ExplosiveImpalerArrow
// 0x0034 (0x0100 - 0x00CC)
class UTgInvListener_ExplosiveImpalerArrow : public UTgInventoryObject_Listen_ActiveWhileOffCooldown
{
public:
	struct FAimData                                    m_AimData;                                                // 0x00CC(0x0034)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_ExplosiveImpalerArrow");
		return ptr;
	}

};


// Class TgGame.TgInvListener_ReplaceCurveSets
// 0x0000 (0x00CC - 0x00CC)
class UTgInvListener_ReplaceCurveSets : public UTgInventoryObject_Listen_ActiveWhileOffCooldown
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_ReplaceCurveSets");
		return ptr;
	}

};


// Class TgGame.TgInvListener_SetChildFiremode
// 0x0000 (0x00CC - 0x00CC)
class UTgInvListener_SetChildFiremode : public UTgInventoryObject_Listen_ActiveWhileOffCooldown
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_SetChildFiremode");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Jolt
// 0x0000 (0x00CC - 0x00CC)
class UTgInventoryObject_Listen_Jolt : public UTgInvListener_SetChildFiremode
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Jolt");
		return ptr;
	}

};


// Class TgGame.TgInvListener_SetPetFiremode
// 0x0000 (0x00CC - 0x00CC)
class UTgInvListener_SetPetFiremode : public UTgInventoryObject_Listen_ActiveWhileOffCooldown
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_SetPetFiremode");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_AddDamage
// 0x0004 (0x00CC - 0x00C8)
class UTgInventoryObject_Listen_AddDamage : public UTgInvListener
{
public:
	unsigned long                                      m_bAutoProcOnInhand : 1;                                  // 0x00C8(0x0004)
	unsigned long                                      m_bCheckIsValidTarget : 1;                                // 0x00C8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_AddDamage");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_AddDamageMaxHealthPercent
// 0x0000 (0x00CC - 0x00CC)
class UTgInventoryObject_Listen_AddDamageMaxHealthPercent : public UTgInventoryObject_Listen_AddDamage
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_AddDamageMaxHealthPercent");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_AddDamagePerTarget
// 0x0000 (0x00CC - 0x00CC)
class UTgInventoryObject_Listen_AddDamagePerTarget : public UTgInventoryObject_Listen_AddDamage
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_AddDamagePerTarget");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_AddDamagePlusHit
// 0x0000 (0x00CC - 0x00CC)
class UTgInventoryObject_Listen_AddDamagePlusHit : public UTgInventoryObject_Listen_AddDamage
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_AddDamagePlusHit");
		return ptr;
	}

};


// Class TgGame.TgInvListener_AddDamageMissingHealth
// 0x0000 (0x00CC - 0x00CC)
class UTgInvListener_AddDamageMissingHealth : public UTgInventoryObject_Listen_AddDamage
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_AddDamageMissingHealth");
		return ptr;
	}

};


// Class TgGame.TgInvListener_AddDamageMissingHealthPercent
// 0x0000 (0x00CC - 0x00CC)
class UTgInvListener_AddDamageMissingHealthPercent : public UTgInventoryObject_Listen_AddDamage
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_AddDamageMissingHealthPercent");
		return ptr;
	}

};


// Class TgGame.TgInvListener_ConsumeMarksForDamage
// 0x0010 (0x00DC - 0x00CC)
class UTgInvListener_ConsumeMarksForDamage : public UTgInventoryObject_Listen_AddDamage
{
public:
	TArray<class ATgPawn*>                             m_PendingMarkRemoval;                                     // 0x00CC(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_ConsumeMarksForDamage");
		return ptr;
	}

};


// Class TgGame.TgInvListener_ExtraDamageAboveHealthPercent
// 0x0000 (0x00CC - 0x00CC)
class UTgInvListener_ExtraDamageAboveHealthPercent : public UTgInventoryObject_Listen_AddDamage
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_ExtraDamageAboveHealthPercent");
		return ptr;
	}

};


// Class TgGame.TgInvListener_ExtraDamageBelowHealthPercent
// 0x0000 (0x00CC - 0x00CC)
class UTgInvListener_ExtraDamageBelowHealthPercent : public UTgInventoryObject_Listen_AddDamage
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_ExtraDamageBelowHealthPercent");
		return ptr;
	}

};


// Class TgGame.TgInvListener_ScaleDamageOverDistance
// 0x0000 (0x00CC - 0x00CC)
class UTgInvListener_ScaleDamageOverDistance : public UTgInventoryObject_Listen_AddDamage
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_ScaleDamageOverDistance");
		return ptr;
	}

};


// Class TgGame.TgInvListener_ScaleDamageOverDistanceNoCrit
// 0x0000 (0x00CC - 0x00CC)
class UTgInvListener_ScaleDamageOverDistanceNoCrit : public UTgInvListener_ScaleDamageOverDistance
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_ScaleDamageOverDistanceNoCrit");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_AdjustFiringInstances
// 0x0028 (0x00F0 - 0x00C8)
class UTgInventoryObject_Listen_AdjustFiringInstances : public UTgInvListener
{
public:
	TArray<struct FAdjustedFiringInstance>             m_pFiringInstancesToAdjust;                               // 0x00C8(0x0010) (Native)
	int                                                m_nItemDeviceTypeToTrack;                                 // 0x00D8(0x0004)
	int                                                m_nActivationItemDeviceType;                              // 0x00DC(0x0004)
	int                                                m_nActivationDeviceType;                                  // 0x00E0(0x0004)
	unsigned long                                      m_bJustActivated : 1;                                     // 0x00E4(0x0004)
	float                                              m_fDuration;                                              // 0x00E8(0x0004)
	float                                              m_fLastActivation;                                        // 0x00EC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_AdjustFiringInstances");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_AffectedByDevice
// 0x0000 (0x00C8 - 0x00C8)
class UTgInventoryObject_Listen_AffectedByDevice : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_AffectedByDevice");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_AffectedByDeviceActiveWhile
// 0x0004 (0x00CC - 0x00C8)
class UTgInventoryObject_Listen_AffectedByDeviceActiveWhile : public UTgInventoryObject_Listen_AffectedByDevice
{
public:
	unsigned long                                      m_bIsCardActive : 1;                                      // 0x00C8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_AffectedByDeviceActiveWhile");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_AffectedByDeviceDamage
// 0x0000 (0x00C8 - 0x00C8)
class UTgInventoryObject_Listen_AffectedByDeviceDamage : public UTgInventoryObject_Listen_AffectedByDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_AffectedByDeviceDamage");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_AffectedByDeviceKill
// 0x0000 (0x00C8 - 0x00C8)
class UTgInventoryObject_Listen_AffectedByDeviceKill : public UTgInventoryObject_Listen_AffectedByDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_AffectedByDeviceKill");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_AffectedByDeviceLifesteal
// 0x0008 (0x00D0 - 0x00C8)
class UTgInventoryObject_Listen_AffectedByDeviceLifesteal : public UTgInventoryObject_Listen_AffectedByDevice
{
public:
	class UTgDeviceFire_MirrorDamageToHeal*            m_CachedFiremode;                                         // 0x00C8(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_AffectedByDeviceLifesteal");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_AffectedByDeviceTarget
// 0x0014 (0x00DC - 0x00C8)
class UTgInventoryObject_Listen_AffectedByDeviceTarget : public UTgInventoryObject_Listen_AffectedByDevice
{
public:
	unsigned long                                      m_bIsCardActive : 1;                                      // 0x00C8(0x0004)
	TArray<class AActor*>                              m_HitActors;                                              // 0x00CC(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_AffectedByDeviceTarget");
		return ptr;
	}

};


// Class TgGame.TgInvListener_AffectedByDeviceApplyEffect
// 0x0000 (0x00C8 - 0x00C8)
class UTgInvListener_AffectedByDeviceApplyEffect : public UTgInventoryObject_Listen_AffectedByDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_AffectedByDeviceApplyEffect");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_AirBlast
// 0x0000 (0x00C8 - 0x00C8)
class UTgInventoryObject_Listen_AirBlast : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_AirBlast");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_ApplyEffectOnDeviceBase
// 0x0020 (0x00E8 - 0x00C8)
class UTgInventoryObject_Listen_ApplyEffectOnDeviceBase : public UTgInvListener
{
public:
	TArray<class UTgEffectGroup*>                      m_pEffectGroups;                                          // 0x00C8(0x0010) (NeedCtorLink)
	TArray<class ATgPawn*>                             m_pAffectedPawns;                                         // 0x00D8(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_ApplyEffectOnDeviceBase");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_ApplyEffectOnDeployableHit
// 0x0000 (0x00E8 - 0x00E8)
class UTgInventoryObject_Listen_ApplyEffectOnDeployableHit : public UTgInventoryObject_Listen_ApplyEffectOnDeviceBase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_ApplyEffectOnDeployableHit");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_ApplyEffectOnDeviceDamage
// 0x0000 (0x00E8 - 0x00E8)
class UTgInventoryObject_Listen_ApplyEffectOnDeviceDamage : public UTgInventoryObject_Listen_ApplyEffectOnDeviceBase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_ApplyEffectOnDeviceDamage");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_ApplyEffectOnDeviceFire
// 0x0000 (0x00E8 - 0x00E8)
class UTgInventoryObject_Listen_ApplyEffectOnDeviceFire : public UTgInventoryObject_Listen_ApplyEffectOnDeviceBase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_ApplyEffectOnDeviceFire");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_ApplyEffectOnDeviceHeld
// 0x0000 (0x00E8 - 0x00E8)
class UTgInventoryObject_Listen_ApplyEffectOnDeviceHeld : public UTgInventoryObject_Listen_ApplyEffectOnDeviceBase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_ApplyEffectOnDeviceHeld");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_ApplyEffectOnDeviceHit
// 0x0000 (0x00E8 - 0x00E8)
class UTgInventoryObject_Listen_ApplyEffectOnDeviceHit : public UTgInventoryObject_Listen_ApplyEffectOnDeviceBase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_ApplyEffectOnDeviceHit");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_ApplyEffectOnDeviceHitSpecial
// 0x0000 (0x00E8 - 0x00E8)
class UTgInventoryObject_Listen_ApplyEffectOnDeviceHitSpecial : public UTgInventoryObject_Listen_ApplyEffectOnDeviceBase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_ApplyEffectOnDeviceHitSpecial");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_ApplyEffectOnDeviceStop
// 0x0000 (0x00E8 - 0x00E8)
class UTgInventoryObject_Listen_ApplyEffectOnDeviceStop : public UTgInventoryObject_Listen_ApplyEffectOnDeviceBase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_ApplyEffectOnDeviceStop");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_ArcingBeam
// 0x0014 (0x00DC - 0x00C8)
class UTgInventoryObject_Listen_ArcingBeam : public UTgInvListener
{
public:
	int                                                m_nDeviceId;                                              // 0x00C8(0x0004)
	TArray<class AActor*>                              m_MarkedTargets;                                          // 0x00CC(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_ArcingBeam");
		return ptr;
	}


	int CountMarksForActor(class AActor* Actor);
	void ExpireUIMarks();
	void STATIC_RemoveUIMarks(class AActor* Target, int nNumMarks);
	void STATIC_AddUIMarks(class AActor* Target, int nNumMarks);
};


// Class TgGame.TgInventoryObject_Listen_AuraMod
// 0x001C (0x00E4 - 0x00C8)
class UTgInventoryObject_Listen_AuraMod : public UTgInvListener
{
public:
	TArray<class AActor*>                              m_AffectedActors;                                         // 0x00C8(0x0010) (NeedCtorLink)
	unsigned long                                      m_bAuraIsActive : 1;                                      // 0x00D8(0x0004)
	class ATgDevice_Aura*                              m_CachedAuraDevice;                                       // 0x00DC(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_AuraMod");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Backstab
// 0x0000 (0x00C8 - 0x00C8)
class UTgInventoryObject_Listen_Backstab : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Backstab");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_BackstabExtraDamage
// 0x0000 (0x00C8 - 0x00C8)
class UTgInventoryObject_Listen_BackstabExtraDamage : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_BackstabExtraDamage");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_BarricadeEffect
// 0x0000 (0x00C8 - 0x00C8)
class UTgInventoryObject_Listen_BarricadeEffect : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_BarricadeEffect");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_BlastShotHitEffect
// 0x0014 (0x00DC - 0x00C8)
class UTgInventoryObject_Listen_BlastShotHitEffect : public UTgInvListener
{
public:
	TArray<class AActor*>                              m_PreviouslyHitActors;                                    // 0x00C8(0x0010) (NeedCtorLink)
	int                                                m_nTargetType;                                            // 0x00D8(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_BlastShotHitEffect");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_BuffNextAttack
// 0x0008 (0x00D0 - 0x00C8)
class UTgInventoryObject_Listen_BuffNextAttack : public UTgInvListener
{
public:
	unsigned long                                      bIsFirstAttackAfterUse : 1;                               // 0x00C8(0x0004)
	unsigned long                                      bFirstOnly : 1;                                           // 0x00C8(0x0004)
	float                                              fEndTime;                                                 // 0x00CC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_BuffNextAttack");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_CombatRepair
// 0x0008 (0x00D0 - 0x00C8)
class UTgInventoryObject_Listen_CombatRepair : public UTgInvListener
{
public:
	class ATgPawn*                                     m_CachedPawnOwner;                                        // 0x00C8(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_CombatRepair");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Conduit
// 0x0018 (0x00E0 - 0x00C8)
class UTgInventoryObject_Listen_Conduit : public UTgInvListener
{
public:
	int                                                m_nDeviceIdShockPulseMain;                                // 0x00C8(0x0004)
	int                                                m_nDeviceIdShockPulseSupport;                             // 0x00CC(0x0004)
	TArray<class AActor*>                              m_EnemiesHitThisPulse;                                    // 0x00D0(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Conduit");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_DefianceHit
// 0x0000 (0x00C8 - 0x00C8)
class UTgInventoryObject_Listen_DefianceHit : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_DefianceHit");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_DeployOnDeployable
// 0x0010 (0x00D8 - 0x00C8)
class UTgInventoryObject_Listen_DeployOnDeployable : public UTgInvListener
{
public:
	TArray<int>                                        m_ValidDeployableIds;                                     // 0x00C8(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_DeployOnDeployable");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_DeployOnDeviceHit
// 0x0000 (0x00C8 - 0x00C8)
class UTgInventoryObject_Listen_DeployOnDeviceHit : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_DeployOnDeviceHit");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_DisenchantBonus
// 0x0000 (0x00C8 - 0x00C8)
class UTgInventoryObject_Listen_DisenchantBonus : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_DisenchantBonus");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_DoubleTap
// 0x0028 (0x00F0 - 0x00C8)
class UTgInventoryObject_Listen_DoubleTap : public UTgInvListener
{
public:
	float                                              m_fBaseWeaponDamage;                                      // 0x00C8(0x0004)
	float                                              m_fDoubleTapDelay;                                        // 0x00CC(0x0004)
	TArray<class AActor*>                              m_PendingDoubleTapActors;                                 // 0x00D0(0x0010) (NeedCtorLink)
	TArray<float>                                      m_PendingDoubleTapTimes;                                  // 0x00E0(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_DoubleTap");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_EnergyCharge
// 0x0014 (0x00DC - 0x00C8)
class UTgInventoryObject_Listen_EnergyCharge : public UTgInvListener
{
public:
	class ATgPawn*                                     m_CachedTgPawn;                                           // 0x00C8(0x0008)
	float                                              m_fChargeMultiplierDamageDealt;                           // 0x00D0(0x0004)
	float                                              m_fChargeMultiplierDamageTaken;                           // 0x00D4(0x0004)
	float                                              m_fChargeMultiplierPetDamage;                             // 0x00D8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_EnergyCharge");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_EquivalentExchange
// 0x0000 (0x00C8 - 0x00C8)
class UTgInventoryObject_Listen_EquivalentExchange : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_EquivalentExchange");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_FireInsteadOfDeath
// 0x0008 (0x00D0 - 0x00C8)
class UTgInventoryObject_Listen_FireInsteadOfDeath : public UTgInvListener
{
public:
	float                                              m_fImmuneTimer;                                           // 0x00C8(0x0004)
	unsigned long                                      m_bPendingActivation : 1;                                 // 0x00CC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_FireInsteadOfDeath");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_FireOnDamageInterruptedStealth
// 0x0000 (0x00C8 - 0x00C8)
class UTgInventoryObject_Listen_FireOnDamageInterruptedStealth : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_FireOnDamageInterruptedStealth");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_FireOnKill
// 0x0000 (0x00C8 - 0x00C8)
class UTgInventoryObject_Listen_FireOnKill : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_FireOnKill");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_FireOnElimination
// 0x0000 (0x00C8 - 0x00C8)
class UTgInventoryObject_Listen_FireOnElimination : public UTgInventoryObject_Listen_FireOnKill
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_FireOnElimination");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_FireOnLandAfterLeap
// 0x0000 (0x00C8 - 0x00C8)
class UTgInventoryObject_Listen_FireOnLandAfterLeap : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_FireOnLandAfterLeap");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_FireOnLowHealth
// 0x0000 (0x00C8 - 0x00C8)
class UTgInventoryObject_Listen_FireOnLowHealth : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_FireOnLowHealth");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_FireOnTeleport
// 0x0000 (0x00C8 - 0x00C8)
class UTgInventoryObject_Listen_FireOnTeleport : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_FireOnTeleport");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_FireWithDeployable
// 0x0000 (0x00C8 - 0x00C8)
class UTgInventoryObject_Listen_FireWithDeployable : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_FireWithDeployable");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_FirstShotAfterMovementAbility
// 0x0010 (0x00D8 - 0x00C8)
class UTgInventoryObject_Listen_FirstShotAfterMovementAbility : public UTgInvListener
{
public:
	float                                              m_fLastMovementAbilityTime;                               // 0x00C8(0x0004)
	unsigned long                                      m_bJustFinishedMovementAbility : 1;                       // 0x00CC(0x0004)
	int                                                m_nNumApplicationsRemaining;                              // 0x00D0(0x0004)
	float                                              m_fLastAppliedTime;                                       // 0x00D4(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_FirstShotAfterMovementAbility");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Exaction
// 0x0008 (0x00E0 - 0x00D8)
class UTgInventoryObject_Listen_Exaction : public UTgInventoryObject_Listen_FirstShotAfterMovementAbility
{
public:
	class UTgDeviceFire_MirrorDamageToHeal*            m_CachedFiremode;                                         // 0x00D8(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Exaction");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_FirstShotDuringOrAfterMovementAbility
// 0x0004 (0x00DC - 0x00D8)
class UTgInventoryObject_Listen_FirstShotDuringOrAfterMovementAbility : public UTgInventoryObject_Listen_FirstShotAfterMovementAbility
{
public:
	unsigned long                                      m_bMovementAbilityActive : 1;                             // 0x00D8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_FirstShotDuringOrAfterMovementAbility");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_FirstShotDuringOrAfterStealth
// 0x0008 (0x00D0 - 0x00C8)
class UTgInventoryObject_Listen_FirstShotDuringOrAfterStealth : public UTgInvListener
{
public:
	unsigned long                                      m_bWasStealthed : 1;                                      // 0x00C8(0x0004)
	float                                              m_fLastStealthTime;                                       // 0x00CC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_FirstShotDuringOrAfterStealth");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_ForgeDevice
// 0x0004 (0x00CC - 0x00C8)
class UTgInventoryObject_Listen_ForgeDevice : public UTgInvListener
{
public:
	unsigned long                                      bFirstItem : 1;                                           // 0x00C8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_ForgeDevice");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_ForgeDiscount
// 0x0000 (0x00C8 - 0x00C8)
class UTgInventoryObject_Listen_ForgeDiscount : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_ForgeDiscount");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_ForgeTime
// 0x0000 (0x00C8 - 0x00C8)
class UTgInventoryObject_Listen_ForgeTime : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_ForgeTime");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_FragGrenade
// 0x0000 (0x00C8 - 0x00C8)
class UTgInventoryObject_Listen_FragGrenade : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_FragGrenade");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_GourdEffect
// 0x0000 (0x00C8 - 0x00C8)
class UTgInventoryObject_Listen_GourdEffect : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_GourdEffect");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Headhunter
// 0x0000 (0x00C8 - 0x00C8)
class UTgInventoryObject_Listen_Headhunter : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Headhunter");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_HealthByPercent
// 0x0004 (0x00CC - 0x00C8)
class UTgInventoryObject_Listen_HealthByPercent : public UTgInvListener
{
public:
	int                                                m_iAppliedStacks;                                         // 0x00C8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_HealthByPercent");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_HealthPCT_In_Range
// 0x0004 (0x00CC - 0x00C8)
class UTgInventoryObject_Listen_HealthPCT_In_Range : public UTgInvListener
{
public:
	unsigned long                                      m_bApplied : 1;                                           // 0x00C8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_HealthPCT_In_Range");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_HitAirborne
// 0x0000 (0x00C8 - 0x00C8)
class UTgInventoryObject_Listen_HitAirborne : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_HitAirborne");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_HitAirborneOwner
// 0x0000 (0x00C8 - 0x00C8)
class UTgInventoryObject_Listen_HitAirborneOwner : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_HitAirborneOwner");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_HitOnHeadshot
// 0x0000 (0x00C8 - 0x00C8)
class UTgInventoryObject_Listen_HitOnHeadshot : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_HitOnHeadshot");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Hustle
// 0x0000 (0x00C8 - 0x00C8)
class UTgInventoryObject_Listen_Hustle : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Hustle");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_InHand_HitMissStacker
// 0x0008 (0x00D0 - 0x00C8)
class UTgInventoryObject_Listen_InHand_HitMissStacker : public UTgInvListener
{
public:
	float                                              m_fLastStackTime;                                         // 0x00C8(0x0004)
	int                                                m_nAppliedStacks;                                         // 0x00CC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_InHand_HitMissStacker");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_KillShards
// 0x0000 (0x00C8 - 0x00C8)
class UTgInventoryObject_Listen_KillShards : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_KillShards");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_LazarusResurrect
// 0x0000 (0x00C8 - 0x00C8)
class UTgInventoryObject_Listen_LazarusResurrect : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_LazarusResurrect");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_LoogieExploded
// 0x0000 (0x00C8 - 0x00C8)
class UTgInventoryObject_Listen_LoogieExploded : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_LoogieExploded");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_MirrorDamageToHealBlock
// 0x0008 (0x00D0 - 0x00C8)
class UTgInventoryObject_Listen_MirrorDamageToHealBlock : public UTgInvListener
{
public:
	class UTgDeviceFire_MirrorDamageToHealBlock*       m_CachedFiremode;                                         // 0x00C8(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_MirrorDamageToHealBlock");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_ModifyADSSpeed
// 0x0000 (0x00C8 - 0x00C8)
class UTgInventoryObject_Listen_ModifyADSSpeed : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_ModifyADSSpeed");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_ModifyADSTime
// 0x0000 (0x00C8 - 0x00C8)
class UTgInventoryObject_Listen_ModifyADSTime : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_ModifyADSTime");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_ModifyAOEAndDamage
// 0x0000 (0x00C8 - 0x00C8)
class UTgInventoryObject_Listen_ModifyAOEAndDamage : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_ModifyAOEAndDamage");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_ModifyDuration
// 0x0000 (0x00C8 - 0x00C8)
class UTgInventoryObject_Listen_ModifyDuration : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_ModifyDuration");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_MultipleHitBonus
// 0x0014 (0x00DC - 0x00C8)
class UTgInventoryObject_Listen_MultipleHitBonus : public UTgInvListener
{
public:
	TArray<class AActor*>                              pHitActors;                                               // 0x00C8(0x0010) (NeedCtorLink)
	unsigned long                                      bAdjustDamage : 1;                                        // 0x00D8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_MultipleHitBonus");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_MultiplyDamage
// 0x0000 (0x00C8 - 0x00C8)
class UTgInventoryObject_Listen_MultiplyDamage : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_MultiplyDamage");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_MultiplyDamageDrawn
// 0x0004 (0x00CC - 0x00C8)
class UTgInventoryObject_Listen_MultiplyDamageDrawn : public UTgInvListener
{
public:
	unsigned long                                      m_bPassedThreshold : 1;                                   // 0x00C8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_MultiplyDamageDrawn");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_NearObjective
// 0x000C (0x00D4 - 0x00C8)
class UTgInventoryObject_Listen_NearObjective : public UTgInvListener
{
public:
	unsigned long                                      m_bIsActive : 1;                                          // 0x00C8(0x0004)
	class ATgPawn_Character*                           m_CachedCharacterPawn;                                    // 0x00CC(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_NearObjective");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_AuraNearObjective
// 0x0000 (0x00D4 - 0x00D4)
class UTgInventoryObject_Listen_AuraNearObjective : public UTgInventoryObject_Listen_NearObjective
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_AuraNearObjective");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_ReachOut
// 0x0000 (0x00D4 - 0x00D4)
class UTgInventoryObject_Listen_ReachOut : public UTgInventoryObject_Listen_NearObjective
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_ReachOut");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_NearOwnTurret
// 0x0004 (0x00CC - 0x00C8)
class UTgInventoryObject_Listen_NearOwnTurret : public UTgInvListener
{
public:
	unsigned long                                      m_bIsActive : 1;                                          // 0x00C8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_NearOwnTurret");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_OnDamaged
// 0x0000 (0x00C8 - 0x00C8)
class UTgInventoryObject_Listen_OnDamaged : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_OnDamaged");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_OppressorMineEffect
// 0x0000 (0x00C8 - 0x00C8)
class UTgInventoryObject_Listen_OppressorMineEffect : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_OppressorMineEffect");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_OutOfCombat
// 0x0004 (0x00CC - 0x00C8)
class UTgInventoryObject_Listen_OutOfCombat : public UTgInvListener
{
public:
	unsigned long                                      m_bEffectIsApplied : 1;                                   // 0x00C8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_OutOfCombat");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_PetAbility
// 0x0000 (0x00C8 - 0x00C8)
class UTgInventoryObject_Listen_PetAbility : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_PetAbility");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_AugmentPetHit
// 0x0000 (0x00C8 - 0x00C8)
class UTgInventoryObject_Listen_AugmentPetHit : public UTgInventoryObject_Listen_PetAbility
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_AugmentPetHit");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Unveil
// 0x0000 (0x00C8 - 0x00C8)
class UTgInventoryObject_Listen_Unveil : public UTgInventoryObject_Listen_AugmentPetHit
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Unveil");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_PetAbility_Deploy
// 0x0000 (0x00C8 - 0x00C8)
class UTgInventoryObject_Listen_PetAbility_Deploy : public UTgInventoryObject_Listen_PetAbility
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_PetAbility_Deploy");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_PetAbilityWhileDeployableActive
// 0x0004 (0x00CC - 0x00C8)
class UTgInventoryObject_Listen_PetAbilityWhileDeployableActive : public UTgInventoryObject_Listen_PetAbility
{
public:
	int                                                m_nActiveDeployableCount;                                 // 0x00C8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_PetAbilityWhileDeployableActive");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_PetDied
// 0x0000 (0x00C8 - 0x00C8)
class UTgInventoryObject_Listen_PetDied : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_PetDied");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_PipConsequential
// 0x0004 (0x00CC - 0x00C8)
class UTgInventoryObject_Listen_PipConsequential : public UTgInvListener
{
public:
	int                                                s_nHitCounter;                                            // 0x00C8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_PipConsequential");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_RainOfFire
// 0x0000 (0x00C8 - 0x00C8)
class UTgInventoryObject_Listen_RainOfFire : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_RainOfFire");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_ReduceAlternateCooldown
// 0x0004 (0x00CC - 0x00C8)
class UTgInventoryObject_Listen_ReduceAlternateCooldown : public UTgInvListener
{
public:
	unsigned long                                      m_bAppliedReduction : 1;                                  // 0x00C8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_ReduceAlternateCooldown");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_ReduceCooldown
// 0x0000 (0x00C8 - 0x00C8)
class UTgInventoryObject_Listen_ReduceCooldown : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_ReduceCooldown");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_ReversalEffect
// 0x0000 (0x00C8 - 0x00C8)
class UTgInventoryObject_Listen_ReversalEffect : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_ReversalEffect");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_ReviveHealth
// 0x0000 (0x00C8 - 0x00C8)
class UTgInventoryObject_Listen_ReviveHealth : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_ReviveHealth");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_SalvoExplode
// 0x0000 (0x00C8 - 0x00C8)
class UTgInventoryObject_Listen_SalvoExplode : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_SalvoExplode");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_SetFireMode
// 0x0000 (0x00C8 - 0x00C8)
class UTgInventoryObject_Listen_SetFireMode : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_SetFireMode");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_ShellShieldEffect
// 0x0000 (0x00C8 - 0x00C8)
class UTgInventoryObject_Listen_ShellShieldEffect : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_ShellShieldEffect");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_ShieldEffect
// 0x0000 (0x00C8 - 0x00C8)
class UTgInventoryObject_Listen_ShieldEffect : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_ShieldEffect");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_SizeOfTheFight
// 0x0000 (0x00C8 - 0x00C8)
class UTgInventoryObject_Listen_SizeOfTheFight : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_SizeOfTheFight");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_SmokeScreenEffect
// 0x0000 (0x00C8 - 0x00C8)
class UTgInventoryObject_Listen_SmokeScreenEffect : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_SmokeScreenEffect");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_SpawnTeamHealthNugget
// 0x0010 (0x00D8 - 0x00C8)
class UTgInventoryObject_Listen_SpawnTeamHealthNugget : public UTgInvListener
{
public:
	class UTgSpecialFx*                                m_NuggetSpawnFX;                                          // 0x00C8(0x0008)
	int                                                m_NuggetSpawnFXID;                                        // 0x00D0(0x0004)
	unsigned long                                      m_bUseCV1ForSpawnChance : 1;                              // 0x00D4(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_SpawnTeamHealthNugget");
		return ptr;
	}


	void SpawnTeamHealthNugget(class ATgPawn* Target, const struct FVector& SpawnDirection);
};


// Class TgGame.TgInventoryObject_Listen_FirstAidKit
// 0x0000 (0x00D8 - 0x00D8)
class UTgInventoryObject_Listen_FirstAidKit : public UTgInventoryObject_Listen_SpawnTeamHealthNugget
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_FirstAidKit");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_SpringBloom
// 0x0000 (0x00C8 - 0x00C8)
class UTgInventoryObject_Listen_SpringBloom : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_SpringBloom");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Stack
// 0x0000 (0x00C8 - 0x00C8)
class UTgInventoryObject_Listen_Stack : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Stack");
		return ptr;
	}


	void AddStackCount(int nStackCount);
};


// Class TgGame.TgInventoryObject_Listen_Get_Nugget
// 0x0000 (0x00C8 - 0x00C8)
class UTgInventoryObject_Listen_Get_Nugget : public UTgInventoryObject_Listen_Stack
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Get_Nugget");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_StackPerPetAlive
// 0x0000 (0x00C8 - 0x00C8)
class UTgInventoryObject_Listen_StackPerPetAlive : public UTgInventoryObject_Listen_Stack
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_StackPerPetAlive");
		return ptr;
	}


	void UpdatePetCountStacks(bool bEmptyStacks);
};


// Class TgGame.TgInventoryObject_Listen_StandingStill
// 0x0000 (0x00C8 - 0x00C8)
class UTgInventoryObject_Listen_StandingStill : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_StandingStill");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_StandingStillSelfEffect
// 0x0010 (0x00D8 - 0x00C8)
class UTgInventoryObject_Listen_StandingStillSelfEffect : public UTgInvListener
{
public:
	float                                              m_fRestTime;                                              // 0x00C8(0x0004)
	unsigned long                                      m_bIsApplied : 1;                                         // 0x00CC(0x0004)
	class ATgPawn*                                     m_CachedPawnOwner;                                        // 0x00D0(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_StandingStillSelfEffect");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_StatusIsOnTarget
// 0x0000 (0x00C8 - 0x00C8)
class UTgInventoryObject_Listen_StatusIsOnTarget : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_StatusIsOnTarget");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_StickyBombDetonate
// 0x0000 (0x00C8 - 0x00C8)
class UTgInventoryObject_Listen_StickyBombDetonate : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_StickyBombDetonate");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_TotemEffect
// 0x0000 (0x00C8 - 0x00C8)
class UTgInventoryObject_Listen_TotemEffect : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_TotemEffect");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_TripWire
// 0x0000 (0x00C8 - 0x00C8)
class UTgInventoryObject_Listen_TripWire : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_TripWire");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_TrueGrit
// 0x0000 (0x00C8 - 0x00C8)
class UTgInventoryObject_Listen_TrueGrit : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_TrueGrit");
		return ptr;
	}

};


// Class TgGame.TgInvListener_ActiveDeployableEffect
// 0x0010 (0x00D8 - 0x00C8)
class UTgInvListener_ActiveDeployableEffect : public UTgInvListener
{
public:
	TArray<int>                                        m_AppliedTargetIds;                                       // 0x00C8(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_ActiveDeployableEffect");
		return ptr;
	}

};


// Class TgGame.TgInvListener_ApplyHitSpecialOnKill
// 0x0000 (0x00C8 - 0x00C8)
class UTgInvListener_ApplyHitSpecialOnKill : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_ApplyHitSpecialOnKill");
		return ptr;
	}

};


// Class TgGame.TgInvListener_ApplyHitSpecialOnKillOrElimination
// 0x0000 (0x00C8 - 0x00C8)
class UTgInvListener_ApplyHitSpecialOnKillOrElimination : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_ApplyHitSpecialOnKillOrElimination");
		return ptr;
	}

};


// Class TgGame.TgInvListener_ConsecutiveInhandHits
// 0x0018 (0x00E0 - 0x00C8)
class UTgInvListener_ConsecutiveInhandHits : public UTgInvListener
{
public:
	TArray<struct FCIHStack>                           s_stacks;                                                 // 0x00C8(0x0010) (NeedCtorLink)
	class ATgPawn*                                     s_pLastTargetHit;                                         // 0x00D8(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_ConsecutiveInhandHits");
		return ptr;
	}

};


// Class TgGame.TgInvListener_DeployOnElimination
// 0x0000 (0x00C8 - 0x00C8)
class UTgInvListener_DeployOnElimination : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_DeployOnElimination");
		return ptr;
	}

};


// Class TgGame.TgInvListener_HitSelfInsteadOfDeath
// 0x0000 (0x00C8 - 0x00C8)
class UTgInvListener_HitSelfInsteadOfDeath : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_HitSelfInsteadOfDeath");
		return ptr;
	}

};


// Class TgGame.TgInvListener_HitSelfOnHeadshot
// 0x0000 (0x00C8 - 0x00C8)
class UTgInvListener_HitSelfOnHeadshot : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_HitSelfOnHeadshot");
		return ptr;
	}

};


// Class TgGame.TgInvListener_HitWithDeviceFiremode
// 0x0000 (0x00C8 - 0x00C8)
class UTgInvListener_HitWithDeviceFiremode : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_HitWithDeviceFiremode");
		return ptr;
	}

};


// Class TgGame.TgInvListener_RedirectDamageToDeployables
// 0x0010 (0x00D8 - 0x00C8)
class UTgInvListener_RedirectDamageToDeployables : public UTgInvListener
{
public:
	TArray<class ATgDeployable*>                       m_ActiveDeployables;                                      // 0x00C8(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_RedirectDamageToDeployables");
		return ptr;
	}

};


// Class TgGame.TgInvListener_ShieldLifesteal
// 0x0000 (0x00C8 - 0x00C8)
class UTgInvListener_ShieldLifesteal : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_ShieldLifesteal");
		return ptr;
	}

};


// Class TgGame.TgPickupFactory
// 0x0030 (0x03D4 - 0x03A4)
class ATgPickupFactory : public APickupFactory
{
public:
	unsigned long                                      bRotatingPickup : 1;                                      // 0x03A4(0x0004)
	float                                              YawRotationRate;                                          // 0x03A8(0x0004)
	class AController*                                 TeamOwner[0x4];                                           // 0x03AC(0x0008)
	class UPrimitiveComponent*                         BaseMesh;                                                 // 0x03CC(0x0008) (ExportObject, Component, EditInline)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPickupFactory");
		return ptr;
	}


	bool STATIC_StopsProjectile(class AProjectile* P);
	void STATIC_RespawnEffect();
	void UpdateHUD(class ATgHUD* H);
	bool ShouldCamp(class ATgAIController* B, float MaxWait);
};


// Class TgGame.TgSeqAct_AIFreeze
// 0x0004 (0x010C - 0x0108)
class UTgSeqAct_AIFreeze : public USequenceAction
{
public:
	int                                                TaskForceNumber;                                          // 0x0108(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_AIFreeze");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_AIMoveToActor
// 0x0008 (0x0110 - 0x0108)
class UTgSeqAct_AIMoveToActor : public USequenceAction
{
public:
	class AActor*                                      Destination;                                              // 0x0108(0x0008) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_AIMoveToActor");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_AITargetActor
// 0x0008 (0x0110 - 0x0108)
class UTgSeqAct_AITargetActor : public USequenceAction
{
public:
	class AActor*                                      CombatTarget;                                             // 0x0108(0x0008) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_AITargetActor");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_BeginWaitForLookAt
// 0x0010 (0x0118 - 0x0108)
class UTgSeqAct_BeginWaitForLookAt : public USequenceAction
{
public:
	struct FVector                                     LocationToLookAt;                                         // 0x0108(0x000C) (Edit)
	float                                              MinOffsetDistance;                                        // 0x0114(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_BeginWaitForLookAt");
		return ptr;
	}


	void STATIC_Activated();
};


// Class TgGame.TgSeqAct_ClearObjectiveGroup
// 0x0000 (0x0108 - 0x0108)
class UTgSeqAct_ClearObjectiveGroup : public USequenceAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_ClearObjectiveGroup");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_ClientLoadDevices
// 0x0014 (0x011C - 0x0108)
class UTgSeqAct_ClientLoadDevices : public USequenceAction
{
public:
	TArray<int>                                        m_DeviceIdList;                                           // 0x0108(0x0010) (Edit, NeedCtorLink)
	unsigned long                                      m_bClearExistingLoads : 1;                                // 0x0118(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_ClientLoadDevices");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_CloseHUDMenus
// 0x0000 (0x0108 - 0x0108)
class UTgSeqAct_CloseHUDMenus : public USequenceAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_CloseHUDMenus");
		return ptr;
	}


	void STATIC_Activated();
};


// Class TgGame.TgSeqAct_DefenseWaveSpawner
// 0x000C (0x0114 - 0x0108)
class UTgSeqAct_DefenseWaveSpawner : public USequenceAction
{
public:
	int                                                m_nRoundNumber;                                           // 0x0108(0x0004)
	float                                              m_fSpawnFrequency;                                        // 0x010C(0x0004)
	float                                              m_fNextSpawnTime;                                         // 0x0110(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_DefenseWaveSpawner");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_DisableForge
// 0x0000 (0x0108 - 0x0108)
class UTgSeqAct_DisableForge : public USequenceAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_DisableForge");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_DisplayObjective
// 0x0004 (0x010C - 0x0108)
class UTgSeqAct_DisplayObjective : public USequenceAction
{
public:
	int                                                m_nMessageId;                                             // 0x0108(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_DisplayObjective");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_DisplayPrompt
// 0x0014 (0x011C - 0x0108)
class UTgSeqAct_DisplayPrompt : public USequenceAction
{
public:
	struct FString                                     m_sCommand;                                               // 0x0108(0x0010) (NeedCtorLink)
	int                                                m_nMessageId;                                             // 0x0118(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_DisplayPrompt");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_DisplayTooltip
// 0x0008 (0x0110 - 0x0108)
class UTgSeqAct_DisplayTooltip : public USequenceAction
{
public:
	int                                                m_nMessageId;                                             // 0x0108(0x0004)
	unsigned long                                      m_bLeftPlacement : 1;                                     // 0x010C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_DisplayTooltip");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_EndMission
// 0x0000 (0x0108 - 0x0108)
class UTgSeqAct_EndMission : public USequenceAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_EndMission");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_EndTutorial
// 0x0000 (0x0108 - 0x0108)
class UTgSeqAct_EndTutorial : public USequenceAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_EndTutorial");
		return ptr;
	}


	void STATIC_Activated();
};


// Class TgGame.TgSeqAct_FillUltimateEnergy
// 0x0000 (0x0108 - 0x0108)
class UTgSeqAct_FillUltimateEnergy : public USequenceAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_FillUltimateEnergy");
		return ptr;
	}


	void STATIC_Activated();
};


// Class TgGame.TgSeqAct_ForceClientTutorialAction
// 0x0002 (0x010A - 0x0108)
class UTgSeqAct_ForceClientTutorialAction : public USequenceAction
{
public:
	TEnumAsByte<EeForcedClientTutorialAction>          ForcedAction;                                             // 0x0108(0x0001) (Edit)
	TEnumAsByte<EeTutorialForceableElements>           GameUIElement;                                            // 0x0109(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_ForceClientTutorialAction");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_GetLocalPlayerController
// 0x0008 (0x0110 - 0x0108)
class UTgSeqAct_GetLocalPlayerController : public USequenceAction
{
public:
	class ATgPlayerController*                         LocalPlayerController;                                    // 0x0108(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_GetLocalPlayerController");
		return ptr;
	}


	void STATIC_Activated();
};


// Class TgGame.TgSeqAct_GetMaterialInst
// 0x001C (0x0124 - 0x0108)
class UTgSeqAct_GetMaterialInst : public USequenceAction
{
public:
	class UMaterialInstance*                           MatInst;                                                  // 0x0108(0x0008) (Edit)
	struct FString                                     MatInstName;                                              // 0x0110(0x0010) (Edit, NeedCtorLink)
	int                                                MaterialIndex;                                            // 0x0120(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_GetMaterialInst");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_GetPlayerCount
// 0x0018 (0x0120 - 0x0108)
class UTgSeqAct_GetPlayerCount : public USequenceAction
{
public:
	int                                                m_nTaskForce;                                             // 0x0108(0x0004) (Edit)
	float                                              m_fPlayerCount;                                           // 0x010C(0x0004)
	float                                              m_fAssaultCount;                                          // 0x0110(0x0004)
	float                                              m_fMedicCount;                                            // 0x0114(0x0004)
	float                                              m_fReconCount;                                            // 0x0118(0x0004)
	float                                              m_fRoboticsCount;                                         // 0x011C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_GetPlayerCount");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_GetTaskForceCount
// 0x000C (0x0114 - 0x0108)
class UTgSeqAct_GetTaskForceCount : public USequenceAction
{
public:
	int                                                Taskforce;                                                // 0x0108(0x0004) (Edit)
	int                                                m_nPlayerCount;                                           // 0x010C(0x0004)
	int                                                m_nBotCount;                                              // 0x0110(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_GetTaskForceCount");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_GiveCredits
// 0x0004 (0x010C - 0x0108)
class UTgSeqAct_GiveCredits : public USequenceAction
{
public:
	int                                                CreditsToGive;                                            // 0x0108(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_GiveCredits");
		return ptr;
	}


	void STATIC_Activated();
};


// Class TgGame.TgSeqAct_GiveFullVitals
// 0x0000 (0x0108 - 0x0108)
class UTgSeqAct_GiveFullVitals : public USequenceAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_GiveFullVitals");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_GiveShards
// 0x0004 (0x010C - 0x0108)
class UTgSeqAct_GiveShards : public USequenceAction
{
public:
	int                                                m_nShardAmount;                                           // 0x0108(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_GiveShards");
		return ptr;
	}


	void STATIC_Activated();
};


// Class TgGame.TgSeqAct_MapOutroFinished
// 0x0000 (0x0108 - 0x0108)
class UTgSeqAct_MapOutroFinished : public USequenceAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_MapOutroFinished");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_NavIndicator
// 0x0008 (0x0110 - 0x0108)
class UTgSeqAct_NavIndicator : public USequenceAction
{
public:
	class AActor*                                      m_NavTarget;                                              // 0x0108(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_NavIndicator");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_PingMinimap
// 0x0008 (0x0110 - 0x0108)
class UTgSeqAct_PingMinimap : public USequenceAction
{
public:
	class AActor*                                      m_PingTarget;                                             // 0x0108(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_PingMinimap");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_PlayFullBodyAnim
// 0x0018 (0x0120 - 0x0108)
class UTgSeqAct_PlayFullBodyAnim : public USequenceAction
{
public:
	struct FName                                       c_AnimName;                                               // 0x0108(0x0008) (Edit)
	float                                              c_fRate;                                                  // 0x0110(0x0004) (Edit)
	float                                              c_fBlendInTime;                                           // 0x0114(0x0004) (Edit)
	float                                              c_fBlendOutTime;                                          // 0x0118(0x0004) (Edit)
	unsigned long                                      c_bLooping : 1;                                           // 0x011C(0x0004) (Edit)
	unsigned long                                      c_bOverride : 1;                                          // 0x011C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_PlayFullBodyAnim");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_PlayRecoilSkelControl
// 0x0010 (0x0118 - 0x0108)
class UTgSeqAct_PlayRecoilSkelControl : public USequenceAction
{
public:
	struct FName                                       SkelControlName;                                          // 0x0108(0x0008) (Edit)
	struct FName                                       ProfileName;                                              // 0x0110(0x0008) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_PlayRecoilSkelControl");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_ProgressTo
// 0x0008 (0x013C - 0x0134)
class UTgSeqAct_ProgressTo : public USeqAct_Delay
{
public:
	class ATgPawn*                                     m_Instigator;                                             // 0x0134(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_ProgressTo");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_PushMatinee
// 0x000C (0x0228 - 0x021C)
class UTgSeqAct_PushMatinee : public USeqAct_Interp
{
public:
	float                                              m_fCheckpoint1Time;                                       // 0x021C(0x0004) (Edit, Const)
	float                                              m_fCheckpoint2Time;                                       // 0x0220(0x0004) (Edit, Const)
	int                                                m_nDefenderTaskForce;                                     // 0x0224(0x0004) (Edit, Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_PushMatinee");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_RequestMission
// 0x0004 (0x010C - 0x0108)
class UTgSeqAct_RequestMission : public USequenceAction
{
public:
	int                                                m_nMapGameId;                                             // 0x0108(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_RequestMission");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_ResetCooldowns
// 0x0000 (0x0108 - 0x0108)
class UTgSeqAct_ResetCooldowns : public USequenceAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_ResetCooldowns");
		return ptr;
	}


	void STATIC_Activated();
};


// Class TgGame.TgSeqAct_RespawnAllPlayers
// 0x0004 (0x010C - 0x0108)
class UTgSeqAct_RespawnAllPlayers : public USequenceAction
{
public:
	unsigned long                                      bResetLivingPlayers : 1;                                  // 0x0108(0x0004) (Edit)
	unsigned long                                      bResetDeadPlayers : 1;                                    // 0x0108(0x0004) (Edit)
	unsigned long                                      bResetHealth : 1;                                         // 0x0108(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_RespawnAllPlayers");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_SendPlayerTrackingEvent
// 0x001C (0x0124 - 0x0108)
class UTgSeqAct_SendPlayerTrackingEvent : public USequenceAction
{
public:
	int                                                m_nEventId;                                               // 0x0108(0x0004) (Edit)
	int                                                m_nSubEventID;                                            // 0x010C(0x0004) (Edit)
	struct FString                                     m_ReferenceName;                                          // 0x0110(0x0010) (Edit, NeedCtorLink)
	int                                                m_nReferenceValue;                                        // 0x0120(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_SendPlayerTrackingEvent");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_SetCreditGainBlock
// 0x0004 (0x010C - 0x0108)
class UTgSeqAct_SetCreditGainBlock : public USequenceAction
{
public:
	int                                                m_bBlockCreditGain;                                       // 0x0108(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_SetCreditGainBlock");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_SetEnergyGainBlock
// 0x0004 (0x010C - 0x0108)
class UTgSeqAct_SetEnergyGainBlock : public USequenceAction
{
public:
	int                                                m_bBlockEnergyGain;                                       // 0x0108(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_SetEnergyGainBlock");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_SetHexState
// 0x0004 (0x010C - 0x0108)
class UTgSeqAct_SetHexState : public USequenceAction
{
public:
	unsigned long                                      m_bChallengerWon : 1;                                     // 0x0108(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_SetHexState");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_SetInputEnabled
// 0x0004 (0x010C - 0x0108)
class UTgSeqAct_SetInputEnabled : public USequenceAction
{
public:
	unsigned long                                      bEnableMoveForward : 1;                                   // 0x0108(0x0004) (Edit)
	unsigned long                                      bEnableMoveBackward : 1;                                  // 0x0108(0x0004) (Edit)
	unsigned long                                      bEnableMoveLeft : 1;                                      // 0x0108(0x0004) (Edit)
	unsigned long                                      bEnableMoveRight : 1;                                     // 0x0108(0x0004) (Edit)
	unsigned long                                      bEnableLookUp : 1;                                        // 0x0108(0x0004) (Edit)
	unsigned long                                      bEnableLookDown : 1;                                      // 0x0108(0x0004) (Edit)
	unsigned long                                      bEnableLookLeft : 1;                                      // 0x0108(0x0004) (Edit)
	unsigned long                                      bEnableLookRight : 1;                                     // 0x0108(0x0004) (Edit)
	unsigned long                                      bEnableJumping : 1;                                       // 0x0108(0x0004) (Edit)
	unsigned long                                      bEnableMounting : 1;                                      // 0x0108(0x0004) (Edit)
	unsigned long                                      bEnableAuto : 1;                                          // 0x0108(0x0004) (Edit)
	unsigned long                                      bEnableAlt : 1;                                           // 0x0108(0x0004) (Edit)
	unsigned long                                      bEnableBattleAbility : 1;                                 // 0x0108(0x0004) (Edit)
	unsigned long                                      bEnableMovementAbility : 1;                               // 0x0108(0x0004) (Edit)
	unsigned long                                      bEnableUltimate : 1;                                      // 0x0108(0x0004) (Edit)
	unsigned long                                      bEnableEmote : 1;                                         // 0x0108(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_SetInputEnabled");
		return ptr;
	}


	void STATIC_Activated();
};


// Class TgGame.TgSeqAct_SetMapLane
// 0x0004 (0x010C - 0x0108)
class UTgSeqAct_SetMapLane : public USequenceAction
{
public:
	int                                                m_nMapLane;                                               // 0x0108(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_SetMapLane");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_SetMissionTime
// 0x000C (0x0114 - 0x0108)
class UTgSeqAct_SetMissionTime : public USequenceAction
{
public:
	float                                              m_fMissionTimeSecs;                                       // 0x0108(0x0004) (Edit)
	float                                              m_fIncrementSecs;                                         // 0x010C(0x0004) (Edit)
	float                                              m_fMissionTimeRemaining;                                  // 0x0110(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_SetMissionTime");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_SetPlayerLevel
// 0x0004 (0x010C - 0x0108)
class UTgSeqAct_SetPlayerLevel : public USequenceAction
{
public:
	int                                                m_nLevel;                                                 // 0x0108(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_SetPlayerLevel");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_SetPlayerMesh
// 0x0004 (0x010C - 0x0108)
class UTgSeqAct_SetPlayerMesh : public USequenceAction
{
public:
	int                                                m_nMeshAsmId;                                             // 0x0108(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_SetPlayerMesh");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_SetPlayerMeshVisible
// 0x0004 (0x010C - 0x0108)
class UTgSeqAct_SetPlayerMeshVisible : public USequenceAction
{
public:
	unsigned long                                      bIs1PMeshVisible : 1;                                     // 0x0108(0x0004) (Edit)
	unsigned long                                      bIs3PMeshVisible : 1;                                     // 0x0108(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_SetPlayerMeshVisible");
		return ptr;
	}


	void STATIC_Activated();
};


// Class TgGame.TgSeqAct_SetUIClock
// 0x0004 (0x010C - 0x0108)
class UTgSeqAct_SetUIClock : public USequenceAction
{
public:
	unsigned long                                      ShowAlarmTexture : 1;                                     // 0x0108(0x0004) (Edit)
	unsigned long                                      UseProgressBar : 1;                                       // 0x0108(0x0004) (Edit)
	unsigned long                                      IsCountingDown : 1;                                       // 0x0108(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_SetUIClock");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_SetUITextBox
// 0x0009 (0x0111 - 0x0108)
class UTgSeqAct_SetUITextBox : public USequenceAction
{
public:
	int                                                TextBox_MessageID;                                        // 0x0108(0x0004) (Edit)
	unsigned long                                      TextBox_TargetSecondary : 1;                              // 0x010C(0x0004) (Edit)
	unsigned long                                      TextBox_UseDuration : 1;                                  // 0x010C(0x0004) (Edit)
	unsigned long                                      TextBox_AllowEscape : 1;                                  // 0x010C(0x0004) (Edit)
	TEnumAsByte<EAlertType>                            TextBox_MessageType;                                      // 0x0110(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_SetUITextBox");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_Skydive
// 0x0000 (0x0108 - 0x0108)
class UTgSeqAct_Skydive : public USequenceAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_Skydive");
		return ptr;
	}


	void STATIC_Activated();
};


// Class TgGame.TgSeqAct_TemporaryAddDevice
// 0x0008 (0x0110 - 0x0108)
class UTgSeqAct_TemporaryAddDevice : public USequenceAction
{
public:
	int                                                m_nDeviceId;                                              // 0x0108(0x0004) (Edit)
	int                                                m_nEquipPoint;                                            // 0x010C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_TemporaryAddDevice");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_TemporaryRemoveDevice
// 0x0004 (0x010C - 0x0108)
class UTgSeqAct_TemporaryRemoveDevice : public USequenceAction
{
public:
	int                                                m_nEquipPoint;                                            // 0x0108(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_TemporaryRemoveDevice");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_ToggleStaticMeshSilhouette
// 0x000C (0x0114 - 0x0108)
class UTgSeqAct_ToggleStaticMeshSilhouette : public USequenceAction
{
public:
	class AStaticMeshActor*                            SMA;                                                      // 0x0108(0x0008) (Edit)
	unsigned long                                      bIsEnabled : 1;                                           // 0x0110(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_ToggleStaticMeshSilhouette");
		return ptr;
	}


	void STATIC_Activated();
};


// Class TgGame.TgSeqAct_TrainingAwards
// 0x0010 (0x0118 - 0x0108)
class UTgSeqAct_TrainingAwards : public USequenceAction
{
public:
	float                                              m_fGoldTime;                                              // 0x0108(0x0004) (Edit)
	float                                              m_fSilverTime;                                            // 0x010C(0x0004) (Edit)
	float                                              m_fBronzeTime;                                            // 0x0110(0x0004) (Edit)
	float                                              m_fPassTime;                                              // 0x0114(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_TrainingAwards");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_TriggerBots
// 0x0014 (0x011C - 0x0108)
class UTgSeqAct_TriggerBots : public USequenceAction
{
public:
	unsigned long                                      bUseDestination : 1;                                      // 0x0108(0x0004) (Edit)
	class AActor*                                      TargetActor;                                              // 0x010C(0x0008) (Edit)
	class AActor*                                      destActor;                                                // 0x0114(0x0008) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_TriggerBots");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_TutorialHighlighter
// 0x0001 (0x0109 - 0x0108)
class UTgSeqAct_TutorialHighlighter : public USequenceAction
{
public:
	TEnumAsByte<EeTutorialHighlighterElement>          GameUIElement;                                            // 0x0108(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_TutorialHighlighter");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_TutorialInstruction
// 0x0004 (0x010C - 0x0108)
class UTgSeqAct_TutorialInstruction : public USequenceAction
{
public:
	int                                                nMsgId;                                                   // 0x0108(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_TutorialInstruction");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_TutorialTips
// 0x0004 (0x010C - 0x0108)
class UTgSeqAct_TutorialTips : public USequenceAction
{
public:
	int                                                nMsgId;                                                   // 0x0108(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_TutorialTips");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_UIAlert
// 0x0024 (0x012C - 0x0108)
class UTgSeqAct_UIAlert : public USequenceAction
{
public:
	int                                                nMsgId;                                                   // 0x0108(0x0004) (Edit)
	TArray<int>                                        Taskforces;                                               // 0x010C(0x0010) (NeedCtorLink)
	TArray<unsigned long>                              Broadcast;                                                // 0x011C(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_UIAlert");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_UIElementVisibility
// 0x0024 (0x012C - 0x0108)
class UTgSeqAct_UIElementVisibility : public USequenceAction
{
public:
	unsigned long                                      ShowElement : 1;                                          // 0x0108(0x0004) (Edit)
	struct FString                                     UISceneName;                                              // 0x010C(0x0010) (Edit, NeedCtorLink)
	struct FString                                     UIElementName;                                            // 0x011C(0x0010) (Edit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_UIElementVisibility");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_UnlockChest
// 0x0000 (0x0108 - 0x0108)
class UTgSeqAct_UnlockChest : public USequenceAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_UnlockChest");
		return ptr;
	}

};


// Class TgGame.TgSeqCond_And
// 0x0000 (0x00EC - 0x00EC)
class UTgSeqCond_And : public USequenceCondition
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqCond_And");
		return ptr;
	}

};


// Class TgGame.TgSeqCond_CompareDamageType
// 0x0000 (0x00EC - 0x00EC)
class UTgSeqCond_CompareDamageType : public USequenceCondition
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqCond_CompareDamageType");
		return ptr;
	}

};


// Class TgGame.TgSeqCond_CompareDeviceId
// 0x000C (0x00F8 - 0x00EC)
class UTgSeqCond_CompareDeviceId : public USequenceCondition
{
public:
	class UObject*                                     Device;                                                   // 0x00EC(0x0008) (Edit)
	int                                                DeviceID;                                                 // 0x00F4(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqCond_CompareDeviceId");
		return ptr;
	}

};


// Class TgGame.TgSeqCond_HasCondition
// 0x0001 (0x00ED - 0x00EC)
class UTgSeqCond_HasCondition : public USequenceCondition
{
public:
	TEnumAsByte<EConditionType>                        ConditionList;                                            // 0x00EC(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqCond_HasCondition");
		return ptr;
	}

};


// Class TgGame.TgSeqCond_IsHuman
// 0x0000 (0x00EC - 0x00EC)
class UTgSeqCond_IsHuman : public USequenceCondition
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqCond_IsHuman");
		return ptr;
	}

};


// Class TgGame.TgSeqCond_IsLoggedIn
// 0x0000 (0x00EC - 0x00EC)
class UTgSeqCond_IsLoggedIn : public USequenceCondition
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqCond_IsLoggedIn");
		return ptr;
	}

};


// Class TgGame.TgSeqCond_IsSecuring
// 0x0000 (0x00EC - 0x00EC)
class UTgSeqCond_IsSecuring : public USequenceCondition
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqCond_IsSecuring");
		return ptr;
	}

};


// Class TgGame.TgSeqCond_IsSpectating
// 0x0000 (0x00EC - 0x00EC)
class UTgSeqCond_IsSpectating : public USequenceCondition
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqCond_IsSpectating");
		return ptr;
	}

};


// Class TgGame.TgSeqCond_Or
// 0x0000 (0x00EC - 0x00EC)
class UTgSeqCond_Or : public USequenceCondition
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqCond_Or");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_ChestOpened
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_ChestOpened : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_ChestOpened");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_ChestStartEncounter
// 0x0008 (0x0130 - 0x0128)
class UTgSeqEvent_ChestStartEncounter : public USequenceEvent
{
public:
	class ATgDeploy_LootCrateEncounter*                m_ChestDeployable;                                        // 0x0128(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_ChestStartEncounter");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_ClientGameOver
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_ClientGameOver : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_ClientGameOver");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_DeployableFired
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_DeployableFired : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_DeployableFired");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_DeviceEquipped
// 0x0004 (0x012C - 0x0128)
class UTgSeqEvent_DeviceEquipped : public USequenceEvent
{
public:
	int                                                m_nDeviceId;                                              // 0x0128(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_DeviceEquipped");
		return ptr;
	}


	void STATIC_CheckDeviceEquipped(class AActor* InInstigator, int nDeviceId);
};


// Class TgGame.TgSeqEvent_DeviceUsed
// 0x0004 (0x012C - 0x0128)
class UTgSeqEvent_DeviceUsed : public USequenceEvent
{
public:
	int                                                m_nDeviceId;                                              // 0x0128(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_DeviceUsed");
		return ptr;
	}


	void STATIC_CheckDeviceUsed(class AActor* InInstigator, int nDeviceId);
};


// Class TgGame.TgSeqEvent_EnergyUpdated
// 0x0004 (0x012C - 0x0128)
class UTgSeqEvent_EnergyUpdated : public USequenceEvent
{
public:
	int                                                ResultEnergy;                                             // 0x0128(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_EnergyUpdated");
		return ptr;
	}


	int STATIC_GetIndex(float CurrentEnergy, float PreviousEnergy);
};


// Class TgGame.TgSeqEvent_Escort_Despawn_Success
// 0x0004 (0x012C - 0x0128)
class UTgSeqEvent_Escort_Despawn_Success : public USequenceEvent
{
public:
	int                                                DefendersTaskForce;                                       // 0x0128(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_Escort_Despawn_Success");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_FiringDevice
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_FiringDevice : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_FiringDevice");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_ForgeComplete
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_ForgeComplete : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_ForgeComplete");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_ItemForged
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_ItemForged : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_ItemForged");
		return ptr;
	}


	void STATIC_ItemForged(class AActor* InOriginator, class AActor* InInstigator, int inDeviceId);
};


// Class TgGame.TgSeqEvent_LevelFadedIn
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_LevelFadedIn : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_LevelFadedIn");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_MissionTimer
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_MissionTimer : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_MissionTimer");
		return ptr;
	}


	void UpdateChallengerWonValue(bool bValue);
};


// Class TgGame.TgSeqEvent_MissionTimeRemaining
// 0x0004 (0x012C - 0x0128)
class UTgSeqEvent_MissionTimeRemaining : public USequenceEvent
{
public:
	float                                              SecsRemaining;                                            // 0x0128(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_MissionTimeRemaining");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_Named
// 0x0001 (0x0129 - 0x0128)
class UTgSeqEvent_Named : public USequenceEvent
{
public:
	TEnumAsByte<ETSE_NAME>                             NamedEvent;                                               // 0x0128(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_Named");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_PayloadMissionEvents
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_PayloadMissionEvents : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_PayloadMissionEvents");
		return ptr;
	}


	void UpdateTaskForceWonValue(unsigned char iValue);
	void UpdateTaskForceAttackValue(unsigned char iValue);
};


// Class TgGame.TgSeqEvent_PlayerMoved
// 0x0004 (0x012C - 0x0128)
class UTgSeqEvent_PlayerMoved : public USequenceEvent
{
public:
	int                                                ResultEnergy;                                             // 0x0128(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_PlayerMoved");
		return ptr;
	}


	int STATIC_GetIndex(TEnumAsByte<EPlayerCardinalDirection> MovementDirection);
};


// Class TgGame.TgSeqEvent_ReachShards
// 0x0004 (0x012C - 0x0128)
class UTgSeqEvent_ReachShards : public USequenceEvent
{
public:
	int                                                nShardCount;                                              // 0x0128(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_ReachShards");
		return ptr;
	}


	void STATIC_HandleShardAdjustment(class AActor* InOriginator, class AActor* InInstigator, int nNewShardTotal);
};


// Class TgGame.TgSeqEvent_SkydiveLanded
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_SkydiveLanded : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_SkydiveLanded");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_SkydiveStart
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_SkydiveStart : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_SkydiveStart");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_SpawnLanePusher
// 0x0004 (0x012C - 0x0128)
class UTgSeqEvent_SpawnLanePusher : public USequenceEvent
{
public:
	int                                                Taskforce;                                                // 0x0128(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_SpawnLanePusher");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_SpawnWise
// 0x0004 (0x012C - 0x0128)
class UTgSeqEvent_SpawnWise : public USequenceEvent
{
public:
	int                                                Taskforce;                                                // 0x0128(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_SpawnWise");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_TakeDamage
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_TakeDamage : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_TakeDamage");
		return ptr;
	}


	void STATIC_HandleDamage(class AActor* InOriginator, class AActor* InInstigator, int inAmount, class UClass* inDamageType, class ATgDevice* InDevice);
};


// Class TgGame.TgSeqEvent_TaskForceInactive
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_TaskForceInactive : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_TaskForceInactive");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_TeamInactive
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_TeamInactive : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_TeamInactive");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_TicketCountUpdated
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_TicketCountUpdated : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_TicketCountUpdated");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_UI_Event
// 0x0008 (0x0130 - 0x0128)
class UTgSeqEvent_UI_Event : public USequenceEvent
{
public:
	int                                                mDeckNum;                                                 // 0x0128(0x0004)
	int                                                mEmptyItemSlots;                                          // 0x012C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_UI_Event");
		return ptr;
	}


	void STATIC_ItemUpgraded(class AActor* InOriginator, class AActor* InInstigator);
	void STATIC_ItemPurchased(class AActor* InOriginator, class AActor* InInstigator, int EmptySlots);
	void STATIC_ItemMenuOpened(class AActor* InOriginator, class AActor* InInstigator);
	void STATIC_DeckSelected(class AActor* InOriginator, class AActor* InInstigator, int Deck);
	void STATIC_DeckChanged(class AActor* InOriginator, class AActor* InInstigator, int Deck);
	void STATIC_DeckMenuOpened(class AActor* InOriginator, class AActor* InInstigator);
	void STATIC_ItemUIInitialized(class AActor* InOriginator, class AActor* InInstigator);
	void STATIC_DeckUIInitialized(class AActor* InOriginator, class AActor* InInstigator);
};


// Class TgGame.TgSeqEvent_UpdateLanePusherCount
// 0x0004 (0x012C - 0x0128)
class UTgSeqEvent_UpdateLanePusherCount : public USequenceEvent
{
public:
	int                                                Taskforce;                                                // 0x0128(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_UpdateLanePusherCount");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_Used
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_Used : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_Used");
		return ptr;
	}

};


// Class TgGame.TgSeqOp_MathCalc
// 0x0004 (0x00F0 - 0x00EC)
class UTgSeqOp_MathCalc : public USequenceCondition
{
public:
	float                                              m_fResult;                                                // 0x00EC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqOp_MathCalc");
		return ptr;
	}

};


// Class TgGame.TgSeqVar_DamageType
// 0x0008 (0x00A8 - 0x00A0)
class UTgSeqVar_DamageType : public USequenceVariable
{
public:
	class UClass*                                      DamageTypeValue;                                          // 0x00A0(0x0008) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqVar_DamageType");
		return ptr;
	}

};


// Class TgGame.TgSeqVar_Player
// 0x0038 (0x0114 - 0x00DC)
class UTgSeqVar_Player : public USeqVar_Player
{
public:
	TArray<class UObject*>                             HumanPlayers;                                             // 0x00DC(0x0010) (Transient, NeedCtorLink)
	TArray<class UObject*>                             BotPlayers;                                               // 0x00EC(0x0010) (Transient, NeedCtorLink)
	TArray<class UObject*>                             PetPlayers;                                               // 0x00FC(0x0010) (Transient, NeedCtorLink)
	unsigned long                                      bAllBots : 1;                                             // 0x010C(0x0004) (Edit)
	unsigned long                                      bAllHumans : 1;                                           // 0x010C(0x0004) (Edit)
	unsigned long                                      bAllHumansAndPets : 1;                                    // 0x010C(0x0004) (Edit)
	int                                                nTaskForceNumber;                                         // 0x0110(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqVar_Player");
		return ptr;
	}

};


// Class TgGame.TgSeqVar_RouteNumber
// 0x0000 (0x00A4 - 0x00A4)
class UTgSeqVar_RouteNumber : public USeqVar_Int
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqVar_RouteNumber");
		return ptr;
	}

};


// Class TgGame.TgTrigger_AIControlledCharacters
// 0x0000 (0x0290 - 0x0290)
class ATgTrigger_AIControlledCharacters : public ATrigger
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgTrigger_AIControlledCharacters");
		return ptr;
	}

};


// Class TgGame.TgTrigger_Instance
// 0x0018 (0x02A8 - 0x0290)
class ATgTrigger_Instance : public ATrigger
{
public:
	int                                                m_nMapId;                                                 // 0x0290(0x0004) (Edit, EditInline)
	unsigned long                                      m_nPreload : 1;                                           // 0x0294(0x0004) (Edit, EditInline)
	unsigned long                                      m_nTaskForce : 1;                                         // 0x0294(0x0004) (Edit, EditInline)
	struct FString                                     m_SpawnPointName;                                         // 0x0298(0x0010) (Edit, NeedCtorLink, EditInline)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgTrigger_Instance");
		return ptr;
	}


	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_HandleTouch(class AActor* Other, const struct FVector& HitLocation, const struct FVector& HitNormal);
};


// Class TgGame.TgTrigger_PlayerControlledCharacters
// 0x0000 (0x0290 - 0x0290)
class ATgTrigger_PlayerControlledCharacters : public ATrigger
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgTrigger_PlayerControlledCharacters");
		return ptr;
	}

};


// Class TgGame.TgTrigger_Use
// 0x0030 (0x02C0 - 0x0290)
class ATgTrigger_Use : public ATrigger
{
public:
	struct FString                                     m_sDisplayText;                                           // 0x0290(0x0010) (Edit, NeedCtorLink, EditInline)
	struct FString                                     m_sInactiveText;                                          // 0x02A0(0x0010) (Edit, NeedCtorLink, EditInline)
	int                                                m_nInteractDistance;                                      // 0x02B0(0x0004) (Edit, EditInline)
	unsigned long                                      m_bAimToInteract : 1;                                     // 0x02B4(0x0004) (Edit, EditInline)
	int                                                m_nDisplayMsgId;                                          // 0x02B8(0x0004) (Edit, EditInline)
	int                                                m_nInactiveMsgId;                                         // 0x02BC(0x0004) (Edit, EditInline)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgTrigger_Use");
		return ptr;
	}


	void UnTouch(class AActor* Other);
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	int STATIC_GetMsgIdToDisplay();
	bool STATIC_IsUsedEnabled();
	void UsedByPawn(class ATgPawn* User);
};


// Class TgGame.Interface_AIAnnotation
// 0x0000 (0x0060 - 0x0060)
class UInterface_AIAnnotation : public UInterface
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.Interface_AIAnnotation");
		return ptr;
	}


	void STATIC_GetAdjustedPosition(class APawn* AnnotationOwner, class AActor* Target, struct FVector* out_Position);
};


// Class TgGame.TgAudioOcclusionActor
// 0x0028 (0x02A8 - 0x0280)
class ATgAudioOcclusionActor : public AActor
{
public:
	struct FPointer                                    VfTable_IInterface_NavigationHandle;                      // 0x0280(0x0008) (Const, Native, NoExport)
	class UClass*                                      m_NavigationHandleClass;                                  // 0x0288(0x0008)
	class UNavigationHandle*                           m_NavigationHandle;                                       // 0x0290(0x0008)
	struct FVector                                     NavMeshPath_SearchExtent_Modifier;                        // 0x0298(0x000C)
	float                                              m_fCurrentMaxPathLength;                                  // 0x02A4(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAudioOcclusionActor");
		return ptr;
	}


	void STATIC_NotifyPathChanged();
	float CalcOcclusionAmount(class AActor* SourceActor);
	void PostBeginPlay();
};


// Class TgGame.TgLanePylon
// 0x0004 (0x0494 - 0x0490)
class ATgLanePylon : public APylon
{
public:
	int                                                m_nLane;                                                  // 0x0490(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgLanePylon");
		return ptr;
	}

};


// Class TgGame.TgTeamBlocker
// 0x0004 (0x029C - 0x0298)
class ATgTeamBlocker : public ATgMeshAssembly
{
public:
	unsigned long                                      m_bBlockFlagCarrier : 1;                                  // 0x0298(0x0004) (Edit)
	unsigned long                                      m_bBlockFriendlyFire : 1;                                 // 0x0298(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgTeamBlocker");
		return ptr;
	}

};


// Class TgGame.TgDoorMarker
// 0x0020 (0x02BC - 0x029C)
class ATgDoorMarker : public ATgTeamBlocker
{
public:
	TEnumAsByte<EDoorStatus>                           r_eStatus;                                                // 0x029C(0x0001) (Net)
	TEnumAsByte<EDoorStatus>                           m_eInitStatus;                                            // 0x029D(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x2];                                       // 0x029E(0x0002) MISSED OFFSET
	class ATgCollisionProxy*                           s_CollisionProxy;                                         // 0x02A0(0x0008)
	float                                              m_fProximity;                                             // 0x02A8(0x0004) (Edit)
	int                                                m_nTeamThatControlsDoor;                                  // 0x02AC(0x0004) (Edit)
	int                                                m_nMeshAssemblyId;                                        // 0x02B0(0x0004) (Edit)
	class USkeletalMeshComponent*                      m_DoorSMC;                                                // 0x02B4(0x0008) (Edit, ExportObject, Component, EditInline)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDoorMarker");
		return ptr;
	}


	void SetDoorStatus(TEnumAsByte<EDoorStatus> eStatus);
	void CalculateDoorStatus();
	bool ShouldDoorBeClosed();
	bool ShouldDoorBeOpened();
	void UnTouch(class AActor* Other);
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void ClientOnStatusChange();
	void PostBeginPlay();
	void STATIC_ReplicatedEvent(const struct FName& VarName);
	void STATIC_LoadMesh();
};


// Class TgGame.TgNavigationPoint
// 0x0008 (0x0380 - 0x0378)
class ATgNavigationPoint : public ANavigationPoint
{
public:
	int                                                m_nMapObjectId;                                           // 0x0378(0x0004) (Edit, EditConst)
	float                                              m_fLastSpawnedTime;                                       // 0x037C(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgNavigationPoint");
		return ptr;
	}

};


// Class TgGame.TgActionPoint
// 0x0008 (0x0388 - 0x0380)
class ATgActionPoint : public ATgNavigationPoint
{
public:
	TEnumAsByte<EeActionPointType>                     ActionType;                                               // 0x0380(0x0001) (Edit)
	unsigned char                                      nObjectiveNum;                                            // 0x0381(0x0001) (Edit)
	unsigned char                                      nTaskForce;                                               // 0x0382(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x1];                                       // 0x0383(0x0001) MISSED OFFSET
	unsigned long                                      bUseRotation : 1;                                         // 0x0384(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgActionPoint");
		return ptr;
	}

};


// Class TgGame.TgAIAnnotation
// 0x0014 (0x0394 - 0x0380)
class ATgAIAnnotation : public ATgNavigationPoint
{
public:
	struct FPointer                                    VfTable_IInterface_AIAnnotation;                          // 0x0380(0x0008) (Const, Native, NoExport)
	TEnumAsByte<EAIAnnotationType>                     AnnotationType;                                           // 0x0388(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0389(0x0003) MISSED OFFSET
	class APawn*                                       m_pClaimedBy;                                             // 0x038C(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIAnnotation");
		return ptr;
	}


	void PostBeginPlay();
	void STATIC_GetAdjustedPosition(class APawn* AnnotationOwner, class AActor* Target, struct FVector* out_Position);
	void Initialize();
	void STATIC_Claim(class APawn* pClaimedBy);
	class APawn* STATIC_GetClaimedBy();
};


// Class TgGame.TgAssaultPoint
// 0x0002 (0x0396 - 0x0394)
class ATgAssaultPoint : public ATgAIAnnotation
{
public:
	TEnumAsByte<EAssaultType>                          AssaultPointType;                                         // 0x0394(0x0001) (Edit)
	TEnumAsByte<ELocationType>                         LocationType;                                             // 0x0395(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAssaultPoint");
		return ptr;
	}

};


// Class TgGame.TgCoverPoint
// 0x0028 (0x03BC - 0x0394)
class ATgCoverPoint : public ATgAIAnnotation
{
public:
	unsigned long                                      m_bLeanLeft : 1;                                          // 0x0394(0x0004) (Edit)
	unsigned long                                      m_bLeanRight : 1;                                         // 0x0394(0x0004) (Edit)
	unsigned long                                      m_bAllowPopup : 1;                                        // 0x0394(0x0004) (Edit)
	unsigned long                                      m_bAllowMantle : 1;                                       // 0x0394(0x0004) (Edit)
	struct FVector                                     m_vLeanLeft;                                              // 0x0398(0x000C)
	struct FVector                                     m_vLeanRight;                                             // 0x03A4(0x000C)
	struct FVector                                     m_vPopUp;                                                 // 0x03B0(0x000C)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCoverPoint");
		return ptr;
	}


	void PostBeginPlay();
	void STATIC_GetAdjustedPosition(class APawn* AnnotationOwner, class AActor* Target, struct FVector* out_Position);
};


// Class TgGame.TgNavigationPointSpawnable
// 0x0000 (0x0380 - 0x0380)
class ATgNavigationPointSpawnable : public ATgNavigationPoint
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgNavigationPointSpawnable");
		return ptr;
	}

};


// Class TgGame.TgPointOfInterest
// 0x0014 (0x0394 - 0x0380)
class ATgPointOfInterest : public ATgNavigationPoint
{
public:
	int                                                m_nNameMsgId;                                             // 0x0380(0x0004) (Edit)
	struct FString                                     m_sDebugName;                                             // 0x0384(0x0010) (Edit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPointOfInterest");
		return ptr;
	}

};


// Class TgGame.TgNavMeshPath_AlongLane
// 0x0004 (0x007C - 0x0078)
class UTgNavMeshPath_AlongLane : public UNavMeshPathConstraint
{
public:
	int                                                m_nLane;                                                  // 0x0078(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgNavMeshPath_AlongLane");
		return ptr;
	}


	void STATIC_Recycle();
	bool AlongLane(class UNavigationHandle* NavHandle, int nLane);
};


// Class TgGame.TgPathfinder
// 0x0098 (0x0318 - 0x0280)
class ATgPathfinder : public AActor
{
public:
	struct FPointer                                    VfTable_IInterface_NavigationHandle;                      // 0x0280(0x0008) (Const, Native, NoExport)
	float                                              m_fMaxSpeed;                                              // 0x0288(0x0004) (Edit)
	TArray<struct FVector>                             m_vWaypoints;                                             // 0x028C(0x0010) (AlwaysInit, NeedCtorLink)
	float                                              m_fPathCheckRadius;                                       // 0x029C(0x0004)
	class UHavokNavigationHandle*                      m_NavigationHandle;                                       // 0x02A0(0x0008)
	class ASplineActor*                                m_Spline;                                                 // 0x02A8(0x0008)
	class ASplineActor*                                m_CurrentSpline;                                          // 0x02B0(0x0008)
	float                                              m_fCurrentSplineDist;                                     // 0x02B8(0x0004)
	struct FNavMeshPathParams                          m_NavMeshPathParams;                                      // 0x02BC(0x0038) (Edit, EditInline)
	TArray<class ATgPathfinderWalker*>                 m_ActiveWalkers;                                          // 0x02F4(0x0010) (NeedCtorLink)
	float                                              m_WalkerLifeSpan;                                         // 0x0304(0x0004)
	struct FScriptDelegate                             __OnFinishedPathing__Delegate;                            // 0x0308(0x000C) (NeedCtorLink)
	unsigned char                                      UnknownData00[0x4];                                       // 0x0308(0x0004) FIX WRONG TYPE SIZE OF PREVIOUS PROPERTY

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPathfinder");
		return ptr;
	}


	void STATIC_OnPathfinderWalkerFinishedPathing(class ATgPathfinderWalker* Walker);
	void SpawnWalker();
	void StopWalkerStream();
	void StartWalkerStream(float StreamTime, float WalkerPulseTime, float WalkerLifetime, float WalkerSpeed);
	void Destroyed();
	void SetupPathProperties(float PathCheckRadius, float PathSpeed);
	void STATIC_NotifyPathChanged();
	bool SetRouteTo(class AActor* destActor, bool bDrawDebugPath);
	void STATIC_OnFinishedPathing(class ATgPathfinder* Pathfinder);
};


// Class TgGame.TgPathfinderWalker
// 0x0024 (0x02A4 - 0x0280)
class ATgPathfinderWalker : public AActor
{
public:
	class ATgPathfinder*                               m_Pathfinder;                                             // 0x0280(0x0008)
	class ASplineActor*                                m_CurrentSpline;                                          // 0x0288(0x0008)
	float                                              m_fCurrentSplineDist;                                     // 0x0290(0x0004)
	struct FScriptDelegate                             __OnFinishedPathing__Delegate;                            // 0x0294(0x000C) (NeedCtorLink)
	unsigned char                                      UnknownData00[0x4];                                       // 0x0294(0x0004) FIX WRONG TYPE SIZE OF PREVIOUS PROPERTY

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPathfinderWalker");
		return ptr;
	}


	void Destroyed();
	void SetPathfinder(class ATgPathfinder* Pathfinder);
	void STATIC_OnFinishedPathing(class ATgPathfinderWalker* PathfinderWalker);
};


// Class TgGame.TgPathPreviewActor
// 0x0058 (0x02D8 - 0x0280)
class ATgPathPreviewActor : public AActor
{
public:
	struct FPointer                                    VfTable_IInterface_NavigationHandle;                      // 0x0280(0x0008) (Const, Native, NoExport)
	class ATgPathPreviewActor*                         m_Destination;                                            // 0x0288(0x0008) (Edit)
	class ATgPathPreviewActor*                         m_Source;                                                 // 0x0290(0x0008)
	class UHavokNavigationHandle*                      m_NavigationHandle;                                       // 0x0298(0x0008)
	struct FNavMeshPathParams                          m_NavMeshPathParams;                                      // 0x02A0(0x0038) (Edit, EditInline)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPathPreviewActor");
		return ptr;
	}


	void STATIC_NotifyPathChanged();
};


// Class TgGame.TgPathPreviewRenderingComponent
// 0x0000 (0x024C - 0x024C)
class UTgPathPreviewRenderingComponent : public UPrimitiveComponent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPathPreviewRenderingComponent");
		return ptr;
	}

};


// Class TgGame.TgPlayerStartRoyale
// 0x0001 (0x0389 - 0x0388)
class ATgPlayerStartRoyale : public APlayerStart
{
public:
	TEnumAsByte<ERoyaleRegion>                         m_Region;                                                 // 0x0388(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPlayerStartRoyale");
		return ptr;
	}

};


// Class TgGame.TgSkeletalMeshActor
// 0x0044 (0x032C - 0x02E8)
class ATgSkeletalMeshActor : public ASkeletalMeshActor
{
public:
	struct FMeshAssets                                 c_MeshAssets;                                             // 0x02E8(0x0040) (NeedCtorLink)
	unsigned long                                      c_bLoadMeshAssetts : 1;                                   // 0x0328(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkeletalMeshActor");
		return ptr;
	}


	void DoKismetAttachment(class AActor* Attachment, class USeqAct_AttachToActor* Action);
	void STATIC_OnParentAnimComponent(class UTgSeqAct_ParentAnimComponent* Action);
	void STATIC_LoadClientOnlyMeshAssets();
	class UMeshComponent* CreateMeshComponent(int MeshAsmId, class UMeshComponent* DestComponent, bool bPartialFixup);
	class UTgStaticMeshComponent* CreateStaticMeshComponent(int MeshAsmId, class UTgStaticMeshComponent* DestComponent);
	class UTgSkeletalMeshComponent* CreateSkeletalMeshComponent(int MeshAsmId, class UTgSkeletalMeshComponent* DestComponent, bool bPartialFixup);
	bool AttachToSocket(class AActor* Attachment, const struct FName& BoneName);
};


// Class TgGame.TgSkeletalMeshActorSpawnable
// 0x0000 (0x032C - 0x032C)
class ATgSkeletalMeshActorSpawnable : public ATgSkeletalMeshActor
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkeletalMeshActorSpawnable");
		return ptr;
	}

};


// Class TgGame.TgNavRouteIndicator
// 0x004C (0x0378 - 0x032C)
class ATgNavRouteIndicator : public ATgSkeletalMeshActorSpawnable
{
public:
	struct FPointer                                    VfTable_IInterface_NavigationHandle;                      // 0x032C(0x0008) (Const, Native, NoExport)
	TArray<struct FVector>                             WayPoints;                                                // 0x0334(0x0010) (AlwaysInit, NeedCtorLink)
	int                                                Position;                                                 // 0x0344(0x0004)
	float                                              m_fPositionStartTime;                                     // 0x0348(0x0004)
	float                                              m_fPositionMaxSeekTime;                                   // 0x034C(0x0004)
	float                                              m_fSpinUpTime;                                            // 0x0350(0x0004)
	float                                              m_fSpinDownTime;                                          // 0x0354(0x0004)
	class UTgSpecialFx*                                m_SpinUpFx;                                               // 0x0358(0x0008)
	class UTgSpecialFx*                                m_PathingFx;                                              // 0x0360(0x0008)
	class UTgSpecialFx*                                m_SpinDownFx;                                             // 0x0368(0x0008)
	class UNavigationHandle*                           NavigationHandle;                                         // 0x0370(0x0008) (EditInline)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgNavRouteIndicator");
		return ptr;
	}


	void STATIC_NotifyPathChanged();
	float STATIC_GetMaxSpeed();
	void StartNextPath();
	void StartSeeking();
	void STATIC_FindNavHandlePath(class AActor* destActor, float Dist);
	TEnumAsByte<EeSetRouteResult> SetRouteTo(class AActor* destActor);
	void Destroyed();
	void PostBeginPlay();
	void STATIC_UpdateRotation(float fDeltaSeconds);
	bool AdvanceWayPoint();
	struct FVector STATIC_GetCurrentWayPoint();
	TEnumAsByte<EeSetRouteResult> SetRoute(class AActor* destActor);
	void DeactivatePathingFx();
	void DeactivateFx();
	void ActivatePathingFx();
	void ActivateSpinDownFx();
	void ActivateSpinUpFx();
};


// Class TgGame.TgSpawnTeleporterExit
// 0x0014 (0x0294 - 0x0280)
class ATgSpawnTeleporterExit : public AActor
{
public:
	int                                                nTaskForce;                                               // 0x0280(0x0004) (Edit)
	int                                                nLane;                                                    // 0x0284(0x0004) (Edit)
	int                                                nGamePhase;                                               // 0x0288(0x0004) (Edit)
	int                                                nPriority;                                                // 0x028C(0x0004) (Edit)
	unsigned long                                      bEnabled : 1;                                             // 0x0290(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSpawnTeleporterExit");
		return ptr;
	}


	bool STATIC_PawnCanUse(class ATgPawn* TgP);
	void OnToggle(class USeqAct_Toggle* Action);
	struct FVector GetTargetLocation(class AActor* RequestedBy, bool bRequestAlternateLoc);
	bool STATIC_HasRoomForPawn(class ATgPawn* TgP);
};


// Class TgGame.TgSplineActor
// 0x0008 (0x02F0 - 0x02E8)
class ATgSplineActor : public ASplineActor
{
public:
	TEnumAsByte<ELanePusherActionPoint>                m_ActionPoint;                                            // 0x02E8(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x02E9(0x0003) MISSED OFFSET
	unsigned long                                      m_bPreview : 1;                                           // 0x02EC(0x0004) (Edit, Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSplineActor");
		return ptr;
	}


	float DistanceToActionPoint(TEnumAsByte<ELanePusherActionPoint> ActionPoint);
	float DistanceToEndOfSplineChain();
	void STATIC_UpdateSplineComponents();
};


// Class TgGame.TgStartPoint
// 0x0034 (0x03BC - 0x0388)
class ATgStartPoint : public APlayerStart
{
public:
	int                                                m_nMapObjectId;                                           // 0x0388(0x0004) (Edit, EditConst)
	int                                                m_nStartGroup;                                            // 0x038C(0x0004) (Edit)
	int                                                m_nReturnMapType;                                         // 0x0390(0x0004) (Edit)
	float                                              m_fStartRating;                                           // 0x0394(0x0004) (Edit)
	float                                              m_fCurrentRating;                                         // 0x0398(0x0004) (Edit)
	float                                              m_fResetRating;                                           // 0x039C(0x0004) (Edit)
	float                                              m_fDecreaseRate;                                          // 0x03A0(0x0004) (Edit)
	TArray<class UClass*>                              m_ArrayOfFloats;                                          // 0x03A4(0x0010) (Edit, NeedCtorLink)
	class ATgTeleporter*                               m_TgTeleporter;                                           // 0x03B4(0x0008) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgStartPoint");
		return ptr;
	}


	int STATIC_GetStartGroupNumber();
	void AdjustRating();
	float STATIC_GetRating(class AController* Player);
	void PreBeginPlay();
	void STATIC_LoadObjectConfig();
};


// Class TgGame.TgTeamPlayerStart
// 0x0048 (0x0404 - 0x03BC)
class ATgTeamPlayerStart : public ATgStartPoint
{
public:
	unsigned char                                      m_nTaskForce;                                             // 0x03BC(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x03BD(0x0003) MISSED OFFSET
	int                                                m_nPriority;                                              // 0x03C0(0x0004) (Edit)
	int                                                nPrevPriority;                                            // 0x03C4(0x0004) (Edit)
	float                                              m_fMaxDistForEnemyCheckUU;                                // 0x03C8(0x0004) (Edit)
	float                                              m_fMaxDistForHazardCheckUU;                               // 0x03CC(0x0004) (Edit)
	float                                              m_fMaxWeightForEnemyDistanceCheck;                        // 0x03D0(0x0004) (Edit)
	float                                              m_fMaxDistForAllyCheckUU;                                 // 0x03D4(0x0004) (Edit)
	float                                              m_fMinDistForAllyCheckUU;                                 // 0x03D8(0x0004) (Edit)
	float                                              m_fMaxWeightForAllyDistanceCheck;                         // 0x03DC(0x0004) (Edit)
	float                                              m_fRandomRatingWeighting;                                 // 0x03E0(0x0004) (Edit)
	unsigned long                                      m_bInitialSpawnOnly : 1;                                  // 0x03E4(0x0004) (Edit)
	unsigned long                                      m_bDisallowEnemyLOS : 1;                                  // 0x03E4(0x0004) (Edit)
	unsigned long                                      m_bRotateTowardNearestVisibleAlly : 1;                    // 0x03E4(0x0004) (Edit)
	float                                              m_fExtraHeightToTraceTo;                                  // 0x03E8(0x0004)
	int                                                m_nMinLevel;                                              // 0x03EC(0x0004) (EditConst)
	float                                              m_fLastUsedTimeStamp;                                     // 0x03F0(0x0004) (Transient)
	TArray<class ATgRepInfo_Player*>                   s_AssignedPlayers;                                        // 0x03F4(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgTeamPlayerStart");
		return ptr;
	}


	void STATIC_OnSetTaskforce(class UTgSeqAct_SetTaskforce* Action);
	float STATIC_GetRating(class AController* Player);
	int STATIC_GetSupportedTaskforce();
	void Destroyed();
	struct FRotator STATIC_GetSpawnRotationFor(class APawn* TgP);
	float STATIC_NativeGetRating(class AController* Player, float fRating);
	bool AreaUnoccupied();
	bool STATIC_IsAssignedToPlayer();
	void STATIC_LoadObjectConfig();
};


// Class TgGame.TgTeleporter
// 0x000E (0x03B2 - 0x03A4)
class ATgTeleporter : public ATeleporter
{
public:
	int                                                m_nMapObjectId;                                           // 0x03A4(0x0004) (Edit)
	int                                                m_nMapId;                                                 // 0x03A8(0x0004) (Edit)
	unsigned long                                      m_nPreload : 1;                                           // 0x03AC(0x0004) (Edit)
	unsigned long                                      m_bSetTaskForce : 1;                                      // 0x03AC(0x0004) (Edit)
	unsigned long                                      m_bBalanceTaskForce : 1;                                  // 0x03AC(0x0004) (Edit)
	unsigned long                                      m_bIgnoreNonMembers : 1;                                  // 0x03AC(0x0004) (Edit)
	unsigned long                                      m_bUsePlayerStart : 1;                                    // 0x03AC(0x0004) (Edit)
	unsigned long                                      m_bRequestMission : 1;                                    // 0x03AC(0x0004) (Edit)
	unsigned char                                      m_nStartGroup;                                            // 0x03B0(0x0001) (Edit)
	unsigned char                                      m_nTaskForce;                                             // 0x03B1(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgTeleporter");
		return ptr;
	}


	bool UsePlayerStart(class AActor* Other);
	void STATIC_PostTouch(class AActor* Other);
	void PostBeginPlay();
	void PreBeginPlay();
	void STATIC_LoadObjectConfig();
	bool STATIC_HandlePostTouch(class AActor* Other);
};


// Class TgGame.TgAudioPawnDialogue
// 0x00C4 (0x0124 - 0x0060)
class UTgAudioPawnDialogue : public UObject
{
public:
	TArray<struct FChatterEvent>                       m_ChatterEvents;                                          // 0x0060(0x0010) (NeedCtorLink)
	TArray<struct FDialogueEvent>                      m_DialogueEvents;                                         // 0x0070(0x0010) (NeedCtorLink)
	float                                              m_fCategoryCooldownTimestamps[0x12];                      // 0x0080(0x0004)
	float                                              m_fCategoryCooldownBase[0x12];                            // 0x00C8(0x0004)
	class ATgPawn*                                     m_pOwner;                                                 // 0x0110(0x0008)
	float                                              m_fLastEmoteTime;                                         // 0x0118(0x0004)
	unsigned long                                      m_bSpeaking : 1;                                          // 0x011C(0x0004)
	unsigned long                                      m_bInitialized : 1;                                       // 0x011C(0x0004)
	int                                                m_nInvokedWeapon;                                         // 0x0120(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAudioPawnDialogue");
		return ptr;
	}


	void Initialize(class ATgPawn* pOwner);
	void STATIC_OnEmoteEnded();
};


// Class TgGame.TgCombatActor
// 0x0000 (0x0060 - 0x0060)
class UTgCombatActor : public UInterface
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCombatActor");
		return ptr;
	}


	void STATIC_GetAimAssistBounds(struct FVector* ObserverLocation, float* Width, float* Height, struct FVector* Center);
	float STATIC_GetMaxAimAssistStacks();
	class AActor* STATIC_GetActorFromCombatActor();
	class AActor* STATIC_GetPetOwner();
	bool STATIC_IsPet();
	TEnumAsByte<EGameplayDesignType> STATIC_GetDesignType();
	class ATgEffectManager* STATIC_GetEffectManager();
	float STATIC_GetMarkedPercentInhand(class AActor* InstigatorPawn);
	float STATIC_GetMarkedPercent(class AActor* InstigatorPawn);
	int STATIC_GetPropIndex(int nPropId);
	float STATIC_GetPropCurrentValue(int nPropIndex);
	float STATIC_GetPropBaseValue(int nPropIndex);
	struct FVector STATIC_GetLocation();
	bool STATIC_LocalPlayerHasLOS();
	void STATIC_HandleNotificationsForAI(float fStatChange, class ATgPawn* InstigatorPawn);
	float STATIC_GetDamageToLeaveStealth();
	void TakeStealthDamage(float fDamage);
	int TakePersonalArmorDamage(float fDamage, class AController* InstigatedBy, class UClass* DamageType, const struct FImpactInfo& Impact, class AActor* DamageCauser, struct FExtraDamageInfo* ExtraInfo);
	bool ShieldDamageAppliesToHealth();
	int TakePersonalShieldDamage(float fDamage, class AController* InstigatedBy, class UClass* DamageType, const struct FImpactInfo& Impact, class AActor* DamageCauser, struct FExtraDamageInfo* ExtraInfo);
	bool CanUsePersonalShield();
	bool CanTakeShieldDamage();
	void TakeManaDamage(float fDamage, class AController* InstigatedBy, class UClass* DamageType, const struct FImpactInfo& Impact, const struct FExtraDamageInfo& ExtraInfo, class AActor* DamageCauser);
	bool CanTakeManaDamage();
	bool CanBeLifestealTarget();
	bool CanBeLifestealInstigator();
	void TakeHealthDamage(float fDamage, class AController* InstigatedBy, class UClass* DamageType, const struct FImpactInfo& Impact, const struct FExtraDamageInfo& ExtraInfo, class AActor* DamageCauser);
	void STATIC_MitigateHealthDamage(class ATgPawn* pInstigator, class UTgEffectDamage* Effect, const struct FImpactInfo& Impact, bool bIsHeadshot, float* NewValue, float* fPercReduction);
	float STATIC_GetSpecialDamageTakenPercentAI();
	float STATIC_GetSpecialDamageDealtPercentAI();
	void BuffDamage(class AActor* Target, class UTgEffectDamage* Effect, const struct FImpactInfo& Impact, float fBaseDamage, float* fProratedAmount, struct FExtraDamageInfo* ExtraInfo);
	bool STATIC_IsImmuneToHealing();
	bool CanBeExecuted();
	bool STATIC_IsImmuneToDamage();
	bool STATIC_OnlyTakeHeadShots();
	bool CanTakeHeadShots();
	bool CanDealHeadShots();
	bool CanTakeHealthDamage();
	float STATIC_GetDiminishedGroundSpeed();
	void STATIC_GetAdditionalLifestealMultipliers(struct FDiminishedEffectInfo* DiminishingInfo, struct FImpactInfo* Impact);
	void STATIC_GetAdditionalDamageTakenMultipliers(class ATgDevice* damagingDevice, struct FDiminishedEffectInfo* DiminishingInfo, struct FImpactInfo* Impact);
	float STATIC_GetMaxShield();
	float STATIC_GetShieldHealth();
	float STATIC_GetMaxMana();
	float STATIC_GetMana();
	float STATIC_GetHealthPercent();
	float STATIC_GetMaxHealth();
	float STATIC_GetHealth();
};


// Class TgGame.TgDropShadowDecalComponent
// 0x0010 (0x0320 - 0x0310)
class UTgDropShadowDecalComponent : public UStaticMeshComponent
{
public:
	float                                              LastCachedZ;                                              // 0x0310(0x0004) (Transient)
	struct FVector                                     LastOwnerPos;                                             // 0x0314(0x000C) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDropShadowDecalComponent");
		return ptr;
	}


	void UpdatePosition(class ATgPawn* TgPOwner, bool bIsInitial, struct FVector* OwnerOffset);
};


// Class TgGame.TgHeadShotComponent
// 0x001C (0x0278 - 0x025C)
class UTgHeadShotComponent : public UCylinderComponent
{
public:
	class UTgSkeletalMeshComponent*                    m_SkelComp;                                               // 0x025C(0x0008) (ExportObject, Component, EditInline)
	struct FName                                       m_HeadBone;                                               // 0x0264(0x0008)
	struct FVector                                     m_vHeadOffset;                                            // 0x026C(0x000C)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgHeadShotComponent");
		return ptr;
	}

};


// Class TgGame.TgPaladinsController
// 0x0000 (0x0060 - 0x0060)
class UTgPaladinsController : public UInterface
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPaladinsController");
		return ptr;
	}


	int STATIC_GetTaskForceNumber();
	class ATgPawn* STATIC_GetTgPawn();
	void STATIC_Revive();
	void STATIC_LiveRespawn(bool bResetHealth, bool bResetDevices);
	void SetRewardValues(int XP, int Currency, class AActor* Source, TEnumAsByte<ERewardValueType> RewardType, bool bFlankKill);
	void ResetUlt();
	void SetCredits(int nCreditsAmount);
	int STATIC_GetCredits();
};


// Class TgGame.TgPawn
// 0x28CC (0x2E78 - 0x05AC)
class ATgPawn : public AGamePawn
{
public:
	struct FPointer                                    VfTable_ITgSkinnableInterface;                            // 0x05AC(0x0008) (Const, Native, NoExport)
	struct FPointer                                    VfTable_ITgCombatActor;                                   // 0x05B4(0x0008) (Const, Native, NoExport)
	struct FPointer                                    VfTable_ITgObserver_ViewTargetChanged;                    // 0x05BC(0x0008) (Const, Native, NoExport)
	struct FPointer                                    VfTable_ITgInteractiveAudio;                              // 0x05C4(0x0008) (Const, Native, NoExport)
	struct FVector                                     r_vPhysTweenTarget;                                       // 0x05CC(0x000C) (Net)
	TEnumAsByte<ETweenState>                           r_eTweenState;                                            // 0x05D8(0x0001) (Net)
	TEnumAsByte<ETweenState>                           m_eLocalTweenState;                                       // 0x05D9(0x0001)
	unsigned char                                      s_BitPackedHitReaction;                                   // 0x05DA(0x0001)
	TEnumAsByte<EGrabState>                            r_eGrabState;                                             // 0x05DB(0x0001) (Net)
	TEnumAsByte<EGrabState>                            m_eLocalGrabState;                                        // 0x05DC(0x0001)
	TEnumAsByte<EChargeState>                          r_eChargeState;                                           // 0x05DD(0x0001) (Net)
	TEnumAsByte<ETG_DEATH_REASON>                      r_eDeathReason;                                           // 0x05DE(0x0001) (Net)
	TEnumAsByte<ETgMeshVisibilityState>                c_PreviousMeshVisibilityState;                            // 0x05DF(0x0001)
	TEnumAsByte<ETG_REP_DEVICE_STATE>                  r_ReplicatedDeviceState[0x14];                            // 0x05E0(0x0001) (Net)
	TEnumAsByte<ETG_EQUIP_POINT>                       r_eDesiredInHand;                                         // 0x05F4(0x0001) (Net)
	TEnumAsByte<ETG_EQUIP_POINT>                       m_eCachedDesiredInHand;                                   // 0x05F5(0x0001)
	TEnumAsByte<ETG_EQUIP_POINT>                       m_eEquippedInHand;                                        // 0x05F6(0x0001)
	unsigned char                                      r_nPackedFireMultiRanges[0x14];                           // 0x05F7(0x0001) (Net)
	TEnumAsByte<ETG_EQUIP_POINT>                       r_eDesiredAIDevice;                                       // 0x060B(0x0001)
	TEnumAsByte<ESTEALTH_TYPE>                         r_eIsStealthed;                                           // 0x060C(0x0001) (Net)
	TEnumAsByte<ESTEALTH_TYPE>                         c_eIsStealthed;                                           // 0x060D(0x0001)
	unsigned char                                      r_nInCombatNonce;                                         // 0x060E(0x0001) (Net)
	unsigned char                                      c_nInCombatNonceAck;                                      // 0x060F(0x0001)
	TEnumAsByte<EDeployableOverlayIcon>                m_InitHUDOverlayIcon;                                     // 0x0610(0x0001) (Const)
	TEnumAsByte<EDeployableOverlayState>               m_InitHUDOverlayState;                                    // 0x0611(0x0001) (Const)
	TEnumAsByte<ETG_POSTURE>                           m_ePosture;                                               // 0x0612(0x0001)
	TEnumAsByte<EStunType>                             r_eCurrentStunType;                                       // 0x0613(0x0001) (Net)
	unsigned char                                      c_nLocalRespawnBeaconHUDState;                            // 0x0614(0x0001)
	TEnumAsByte<EOverlayMICType>                       m_OverlayCurrentTypeBody;                                 // 0x0615(0x0001)
	TEnumAsByte<EOverlayMICType>                       m_OverlayCurrentTypeWeapon;                               // 0x0616(0x0001)
	TEnumAsByte<ESceneDepthPriorityGroup>              m_eCharacterCustom1OverlayDepthGroup;                     // 0x0617(0x0001) (Const)
	TEnumAsByte<EForcedSilhouetteVisibility>           m_eForcedSilhouetteVisibility;                            // 0x0618(0x0001) (Edit)
	TEnumAsByte<EHitReactionType>                      m_HitReactionType;                                        // 0x0619(0x0001) (Edit)
	TEnumAsByte<EMountState>                           r_eMountState;                                            // 0x061A(0x0001) (Net)
	TEnumAsByte<EUITargetingType>                      c_UITargetingType;                                        // 0x061B(0x0001)
	TEnumAsByte<EMetaGameState>                        m_eMetaGameState;                                         // 0x061C(0x0001)
	TEnumAsByte<EBotBehaviorState>                     m_eBotBehaviorState;                                      // 0x061D(0x0001)
	unsigned char                                      m_nIsInIntroState;                                        // 0x061E(0x0001)
	TEnumAsByte<EPolymorphType>                        c_PrevPolymorph;                                          // 0x061F(0x0001) (Transient)
	TEnumAsByte<EPolymorphType>                        c_LocalPolymorph;                                         // 0x0620(0x0001) (Transient)
	TEnumAsByte<EPolymorphType>                        r_CurrentPolymorph;                                       // 0x0621(0x0001) (Net)
	TEnumAsByte<EThreatLevel>                          c_ThreatLevel;                                            // 0x0622(0x0001)
	TEnumAsByte<EThreatLevel>                          c_LastThreatLevel;                                        // 0x0623(0x0001)
	TEnumAsByte<ELocalViewerRangeState>                m_RangeStateFromLocalViewer;                              // 0x0624(0x0001) (Const)
	TEnumAsByte<EEmote>                                c_eCurrentAudioEmotePlaying;                              // 0x0625(0x0001)
	TEnumAsByte<ETgVaultTypes>                         m_CurrentVaultType;                                       // 0x0626(0x0001)
	TEnumAsByte<ETgWindowVaultStates>                  m_eWindowVaultState;                                      // 0x0627(0x0001)
	TEnumAsByte<ESkydivingState>                       m_eSkydivingState;                                        // 0x0628(0x0001)
	TEnumAsByte<ESkydivingState>                       m_ePrevSkydivingState;                                    // 0x0629(0x0001)
	TEnumAsByte<ESprintState>                          m_eSprintState;                                           // 0x062A(0x0001)
	unsigned char                                      UnknownData00[0x1];                                       // 0x062B(0x0001) MISSED OFFSET
	float                                              m_fPhysTweenDist;                                         // 0x062C(0x0004)
	float                                              r_fPhysTweenDuration;                                     // 0x0630(0x0004) (Net)
	int                                                m_nPhysTweenPostureId;                                    // 0x0634(0x0004)
	unsigned long                                      r_bPhysTweenInterrupted : 1;                              // 0x0638(0x0004) (Net)
	unsigned long                                      s_bIsInGrass : 1;                                         // 0x0638(0x0004)
	unsigned long                                      r_bIsInItemShop : 1;                                      // 0x0638(0x0004) (Net)
	unsigned long                                      r_bHasLeftItemShop : 1;                                   // 0x0638(0x0004) (Net)
	unsigned long                                      r_bGrabInterrupted : 1;                                   // 0x0638(0x0004) (Net)
	unsigned long                                      m_PreGrabCollideActors : 1;                               // 0x0638(0x0004)
	unsigned long                                      m_PreGrabBlockActors : 1;                                 // 0x0638(0x0004)
	unsigned long                                      r_bUsePhysFlyingForCharge : 1;                            // 0x0638(0x0004) (Net)
	unsigned long                                      r_bChargeIgnoreHumanoidBlocking : 1;                      // 0x0638(0x0004) (Net)
	unsigned long                                      m_bWantsCharge : 1;                                       // 0x0638(0x0004)
	unsigned long                                      m_bCanJumpWhileCharging : 1;                              // 0x0638(0x0004)
	unsigned long                                      m_bCanChargeInAir : 1;                                    // 0x0638(0x0004)
	unsigned long                                      m_bEndChargeInFalling : 1;                                // 0x0638(0x0004)
	unsigned long                                      m_bIgnoreFriendlyBlocking : 1;                            // 0x0638(0x0004)
	unsigned long                                      m_bIgnoreEnemyBlocking : 1;                               // 0x0638(0x0004)
	unsigned long                                      m_bHasDestroyedMesh : 1;                                  // 0x0638(0x0004) (Const)
	unsigned long                                      m_bDefaultPropsInitialized : 1;                           // 0x0638(0x0004)
	unsigned long                                      m_bAffectedByVortices : 1;                                // 0x0638(0x0004)
	unsigned long                                      s_LoadMeshServerSide : 1;                                 // 0x0638(0x0004)
	unsigned long                                      c_bDeviceHiddenDueToFullBodyAnim : 1;                     // 0x0638(0x0004)
	unsigned long                                      c_bMeshHiddenDueToDeath : 1;                              // 0x0638(0x0004)
	unsigned long                                      c_bHideMeshFromCameraPenetration : 1;                     // 0x0638(0x0004)
	unsigned long                                      c_bHideMeshFromKismet : 1;                                // 0x0638(0x0004)
	unsigned long                                      r_bInGlobalOffhandCooldown : 1;                           // 0x0638(0x0004) (Net)
	unsigned long                                      bInGlobalOffhandCooldownClient : 1;                       // 0x0638(0x0004)
	unsigned long                                      m_bInFireLock : 1;                                        // 0x0638(0x0004)
	unsigned long                                      c_bHasAutoEquippedNonMeleeWeapon : 1;                     // 0x0638(0x0004)
	unsigned long                                      m_bCachedLocalPlayerHasLOS : 1;                           // 0x0638(0x0004)
	unsigned long                                      c_bIsStealthMaterialOn : 1;                               // 0x0638(0x0004)
	unsigned long                                      r_bIsVolumeStealthed : 1;                                 // 0x0638(0x0004) (Net)
	unsigned long                                      r_bIsVolumeStealthFading : 1;                             // 0x0638(0x0004) (Net)
	unsigned long                                      m_bDisableVolumeStealth : 1;                              // 0x0638(0x0004)
	unsigned long                                      r_bDisableVolumeStealth : 1;                              // 0x063C(0x0004) (Net)
	unsigned long                                      m_bCannotBeVolumeStealthed : 1;                           // 0x063C(0x0004) (Const)
	unsigned long                                      m_bPlayingStealth : 1;                                    // 0x063C(0x0004)
	unsigned long                                      m_bPlayingDetected : 1;                                   // 0x063C(0x0004)
	unsigned long                                      c_bHiddenDueToStealth : 1;                                // 0x063C(0x0004)
	unsigned long                                      c_bHiddenDueToObscuringDeployable : 1;                    // 0x063C(0x0004)
	unsigned long                                      r_bCanStartStealthInCombat : 1;                           // 0x063C(0x0004) (Net)
	unsigned long                                      m_bIsVisionBlocker : 1;                                   // 0x063C(0x0004) (Const)
	unsigned long                                      m_bIsAIVisionBlocker : 1;                                 // 0x063C(0x0004) (Const)
	unsigned long                                      m_bApplyDistanceFade : 1;                                 // 0x063C(0x0004)
	unsigned long                                      r_bIsBot : 1;                                             // 0x063C(0x0004) (Net)
	unsigned long                                      s_bInvisibleToPets : 1;                                   // 0x063C(0x0004)
	unsigned long                                      s_bCanSeePets : 1;                                        // 0x063C(0x0004)
	unsigned long                                      c_bIsFrametestZombie : 1;                                 // 0x063C(0x0004) (Transient)
	unsigned long                                      r_bIsAnimInStrafeMode : 1;                                // 0x063C(0x0004) (Net)
	unsigned long                                      m_ReachedTargetSoKillRootMotion : 1;                      // 0x063C(0x0004)
	unsigned long                                      s_bCanApplyEffects : 1;                                   // 0x063C(0x0004)
	unsigned long                                      m_bInitialized : 1;                                       // 0x063C(0x0004)
	unsigned long                                      m_bUseInterrupted : 1;                                    // 0x063C(0x0004)
	unsigned long                                      c_bIgnoreInterruption : 1;                                // 0x063C(0x0004)
	unsigned long                                      r_bNoEnergyCost : 1;                                      // 0x063C(0x0004) (Net)
	unsigned long                                      m_bCheatUseNoEnergy : 1;                                  // 0x063C(0x0004)
	unsigned long                                      m_bCheatNoRecharge : 1;                                   // 0x063C(0x0004)
	unsigned long                                      m_bIsInvisibleToAI : 1;                                   // 0x063C(0x0004)
	unsigned long                                      r_bInCombatFlag : 1;                                      // 0x063C(0x0004) (Net)
	unsigned long                                      s_bIsStill : 1;                                           // 0x063C(0x0004)
	unsigned long                                      m_bHitWallThisTick : 1;                                   // 0x063C(0x0004)
	unsigned long                                      r_bIsAFK : 1;                                             // 0x063C(0x0004) (Net)
	unsigned long                                      c_bHandIKEnabledFromAnimSet : 1;                          // 0x063C(0x0004)
	unsigned long                                      c_bCanDoTurnInPlaceAnim : 1;                              // 0x063C(0x0004)
	unsigned long                                      c_bIsPlayingTurnInPlaceAnim : 1;                          // 0x063C(0x0004)
	unsigned long                                      m_bShouldApplyCCImmuneOverlay : 1;                        // 0x063C(0x0004)
	unsigned long                                      m_bToggleZoom : 1;                                        // 0x0640(0x0004)
	unsigned long                                      m_bCanBeKnockedBack : 1;                                  // 0x0640(0x0004)
	unsigned long                                      m_bCausesPushblock : 1;                                   // 0x0640(0x0004)
	unsigned long                                      m_bPushblockAffectsFriendlies : 1;                        // 0x0640(0x0004)
	unsigned long                                      m_bPushblockAffectsEnemies : 1;                           // 0x0640(0x0004)
	unsigned long                                      m_bIsCrowdControlImmuneKismet : 1;                        // 0x0640(0x0004)
	unsigned long                                      m_bUseSmoothNetReceiveRotation : 1;                       // 0x0640(0x0004)
	unsigned long                                      m_bForceSmoothCorrection : 1;                             // 0x0640(0x0004)
	unsigned long                                      r_bIsRotationLockedForSpectate : 1;                       // 0x0640(0x0004) (Net)
	unsigned long                                      m_bAlwaysUseAccurateRotation : 1;                         // 0x0640(0x0004) (Const)
	unsigned long                                      r_bHasAccurateRotation : 1;                               // 0x0640(0x0004) (Net)
	unsigned long                                      c_bUpdateSkelMeshWhenNotRendered : 1;                     // 0x0640(0x0004)
	unsigned long                                      c_bUpdateSkelMeshWhenNotRenderedServer : 1;               // 0x0640(0x0004)
	unsigned long                                      r_bSilenced : 1;                                          // 0x0640(0x0004) (Net)
	unsigned long                                      r_bDisarmed : 1;                                          // 0x0640(0x0004) (Net)
	unsigned long                                      r_bCrippled : 1;                                          // 0x0640(0x0004) (Net)
	unsigned long                                      r_bIsInStasis : 1;                                        // 0x0640(0x0004) (Net)
	unsigned long                                      r_bCanBePulled : 1;                                       // 0x0640(0x0004) (Net)
	unsigned long                                      s_bHasCrippleEffect : 1;                                  // 0x0640(0x0004)
	unsigned long                                      c_bEnemyMatLoaded : 1;                                    // 0x0640(0x0004)
	unsigned long                                      r_bIsFlashBang : 1;                                       // 0x0640(0x0004) (Net)
	unsigned long                                      r_bIsJumping : 1;                                         // 0x0640(0x0004) (Net)
	unsigned long                                      r_bIsShortJump : 1;                                       // 0x0640(0x0004) (Net)
	unsigned long                                      m_bIsLanding : 1;                                         // 0x0640(0x0004)
	unsigned long                                      m_bAllowHigherWallJumping : 1;                            // 0x0640(0x0004)
	unsigned long                                      m_bIgnorePhysCheckForJump : 1;                            // 0x0640(0x0004)
	unsigned long                                      m_bHasPlayedDeathAnimation : 1;                           // 0x0640(0x0004)
	unsigned long                                      m_bForceDeathAnim : 1;                                    // 0x0640(0x0004)
	unsigned long                                      r_bHasRespawnBeacon : 1;                                  // 0x0640(0x0004) (Net)
	unsigned long                                      m_bDestroyOnOwnerDeathFlag : 1;                           // 0x0640(0x0004)
	unsigned long                                      r_bNeedPlaySpawnFx : 1;                                   // 0x0640(0x0004) (Net)
	unsigned long                                      c_bSpawnFxPlayed : 1;                                     // 0x0640(0x0004)
	unsigned long                                      c_bTargeted : 1;                                          // 0x0644(0x0004)
	unsigned long                                      c_bTargetedLightup : 1;                                   // 0x0644(0x0004)
	unsigned long                                      c_bApplyDropShadow : 1;                                   // 0x0644(0x0004)
	unsigned long                                      m_bShowNameplate : 1;                                     // 0x0644(0x0004)
	unsigned long                                      r_bInitialIsEnemy : 1;                                    // 0x0644(0x0004) (Net)
	unsigned long                                      c_bNeedsAssetLoad : 1;                                    // 0x0644(0x0004)
	unsigned long                                      c_bNeedsAssetSwap : 1;                                    // 0x0644(0x0004)
	unsigned long                                      c_bNeedsDeviceFormChange : 1;                             // 0x0644(0x0004)
	unsigned long                                      r_bPawnHasLanded : 1;                                     // 0x0644(0x0004) (Net)
	unsigned long                                      r_bDebugShowAIDebug : 1;                                  // 0x0644(0x0004) (Net)
	unsigned long                                      m_SwapToDestroyedMeshOnTick : 1;                          // 0x0644(0x0004)
	unsigned long                                      m_bBlockCamera : 1;                                       // 0x0644(0x0004) (Edit)
	unsigned long                                      m_bOverlaysEnabled : 1;                                   // 0x0644(0x0004)
	unsigned long                                      m_b1POverlaysEnabled : 1;                                 // 0x0644(0x0004)
	unsigned long                                      m_b1POverlaysActive : 1;                                  // 0x0644(0x0004)
	unsigned long                                      m_bSilhouettesVisible : 1;                                // 0x0644(0x0004)
	unsigned long                                      m_bUseSilhouettes : 1;                                    // 0x0644(0x0004) (Edit, Const)
	unsigned long                                      m_bSilhouettesVisibleForObserverSpectator : 1;            // 0x0644(0x0004)
	unsigned long                                      m_bIgnoreTearOffMomentum : 1;                             // 0x0644(0x0004) (Edit)
	unsigned long                                      m_bAcceptsHitReactions : 1;                               // 0x0644(0x0004) (Edit)
	unsigned long                                      m_bIsFadingOut : 1;                                       // 0x0644(0x0004)
	unsigned long                                      m_bUseDamageTypeForDeathAnim : 1;                         // 0x0644(0x0004)
	unsigned long                                      r_bDemoCanPurchaseItems : 1;                              // 0x0644(0x0004) (Net)
	unsigned long                                      s_bHasInteractedWithStore : 1;                            // 0x0644(0x0004)
	unsigned long                                      s_bAlwaysRelevantExceptRoyale : 1;                        // 0x0644(0x0004)
	unsigned long                                      m_bDoSmoothCorrectionThisTick : 1;                        // 0x0644(0x0004)
	unsigned long                                      m_bOnlyTakeHeadshotDamage : 1;                            // 0x0644(0x0004)
	unsigned long                                      r_bIsMounted : 1;                                         // 0x0644(0x0004) (Net)
	unsigned long                                      m_bIsEnteringMount : 1;                                   // 0x0644(0x0004)
	unsigned long                                      m_bCreateMountMeshDeferred : 1;                           // 0x0644(0x0004)
	unsigned long                                      m_bCanAlignMount : 1;                                     // 0x0644(0x0004)
	unsigned long                                      m_bInADS : 1;                                             // 0x0644(0x0004)
	unsigned long                                      m_bUpdateInhandDeferred : 1;                              // 0x0648(0x0004)
	unsigned long                                      m_bUpdateEyeHeight : 1;                                   // 0x0648(0x0004) (Const)
	unsigned long                                      m_bJustLanded : 1;                                        // 0x0648(0x0004)
	unsigned long                                      m_bLandRecovery : 1;                                      // 0x0648(0x0004)
	unsigned long                                      r_bIsSprinting : 1;                                       // 0x0648(0x0004) (Net)
	unsigned long                                      r_bJustJumped : 1;                                        // 0x0648(0x0004) (Net)
	unsigned long                                      m_bStunEnergyRegen : 1;                                   // 0x0648(0x0004)
	unsigned long                                      c_bHealAkEventPlaying : 1;                                // 0x0648(0x0004)
	unsigned long                                      m_bPainAkEventPlaying : 1;                                // 0x0648(0x0004)
	unsigned long                                      r_bIsDazed : 1;                                           // 0x0648(0x0004) (Net)
	unsigned long                                      r_bIsMarked : 1;                                          // 0x0648(0x0004) (Net)
	unsigned long                                      r_bIsBleeding : 1;                                        // 0x0648(0x0004) (Net)
	unsigned long                                      r_bIsOnFire : 1;                                          // 0x0648(0x0004) (Net)
	unsigned long                                      r_bIsRooted : 1;                                          // 0x0648(0x0004) (Net)
	unsigned long                                      r_bIsKnockedBack : 1;                                     // 0x0648(0x0004) (Net)
	unsigned long                                      r_bIsPoisoned : 1;                                        // 0x0648(0x0004) (Net)
	unsigned long                                      r_bIsSlowed : 1;                                          // 0x0648(0x0004) (Net)
	unsigned long                                      r_bIsFrozen : 1;                                          // 0x0648(0x0004) (Net)
	unsigned long                                      r_bIsCCImmune : 1;                                        // 0x0648(0x0004) (Net)
	unsigned long                                      r_bIsRevealed : 1;                                        // 0x0648(0x0004) (Net)
	unsigned long                                      r_bIsWallHacking : 1;                                     // 0x0648(0x0004) (Net)
	unsigned long                                      r_bIsInSelfKnockBack : 1;                                 // 0x0648(0x0004) (Net)
	unsigned long                                      m_bUseOutlines : 1;                                       // 0x0648(0x0004) (Edit)
	unsigned long                                      m_bIsLeaping : 1;                                         // 0x0648(0x0004)
	unsigned long                                      m_bCanSpawnHealthNuggetsOnDeath : 1;                      // 0x0648(0x0004)
	unsigned long                                      m_bCanAutoMountOnRespawn : 1;                             // 0x0648(0x0004)
	unsigned long                                      c_bShowingDisarm : 1;                                     // 0x0648(0x0004)
	unsigned long                                      r_bFirstSpawnWave : 1;                                    // 0x0648(0x0004) (Net)
	unsigned long                                      m_bWaitForIntroAnimToEnd : 1;                             // 0x0648(0x0004)
	unsigned long                                      m_bIntroAnimFinished : 1;                                 // 0x0648(0x0004)
	unsigned long                                      m_bAllowIntroWhiteOut : 1;                                // 0x0648(0x0004)
	unsigned long                                      m_bIntroWhiteOutActive : 1;                               // 0x0648(0x0004)
	unsigned long                                      m_bAirAccuracyPenalty : 1;                                // 0x064C(0x0004)
	unsigned long                                      c_bThreatInLineOfSightRecently : 1;                       // 0x064C(0x0004)
	unsigned long                                      m_bCanBeHeadShot : 1;                                     // 0x064C(0x0004)
	unsigned long                                      c_bHide3PWeaponMeshWhileMounted : 1;                      // 0x064C(0x0004) (Edit)
	unsigned long                                      m_bShouldBeFirstPersonLastFrame : 1;                      // 0x064C(0x0004) (Transient)
	unsigned long                                      m_bFadeOutOnLifeAfterDeathTimerExpired : 1;               // 0x064C(0x0004)
	unsigned long                                      m_bUsesRecoil : 1;                                        // 0x064C(0x0004)
	unsigned long                                      m_bUsingSecondaryPhysicsAsset : 1;                        // 0x064C(0x0004)
	unsigned long                                      m_bWasKilledByEnvironment : 1;                            // 0x064C(0x0004) (Transient)
	unsigned long                                      m_bShouldSmoothEyeHeight : 1;                             // 0x064C(0x0004)
	unsigned long                                      m_bHasAstroBuff : 1;                                      // 0x064C(0x0004)
	unsigned long                                      r_bIsLifted : 1;                                          // 0x064C(0x0004) (Net)
	unsigned long                                      m_bCameraOverrideLocation : 1;                            // 0x064C(0x0004)
	unsigned long                                      m_bShouldMantle : 1;                                      // 0x064C(0x0004)
	unsigned long                                      m_bWindowVaultDeviceLockout : 1;                          // 0x064C(0x0004)
	unsigned long                                      r_bIsADS : 1;                                             // 0x064C(0x0004) (Net)
	unsigned long                                      m_bScopedIn : 1;                                          // 0x064C(0x0004)
	unsigned long                                      c_bSaveModMoveSpeed : 1;                                  // 0x064C(0x0004)
	unsigned long                                      m_bBehindView : 1;                                        // 0x064C(0x0004)
	unsigned long                                      r_bClientUsingForced3pOption : 1;                         // 0x064C(0x0004) (Net)
	unsigned long                                      m_bWantsSkydivingTrail : 1;                               // 0x064C(0x0004)
	unsigned long                                      m_bSkydivingTrailEnabled : 1;                             // 0x064C(0x0004)
	unsigned long                                      m_bFogDamageDisabled : 1;                                 // 0x064C(0x0004)
	unsigned long                                      r_bArmorVisible : 1;                                      // 0x064C(0x0004) (Net)
	unsigned long                                      m_bUIInputLock : 1;                                       // 0x064C(0x0004)
	unsigned long                                      m_bQuietFootstepStateEnabled : 1;                         // 0x064C(0x0004)
	unsigned long                                      m_bJustLaunchedFromCatapult : 1;                          // 0x064C(0x0004)
	unsigned long                                      c_bIsPlayingCatapultPawnFX : 1;                           // 0x064C(0x0004)
	unsigned long                                      m_bLockSkelControlRotation : 1;                           // 0x064C(0x0004)
	int                                                r_nPhysTweenFlags;                                        // 0x0650(0x0004) (Net)
	struct FString                                     m_sGameplayPackage;                                       // 0x0654(0x0010) (Edit, NeedCtorLink)
	TScriptInterface<class UTgInteractiveAudio>        m_AsInteractiveAudio;                                     // 0x0664(0x0010)
	class UTgAudioPawnDialogue*                        m_PawnDialogue;                                           // 0x0674(0x0008)
	float                                              c_fLastAttackAudioCueTimestamp;                           // 0x067C(0x0004)
	float                                              c_fLastAttackFromBehindAudioCueTimestamp;                 // 0x0680(0x0004)
	float                                              c_fLastAttackFromAboveAudioCueTimestamp;                  // 0x0684(0x0004)
	float                                              c_fLastAttackFromSniperAudioCueTimestamp;                 // 0x0688(0x0004)
	float                                              c_fRequestCooldownEmotePause;                             // 0x068C(0x0004)
	class ATgPawn*                                     r_GrabSource;                                             // 0x0690(0x0008) (Net)
	float                                              r_fGrabDuration;                                          // 0x0698(0x0004) (Net)
	struct FName                                       r_GrabAttachSocket;                                       // 0x069C(0x0008) (Net)
	struct FVector                                     r_vGrabLocationOffset;                                    // 0x06A4(0x000C) (Net)
	struct FRotator                                    r_rGrabRotationOffset;                                    // 0x06B0(0x000C) (Net)
	struct FVector                                     m_vGrabDestRelLocation;                                   // 0x06BC(0x000C)
	struct FRotator                                    m_rGrabDestRelRotation;                                   // 0x06C8(0x000C)
	int                                                m_nPhysGrabPostureId;                                     // 0x06D4(0x0004)
	TArray<class ATgPawn*>                             s_GrabbedTargets;                                         // 0x06D8(0x0010) (NeedCtorLink)
	int                                                r_nCannotBeGrabSource;                                    // 0x06E8(0x0004) (Net)
	TArray<class AActor*>                              m_TeleportNotifyList;                                     // 0x06EC(0x0010) (NeedCtorLink)
	float                                              r_fChargeInitialYaw;                                      // 0x06FC(0x0004) (Net)
	float                                              r_fChargeInitialPitch;                                    // 0x0700(0x0004) (Net)
	struct FVector                                     r_vChargeInitialLocation;                                 // 0x0704(0x000C) (Net)
	float                                              r_fChargeSpeed;                                           // 0x0710(0x0004) (Net)
	float                                              r_fChargeRange;                                           // 0x0714(0x0004) (Net)
	float                                              r_fChargeTurnRate;                                        // 0x0718(0x0004) (Net)
	int                                                m_nCoreMeshAsmId;                                         // 0x071C(0x0004) (Const)
	struct FPointer                                    m_CoreMeshAssembly;                                       // 0x0720(0x0008) (Const, Native)
	int                                                m_nBodyMeshAsmId;                                         // 0x0728(0x0004) (Const)
	struct FPointer                                    m_BodyMeshAssembly;                                       // 0x072C(0x0008) (Const, Native)
	struct FPointer                                    m_DestroyedMeshAssembly;                                  // 0x0734(0x0008) (Const, Native)
	int                                                m_n1PHeadMeshId;                                          // 0x073C(0x0004)
	int                                                r_nPawnId;                                                // 0x0740(0x0004) (Net)
	float                                              c_fLastUpdateTime;                                        // 0x0744(0x0004)
	int                                                m_nArchetype;                                             // 0x0748(0x0004)
	class ATgEffectManager*                            r_EffectManager;                                          // 0x074C(0x0008) (Net)
	TArray<struct FTgPropertyInstance>                 m_Properties;                                             // 0x0754(0x0010) (NeedCtorLink)
	float                                              r_CurrentPropValues[0x9E];                                // 0x0764(0x0004) (Net)
	float                                              m_LocalPropValues[0x9E];                                  // 0x09DC(0x0004)
	float                                              s_PropValuesRepResolution[0x9E];                          // 0x0C54(0x0004)
	float                                              s_DefaultPropValues[0x9E];                                // 0x0ECC(0x0004) (Net)
	float                                              r_fCachedMaxHealth;                                       // 0x1144(0x0004) (Net)
	TArray<struct FDebugPropertyMod>                   s_DebugPropertyMods;                                      // 0x1148(0x0010) (NeedCtorLink)
	class ATgAkActorUnoccluded*                        m_AkActorUnoccluded;                                      // 0x1158(0x0008)
	struct FEEmoteCategoryChance                       m_EmoteChances;                                           // 0x1160(0x002C) (Config)
	struct FEEmoteAbilityChance                        m_EmoteChancesAbility;                                    // 0x118C(0x0014) (Config)
	int                                                c_nEmoteCameraStackId;                                    // 0x11A0(0x0004)
	float                                              m_fLastEmoteTime;                                         // 0x11A4(0x0004) (Transient)
	float                                              m_fEmoteGlobalCooldown;                                   // 0x11A8(0x0004)
	TArray<float>                                      m_fLastEmoteCatTimes;                                     // 0x11AC(0x0010) (NeedCtorLink)
	TArray<float>                                      m_fLastPlayerVGSEmoteTimes;                               // 0x11BC(0x0010) (NeedCtorLink)
	float                                              m_fEmoteNonLocalCooldown;                                 // 0x11CC(0x0004)
	float                                              m_fLastNonLocalEmoteTime;                                 // 0x11D0(0x0004)
	TArray<struct FECustomEmoteData>                   c_CustomEmoteData;                                        // 0x11D4(0x0010) (NeedCtorLink)
	int                                                c_nLastCustomEmoteIndex;                                  // 0x11E4(0x0004)
	float                                              m_fSprayAccurateTraceLength;                              // 0x11E8(0x0004)
	float                                              m_fSprayDecalWidth;                                       // 0x11EC(0x0004)
	float                                              m_fSprayDecalHeight;                                      // 0x11F0(0x0004)
	float                                              m_fSprayDecalDepth;                                       // 0x11F4(0x0004)
	class UDecalComponent*                             c_SprayDecal;                                             // 0x11F8(0x0008) (ExportObject, Component, EditInline)
	TArray<struct FECustomSprayData>                   c_CustomSprayData;                                        // 0x1200(0x0010) (NeedCtorLink)
	int                                                c_nLastCustomSprayIndex;                                  // 0x1210(0x0004)
	float                                              m_fSoftLandVelocityCutoff;                                // 0x1214(0x0004)
	float                                              m_fHardLandVelocityCutoff;                                // 0x1218(0x0004)
	float                                              s_nSpawnTime;                                             // 0x121C(0x0004)
	int                                                r_nPhysicalType;                                          // 0x1220(0x0004) (Net)
	float                                              r_fReconnectTime;                                         // 0x1224(0x0004) (Net)
	TArray<class ATgCollisionProxy_Vortex*>            m_CurrentVortexList;                                      // 0x1228(0x0010) (NeedCtorLink)
	TArray<class ATgDeploy_BlackHole*>                 m_CurrentBlackHoleList;                                   // 0x1238(0x0010) (NeedCtorLink)
	class UClass*                                      m_DeathDamageType;                                        // 0x1248(0x0008)
	struct FVector                                     m_DeathHitLocation;                                       // 0x1250(0x000C)
	int                                                m_nDeathFXMaterialHandle;                                 // 0x125C(0x0004)
	struct FEquipDeviceInfo                            r_EquipDeviceInfo[0x14];                                  // 0x1260(0x0014) (Net)
	class ATgDevice*                                   m_EquippedDevices[0x14];                                  // 0x13F0(0x0008)
	int                                                m_CarriedAmmo[0x14];                                      // 0x1490(0x0004)
	class UTgDeviceForm*                               c_EquipForm[0x14];                                        // 0x14E0(0x0008)
	struct FName                                       c_EquipFormState[0x14];                                   // 0x1580(0x0008)
	struct FName                                       c_nmInHandSocket;                                         // 0x1620(0x0008)
	struct FVector2D                                   r_v2dInHandEquipInfo;                                     // 0x1628(0x0008) (Net)
	class ATgDevice*                                   c_CurrentTargetingDevice;                                 // 0x1630(0x0008)
	class ATgDevice*                                   c_CurrentStartActionDevice;                               // 0x1638(0x0008)
	float                                              c_fShouldStartActionTimeStamp;                            // 0x1640(0x0004)
	class ATgDevice*                                   m_CurrentInHandDevice;                                    // 0x1644(0x0008)
	int                                                c_nLockInHandToTargetingDevice;                           // 0x164C(0x0004)
	class UTgSpecialFx*                                c_WorldBracketFX;                                         // 0x1650(0x0008)
	int                                                c_nLastProcessedFlashEventIdx;                            // 0x1658(0x0004)
	int                                                r_nFirstValidFlashEventIdx;                               // 0x165C(0x0004) (Net)
	int                                                r_nFlashQueIndex;                                         // 0x1660(0x0004) (Net)
	int                                                r_nFlashEvent[0x20];                                      // 0x1664(0x0004) (Net)
	struct FVector                                     r_vFlashLocation[0x20];                                   // 0x16E4(0x000C) (Net)
	struct FVector                                     r_vFlashRayDir[0x20];                                     // 0x1864(0x000C) (Net)
	float                                              r_vFlashRefireTime[0x20];                                 // 0x19E4(0x0004) (Net)
	class AActor*                                      r_pFlashTarget[0x20];                                     // 0x1A64(0x0008) (Net)
	class UClass*                                      r_pFlashDamageType[0x20];                                 // 0x1B64(0x0008) (Net)
	int                                                r_nFlashFireInfo[0x20];                                   // 0x1C64(0x0004) (Net)
	float                                              r_fFireMultiMaxRange;                                     // 0x1CE4(0x0004) (Net)
	int                                                r_nFireMultiSeed;                                         // 0x1CE8(0x0004) (Net)
	float                                              r_fFireMultiSpreadAngle;                                  // 0x1CEC(0x0004) (Net)
	float                                              s_fTauntAmount;                                           // 0x1CF0(0x0004)
	float                                              m_fLastPainSound;                                         // 0x1CF4(0x0004)
	class ULightEnvironmentComponent*                  LightEnvironment;                                         // 0x1CF8(0x0008) (Edit, Const, ExportObject, Component, EditInline)
	struct FVector                                     FireLocationOffsets[0x14];                                // 0x1D00(0x000C)
	float                                              BotTurnAcceleration;                                      // 0x1DF0(0x0004)
	float                                              BotTurnSpeed;                                             // 0x1DF4(0x0004)
	float                                              m_fMaxAimAssistStacks;                                    // 0x1DF8(0x0004)
	float                                              m_fLOSReevaluationPeriod;                                 // 0x1DFC(0x0004)
	float                                              m_fLOSEvalTimer;                                          // 0x1E00(0x0004)
	float                                              r_fStealthFadeRate;                                       // 0x1E04(0x0004) (Net)
	class AActor*                                      r_CurrentVisibilityVolumes[0x2];                          // 0x1E08(0x0008) (Net)
	class ATgDeployable*                               r_ObscuringDeployables[0xA];                              // 0x1E18(0x0008) (Net)
	class ATgDeployable*                               r_BlindingDeployables[0xA];                               // 0x1E68(0x0008) (Net)
	class AActor*                                      r_VisibleThroughWallsInstigators[0xC];                    // 0x1EB8(0x0008) (Net)
	class AActor*                                      r_VisibleThroughStealthInstigators[0xC];                  // 0x1F18(0x0008) (Net)
	float                                              m_fVolumeStealthDisableTime;                              // 0x1F78(0x0004) (Const)
	float                                              c_fVolumeFadeValue;                                       // 0x1F7C(0x0004) (Transient)
	float                                              c_fDistanceFadeValue;                                     // 0x1F80(0x0004) (Transient)
	float                                              c_fStealthFadeValue;                                      // 0x1F84(0x0004) (Transient)
	float                                              c_fObscuringDeployableFadeValue;                          // 0x1F88(0x0004) (Transient)
	float                                              c_fBlindingDeployableFadeValue;                           // 0x1F8C(0x0004) (Transient)
	float                                              c_fCurrentFadeValue;                                      // 0x1F90(0x0004) (Transient)
	float                                              c_fDistanceLastCollidingVisionRange;                      // 0x1F94(0x0004) (Transient)
	float                                              c_fLocalStealthFadeRate;                                  // 0x1F98(0x0004)
	class UTgSpecialFx*                                c_TeleporterEnterFX;                                      // 0x1F9C(0x0008)
	class UTgSpecialFx*                                c_TeleporterExitFX;                                       // 0x1FA4(0x0008)
	class UTgSpecialFx*                                c_BlinkEnterFX;                                           // 0x1FAC(0x0008)
	class UTgSpecialFx*                                c_BlinkExitFX;                                            // 0x1FB4(0x0008)
	class UTgSpecialFx*                                c_DetectedFx;                                             // 0x1FBC(0x0008)
	class UTgSpecialFx*                                c_PetSuccessfulHitFx;                                     // 0x1FC4(0x0008)
	float                                              c_fFxScaleSize;                                           // 0x1FCC(0x0004) (Const)
	float                                              m_fLifeAfterDeathSecs;                                    // 0x1FD0(0x0004)
	class AActor*                                      r_aDebugTarget;                                           // 0x1FD4(0x0008) (Net)
	class AActor*                                      r_aDebugDestination;                                      // 0x1FDC(0x0008) (Net)
	class AActor*                                      r_aDebugNextNav;                                          // 0x1FE4(0x0008) (Net)
	struct FVector                                     r_vDebugNextNavMeshPoint;                                 // 0x1FEC(0x000C) (Net)
	struct FVector                                     r_vDebugSpreadoutLocation;                                // 0x1FF8(0x000C) (Net)
	int                                                r_nDebugHearingRange;                                     // 0x2004(0x0004) (Net)
	int                                                r_nDebugSightRange;                                       // 0x2008(0x0004) (Net)
	int                                                r_nDebugFOV;                                              // 0x200C(0x0004) (Net)
	struct FString                                     r_sDebugAction;                                           // 0x2010(0x0010) (Net, NeedCtorLink)
	struct FString                                     r_sDebugName;                                             // 0x2020(0x0010) (Net, NeedCtorLink)
	struct FString                                     r_sDebugFactory;                                          // 0x2030(0x0010) (Net, NeedCtorLink)
	struct FVector                                     s_vOneWayMovement;                                        // 0x2040(0x000C)
	struct FVector                                     r_vDown;                                                  // 0x204C(0x000C) (Net)
	float                                              m_fMountFrictionMultiplier;                               // 0x2058(0x0004)
	float                                              m_fBackpedalPct;                                          // 0x205C(0x0004)
	float                                              m_fMountBackpedalPct;                                     // 0x2060(0x0004)
	class AActor*                                      r_TargetActor;                                            // 0x2064(0x0008) (Net)
	class AActor*                                      r_LockedTarget;                                           // 0x206C(0x0008) (Net)
	int                                                c_TargetMethod;                                           // 0x2074(0x0004)
	class ATgPawn*                                     s_Pets[0x8];                                              // 0x2078(0x0008)
	class ATgPawn*                                     m_PetOwner;                                               // 0x20B8(0x0008)
	int                                                c_ActivePets;                                             // 0x20C0(0x0004)
	class AActor*                                      s_LastAttacker;                                           // 0x20C4(0x0008)
	class AActor*                                      s_LastAttacked;                                           // 0x20CC(0x0008)
	class AActor*                                      s_LastChickened;                                          // 0x20D4(0x0008)
	class AActor*                                      m_CurrentMeleeTarget;                                     // 0x20DC(0x0008)
	class ATgPawn*                                     r_Owner;                                                  // 0x20E4(0x0008) (Net)
	int                                                s_nSpawnerDeviceInstId;                                   // 0x20EC(0x0004)
	int                                                s_nSpawnerDeviceModeId;                                   // 0x20F0(0x0004)
	struct FDeathInfo                                  r_DeathInfo;                                              // 0x20F4(0x0024) (Net)
	int                                                r_nResetCharacter;                                        // 0x2118(0x0004) (Net)
	int                                                r_nLiveRespawn;                                           // 0x211C(0x0004) (Net)
	struct FName                                       DyingStateName;                                           // 0x2120(0x0008)
	int                                                m_nSpawnLocationId;                                       // 0x2128(0x0004)
	int                                                m_nSpawnTableId;                                          // 0x212C(0x0004)
	int                                                m_nSpawnTableDetailId;                                    // 0x2130(0x0004)
	class APlayerStart*                                m_LastPlayerStart;                                        // 0x2134(0x0008)
	float                                              m_fStandingHeight;                                        // 0x213C(0x0004)
	float                                              m_fStandingRadius;                                        // 0x2140(0x0004)
	float                                              m_fTargetCylinderHeight;                                  // 0x2144(0x0004)
	float                                              m_fTargetCylinderRadius;                                  // 0x2148(0x0004)
	int                                                r_nPacingType;                                            // 0x214C(0x0004) (Net)
	int                                                m_nKillShards;                                            // 0x2150(0x0004)
	class AActor*                                      m_CurrentUseActor;                                        // 0x2154(0x0008)
	float                                              m_fBaseTranslationOffset;                                 // 0x215C(0x0004)
	float                                              m_fCrouchTranslationOffset;                               // 0x2160(0x0004)
	float                                              r_fInCombatTime;                                          // 0x2164(0x0004) (Net)
	float                                              m_fInCombatTime;                                          // 0x2168(0x0004)
	float                                              m_fBaseCombatTime;                                        // 0x216C(0x0004)
	float                                              m_fPhaseChangeTime;                                       // 0x2170(0x0004)
	float                                              m_fPhaseChangedTimeStamp;                                 // 0x2174(0x0004)
	float                                              m_PhaseChangeRemainingTime;                               // 0x2178(0x0004)
	int                                                r_nPhase;                                                 // 0x217C(0x0004) (Net)
	int                                                c_PreviousPhase;                                          // 0x2180(0x0004)
	int                                                m_nInitHUDOverlayDisplayMask;                             // 0x2184(0x0004) (Const)
	float                                              m_InitHUDOverlayEnemyViewDist;                            // 0x2188(0x0004) (Const)
	TArray<class UTgAnimNodeSimpleTransitioner*>       m_SimpleTransitionerNodes;                                // 0x218C(0x0010) (NeedCtorLink)
	TArray<class UTgAnimBlendByFire*>                  m_FireBlendNodes;                                         // 0x219C(0x0010) (NeedCtorLink)
	TArray<class UTgAnimNodeBlendByCombatWariness*>    m_CombatWarinessBlendNodes;                               // 0x21AC(0x0010) (NeedCtorLink)
	TArray<class UTgAnimBlendByPosture*>               m_PostureBlendNodes;                                      // 0x21BC(0x0010) (NeedCtorLink)
	TArray<class UTgAnimNodeEmoteSwitch*>              m_AnimNodeEmoteSwitches;                                  // 0x21CC(0x0010) (NeedCtorLink)
	TArray<class UTgAnimBlendByEmote*>                 m_EmoteBlendNodes;                                        // 0x21DC(0x0010) (NeedCtorLink)
	TArray<class UTgAnimNodeEmoteSequence*>            m_EmoteSequenceNodes;                                     // 0x21EC(0x0010) (NeedCtorLink)
	TArray<class UTgAnimNodeBlendByEmoteType*>         m_EmoteTypeNodes;                                         // 0x21FC(0x0010) (NeedCtorLink)
	TArray<class UTgAnimBlendByRealmCharacter*>        m_AnimBlendByRealmCharacter;                              // 0x220C(0x0010) (NeedCtorLink)
	TArray<class UTgAnimNodeBlendByIntroduction*>      m_AnimNodeBlendByIntroductions;                           // 0x221C(0x0010) (NeedCtorLink)
	TArray<class UTgAnimBlendByFireMode*>              m_DeviceModeBlendNodes;                                   // 0x222C(0x0010) (NeedCtorLink)
	TArray<class USkelControlBase*>                    m_SkelControlLocks;                                       // 0x223C(0x0010) (NeedCtorLink)
	TArray<class UTgAnimNodeHitReactionOffset*>        m_HitReactionAnimNode;                                    // 0x224C(0x0010) (NeedCtorLink)
	TArray<class UTgAnimNodeAimOffset*>                m_AimOffsetAnimNodes;                                     // 0x225C(0x0010) (NeedCtorLink)
	TArray<struct FName>                               m_SkelControlLockNames;                                   // 0x226C(0x0010) (NeedCtorLink)
	class UTgAnimNodeSlot*                             m_UpperBodyAnimNode;                                      // 0x227C(0x0008)
	class UAnimNodeSequence*                           m_UpperBodyAnimNodeSequence;                              // 0x2284(0x0008)
	class UTgAnimNodeSlot*                             m_FullBodyAnimNode;                                       // 0x228C(0x0008)
	int                                                m_nYawOffset;                                             // 0x2294(0x0004) (Const, Transient)
	struct FPostureStack                               m_PostureStack;                                           // 0x2298(0x0024) (NeedCtorLink)
	float                                              m_fKnockbackMultiplier;                                   // 0x22BC(0x0004)
	float                                              m_fRBPushStrengthMultiplier;                              // 0x22C0(0x0004) (Edit)
	struct FVector2D                                   m_fRBPushStrengthRange;                                   // 0x22C4(0x0008) (Edit)
	struct FRotator                                    m_PreviousNetReceiveRotation;                             // 0x22CC(0x000C)
	struct FRotator                                    m_TargetNetReceiveRotation;                               // 0x22D8(0x000C)
	float                                              m_RotationInterpRate;                                     // 0x22E4(0x0004)
	int                                                m_nNetRotationCount;                                      // 0x22E8(0x0004)
	int                                                m_nSmoothedRemoteViewPitch;                               // 0x22EC(0x0004)
	int                                                m_nPreviousReceivedRemoteViewPitch;                       // 0x22F0(0x0004)
	int                                                m_nTargetRemoteViewPitch;                                 // 0x22F4(0x0004)
	float                                              m_PitchInterpRate;                                        // 0x22F8(0x0004)
	int                                                m_nNetViewPitchCount;                                     // 0x22FC(0x0004)
	float                                              m_fSmoothCorrectionRate;                                  // 0x2300(0x0004) (Edit)
	int                                                r_nViewYawWhenRotationLocked;                             // 0x2304(0x0004) (Net)
	int                                                m_UnpackedRemoteViewPitch;                                // 0x2308(0x0004)
	int                                                r_nPackedPitchYawForSpectate;                             // 0x230C(0x0004) (Net)
	struct FPointer                                    m_pStatsTracker;                                          // 0x2310(0x0008) (Native)
	class ATgPawn*                                     m_LastDamager;                                            // 0x2318(0x0008)
	float                                              m_LastDamagerTimeStamp;                                   // 0x2320(0x0004)
	TArray<struct FPawnDamagerStruct>                  s_Damagers;                                               // 0x2324(0x0010) (NeedCtorLink)
	class ATgPawn*                                     m_LastKnockbacker;                                        // 0x2334(0x0008)
	float                                              m_fJumpLandingTime;                                       // 0x233C(0x0004)
	float                                              m_fCeilingTraceDistForWallJumping;                        // 0x2340(0x0004) (Config)
	float                                              m_fHorseJumpHeightIncrease;                               // 0x2344(0x0004) (Const)
	class AActor*                                      r_StunTauntTarget;                                        // 0x2348(0x0008) (Net)
	TArray<class ATgRespawnBeaconExit*>                m_LocalTouchingRespawnBeacons;                            // 0x2350(0x0010) (NeedCtorLink)
	class ATgPlayerController*                         c_LocalPC;                                                // 0x2360(0x0008)
	class UTgDropShadowDecalComponent*                 c_PlayerDropShadow;                                       // 0x2368(0x0008) (ExportObject, Component, EditInline)
	class UMaterial*                                   c_PlayerDropShadowTemplate;                               // 0x2370(0x0008)
	class UMaterialInstanceConstant*                   c_PlayerDropShadowMIC;                                    // 0x2378(0x0008)
	float                                              c_fPlayerDropShadowFade;                                  // 0x2380(0x0004) (Transient)
	struct FName                                       c_PlayerDropShadowSocketName;                             // 0x2384(0x0008)
	class UClass*                                      DefaultControlModuleClass;                                // 0x238C(0x0008) (Const)
	float                                              m_fFaceRotationInterpTime;                                // 0x2394(0x0004)
	float                                              m_fRemainingFaceRotationInterpTime;                       // 0x2398(0x0004)
	int                                                r_nBigTeleportCount;                                      // 0x239C(0x0004) (Net)
	int                                                c_nTickCheckingState;                                     // 0x23A0(0x0004)
	class UTgManifestGroup*                            c_AssetManifestGroup;                                     // 0x23A4(0x0008) (ExportObject, NeedCtorLink, EditInline)
	class UTgSpecialFx*                                c_LevelUpFX;                                              // 0x23AC(0x0008)
	int                                                c_nLevelUpFxId;                                           // 0x23B4(0x0004)
	int                                                s_nKillCombo;                                             // 0x23B8(0x0004)
	int                                                s_nKillStreak;                                            // 0x23BC(0x0004)
	int                                                s_nLastDamageDeviceId;                                    // 0x23C0(0x0004)
	int                                                r_nProfileId;                                             // 0x23C4(0x0004) (Net)
	int                                                r_nSettingsOverrideId;                                    // 0x23C8(0x0004) (Net)
	int                                                r_nSkinId;                                                // 0x23CC(0x0004) (Net)
	int                                                r_nHeadSkinId;                                            // 0x23D0(0x0004) (Net)
	int                                                r_nWeaponSkinId;                                          // 0x23D4(0x0004) (Net)
	int                                                r_nMountSkinId;                                           // 0x23D8(0x0004) (Net)
	int                                                r_nContrailSkinId;                                        // 0x23DC(0x0004) (Net)
	int                                                r_nWardSkinId;                                            // 0x23E0(0x0004) (Net)
	int                                                r_nCustomSprayIds[0x5];                                   // 0x23E4(0x0004) (Net)
	int                                                r_nCustomEmoteIds[0x5];                                   // 0x23F8(0x0004) (Net)
	int                                                s_nInitialPlayerId;                                       // 0x240C(0x0004)
	int                                                r_nDeathStampId;                                          // 0x2410(0x0004) (Net)
	int                                                r_nMapMarkerId;                                           // 0x2414(0x0004) (Net)
	struct FPointer                                    m_pAmBot;                                                 // 0x2418(0x0008) (Const, Native)
	struct FPointer                                    m_pAmSkin;                                                // 0x2420(0x0008) (Const, Native)
	struct FPointer                                    m_pAmHead;                                                // 0x2428(0x0008) (Const, Native)
	struct FPointer                                    m_pAmWeaponSkin;                                          // 0x2430(0x0008) (Const, Native)
	struct FPointer                                    m_pAmMountSkin;                                           // 0x2438(0x0008) (Const, Native)
	struct FPointer                                    m_pAmMarkerSkin;                                          // 0x2440(0x0008) (Const, Native)
	struct FPointer                                    m_pAmContrailSkin;                                        // 0x2448(0x0008) (Const, Native)
	struct FPointer                                    m_pAmVoicePack;                                           // 0x2450(0x0008) (Const, Native)
	TArray<struct FPointer>                            m_pAmCustomSprays;                                        // 0x2458(0x0010) (Const, Native)
	TArray<struct FPointer>                            m_pAmCustomEmotes;                                        // 0x2468(0x0010) (Const, Native)
	TArray<struct FPointer>                            m_pAmAllSkins;                                            // 0x2478(0x0010) (Const, Native)
	int                                                c_StunnedPostureID;                                       // 0x2488(0x0004)
	int                                                c_FearedPostureID;                                        // 0x248C(0x0004)
	int                                                c_DisarmedPostureID;                                      // 0x2490(0x0004)
	TArray<class APlayerController*>                   s_Viewers;                                                // 0x2494(0x0010) (NeedCtorLink)
	float                                              m_fLastCTFVolumeTimestamp;                                // 0x24A4(0x0004) (Transient)
	float                                              m_fDamageTakenRTPC;                                       // 0x24A8(0x0004)
	float                                              m_fArmorDamageTakenPercentRTPC;                           // 0x24AC(0x0004)
	float                                              m_fDamageTakenMax;                                        // 0x24B0(0x0004)
	float                                              m_fDamageTakenMaxSustainDuration;                         // 0x24B4(0x0004)
	float                                              m_fDamageTakenRTPCSustainDuration;                        // 0x24B8(0x0004)
	TArray<struct FOverlayInfo>                        m_OverlayInfosBody;                                       // 0x24BC(0x0010) (Edit, Component, NeedCtorLink)
	TArray<struct FOverlayInfo>                        m_OverlayInfosWeapon;                                     // 0x24CC(0x0010) (Edit, Component, NeedCtorLink)
	class UMaterialInstanceConstant*                   m_ExecuteOverlayMaterialFriend;                           // 0x24DC(0x0008) (Const)
	class UMaterialInstanceConstant*                   m_ExecuteOverlayMaterialEnemy;                            // 0x24E4(0x0008) (Const)
	class UMaterialInstanceConstant*                   m_ShieldOverlayMaterialFriend;                            // 0x24EC(0x0008) (Const)
	class UMaterialInstanceConstant*                   m_ShieldOverlayMaterialEnemy;                             // 0x24F4(0x0008) (Const)
	class UMaterialInstanceConstant*                   m_ImmortalOverlayMaterialFriend;                          // 0x24FC(0x0008) (Const)
	class UMaterialInstanceConstant*                   m_ImmortalOverlayMaterialEnemy;                           // 0x2504(0x0008) (Const)
	class UMaterialInstanceConstant*                   m_CharacterCustom1OverlayMaterial;                        // 0x250C(0x0008) (Const)
	class UMaterialInstanceConstant*                   m_FreezeOverlayMaterial;                                  // 0x2514(0x0008) (Const)
	TArray<struct FSilhouetteInfo>                     m_SilhouetteInfos;                                        // 0x251C(0x0010) (Edit, Transient, Component, NeedCtorLink)
	class UClass*                                      m_SilhouetteClass;                                        // 0x252C(0x0008) (Edit)
	TArray<int>                                        m_IgnoredHitPulseIndicies;                                // 0x2534(0x0010) (NeedCtorLink)
	float                                              m_fHitReactionAIPauseTime;                                // 0x2544(0x0004) (Edit)
	float                                              m_fHitReactionBlendOutTime;                               // 0x2548(0x0004) (Edit)
	float                                              m_fHitReactionTweenTime;                                  // 0x254C(0x0004) (Edit)
	float                                              m_fFadeOutTime;                                           // 0x2550(0x0004) (Edit)
	float                                              m_fFadeOutSpeed;                                          // 0x2554(0x0004) (Edit)
	class UTgSpecialFx*                                m_DeathAnimFX;                                            // 0x2558(0x0008)
	TArray<class UTgSkelCon_HitReaction*>              m_HitReactionSkelControls;                                // 0x2560(0x0010) (NeedCtorLink)
	float                                              m_fRemainingHitReactionPulseTime;                         // 0x2570(0x0004)
	float                                              m_fHitReactionPulseTime;                                  // 0x2574(0x0004) (Edit)
	float                                              m_fDisorientSpinRate;                                     // 0x2578(0x0004) (Edit)
	float                                              s_fMaxRelevancyDistanceSquared;                           // 0x257C(0x0004)
	float                                              m_fMaxSmoothNetUpdateDist;                                // 0x2580(0x0004)
	float                                              m_fNoSmoothNetUpdateDist;                                 // 0x2584(0x0004)
	float                                              m_fSmoothNetUpdateTime;                                   // 0x2588(0x0004)
	struct FVector                                     m_vMeshTranslationOffset;                                 // 0x258C(0x000C)
	float                                              m_fInitialHealthPercent;                                  // 0x2598(0x0004)
	float                                              c_fHUDHealthPercent;                                      // 0x259C(0x0004)
	float                                              m_fDamageDealtPercentAI;                                  // 0x25A0(0x0004)
	float                                              m_fDamageTakenPercentAI;                                  // 0x25A4(0x0004)
	TArray<struct FHealingInfo>                        s_RecentHealList;                                         // 0x25A8(0x0010) (NeedCtorLink)
	float                                              m_fRecentHealExpireTime;                                  // 0x25B8(0x0004) (Const)
	int                                                m_nCloneExpirationAttacksCount;                           // 0x25BC(0x0004)
	float                                              m_fCloneLeashRange;                                       // 0x25C0(0x0004)
	float                                              m_fCloneExpirationTime;                                   // 0x25C4(0x0004)
	class ATgRepInfo_Player*                           r_CloneParentPRI;                                         // 0x25C8(0x0008) (Net)
	int                                                r_nMountYaw;                                              // 0x25D0(0x0004) (Net)
	struct FName                                       m_MountFrontTraceSocketName;                              // 0x25D4(0x0008)
	struct FName                                       m_MountBackTraceSocketName;                               // 0x25DC(0x0008)
	struct FName                                       m_MountRootBoneName;                                      // 0x25E4(0x0008)
	class UTgSkelControlSingleBone*                    m_pMountSkelControl;                                      // 0x25EC(0x0008)
	class UTgSkelControlSingleBone*                    m_pMeshSkelControl;                                       // 0x25F4(0x0008)
	float                                              m_fMountPitchPrevious;                                    // 0x25FC(0x0004)
	float                                              m_fMountPitchTarget;                                      // 0x2600(0x0004)
	float                                              m_fMountPitchCurrent;                                     // 0x2604(0x0004)
	float                                              m_fMountVerticalOffsetPrevious;                           // 0x2608(0x0004)
	float                                              m_fMountVerticalOffsetTarget;                             // 0x260C(0x0004)
	int                                                m_nMountPreviousRot;                                      // 0x2610(0x0004)
	float                                              m_nMountAlignInterp;                                      // 0x2614(0x0004)
	class UTgAnimNodeBlendList*                        m_SprintBlendNode;                                        // 0x2618(0x0008)
	class ATgWeaponMeshActor*                          m_WeaponMesh;                                             // 0x2620(0x0008)
	class UTgSkeletalMeshComponent*                    m_BodyMesh;                                               // 0x2628(0x0008) (ExportObject, Component, EditInline)
	class UTgSkeletalMeshComponent*                    m_HeadMesh;                                               // 0x2630(0x0008) (ExportObject, Component, EditInline)
	int                                                m_HeadSilhouetteIndex;                                    // 0x2638(0x0004)
	int                                                m_HeadOverlayIndex;                                       // 0x263C(0x0004)
	int                                                r_nBodyMeshOverride;                                      // 0x2640(0x0004) (Net)
	int                                                r_nHeadMeshOverride;                                      // 0x2644(0x0004) (Net)
	int                                                c_nCurrentHeadMeshID;                                     // 0x2648(0x0004)
	float                                              m_BobFootstepFactor;                                      // 0x264C(0x0004) (Edit, Const)
	float                                              Bob;                                                      // 0x2650(0x0004)
	float                                              LandBob;                                                  // 0x2654(0x0004)
	float                                              JumpBob;                                                  // 0x2658(0x0004)
	float                                              AppliedBob;                                               // 0x265C(0x0004)
	float                                              BobTime;                                                  // 0x2660(0x0004)
	struct FVector                                     WalkBob;                                                  // 0x2664(0x000C)
	float                                              m_fOldZ;                                                  // 0x2670(0x0004)
	float                                              m_fBobMult1;                                              // 0x2674(0x0004)
	float                                              m_fBobMult2;                                              // 0x2678(0x0004)
	float                                              m_fBobBlendAmount;                                        // 0x267C(0x0004)
	float                                              m_fBobBlendSpeed;                                         // 0x2680(0x0004)
	struct FVector                                     AimSpot;                                                  // 0x2684(0x000C)
	struct FVector                                     AimNoise;                                                 // 0x2690(0x000C)
	float                                              m_fAimSpotsetLastRefresh;                                 // 0x269C(0x0004)
	float                                              m_fAimNoiseLastRefresh;                                   // 0x26A0(0x0004)
	float                                              m_fAimPitch;                                              // 0x26A4(0x0004)
	float                                              m_fJetpackPowerPoolCost;                                  // 0x26A8(0x0004) (Edit)
	float                                              m_fSprintPowerPoolCost;                                   // 0x26AC(0x0004) (Edit)
	float                                              m_fSprintMinPowerPoolPct;                                 // 0x26B0(0x0004) (Edit)
	float                                              m_fSprintPct;                                             // 0x26B4(0x0004) (Edit)
	class UAudioComponent*                             m_TakeHitAudioComponent;                                  // 0x26B8(0x0008) (ExportObject, Component, EditInline)
	class UAudioComponent*                             m_PainAudioComponent;                                     // 0x26C0(0x0008) (ExportObject, Component, EditInline)
	class UAkEvent*                                    m_TakeHitAkEvent;                                         // 0x26C8(0x0008)
	class UAkEvent*                                    m_TakeHeadShotAkEvent;                                    // 0x26D0(0x0008)
	class UAkEvent*                                    c_HealPlayAkEvent;                                        // 0x26D8(0x0008)
	class UAkEvent*                                    c_HealStopAkEvent;                                        // 0x26E0(0x0008)
	class UAkEvent*                                    m_PainAkEvent;                                            // 0x26E8(0x0008)
	float                                              m_fLastPainEvent;                                         // 0x26F0(0x0004)
	float                                              m_fPainEventCooldown;                                     // 0x26F4(0x0004)
	class UTgAnimNodePlayFireAnim*                     m_FireAnimNode;                                           // 0x26F8(0x0008)
	class UTgEffectGroup*                              m_StealthPulseEffectGroup;                                // 0x2700(0x0008)
	float                                              m_fStealthPulseTime;                                      // 0x2708(0x0004)
	float                                              r_fKnockedBackFrictionOverride;                           // 0x270C(0x0004) (Net)
	struct FVector                                     r_vKnockedBackVelocityOverride;                           // 0x2710(0x000C) (Net)
	int                                                r_nIncomingImpactCount;                                   // 0x271C(0x0004) (Net)
	float                                              r_fReloadScale;                                           // 0x2720(0x0004) (Net)
	float                                              r_fEquipTimeScale;                                        // 0x2724(0x0004) (Net)
	class ATgPawn*                                     r_HealTarget;                                             // 0x2728(0x0008) (Net)
	class UTgParticleSystemComponent*                  c_HealingBeamPSC;                                         // 0x2730(0x0008) (Edit, ExportObject, Component, EditInline)
	class UTgSkeletalMeshComponent*                    m_OutlineMesh;                                            // 0x2738(0x0008) (ExportObject, Transient, Component, EditInline)
	class UMaterialInstanceConstant*                   m_OutlineMaterial;                                        // 0x2740(0x0008)
	class ATgNearObjectiveVolume*                      m_NearObjectiveVolume;                                    // 0x2748(0x0008)
	float                                              r_fLeapAirControl;                                        // 0x2750(0x0004) (Net)
	float                                              m_fBaseLeapAirControl;                                    // 0x2754(0x0004)
	float                                              m_fKnockAirControl;                                       // 0x2758(0x0004)
	TArray<class ATgDeviceVolume*>                     m_HomeguardVolumes;                                       // 0x275C(0x0010) (NeedCtorLink)
	float                                              m_LastHomeguardTime;                                      // 0x276C(0x0004)
	class UTgSkeletalMeshComponent*                    m_MountMesh;                                              // 0x2770(0x0008) (ExportObject, Component, EditInline)
	float                                              s_fEndStealthDamage;                                      // 0x2778(0x0004)
	float                                              s_fDamageTakenDuringStealth;                              // 0x277C(0x0004)
	float                                              m_fHUDOverlayZOffset;                                     // 0x2780(0x0004) (Edit)
	float                                              m_fHUDOverlayMorphMountedZOffset;                         // 0x2784(0x0004) (Edit)
	int                                                m_lastDamageSourceSlot;                                   // 0x2788(0x0004)
	float                                              m_fLastMoveTime;                                          // 0x278C(0x0004)
	class ATgDeployable*                               s_AttachedProjBlocker;                                    // 0x2790(0x0008)
	float                                              m_fScaleMesh;                                             // 0x2798(0x0004) (Edit)
	float                                              m_fScaleMeshChangePerSecond;                              // 0x279C(0x0004) (Edit)
	float                                              m_fScaleCollisionHeight;                                  // 0x27A0(0x0004) (Edit)
	float                                              m_fScaleCollisionHeightChangePerSecond;                   // 0x27A4(0x0004) (Edit)
	float                                              m_fScaleCollisionRadius;                                  // 0x27A8(0x0004) (Edit)
	float                                              m_fScaleCollisionRadiusChangePerSecond;                   // 0x27AC(0x0004) (Edit)
	int                                                m_IntroPostureID;                                         // 0x27B0(0x0004)
	float                                              r_fIntroTime;                                             // 0x27B4(0x0004) (Net)
	float                                              r_fIntroOffset;                                           // 0x27B8(0x0004) (Net)
	float                                              s_fIntroStartTime;                                        // 0x27BC(0x0004)
	float                                              m_fIntroProgress;                                         // 0x27C0(0x0004)
	struct FName                                       r_ReplicatedState;                                        // 0x27C4(0x0008) (Net)
	TArray<class UAnimNodeSequence*>                   m_RespawnNodes;                                           // 0x27CC(0x0010) (NeedCtorLink)
	TArray<class UTgAnimBlendByBuffMonsterIntro*>      m_BuffCampIntroNodes;                                     // 0x27DC(0x0010) (NeedCtorLink)
	struct FName                                       m_IntialIntroState;                                       // 0x27EC(0x0008)
	struct FName                                       m_nmIntroWhiteOutParamName;                               // 0x27F4(0x0008)
	float                                              m_fIntroWhiteOutScale;                                    // 0x27FC(0x0004)
	float                                              m_fIntroWhiteOutUpTime;                                   // 0x2800(0x0004)
	float                                              m_fIntroWhiteOutDownTime;                                 // 0x2804(0x0004)
	int                                                r_nInsideTaskForceBase;                                   // 0x2808(0x0004) (Net)
	class UTgSpecialFx*                                m_HealFX3P;                                               // 0x280C(0x0008)
	class UTgSpecialFx*                                m_ShieldFX3P;                                             // 0x2814(0x0008)
	float                                              c_fNextTakeHitDisplayGroupTimestamp;                      // 0x281C(0x0004)
	float                                              c_fNextTakeHitDisplayDelay;                               // 0x2820(0x0004)
	class AActor*                                      r_PolymorphInstigator;                                    // 0x2824(0x0008) (Net)
	int                                                m_PrePolymorphHealth;                                     // 0x282C(0x0004)
	int                                                m_PolymorphMaxHealth;                                     // 0x2830(0x0004)
	TArray<struct FRigidBodyImpactInfo>                m_RigidBodyImpacts;                                       // 0x2834(0x0010) (NeedCtorLink)
	int                                                m_nWaterVolumeCount;                                      // 0x2844(0x0004)
	float                                              m_fMinShallowWaterDepth;                                  // 0x2848(0x0004)
	struct FWaterFxData                                m_ShallowWaterFx;                                         // 0x284C(0x0024)
	struct FWaterFxData                                m_DeepWaterFx;                                            // 0x2870(0x0024)
	float                                              c_fServerTimeStamp;                                       // 0x2894(0x0004)
	float                                              m_fZoomDistOverride;                                      // 0x2898(0x0004)
	float                                              m_fZoomDurationOverride;                                  // 0x289C(0x0004)
	struct FDouble                                     c_fLastUnoccludedWeaponSoundTimestamp;                    // 0x28A0(0x0008)
	float                                              c_fThreatBehind;                                          // 0x28A8(0x0004)
	float                                              c_fThreatInEffectiveRange;                                // 0x28AC(0x0004)
	float                                              c_fThreatDistanceSquared;                                 // 0x28B0(0x0004)
	float                                              c_fThreatDistance;                                        // 0x28B4(0x0004)
	float                                              c_fThreatFocused;                                         // 0x28B8(0x0004)
	float                                              c_fThreatFocusTarget;                                     // 0x28BC(0x0004)
	float                                              c_fThreatSeenBy;                                          // 0x28C0(0x0004)
	float                                              c_fThreatDamaged;                                         // 0x28C4(0x0004)
	float                                              c_fThreatOcclusion;                                       // 0x28C8(0x0004)
	float                                              c_fThreatBinnedOcclusion;                                 // 0x28CC(0x0004)
	float                                              c_fThreatShotAt;                                          // 0x28D0(0x0004)
	float                                              c_fThreatUlt;                                             // 0x28D4(0x0004)
	float                                              c_fThreatLevelValue;                                      // 0x28D8(0x0004)
	float                                              c_fThreatDecayResidual;                                   // 0x28DC(0x0004)
	float                                              c_fLastThreatLevelValue;                                  // 0x28E0(0x0004)
	float                                              c_fDBGThreatDistanceFeet;                                 // 0x28E4(0x0004)
	class UTgGameplayCurves*                           r_GameplayCurves;                                         // 0x28E8(0x0008) (Net)
	class UTgGameplayCurves*                           m_BaseCurves;                                             // 0x28F0(0x0008)
	class UTgGameplayCurves*                           m_DownedCurves;                                           // 0x28F8(0x0008)
	int                                                m_nSuccessfulHitSpecialFXId;                              // 0x2900(0x0004)
	TArray<struct FName>                               LLegBoneNames;                                            // 0x2904(0x0010) (NeedCtorLink)
	TArray<struct FName>                               RLegBoneNames;                                            // 0x2914(0x0010) (NeedCtorLink)
	TArray<struct FName>                               LArmBoneNames;                                            // 0x2924(0x0010) (NeedCtorLink)
	TArray<struct FName>                               RArmBoneNames;                                            // 0x2934(0x0010) (NeedCtorLink)
	TArray<struct FName>                               HeadBoneNames;                                            // 0x2944(0x0010) (NeedCtorLink)
	struct FName                                       m_HeadShotComponentBoneName;                              // 0x2954(0x0008)
	class UTgHeadShotComponent*                        m_HeadShotComponent;                                      // 0x295C(0x0008) (ExportObject, Component, EditInline)
	float                                              m_fMountScaleOverride;                                    // 0x2964(0x0004) (Edit)
	class UTgCameraShake*                              m_LandCameraShake;                                        // 0x2968(0x0008)
	class UTgCameraShake*                              m_JumpCameraShake;                                        // 0x2970(0x0008)
	class UTgCameraShake*                              m_DoubleJumpCameraShake;                                  // 0x2978(0x0008)
	class UTgCameraShake*                              m_DisenchantCameraShake;                                  // 0x2980(0x0008)
	class UTgSpecialFx*                                m_DisenchantFx;                                           // 0x2988(0x0008)
	float                                              m_f1PTransitionFireDelay;                                 // 0x2990(0x0004)
	float                                              m_f1PTransitionFireDelayRemaining;                        // 0x2994(0x0004) (Transient)
	float                                              m_fEnergyChargeMultiplier;                                // 0x2998(0x0004)
	float                                              c_fRecreateTrackedProjectilesTimer;                       // 0x299C(0x0004)
	float                                              m_fRecoilSmoothRate;                                      // 0x29A0(0x0004)
	struct FRotator                                    m_rCurrentRecoil;                                         // 0x29A4(0x000C)
	struct FRotator                                    m_rSmoothedRecoil;                                        // 0x29B0(0x000C)
	struct FRotator                                    m_rLastAppliedRecoil;                                     // 0x29BC(0x000C)
	float                                              m_fSettleDelay;                                           // 0x29C8(0x0004)
	float                                              m_fSettleSpeed;                                           // 0x29CC(0x0004)
	float                                              m_fRecoilSettleDeltaTimeOverflow;                         // 0x29D0(0x0004)
	float                                              m_fRecoilSmoothDeltaTimeOverflow;                         // 0x29D4(0x0004)
	struct FRotator                                    m_rVisualRecoil;                                          // 0x29D8(0x000C)
	float                                              m_fVisualRecoilApplicationTime;                           // 0x29E4(0x0004)
	float                                              m_fVisualRecoilDuration;                                  // 0x29E8(0x0004)
	class UTgGameplayCurvesSet_RecoilVisual*           m_VisualRecoilApplied;                                    // 0x29EC(0x0008)
	int                                                r_nVoicePackId;                                           // 0x29F4(0x0004) (Net)
	TArray<struct FVector>                             m_vPendingWallKnockbackHitNormals;                        // 0x29F8(0x0010) (NeedCtorLink)
	TArray<int>                                        m_nPendingPlayerKnockbackHitPawnIds;                      // 0x2A08(0x0010) (NeedCtorLink)
	float                                              m_fTimeOnNonBaseableSurface;                              // 0x2A18(0x0004)
	float                                              m_fNonBaseableSurfaceAirControlDuration;                  // 0x2A1C(0x0004)
	float                                              m_fNonBaseableSurfaceLerpTime;                            // 0x2A20(0x0004)
	float                                              m_fNonBaseableSurfaceRampUpMult;                          // 0x2A24(0x0004)
	float                                              m_fNonBaseableSurfaceMaxMoveAmount;                       // 0x2A28(0x0004)
	float                                              m_fNonBaseableSurfaceGraceTime;                           // 0x2A2C(0x0004)
	float                                              m_fNonBaseableSurfaceExitMaxVelocity;                     // 0x2A30(0x0004)
	float                                              m_fNonBaseableSurfaceControlPercent;                      // 0x2A34(0x0004)
	TArray<class UMaterialInterface*>                  m_OriginalMaterialsBody;                                  // 0x2A38(0x0010) (NeedCtorLink)
	TArray<class UMaterialInterface*>                  m_OriginalMaterialsHead;                                  // 0x2A48(0x0010) (NeedCtorLink)
	TArray<class UMaterialInterface*>                  m_OriginalMaterialsWeapon;                                // 0x2A58(0x0010) (NeedCtorLink)
	TArray<class UMaterialInstanceConstant*>           m_ReplacementMICsBody;                                    // 0x2A68(0x0010) (NeedCtorLink)
	TArray<class UMaterialInstanceConstant*>           m_ReplacementMICsHead;                                    // 0x2A78(0x0010) (NeedCtorLink)
	TArray<class UMaterialInstanceConstant*>           m_ReplacementMICsWeapon;                                  // 0x2A88(0x0010) (NeedCtorLink)
	float                                              m_fEyeHeightSmoothFactor;                                 // 0x2A98(0x0004)
	class UForceFeedbackWaveform*                      m_DeathFFWaveform;                                        // 0x2A9C(0x0008)
	class ATgDevice*                                   m_BuffDevice;                                             // 0x2AA4(0x0008)
	class ATgDevice*                                   m_PrincessPresenceDebuffDevice;                           // 0x2AAC(0x0008)
	class ATgDevice*                                   m_PrincessPresenceBuffDevice;                             // 0x2AB4(0x0008)
	float                                              m_fFlourishTimeout;                                       // 0x2ABC(0x0004)
	int                                                c_nCurrentVGSPlaying;                                     // 0x2AC0(0x0004)
	TArray<struct FScriptDelegate>                     m_SingleUseOn3pTransitionDelegates;                       // 0x2AC4(0x0010) (NeedCtorLink)
	struct FRotator                                    m_PreMountMeshRotation;                                   // 0x2AD4(0x000C)
	class UTgSpecialFx*                                m_MountCastFX3P;                                          // 0x2AE0(0x0008)
	class UTgSpecialFx*                                m_MountSummonFX3P;                                        // 0x2AE8(0x0008)
	class UTgSpecialFx*                                m_ReviveCastFX3P;                                         // 0x2AF0(0x0008)
	class UTgSpecialFx*                                m_OnRevivingFX3P;                                         // 0x2AF8(0x0008)
	float                                              m_fInterpElapsed;                                         // 0x2B00(0x0004)
	float                                              m_fInterpDuration;                                        // 0x2B04(0x0004)
	int                                                m_nInterpStart;                                           // 0x2B08(0x0004)
	int                                                m_nInterpTarget;                                          // 0x2B0C(0x0004)
	struct FVector                                     c_vForced3pAdditionalOffset;                              // 0x2B10(0x000C) (Config)
	struct FVector                                     c_v3pOffsetTest;                                          // 0x2B1C(0x000C)
	struct FVector                                     c_v3pOffsetTestMounted;                                   // 0x2B28(0x000C)
	struct FVector                                     c_vMountCameraOffset[0x2];                                // 0x2B34(0x000C) (Config)
	struct FVector                                     m_vCameraOverrideLocation;                                // 0x2B4C(0x000C)
	TArray<struct FVector>                             m_VaultPath;                                              // 0x2B58(0x0010) (NeedCtorLink)
	struct FName                                       m_nmWindowVaultAnimName;                                  // 0x2B68(0x0008)
	float                                              m_fFaceWallVaultingThreshold;                             // 0x2B70(0x0004)
	float                                              m_fVaultZ;                                                // 0x2B74(0x0004)
	float                                              m_fLedgeGrabDist;                                         // 0x2B78(0x0004) (Edit)
	float                                              m_fLedgeGrabbableWallZ;                                   // 0x2B7C(0x0004) (Edit)
	float                                              m_fLedgeGrabbableZ;                                       // 0x2B80(0x0004) (Edit)
	float                                              m_fMaxLedgeCheckHeight;                                   // 0x2B84(0x0004) (Edit)
	float                                              m_fLedgeMantleDist;                                       // 0x2B88(0x0004) (Edit)
	float                                              m_fLateralLedgeSpeedMult;                                 // 0x2B8C(0x0004) (Edit)
	struct FVector                                     m_vLedgeGrabWallDir;                                      // 0x2B90(0x000C)
	float                                              m_fLedgeDist;                                             // 0x2B9C(0x0004)
	float                                              m_fWindowVaultNoInputTime;                                // 0x2BA0(0x0004)
	float                                              m_fWindowVaultDeviceLockoutTime;                          // 0x2BA4(0x0004)
	float                                              m_fWindowVaultCooldownTime;                               // 0x2BA8(0x0004)
	float                                              m_fADSGroundspeedPct;                                     // 0x2BAC(0x0004)
	float                                              m_fTotalADSZoomTime;                                      // 0x2BB0(0x0004)
	float                                              m_fRemainingADSZoomInTime;                                // 0x2BB4(0x0004)
	float                                              m_fRemainingADSZoomOutTime;                               // 0x2BB8(0x0004)
	struct FString                                     m_sBotCodeNameOverride;                                   // 0x2BBC(0x0010) (Const, NeedCtorLink)
	float                                              m_fHazardDistance;                                        // 0x2BCC(0x0004)
	float                                              m_fHazardRating;                                          // 0x2BD0(0x0004)
	TArray<class ATgDeployable*>                       m_nPickupDeployableList;                                  // 0x2BD4(0x0010) (NeedCtorLink)
	float                                              m_PickupMinDot;                                           // 0x2BE4(0x0004) (Edit)
	float                                              m_fPickupMaxDistance;                                     // 0x2BE8(0x0004)
	float                                              m_fPickupMaxSquareRadius;                                 // 0x2BEC(0x0004)
	float                                              c_fSimModMoveSpeedToSave;                                 // 0x2BF0(0x0004)
	float                                              c_fSavedSimModMoveSpeed;                                  // 0x2BF4(0x0004)
	float                                              r_fRevivingTimer;                                         // 0x2BF8(0x0004) (Net)
	float                                              m_fLastRoyaleTakeHitTime;                                 // 0x2BFC(0x0004)
	int                                                m_nReviveBoostedCount;                                    // 0x2C00(0x0004)
	float                                              m_fSteepTerrainWalkableFloorZ;                            // 0x2C04(0x0004)
	float                                              m_fSteepTerrainSlowMultiplierSmall;                       // 0x2C08(0x0004)
	float                                              m_fSteepTerrainSlowMultiplierMid;                         // 0x2C0C(0x0004)
	float                                              m_fSteepTerrainSlowMultiplierLarge;                       // 0x2C10(0x0004)
	float                                              m_fSteepTerrainSlopeZMidBreakpoint;                       // 0x2C14(0x0004)
	class UTgSpecialFx*                                m_CameraInvisFX3P;                                        // 0x2C18(0x0008)
	TArray<class ATgIndoorVolume*>                     m_TouchingIndoorVolumes;                                  // 0x2C20(0x0010) (NeedCtorLink)
	float                                              m_fDoubleJumpThreshold;                                   // 0x2C30(0x0004)
	int                                                m_nDoubleJumpRemaining;                                   // 0x2C34(0x0004)
	float                                              m_fUnderheadADSDistanceClampAngle;                        // 0x2C38(0x0004) (Config)
	float                                              m_fUnderheadADSDistanceClampPushIn;                       // 0x2C3C(0x0004) (Config)
	float                                              m_fUnderheadADSDistanceClampOvershoot;                    // 0x2C40(0x0004) (Config)
	float                                              m_fOverheadADSDistanceClampAngle;                         // 0x2C44(0x0004) (Config)
	float                                              m_fOverheadADSDistanceClampPushIn;                        // 0x2C48(0x0004) (Config)
	float                                              m_fOverheadADSDistanceClampOvershoot;                     // 0x2C4C(0x0004) (Config)
	struct FVector                                     c_vForced3pAdditionalOffsetADS;                           // 0x2C50(0x000C) (Config)
	float                                              m_fSkydiveAirControl;                                     // 0x2C5C(0x0004)
	float                                              m_fSkydiveGravityMultiplier;                              // 0x2C60(0x0004)
	float                                              m_fSkydiveFromCatapultAirControl;                         // 0x2C64(0x0004)
	float                                              m_fSkydiveFromCatapultGravityMultiplier;                  // 0x2C68(0x0004)
	float                                              m_fCatapultAirControl;                                    // 0x2C6C(0x0004)
	float                                              m_fSkydiveMaxStrafeSpeed;                                 // 0x2C70(0x0004)
	float                                              m_SkydiveAccelRate;                                       // 0x2C74(0x0004)
	float                                              m_SkydiveRootTime;                                        // 0x2C78(0x0004)
	float                                              m_SkydieChickenLandTime;                                  // 0x2C7C(0x0004)
	float                                              m_SkydiveChickenRootTime;                                 // 0x2C80(0x0004)
	float                                              m_SkydiveRootRemainingTime;                               // 0x2C84(0x0004)
	float                                              m_SkydiveBrakePercent;                                    // 0x2C88(0x0004)
	float                                              m_fSkydivePrelandDistance;                                // 0x2C8C(0x0004)
	float                                              m_fSkydivePSParamTime;                                    // 0x2C90(0x0004)
	float                                              m_fFallRootMinSpeed;                                      // 0x2C94(0x0004)
	float                                              m_fFallRootTime;                                          // 0x2C98(0x0004)
	int                                                m_MountLogDebugTimes;                                     // 0x2C9C(0x0004)
	class UAnimSet*                                    m_pPendingWeaponAnimSet;                                  // 0x2CA0(0x0008)
	float                                              m_fAllowableSprintAngle;                                  // 0x2CA8(0x0004)
	int                                                m_nSprintPostureID;                                       // 0x2CAC(0x0004)
	float                                              m_f3pSmoothSpeed1;                                        // 0x2CB0(0x0004) (Edit)
	float                                              m_f3pSmoothSpeed2;                                        // 0x2CB4(0x0004) (Edit)
	class UTgRealmArmor*                               m_ArmorSkin;                                              // 0x2CB8(0x0008)
	TArray<int>                                        m_nDownedTaskForceList;                                   // 0x2CC0(0x0010) (NeedCtorLink)
	class UTgDeviceForm*                               m_pPrevEquipForm;                                         // 0x2CD0(0x0008)
	TArray<struct FDeviceTimer>                        m_DeviceTimers;                                           // 0x2CD8(0x0010) (NeedCtorLink)
	TArray<class UTgAnimNodeBlendCrouch*>              m_AnimNodeBlendCrouchNodes;                               // 0x2CE8(0x0010) (NeedCtorLink)
	TArray<class UGameSkelCtrl_Recoil*>                m_LandRecoilSkelControls;                                 // 0x2CF8(0x0010) (NeedCtorLink)
	struct FTalentInfo                                 r_Talents[0xA];                                           // 0x2D08(0x001C) (Net)
	float                                              m_fNonVerbalEmoteCooldown;                                // 0x2E20(0x0004)
	float                                              m_fNonVerbalEmoteTime;                                    // 0x2E24(0x0004)
	float                                              m_fPolymorphGroundSpeed;                                  // 0x2E28(0x0004)
	float                                              m_fMountCastTime;                                         // 0x2E2C(0x0004)
	float                                              m_fSprintSpeed;                                           // 0x2E30(0x0004)
	float                                              m_fHitIndicatorVerticalDistance;                          // 0x2E34(0x0004)
	float                                              m_fHitIndicatorHorizontalDistance;                        // 0x2E38(0x0004)
	class ATgCatapultActor*                            r_Catapult;                                               // 0x2E3C(0x0008) (Net)
	struct FRotator                                    m_rLockedSkelControlRotation;                             // 0x2E44(0x000C)
	class UTgSkeletalMeshComponent*                    m_pShieldMesh;                                            // 0x2E50(0x0008) (ExportObject, Component, EditInline)
	class ATgWeatherVolume*                            m_CurrentWeatherVolume;                                   // 0x2E58(0x0008)
	class USkelControlSingleBone*                      m_SkelControl_BigHead;                                    // 0x2E60(0x0008)
	struct FScriptDelegate                             __On3pTransitionEvent__Delegate;                          // 0x2E68(0x000C) (NeedCtorLink)
	unsigned char                                      UnknownData01[0x4];                                       // 0x2E68(0x0004) FIX WRONG TYPE SIZE OF PREVIOUS PROPERTY

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn");
		return ptr;
	}


	float STATIC_GetADSZoomAlpha(unsigned char* outZoomState);
	bool UsesFullScreenScope();
	void StopDrivingCatapult(class ATgCatapultActor* Catapult);
	void StartDrivingCatapult(class ATgCatapultActor* Catapult);
	void STATIC_OnClientUpdateShardCount(int n_ShardCount);
	void STATIC_OnServerAcknowledgeShardPickup();
	void STATIC_SetBaseEyeheight();
	float STATIC_GetADSTargetFOV();
	float STATIC_GetADSZoomOutTime();
	float STATIC_GetADSZoomInTime();
	void STATIC_EndADS();
	void STATIC_OnEndADS();
	void StartADS();
	bool STATIC_IsIndoors();
	void ServerResetDebugPropertyMods(const struct FString& sProperty);
	void ServerApplyDebugPropertyMod(const struct FString& sProperty, bool bPercent, float fModifier1, float fModfier2, float fModifier3, float fModifier4, float fModifier5, float fModifier6);
	class ATgDeployable* STATIC_GetDeployableToPickUp();
	void AddDeployableToPickupList(class ATgDeployable* TgDeployable, bool bRemove);
	float STATIC_GetCameraPenetrationCheckRadius();
	struct FVector STATIC_GetCameraOriginOverride(const struct FVector& originalOrigin, TEnumAsByte<ECameraPerspectiveType> ePerspectiveType);
	void StopSprintEffects();
	void PlaySprintEffects();
	bool STATIC_IsSwitchingAnyWeapons();
	bool STATIC_IsFiringAnyWeapons();
	void SetSprinting(bool bNewIsSprinting);
	void TickSprinting(float DeltaTime);
	void EndWindowVaultDeviceLockout();
	void EndWindowVaultCooldown();
	void EndWindowVaultNoInputTime();
	void STATIC_OnEndedVault();
	bool ClientAttemptVault();
	void ClientCancelVault();
	void STATIC_ServerCancelVault();
	void STATIC_ServerDoVault(class ATgWindowVaultVolume* pVaultVolume);
	bool CanVaultNow();
	bool AttemptVaultNow(class ATgWindowVaultVolume* pVaultVolume);
	bool DoVault(const struct FVector& WallDir, TEnumAsByte<ETgVaultTypes> VaultType);
	bool CheckVault();
	void STATIC_OnEmoteSoundFinished();
	void ServerOnEmoteEnded();
	void STATIC_OnEmoteSoundPlayed(TEnumAsByte<EEmote> Emote);
	void STATIC_OnVGSSoundFinished();
	void STATIC_OnVGSSoundPlayed(int nVgsId);
	bool ShouldUseADSSensitivity();
	bool ShouldUseScopeSensitivity();
	void STATIC_EnableMovementCorrection();
	void STATIC_DisableMovementCorrection(float fDisableTime);
	void STATIC_Invoke3pTransitionDelegates();
	void STATIC_RegisterFor3pTransitionCB(const struct FScriptDelegate& EventDelegate);
	void STATIC_AppliedEffectRemoved(class UTgEffect* RemovedEffect);
	void AdjustNewAccel(struct FVector* vNewAccel);
	void StartFlourish();
	void FlourishTimeoutFinished();
	void ServerStartFlourish();
	float STATIC_GetMaxAimAssistStacks();
	class ATgDevice* STATIC_GetDeviceForAimAssist();
	void ResetPermanentEffects();
	void ResetUlt();
	float STATIC_GetEnergyChargeModifier();
	float STATIC_GetEquipTimeScale();
	float STATIC_GetReloadScale();
	bool ShouldNudgePlayer(class ATgPawn* PlayerPawn);
	bool CanBeNudged();
	void ForwardEffects(const struct FImpactInfo& Impact, class UTgEffectGroup* effectGroup, class ATgDevice* SourceDevice, bool bRemove, int StackCount);
	void SetFaceRotationToController();
	void ToggleHealAkEvent(bool bEnable);
	void UpdateHUDHealthPercent(float fPercent);
	void SetHUDOverlayEnemyViewDist(float enemyViewDist);
	void SetHUDOverlayState(TEnumAsByte<EDeployableOverlayState> dos);
	void SetHUDOverlayIcon(TEnumAsByte<EDeployableOverlayIcon> doi);
	void SetHUDOverlayDisplayMask(int dodm);
	float STATIC_CheckOcclusion();
	void SetThreatLevel(TEnumAsByte<EThreatLevel> NewThreatLevel);
	void STATIC_OnCeaseSpectatorViewTarget();
	void STATIC_OnBecameSpectatorViewTarget();
	void STATIC_ForceUpdateAmmoAnim();
	void AllowDeviceToModifyInput(class UTgPlayerInput* tgInput);
	struct FRotator ApplyCameraRotationModifier(const struct FRotator& rCameraRot);
	void STATIC_OnPolymorphChanged(bool bDead);
	void STATIC_RecreateTrackedProjectiles();
	void PrepTrackedProjectileRecreation(float recreateTimeOut);
	void STATIC_PostTimeLapse(bool bPlayOfTheGame);
	void STATIC_PreTimeLapse(bool bPlayOfTheGame);
	void STATIC_SetAux(const struct FName& AuxBusName, float Level);
	void PlayPolymorphEffects(bool bForceOff);
	int STATIC_GetPolymorphMeshID();
	void SetPolymorph(TEnumAsByte<EPolymorphType> NewPolymorph, class AActor* instigatingActor);
	void Polymorph(TEnumAsByte<EPolymorphType> NewPolymorph);
	float STATIC_GetMountingPercent();
	struct FVector STATIC_GetCameraOffsetOverride(const struct FVector& originalOffset, TEnumAsByte<ECameraPerspectiveType> ePerspectiveType);
	struct FVector STATIC_GetMountCameraOffset(TEnumAsByte<EMountType> MountType);
	struct FVector STATIC_GetForced3pAdditionalOffset();
	void STATIC_OnStartTimelapseNewDeviceState();
	void PlayGenericTakeHit(const struct FVector& HitLocation, const struct FVector& HitNormal, class ATgPawn* HitInstigator, float fDamageAmount, struct FExtraDamageInfo* ExtraInfo);
	void PlayFXHoldsBeacon(bool bShouldPlay);
	void ClientUpdateHasRespawnBeacon(bool bHasRespawnBeacon);
	void UpdateHasRespawnBeacon(bool bHasRespawnBeacon);
	void TouchingRespawnBeaconExit(class ATgRespawnBeaconExit* RespawnBeacon, bool IsTouching);
	class ATgRespawnBeaconExit* STATIC_GetTouchingRespawnBeacon();
	void SetInitialHUDOverlayInfo();
	void STATIC_FinishedIntroAnim(class UAnimNode* IntroAnimNode);
	void ExitIntroPosture(bool bForceAnimTreeOut);
	void EnterIntroPosture();
	void SetupIntroAnimNodesAndTimers();
	void STATIC_DoIntroduction(bool bUseInitialIntro);
	bool STATIC_IsPlayingIntro();
	void BeginWhiteOutScaleUp();
	void SetWhiteOutStartTimer();
	void STATIC_IntroTimer();
	void EndWhiteOut();
	void UpdateWhiteOut();
	void STATIC_RemoveBlindingDeployable(class ATgDeployable* deployable);
	void STATIC_AddBlindingDeployable(class ATgDeployable* deployable);
	void STATIC_RemoveObscuringDeployable(class ATgDeployable* deployable);
	void STATIC_AddObscuringDeployable(class ATgDeployable* deployable);
	bool STATIC_IsInstigatorStealthRevealed(class AActor* Viewer);
	void STATIC_RemoveInstigatorStealthReveal(class AActor* Viewer);
	void STATIC_AddInstigatorStealthReveal(class AActor* Viewer);
	bool STATIC_IsInstigatorWallRevealed(class AActor* Viewer);
	void STATIC_RemoveInstigatorWallReveal(class AActor* Viewer);
	void STATIC_AddInstigatorWallReveal(class AActor* Viewer);
	void STATIC_GetAnimSetStrings(TEnumAsByte<EMountType> MountType, TArray<struct FString>* sPaths);
	void UpdateLastPlayerStart(class APlayerStart* NewLastPlayerStart);
	class UTgSpecialFx* TestFx2(int Id);
	void TestFx(float Pct);
	TEnumAsByte<EBotBehaviorState> STATIC_GetBotBehaviorState();
	void UpdateBotBehaviorState(TEnumAsByte<EBotBehaviorState> NewState);
	TEnumAsByte<EMetaGameState> STATIC_GetMetaGameState();
	void UpdateMetaGameState(TEnumAsByte<EMetaGameState> NewState);
	void ClientSetActiveWeapon(class AWeapon* NewWeapon);
	void AddIncomingImpact(int bNumToAdd);
	void SetUITargetingType(TEnumAsByte<EUITargetingType> NewTargetingType, bool bForceRequiredToSet, TEnumAsByte<EUITargetingType> RequiredToSet);
	float STATIC_GetDistanceToNearestCapturePoint();
	void STATIC_InterruptAllMovementDevices();
	void STATIC_InterruptDeviceFiringByClass(class UClass* DeviceClass, bool bForce);
	class ATgDevice* STATIC_GetActiveDeviceByClass(const struct FName& DeviceClassName);
	class ATgDevice* STATIC_GetDeviceByClass(class UClass* DeviceClass);
	bool STATIC_HasActiveDeviceByClass(const struct FName& DeviceClassName);
	bool STATIC_HasDeviceByClass(class UClass* DeviceClass);
	bool STATIC_HasActiveDeviceByID(int DeviceID);
	bool STATIC_HasDeviceByID(int DeviceID);
	void STATIC_InterruptEmotes(class ATgDevice* Dev);
	void STATIC_InterruptInhandReload();
	void STATIC_InterruptAllReloads();
	void STATIC_PlayRevealedEffects(bool bEnabled);
	void STATIC_PlaySlowEffects(bool bEnabled);
	void CleanUpScreenCapturePostProcess();
	void STATIC_PlayFlashBangEffects(bool bEnabled);
	void STATIC_PlayCrippledEffects(bool bEnabled);
	void STATIC_PlayPoisonedEffects(bool bEnabled);
	void STATIC_PlayRootEffects(bool bEnabled);
	void ClientPlayHiddenEffects(bool bEnabled, class UParticleSystem* Template);
	void ClientPlayGrassEffects(bool bEnabled, class UParticleSystem* Template);
	void STATIC_PlayMarkEffects(bool bEnabled);
	void STATIC_PlayKnockbackEffects(bool bEnabled);
	void STATIC_PlayFreezeEffects(bool bEnabled);
	void STATIC_PlayOnFireEffects(bool bEnabled);
	void STATIC_PlayCCImmuneEffects(bool bEnabled);
	void STATIC_PlayDazeEffects(bool bEnabled);
	void STATIC_PlayBleedEffects(bool bEnabled);
	void RemoveStealthEffects();
	bool STATIC_IsFirstPerson();
	void STATIC_OnMountBegin(bool bForceFireDueToRespawn);
	void StopMountingEffects();
	void STATIC_PushMountPostureAndEffects();
	void STATIC_CreateMountMeshAndEffects(bool bPlayAnimFX);
	bool DeferCreateMountMesh();
	struct FName STATIC_GetMeshAssemblyAimProfile(int nMeshId);
	float STATIC_GetMountTime();
	void PlayMountingEffects();
	bool STATIC_OnMountCancelOffhandSlotPressed(class ATgDevice* newDev);
	bool STATIC_CanApplyShield();
	bool STATIC_IsCameraLocked();
	bool STATIC_IsRotationLocked();
	bool STATIC_InputLockedDueToFiring();
	bool STATIC_IsInputLocked();
	void STATIC_OnCameraCutAnimNotify(class UTgAnimNotify_CameraCut* CameraCutNotify);
	void STATIC_KillCloneTimer();
	bool STATIC_CanPlayHitReaction();
	void SetMeshDepthPriority(TEnumAsByte<ESceneDepthPriorityGroup> NewDepth);
	TEnumAsByte<ETG_EQUIP_POINT> STATIC_OverrideOffhandSlot(TEnumAsByte<ETG_EQUIP_POINT> eqp);
	void STATIC_InterruptInhand();
	bool STATIC_IsInJumpLanding();
	bool STATIC_CannotJumpNow();
	bool STATIC_IsFiringAny(TArray<TEnumAsByte<ETG_EQUIP_POINT>> IgnoreEqPoints);
	bool CheckPhysicsStateForJumping();
	bool STATIC_CanFlyWithoutHover();
	void AdjustDevicesForNewDilation(float fPrevDilation, float fNewDilation);
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_PostDemoRewind();
	void STATIC_PreDemoRewind();
	bool STATIC_AnimNotifySound(class USoundCue* Cue);
	void SetEmote3PCamera(bool bOn);
	bool EmoteShouldForce3P(TEnumAsByte<EEmote> Emote);
	bool STATIC_EmoteShouldKillAllOtherVox(TEnumAsByte<EEmote> Emote);
	bool STATIC_IsEmoteOnNonLocalCooldown(TEnumAsByte<EEmote> Emote);
	bool STATIC_AreEmotesOnGlobalCooldown();
	bool STATIC_IsEmoteOnInternalCooldown(TEnumAsByte<EEmote> Emote);
	float STATIC_GetLastEmoteTime(TEnumAsByte<EEmote> Emote);
	void STATIC_RecordNonLocalEmoteTime();
	void STATIC_RecordGlobalEmoteTime();
	void STATIC_RecordInternalEmoteTime(TEnumAsByte<EEmote> Emote);
	float STATIC_GetEmoteInternalCooldown(TEnumAsByte<EEmote> Emote);
	bool STATIC_RespectsEmoteGlobalCooldown(TEnumAsByte<EEmote> Emote);
	bool TriggersEmoteGlobalCooldown(TEnumAsByte<EEmote> Emote);
	bool STATIC_EmoteDiceRoll(TEnumAsByte<EEmote> Emote);
	float STATIC_GetEmoteChance(TEnumAsByte<EEmote> Emote);
	float STATIC_GetAbilityEmoteChance(TEnumAsByte<EEmote> Emote);
	TEnumAsByte<EEmoteCategory> STATIC_GetEmoteCategory(TEnumAsByte<EEmote> Emote);
	bool STATIC_CanEmoteDuringTimelapse(TEnumAsByte<EEmote> Emote);
	bool SelfTeamOnly(TEnumAsByte<EEmote> Emote);
	bool CanPlayCustomEmote();
	void STATIC_ClientPlayEmote(TEnumAsByte<EEmote> Emote, int nExtraInfo, int nTaskForce);
	void STATIC_ClientPlayCustomEmote(int nIndex);
	bool STATIC_IsPlayingMountEmoteAnim();
	bool STATIC_IsPlayingCustomEmote();
	void ToggleMountEmoteAnims(bool bOn);
	bool STATIC_IsMountEmoteValid();
	void STATIC_ClientCustomSpray(int nIndex, const struct FVector& vOrigin, const struct FVector& vAim);
	void STATIC_ClientSpray(const struct FVector& vOrigin, const struct FVector& vAim);
	void STATIC_PlayEmoteSelfOnly(TEnumAsByte<EEmote> Emote, int nExtraInfo);
	void STATIC_PlayDeviceEmoteAll(class ATgDevice* Dev, bool bCallOnOwner);
	TEnumAsByte<EEmote> STATIC_GetDeviceEmoteType(class ATgDevice* Dev);
	void CancelCustomEmote();
	bool ShouldInterruptCustomEmote();
	void ResetWeaponScale();
	void STATIC_LoadSprayMIC(int nIndex);
	void STATIC_LoadCustomEmote(int nIndex);
	struct FString STATIC_GetVGSCustomSuffix();
	struct FString STATIC_GetEmoteSuffix(TEnumAsByte<EEmote> Emote, int ExtraInfo);
	class UAkEvent* STATIC_GetVoxKillAkEvent(int BotId, TEnumAsByte<EEmote> Emote, int ExtraInfo);
	class UAkEvent* STATIC_GetEmoteAkEvent(int BotId, TEnumAsByte<EEmote> Emote, int ExtraInfo);
	struct FString STATIC_GetBotCodeName();
	struct FString STATIC_GetBotRefName();
	struct FString STATIC_GetBotName();
	int STATIC_GetBotId();
	TEnumAsByte<ETG_EQUIP_POINT> STATIC_GetPerCharacterAltEquipPoint();
	void PostBigTeleport();
	void PostTeleport(class ATeleporter* OutTeleporter);
	void ResumeFXFromTeleport();
	void STATIC_HaltFXForTeleport();
	bool PreTeleport(class ATeleporter* InTeleporter);
	void STATIC_OnTeleportNotify(class AActor* TeleportingActor);
	void TeleportNotify();
	void STATIC_RemoveFromTeleportNotify(class AActor* RemoveActor);
	void STATIC_AddToTeleportNotify(class AActor* ToBeNotified);
	void ServerChangePhase(int NewPhase);
	void ChangePhase(int NewPhase);
	void Perf2(bool bEnabled);
	void STATIC_OnPhaseTransitionComplete();
	void STATIC_OnPhaseChange();
	void STATIC_OnPhaseEnded(int nPhaseThatEnded);
	void BaseChange();
	bool CanPickupDroppedItem();
	bool STATIC_IsValidMeleeTarget(class ATgPawn* ProspectiveMeleeTarget);
	void STATIC_SaveDeathInfoForZoomCam(class ATgPawn* KillerOwner, class ATgPawn* Killer, int DeviceID, bool bPetKill);
	void UpdateCooldownsOnDevices();
	void Stun(bool bStunController, TEnumAsByte<EStunType> eType);
	bool CanApplyAimAssist(class ATgPlayerController* LocalPlayerController, class ATgPawn* LocalPawn);
	bool Teleport(const struct FVector& vDest, const struct FRotator& rDest, bool bPlayFx, int TeleportEnterState, int TeleportExitState, bool bFailOnNoSafeSpot, bool bFakeTeleport, struct FVector* vTeleportLocation);
	bool STATIC_IsAboveNonbaseableSurface(const struct FVector& vTestLoc, float fTestDist, class AActor** HitActor, struct FVector* HitNormal);
	bool TeleportTraceCheck(const struct FVector& vTestLoc, const struct FVector& vDestLoc);
	class ATgPawn* STATIC_GetCurrentOwnerPawn();
	bool WasPlayerSpawned();
	bool STATIC_IsTalentEquipped(int nTalentDeviceId);
	bool STATIC_IsTargetWithInCone(class AActor* Target);
	void TickTargeting(float DeltaSeconds);
	void UpdateBob(float DeltaSeconds);
	void TickScale(float DeltaSeconds);
	float TickScaleVariable(float fDesiredValue, float fOldValue, float fScaleChangePerSecond, float DeltaSeconds);
	void AddRecoil(const struct FRotator& rNewRecoil, float fRecoilSmoothRate, float fSettleDelay, float fSettleSpeed);
	void UpdateRecoil(float DeltaTime);
	void Tick(float DeltaSeconds);
	void DoubleCheckSimulatedProxy();
	void TickFriendlyPush();
	bool ShouldRecharge();
	void DisplayMessage(const struct FString& sMessage);
	void STATIC_ModifyPawnPropertiesVolumeChanged();
	void STATIC_OnRigidBodySpringOverextension(class URB_BodyInstance* BodyInstance);
	void SetUsePhysicsWithAnimation(bool Enable);
	class ATgPawn* FindLocalPlayerPawn();
	void BlendToAnimTreeDeviceType();
	void SetVar(int varId);
	void ServerSetVar(int varId);
	void STATIC_ApplyTeleportEffects(const struct FVector& StartLocation);
	void OnTeleport(class USeqAct_Teleport* Action);
	float STATIC_GetJumpSpeedMultiplier();
	float STATIC_GetJumpHeightMultiplier();
	void FlashJumpEffects();
	bool DoJump(bool bUpdating, float JumpZSpeed);
	bool CanDoubleJump();
	bool DoDoubleJump(bool bUpdating);
	void STATIC_ClientCancelJump();
	void ServerCancelJump();
	void TriggerJump();
	void STATIC_StartCrouch(float HeightAdjust);
	void STATIC_EndCrouch(float HeightAdjust);
	float ApplyPitchLimit(float fPitch);
	struct FRotator STATIC_GetBaseAimRotation(class AWeapon* W, bool bIgnoreAutoLock);
	void STATIC_GetAdjustedAimNative(class AWeapon* W, const struct FVector& StartFireLoc, struct FRotator* Rot);
	void STATIC_GetBaseAimRotationNative(class AWeapon* W, bool bIgnoreAutoLock, struct FRotator* Rot);
	struct FVector STATIC_GetWeaponStartTraceLocationAlt(const struct FVector& Offset);
	struct FVector STATIC_GetWeaponStartTraceLocation(class ATgDevice* Dev);
	void STATIC_HideWeaponSwitchProgressBar();
	void DisplayWeaponSwitchProgressBar(float Duration);
	void STATIC_CheckUseDuration(float* fDuration);
	void ClientSetTriggerMessage(class ATgTrigger_Use* newTrigger, int msgId);
	void SetTriggerToUse(class ATgTrigger_Use* Trigger, bool bEnable);
	void STATIC_InterruptAllDevices(bool bForceInterrupt, bool bIgnorePotions);
	bool STATIC_IsUseInterrupted();
	void STATIC_InterruptUse();
	void STATIC_EnableFootControls(int foot, bool bDisable);
	void HitWall(const struct FVector& HitNormal, class AActor* Wall, class UPrimitiveComponent* WallComp);
	bool STATIC_CanBeGrabbed();
	bool STATIC_CanBePulled();
	void Stasis(bool bStasised);
	void STATIC_FlashBang(bool bIsFlashBang);
	void STATIC_Cripple(bool bCrippled);
	void STATIC_Knock(bool bKnocked, float fKnockbackFrictionOverride, const struct FVector& vKnockbackVelocityOverride);
	void StopDisarmFX();
	void PlayDisarmFX();
	void STATIC_Disarm(bool bDisarmed);
	void Silence(bool bSilenced);
	void ResetStunnedBehavior(class ATgPlayerController* PC, class ATgAIController* aic);
	void ClientSetStun();
	void StopFullBodyAnimation(float BlendOutTime);
	void STATIC_OnAnimEnd(class UAnimNodeSequence* SeqNode, float PlayedTime, float ExcessTime);
	void STATIC_OnAnimPlay(class UAnimNodeSequence* SeqNode);
	void gibbedBy(class AActor* Other);
	void DetachConeComponent(class UDrawConeComponent* ConeComponent);
	class UDrawConeComponent* AttachConeComponent(class UDrawConeComponent* ConeComponent, float fRadius, float fAngle);
	void PlayInitialSpawnFX();
	void TriggerKismetPlayerInitialized();
	void STATIC_OnPawnInitialized();
	void STATIC_NativeWaitingForPawnDone();
	void STATIC_OnWaitingForPawnDone();
	void WaitForInventoryThenDoPostPawnSetup();
	void STATIC_HandleClientPostPawnSetup();
	void STATIC_PropertySet(int nPropertyId, float fPreviousValue, float fNewValue);
	void STATIC_AttachDevice();
	void STATIC_DetachDevice();
	void UpdateHealingBeamEffects();
	void STATIC_OnLifeAfterDeathTimerExpired();
	void BeginFadeOut();
	void DelayedRagdollConstraintBreak();
	bool InitRagdoll();
	void STATIC_TurnOff();
	void STATIC_KilledBy(class APawn* EventInstigator);
	void STATIC_OutsideWorldBounds();
	void STATIC_FellOutOfWorld(class UClass* dmgType);
	void FlushDebug();
	void PlayHit(float Damage, class AController* InstigatedBy, const struct FVector& HitLocation, class UClass* dmgType, const struct FVector& Momentum, const struct FTraceHitInfo& HitInfo);
	void STATIC_OnJumpPenaltyEnded();
	void Landed(const struct FVector& HitNormal, class AActor* FloorActor);
	bool STATIC_IsDying();
	void ApplyPawnShadows(bool bOn);
	float STATIC_GetEnergyPercent();
	bool STATIC_InCombat();
	void STATIC_Combat(bool bInCombat);
	void STATIC_InCombatTimer();
	void STATIC_ExitCombat();
	void STATIC_EnterCombat(class AActor* aInstigator, class AActor* ATarget, float fLength);
	float STATIC_GetBaseCombatDuration();
	void STATIC_IsStillTimer();
	void STATIC_BeginMoving();
	void STATIC_ClientEnterCombat(class AActor* aInstigator, class AActor* ATarget, float fLength);
	void UpdateBlindingDeployableState();
	void UpdateObscuringDeployableState();
	void EnableVolumeStealth();
	void DisableVolumeStealth();
	void STATIC_GrassOff();
	void STATIC_GrassOn(class AActor* Vol);
	void ClearStealthDamage();
	void VolumeStealthOff();
	void VolumeStealthOn(class AActor* Vol, bool bFull);
	void VolumeStealthFadeComplete();
	void RemoveVisibilityVolume(class AActor* Vol);
	void AddVisibilityVolume(class AActor* Vol);
	void STATIC_FixUpVisibilityVolumes();
	void STATIC_ApplyStealthClient(bool bForce);
	bool ShouldShowAsStealthed(bool bDetected);
	void STATIC_InterruptLift(class ATgDevice* OriginatingDevice);
	void STATIC_InterruptStealth(class ATgDevice* OriginatingDevice);
	void STATIC_ApplyStealthServer(TEnumAsByte<ESTEALTH_TYPE> eStealthed, float fRate, bool bForce);
	void STATIC_ReceivedCachedMaxHealth();
	void STATIC_ReceivedPropValues();
	void STATIC_ReplicatedEvent(const struct FName& VarName);
	void UpdateFirstValidFlashEventIdx();
	void UpdateWeaponMesh(unsigned char EquipPoint, int DeviceID);
	void TgPawnControllerSet();
	void DisplayDebug(class AHUD* HUD, float* out_YL, float* out_YPos);
	struct FName GetDefaultCameraMode(class APlayerController* RequestedBy);
	void STATIC_LockTargetingDeviceToInHand(bool bEnable);
	TEnumAsByte<ETG_EQUIP_POINT> STATIC_GetEquipSlotOfDevice(class ATgDevice* Dev);
	void SetTargetingDevice(class ATgDevice* Dev, const struct FWeaponMeshSwapStrategy& SwapStrategy);
	void STATIC_ClientSetTargetingDeviceByEqPoint(TEnumAsByte<ETG_EQUIP_POINT> eEquipPoint);
	bool STATIC_SetActiveWeapon(class AWeapon* NewWeapon, bool bForceFastClear);
	bool STATIC_IsInFriendlyItemShop();
	void SetPawnState(const struct FName& NewState);
	void RemoveDeathEffects();
	void SyncClientEnergy(float energy);
	void STATIC_LiveRespawn(bool bResetHealth, bool bResetDevices);
	void STATIC_AutoMount(bool bShouldBeMounted, bool bToggleMount);
	void SetMountOnRespawn();
	void STATIC_OnLiveRespawn();
	void Skydive(float fHeight);
	void STATIC_OnRespawn();
	void STATIC_EquipBestInHandDevice(bool bForceFastClear);
	void TimerDestroy();
	void StopAllAnimations();
	bool VerifyChargeHit(const struct FVector& HitLocation, const struct FVector& HitNormal, const struct FVector& TargetLocation, class AActor* Other);
	bool STATIC_PredictChargeHit(const struct FVector& ChargeDir, const struct FVector& ChargeStart, float fChargeRange, const struct FVector& HitLocation, const struct FVector& HitNormal, const struct FVector& TargetLocation, class AActor* Other);
	void STATIC_GetHitLocationForProximityTouch(class AActor* Target, struct FVector* HitLocation, struct FVector* HitNormal);
	void STATIC_EndPhysCharge(bool bInterrupted);
	void StartPhysCharge(TEnumAsByte<EChargeState> newChargeType, const struct FRotator& InitialDirection, const struct FVector& InitialLocation, float fChargeSpeed, float fChargeRange, bool bIngoreHumanoidBlocking, bool bUsePhysFlyingForCharge);
	bool STATIC_IsGrabSourceValid(class ATgPawn* Target, bool bAllowTurrets, bool bAllowStealthed);
	void STATIC_DecrementCannotBeGrabSource();
	void STATIC_IncrementCannotBeGrabSource(bool bBreakGrabs);
	void TickGrab(float DeltaSeconds);
	void STATIC_SetMovementPhysics();
	bool STATIC_CanBeBaseForPawn(class APawn* aPawn);
	void STATIC_AddVelocity(const struct FVector& NewVelocity, const struct FVector& HitLocation, class UClass* DamageType, const struct FTraceHitInfo& HitInfo);
	void BaselessGrabEnd(bool bInterrupted);
	void BaselessGrabStart(bool bRemoveRoots);
	void DefaultGrabEnd(bool bInterrupted);
	void DefaultGrabStart(bool bRemoveRoots);
	void EndGrab(TEnumAsByte<EGrabState> endingGrabState, bool bInterrupted);
	void BeginGrab(TEnumAsByte<EGrabState> newGrabState);
	bool STATIC_IsBaselessGrab(TEnumAsByte<EGrabState> grabState);
	bool ShouldGrabBreakStealth(TEnumAsByte<EGrabState> grabState);
	void STATIC_OnGrabTargetDetach(TEnumAsByte<EGrabState> endingGrabState, class ATgPawn* Target, bool bInterrupted);
	void STATIC_OnGrabTargetAttach(TEnumAsByte<EGrabState> newGrabState, class ATgPawn* Target);
	void STATIC_ForceAllGrabTargetsDetach(TEnumAsByte<EGrabState> State);
	void STATIC_EndPhysGrab(bool bInterrupted);
	void StartPhysGrab(class ATgPawn* Source, float fTime, TEnumAsByte<EGrabState> grabState, const struct FName& grabSocket, const struct FVector& grabLocOffset, const struct FRotator& grabRotOffset);
	void DefaultTweenEnd(bool bInterrupted);
	void EndTween(TEnumAsByte<ETweenState> endingTweenState, bool bInterrupted);
	void STATIC_PlayHitReaction(int BitPackedHitReaction);
	void STATIC_SendHitReaction(unsigned char HitDirection);
	void DefaultTweenStart(bool bCanBeHit, bool bRemoveRoots, bool bCollideWithWorld);
	void BeginTween(TEnumAsByte<ETweenState> newTweenState, bool bCollideWithWorld);
	void STATIC_EndPhysTween(bool bInterrupted);
	void UpdatePhysTweenTargetLocation(const struct FVector& NewTarget, float updatedTime);
	void StartPhysTween(const struct FVector& Target, float fTime, TEnumAsByte<ETweenState> tweenState, bool bCollideWithWorld, bool bRotateTowardsTarget);
	struct FVector STATIC_GetPhysTweenTargetLocation();
	void RemoveAllEffectsOnDeath();
	void CleanUpDyingEffects();
	void STATIC_OnSwapToDestroyedMesh();
	void AttachDeathAnimationFX(int SpecialFXId, const struct FName& SocketName);
	struct FName STATIC_GetDeathAnimName();
	void RagdollPawn();
	void STATIC_HideMeshForDeath();
	void STATIC_PlayDeathAnimation();
	bool AllowRagdoll();
	void PlayDyingEffects();
	void FindNewTargetTimer();
	void PlayDying(class UClass* dmgType, const struct FVector& HitLoc);
	bool STATIC_IsMonster();
	bool STATIC_IsFiringMelee();
	void STATIC_ClientTriggerGlobalEventClass(class UClass* InEventClass, class AActor* InInstigator, int ActivateIndex);
	void PlayWaterFxIndependant(const struct FVector& HitLocation, const struct FVector& HitNormal, int fxId, class UTgSpecialFx** Fx);
	void PlayWaterEnterExitFx(bool bPlayEnter);
	bool ComputeWaterDepth(bool isEnterExit, struct FVector* HitLocation, struct FVector* HitNormal, int* isShallow);
	void ExitedWaterFXVolume();
	void STATIC_ManageWaterWadeFX();
	void EnteredWaterFXVolume();
	bool STATIC_IsFallingTypePhysics();
	struct FName STATIC_GetFootStepOverride();
	void STATIC_PlayFootStepSound(int FootDown, TEnumAsByte<EFootstepTypes> FootStepType);
	void STATIC_PlayLandingSound(const struct FVector& LandingVelocity);
	void CalculateMaterialSwitch(const struct FVector& TraceStart, const struct FVector& TraceEnd, struct FVector* HitLocation);
	void StopSpecialJumpFx();
	void STATIC_PlaySpecialJumpFx();
	void StopJumpFx();
	void STATIC_PlayJumpFx();
	void STATIC_PlayTeleportEffects(const struct FVector& OriginLocation);
	void STATIC_PlayPreTeleportEffects();
	void STATIC_PlayJumpSound();
	struct FString GetDebugName();
	void STATIC_PostureTransitionEnded(TEnumAsByte<ETG_POSTURE> PostureThatEnded);
	void FaceRotation(const struct FRotator& NewRotation, float DeltaTime);
	void STATIC_InterceptInputDeltaRotation(struct FRotator* rDeltaRotation);
	void STATIC_GetCameraZoomOverride(float* fZoom, float* fZoomDuration);
	bool STATIC_CalcCamera(float fDeltaTime, struct FVector* out_CamLoc, struct FRotator* out_CamRot, float* out_FOV);
	void STATIC_EndViewTarget(class APlayerController* PC);
	void STATIC_BecomeViewTarget(class APlayerController* PC);
	float STATIC_GetPlayerHealthForRender();
	struct FString STATIC_GetPlayerTagForRender();
	struct FString STATIC_GetPlayerNameForRender();
	struct FColor STATIC_GetTargetBoxColor(class ATgPawn* LocalPlayerPawn);
	void STATIC_OnGroupChange();
	void NotifyLocalPlayerTeamReceived();
	void NotifyTeamChanged();
	int STATIC_GetColumnBasedOnIndex(int nIndex);
	int STATIC_GetRowBasedOnIndex(int nIndex);
	int STATIC_GetY2CoordBasedOnIndex(int nIndex);
	int STATIC_GetX2CoordBasedOnIndex(int nIndex);
	int STATIC_GetY1CoordBasedOnIndex(int nIndex);
	int STATIC_GetX1CoordBasedOnIndex(int nIndex);
	class ATgPawn* STATIC_GetLocalPlayerPawn();
	void DamageTakenRTPCReset();
	void DamageTakenMaxReset();
	bool STATIC_LoadPlayerIcons();
	void STATIC_DrawMultiLineText(class UCanvas* Canvas, const struct FString& Text, int X, int Y, int LineHeight);
	void STATIC_ModifyHealthProp(int nDamage);
	void SetHealth(int NewHealth);
	void STATIC_AdjustDamage(class AController* InstigatedBy, const struct FVector& HitLocation, class UClass* DamageType, const struct FTraceHitInfo& HitInfo, class AActor* DamageCauser, int* InDamage, struct FVector* Momentum);
	void STATIC_EndPulseStealth();
	void PulseStealth();
	void TakeHealing(float fHealAmount);
	int TakeArmorDamage(int fDamage, class UClass* DamageType);
	int TakeShieldDamage(int fDamage, class UClass* DamageType);
	void STATIC_TakeDamage(int Damage, class AController* InstigatedBy, const struct FVector& HitLocation, const struct FVector& Momentum, class UClass* DamageType, const struct FTraceHitInfo& HitInfo, class AActor* DamageCauser);
	void STATIC_DrawAIDebug(class UCanvas* Canvas, const struct FVector& ScreenLoc);
	void NotifyTakeHit(class AController* InstigatedBy, const struct FVector& HitLocation, int Damage, class UClass* DamageType, const struct FVector& Momentum, class AActor* DamageCauser);
	void STATIC_SendNotifyTakeHit(class AController* InstigatedBy, const struct FVector& HitLocation, int Damage, class UClass* DamageType, const struct FVector& Momentum);
	void PlayTakeHit(const struct FVector& Direction, int Damage, class UClass* dmgType, struct FExtraDamageInfo* ExtraInfo);
	void PlayTakeHitEmote(int Damage, TEnumAsByte<EHitAudioCue> eCue);
	void STATIC_PlayHitReactionMaterialPulse();
	void EndHeal3P();
	void STATIC_PlayHeal3P();
	void RememberPlayerAttackerExpired();
	void StopPlayFiring();
	void STATIC_ClearFlashLocation(class AWeapon* Who);
	void STATIC_ClearFlashCount(class AWeapon* Who);
	void IncrementFlashCount(class AWeapon* Who, unsigned char FireModeNum);
	void STATIC_PawnGeneric3Flashed();
	void STATIC_PawnGeneric2Flashed();
	void STATIC_PawnGeneric1Flashed();
	void ForceUpdate1PMeshes();
	bool STATIC_CanApplyEffects();
	void STATIC_OnDeviceFormInterruptFire(int nEquipSlot);
	bool ShouldStopWeaponMeshFireEffectsOnDeviceFormStopFire(int nEquipSlot);
	void STATIC_OnDeviceFormStopFire(int nEquipSlot, bool bForceBlendOutOnAnimEnd);
	void PostRecallTimerToKillParticles();
	void STATIC_OnDeviceFormHit(int nEquipSlot, class AActor* Target, float DamageAmount, const struct FVector& HitLocation, const struct FVector& HitNormal, struct FExtraDamageInfo* ExtraInfo);
	void STATIC_OnDeviceFormFire(int nEquipSlot, float fRefireTime, int nFireMode);
	void AddVisualRecoil(int nEquipSlot, float fFireDuration);
	void STATIC_OnDeviceFormStartFire(int nEquipSlot, float FireDuration, int nFireMode, int nAmmoRemaining, bool bForceBlendOutOnAnimEnd);
	void STATIC_OnDeviceFormBuildup(int nEquipSlot, float fBuildupTime);
	bool STATIC_HasLeftItemShop();
	bool STATIC_IsInItemShop();
	void SyncDeviceTimers(class ATgDevice* SourceDevice, class ATgDevice* DestinationDevice);
	void SwapEquippedDevices(class ATgDevice* newDev, int nEqpSlot);
	void STATIC_RestartAllDevices();
	void ClientStopFiringAllDevices(bool bClearEquipEffectFlag, bool bResetCooldowns, bool bKeepFiringMount, bool bServerDeviceLockout);
	void PutAllCardsOnCooldown();
	void StopFiringAllDevices(bool bClearEquipEffectFlag, bool bResetCooldowns, bool bKeepFiringMount, bool bServerDeviceLockout);
	void StopAction(class ATgDevice* Dev, bool bLeftMouse);
	bool StartAction(class ATgDevice* Dev, bool bLeftMouse, bool bUpdateTimeStamp, TEnumAsByte<EDeviceFailType>* failType);
	class ATgDevice* STATIC_GetChickenDevice(bool bLeftMouse);
	void STATIC_AnimSwapDevice();
	void UIH();
	void UpdateInHand(bool bForceFastClear);
	void STATIC_OnDeviceFormExitedTargetingMode(class UTgDeviceForm* form);
	void STATIC_OnDeviceFormEnteredTargetingMode(class UTgDeviceForm* form);
	void EquipPendingDeviceTimer(bool SkipPlayAnim);
	void ShowAnimSets();
	void STATIC_PutInHandDeviceAwayFast(class UTgDeviceForm* form);
	bool CanChangeInHandDeviceOrMode();
	void STATIC_KillAllOwnedPets(bool bGameModeSource);
	void Destroyed();
	bool Died(class AController* Killer, class UClass* dmgType, const struct FVector& HitLocation);
	bool CanBeRevivedBy(class ATgPawn* OtherPawn);
	void PolymorphIntoRoyaleChicken(class ATgPawn* pKiller);
	void STATIC_ReviveSelf();
	void ClientBeginSelfRevive();
	void BeginSelfRevive();
	bool ShouldScoreDown();
	bool ShouldScoreKill();
	void UpdateDeathReason();
	void STATIC_TakeFallingDamage();
	void STATIC_OnJoinTeam(class UTgSeqAct_JoinTeam* Action);
	void STATIC_DespawnOnReconnect();
	void STATIC_Despawn();
	void STATIC_Suicide();
	void SetDeathZoomInfo(class ATgPawn* theKiller, class ATgRepInfo_Player* theKillerPRI, int nHealthPct, int nDeviceId, class ATgRepInfo_Player* OwnerPRI);
	void STATIC_PreRender(class UCanvas* Canvas);
	bool STATIC_IsCustomCharacter();
	void STATIC_MissionTimeUpdate();
	bool STATIC_PostPawnSetup();
	void STATIC_QueueDeviceFormChanged();
	void CrushedBy(class APawn* OtherPawn);
	void SetupPIEMesh(TEnumAsByte<EPIEPawnMeshTypes> PIEPawnType, int BotId);
	void ClearSpawnFxTimer();
	void PostBeginPlay();
	void SetLocalPlayer();
	void PreBeginPlay();
	TEnumAsByte<EAsyncLoadPriority> STATIC_GetDefaultAsyncLoadPriority();
	void SetAsyncLoadPriority(TEnumAsByte<EAsyncLoadPriority> Priority);
	void AllManifestsLoaded();
	void STATIC_ResetMountAnimNodes();
	void ToggleSkelControlLocks(bool bOn);
	void ClearMultiMeshAnimNodeReferences();
	void CacheSkelControlLocks(class UTgSkeletalMeshComponent* smcomp);
	void CacheMultiMeshAnimNodeReferences(class UTgSkeletalMeshComponent* smcomp);
	void CacheMainMeshReferences(class UTgSkeletalMeshComponent* smcomp);
	void STATIC_PostInitAnimTree(class USkeletalMeshComponent* SkelComp);
	void STATIC_OnDespawnBots(class UTgSeqAct_DespawnBots* inAction);
	void STATIC_OnKillpawns(class UTgSeqAct_Killpawns* Action);
	void Falling();
	void STATIC_CollisionChanged();
	void STATIC_OnSetCrowdControlImmune(class UTgSeqAct_SetCrowdControlImmune* inAction);
	void STATIC_OnUIAlert(class UTgSeqAct_UIAlert* Action);
	void STATIC_OnSetTaskforce(class UTgSeqAct_SetTaskforce* Action);
	void STATIC_OnGetTaskForceNumber(class UTgSeqAct_GetTaskForceNumber* Action);
	void STATIC_OnGetTeamIndex(class UTgSeqAct_GetTeamIndex* Action);
	void STATIC_UnPossessed();
	void PossessedBy(class AController* C, bool bVehicleTransition);
	void STATIC_GetAimAssistBounds(struct FVector* ObserverLocation, float* Width, float* Height, struct FVector* Center);
	bool STATIC_PopPosture(int PostureID);
	int STATIC_PushPosture(TEnumAsByte<ETG_POSTURE> Posture);
	void STATIC_SetTalent(int nIndex, int nDeviceId);
	void STATIC_ToggleShieldMesh(bool bShow);
	void ApplyTalent(int nValue);
	void STATIC_ReapplyTalents();
	void EnableStatEffect(int nIndex);
	void DisableStatEffect(int nIndex, float fDuration);
	void STATIC_ReapplyStatEffects();
	bool ApplyStatEffect(int nDeviceId);
	bool CreateSpecialFxForPawn(int nSpecialFxId, const struct FName& nmSocket, class UTgSpecialFx** pFxStorage);
	bool STATIC_IsSimulatedEmote(TEnumAsByte<EEmote> Emote);
	void EmoteForgeItem(int nEventIndex);
	void ForceUnCrouch(int bClientSimulation);
	void STATIC_LoadDefaultWeaponAnimSet();
	void SetSkydiveAnimState(TEnumAsByte<ESkydivingState> eState);
	void STATIC_OnSkydiveAnimEnd();
	void STATIC_HideShowArmor(bool bShow);
	void STATIC_OnDeviceFormCreated(class UTgDeviceForm* pDeviceForm);
	unsigned char STATIC_GetSwappedEquipSlots(unsigned char eEquipSlot);
	void STATIC_NotifyWeaponAnimSetRemoved();
	void SimulatePickup(class ATgDeployable* pPickupDeploy, bool bSecondary);
	void STATIC_InterruptADSDevices(class ATgDevice* pDevice);
	bool CanSprint();
	bool CanCrouch();
	void STATIC_OnMarkedTarget(class ATgPawn* pTarget, int nMarkCountChange);
	void RemovePawnDiedFXMaterials();
	void PlayPawnDiedFX();
	bool ShouldSwapAltAndInhandInputs();
	void STATIC_OnDismount();
	void STATIC_OnLeaveItemShop();
	void STATIC_OnEnterItemShop();
	void BeginBigHeadModeRTPC();
	void EndLocalDeathRTPC();
	void BeginLocalDeathRTPC();
	void EndLocalKillRTPC();
	void BeginLocalKillRTPC();
	void FxActivateIndependant(const struct FName& nmGroup, int nMode, const struct FVector& HitLocation, const struct FVector& HitNormal, int nSocketIndex, int nEquipSlot, bool bUseSocketOverride, bool bBody, bool bHead, bool bWeapon1p, bool bWeapon3p);
	void FxDeactivateGroupWeapon3P(const struct FName& nmGroup, int nMode, int nSocketIndex, int nEquipSlot);
	class UObject* FxReactivateGroupWeapon3P(const struct FName& nmGroup, int nMode, int nSocketIndex, int nEquipSlot, bool bIgnoreRelevancy, bool bFromEffectForm);
	class UObject* FxActivateGroupWeapon3P(const struct FName& nmGroup, int nMode, int nSocketIndex, int nEquipSlot, bool bIgnoreRelevancy, bool bFromEffectForm);
	void FxDeactivateGroupWeapon1P(const struct FName& nmGroup, int nMode, int nSocketIndex, int nEquipSlot);
	class UObject* FxReactivateGroupWeapon1P(const struct FName& nmGroup, int nMode, int nSocketIndex, int nEquipSlot, bool bIgnoreRelevancy, bool bFromEffectForm);
	class UObject* FxActivateGroupWeapon1P(const struct FName& nmGroup, int nMode, int nSocketIndex, int nEquipSlot, bool bIgnoreRelevancy, bool bFromEffectForm);
	void FxDeactivateGroupWeapon(const struct FName& nmGroup, int nMode, int nSocketIndex, int nEquipSlot);
	void FxReactivateGroupWeapon(const struct FName& nmGroup, int nMode, int nSocketIndex, int nEquipSlot, bool bIgnoreRelevancy, bool bFromEffectForm);
	void FxActivateGroupWeapon(const struct FName& nmGroup, int nMode, int nSocketIndex, int nEquipSlot, bool bIgnoreRelevancy, bool bFromEffectForm);
	void FxDeactivateGroupHead(const struct FName& nmGroup, int nMode, int nSocketIndex, int nEquipSlot);
	class UObject* FxReactivateGroupHead(const struct FName& nmGroup, int nMode, int nSocketIndex, int nEquipSlot, bool bIgnoreRelevancy, bool bFromEffectForm);
	class UObject* FxActivateGroupHead(const struct FName& nmGroup, int nMode, int nSocketIndex, int nEquipSlot, bool bIgnoreRelevancy, bool bFromEffectForm);
	void FxDeactivateGroupBody(const struct FName& nmGroup, int nMode, int nSocketIndex, int nEquipSlot);
	class UObject* FxReactivateGroupBody(const struct FName& nmGroup, int nMode, int nSocketIndex, int nEquipSlot, bool bIgnoreRelevancy, bool bFromEffectForm);
	class UObject* FxActivateGroupBody(const struct FName& nmGroup, int nMode, int nSocketIndex, int nEquipSlot, bool bIgnoreRelevancy, bool bFromEffectForm);
	void FxDeactivateGroupSelf(const struct FName& nmGroup, int nMode, int nSocketIndex, int nEquipSlot);
	void FxReactivateGroupSelf(const struct FName& nmGroup, int nMode, int nSocketIndex, int nEquipSlot, bool bIgnoreRelevancy, bool bFromEffectForm);
	void FxActivateGroupSelf(const struct FName& nmGroup, int nMode, int nSocketIndex, int nEquipSlot, bool bIgnoreRelevancy, bool bFromEffectForm);
	void FxDeactivateGroupAllMesh(const struct FName& nmGroup, int nMode, int nSocketIndex, int nEquipSlot, bool bSkipWeaponMesh);
	void FxActivateGroupAllMesh(const struct FName& nmGroup, int nMode, int nSocketIndex, int nEquipSlot, bool bIgnoreRelevancy, bool bFromEffectForm, bool bSkipWeaponMesh);
	void DropInventory();
	void DropHealthNuggetTeamOnly(int nTaskForce, const struct FVector& SpawnVelocity, float fHealOverride, float fHoTOverride);
	void DropHealthNugget(const struct FVector& SpawnVelocity, float fHealOverride, float fHoTOverride);
	void ToggleSilhouetteVisibilityForObserverSpectator(bool bVisible);
	void ToggleSilhouetteVisibility(bool bVisible, bool bDead);
	void SetSilhouetteState(class UMeshComponent* ParentMesh, TEnumAsByte<EOverlayState> NewState);
	bool RemoveSilhouetteInfo(class UMeshComponent* ParentMesh);
	int FindSilhouetteInfo(class UMeshComponent* ParentMesh);
	void ReinitializeSilhouettes();
	int STATIC_InitializeSilhouetteComponent(class UMeshComponent* InMesh);
	void ClearReplacementMaterial();
	void ReplaceMaterial(class UMaterialInstanceConstant* materialToUse, float ParamValue);
	bool ShouldForceHideOverlaysWeapon();
	bool ShouldForceHideOverlaysBody();
	void ToggleOverlay1P3P(bool bActivate1P);
	void UpdateOverlayVisibilityWeapon();
	void UpdateOverlayVisibilityBody();
	void SwapOverlayMICsWeapon(TEnumAsByte<EOverlayMICType> Type);
	void SwapOverlayMICsBody(TEnumAsByte<EOverlayMICType> Type);
	bool RemoveOverlayInfo(class USkeletalMeshComponent* ParentMesh);
	void ReinitializeOverlays();
	bool STATIC_Is3PWeaponOverlay(TEnumAsByte<EOverlayMICType> Type);
	bool STATIC_Is3PBodyOverlay(TEnumAsByte<EOverlayMICType> Type);
	bool STATIC_Is1PWeaponOverlay(TEnumAsByte<EOverlayMICType> Type);
	bool STATIC_Is1PBodyOverlay(TEnumAsByte<EOverlayMICType> Type);
	TEnumAsByte<ESceneDepthPriorityGroup> STATIC_GetOverlayDepthPriority(TEnumAsByte<EOverlayMICType> Type);
	class UMaterialInstanceConstant* STATIC_GetOverlayMaterial(TEnumAsByte<EOverlayMICType> Type);
	class UMaterialInstanceConstant* STATIC_InitializeOverlayInfo(TEnumAsByte<EOverlayMICType> Type, class UTexture* NormalMap, class UTexture* MaskMap);
	int STATIC_InitializeOverlayIndexWeapon(class USkeletalMeshComponent* ParentMesh, bool bIs1POverlay);
	int STATIC_InitializeOverlayIndexBody(class USkeletalMeshComponent* ParentMesh, bool bIs1POverlay);
	int STATIC_InitializeOverlayMeshComponent(class USkeletalMeshComponent* InMesh, bool bIs1POverlay);
	void CacheHitReactionSkelControls();
	void PostPawnSetupServer();
	void STATIC_OnMeshSwapped();
	void SwapToLiveMesh();
	void SwapToDestroyedMesh();
	void AddBodyMesh();
	void RetouchAllVolumes();
	void EffectGroupOnSetActive(bool bActive, bool bRemoving, class UTgEffectGroup* effectGroup);
	void DeployableOnRemoveEffect(class ATgDeployable* dep, class AActor* HitActor);
	void DeployableOnApplyEffect(class ATgDeployable* dep, class AActor* HitActor);
	void DeployableOnDestroyed(class ATgDeployable* dep);
	void DeployableOnDeployed(class ATgDeployable* dep);
	class UClass* DeviceOnOverrideDamageType(class ATgDevice* Dev, class UTgEffectGroup* effectGroup);
	void DeviceOnSetFireMode(class ATgDevice* Dev);
	bool DeviceHasEnoughPowerPool(class ATgDevice* Dev, unsigned char FireModeNum);
	void DeviceAdjustCooldown(class ATgDevice* Dev, float* fCooldown);
	void DeviceAdjustShield(class ATgDevice* Dev, float* fShield);
	void DeviceAdjustHeal(struct FAdjustHealParams* Params, float* fHeal);
	void DeviceAdjustRadius(class ATgDevice* Dev, float* fRadius);
	void DeviceAdjustDamage(struct FAdjustDamageParams* Params, float* fDamage);
	void DeviceOnKilled(class ATgDevice* Dev, float fDamage, struct FImpactInfo* Impact);
	void DeviceOnHealed(struct FOnHealedParams* Params);
	void DeviceOnDamaged(struct FOnDamagedParams* Params);
	void DeviceOnHitSpecial(class ATgDevice* Dev, int nHitSpecialSituationalType, struct FImpactInfo* Impact);
	void STATIC_DeviceOnHit(class ATgDevice* Dev, struct FImpactInfo* Impact);
	void DeviceOnPostHit(class ATgDevice* Dev);
	void DeviceOnStopCooldown(class ATgDevice* Dev);
	void DeviceOnTickCooldown(class ATgDevice* Dev, class UTgTimerManager* pTimerManager);
	void DeviceOnStartCooldown(class ATgDevice* Dev, float* fCooldownTime);
	void DeviceInitialize(class ATgDevice* Dev);
	void DeviceOnGetPostHit(class ATgDevice* Dev, float* fDelay);
	void STATIC_DeviceOnStopFire(class ATgDevice* Dev, bool WasInterrupted);
	void STATIC_DeviceOnStartFire(class ATgDevice* Dev);
	void STATIC_ProjectileOnFire(class ATgProjectile* Proj);
	void STATIC_DeviceOnFire(class ATgDevice* Dev);
	void STATIC_DeviceOnStopBuildup(class ATgDevice* Dev, bool WasInterrupted);
	void STATIC_DeviceOnStartBuildup(class ATgDevice* Dev);
	void DeviceOnHeld(class ATgDevice* pDevPrevious, class ATgDevice* pDevNext);
	void STATIC_PawnOnGetModifiedADSSpeed(float* fSpeed);
	void STATIC_PawnOnGetADSTime(float* fZoomInTime);
	void STATIC_PawnOnTeleported(class ATgSpawnTeleporterEntrance* From, class ATgSpawnTeleporterExit* To, const struct FVector& OriginalPawnLocation);
	void STATIC_PawnOnPetDied(class ATgPawn* pet, class ATgPawn* PetOwner);
	void STATIC_PawnOnPetAdded(class ATgPawn* pet, class ATgPawn* PetOwner);
	void STATIC_PawnOnDamageInterruptedStealth();
	void STATIC_PawnOnLandAfterLeap();
	void STATIC_PawnOnLandAfterJump();
	void STATIC_PawnOnLand();
	void STATIC_PawnOnPetSuccessfulHit(int nFxID);
	void STATIC_PawnOnEndSprint();
	void STATIC_PawnOnStartSprint();
	bool STATIC_PawnCanDisplayImmuneMessage();
	void STATIC_PawnOnModifyEffectLifeTime(class UTgEffectGroup* eg, float* fLifetime);
	void STATIC_PawnOnTaskforceAdd(class ATgRepInfo_TaskForce* tf);
	void STATIC_PawnOnTaskforceRemove(class ATgRepInfo_TaskForce* tf);
	void STATIC_PawnOnGetForgeDevice(int nBotId, int* nDeviceId, int* nIndex, TArray<class UTgCached_LootItem*>* pItems, TArray<int>* pExcludedList);
	void STATIC_PawnOnGetForgeDuration(int* nDuration, int* nIndex);
	void STATIC_PawnOnGetForgeCost(int* nShards, int* nIndex);
	void STATIC_PawnOnGetDisenchantValue(int* nShards);
	void STATIC_PawnOnCurrency(class AActor* Source, int* nCurrency);
	void STATIC_PawnOnXp(class AActor* Source, int* nXp);
	void STATIC_PawnOnEndStill();
	void STATIC_PawnOnBecomeStill();
	void STATIC_PawnOnExitCombat();
	void STATIC_PawnOnEnterCombat();
	void STATIC_PawnOnRevive();
	void STATIC_PawnOnDied(class AController* pKilller);
	void STATIC_PawnOnAssistedDown(class AActor* pVictim);
	void STATIC_PawnOnDowned(class AActor* pKiller, class AActor* pVictim);
	void STATIC_PawnOnAssisted(class AActor* pVictim);
	void STATIC_PawnOnChickenRevived(class AActor* pChicken, float* nHealth);
	void STATIC_PawnOnKilled(class AActor* pKiller, class AActor* pVictim);
	void STATIC_PawnOnHealed(struct FOnHealedParams* Params);
	void STATIC_PawnOnDamageMitigation(class ATgPawn* attacker, class UTgEffectGroup* eg, int nPropertyId, float* fDamage);
	void STATIC_PawnOnPreDamageMitigation(class ATgPawn* attacker, class UTgEffectGroup* eg, int nPropertyId, float* fDamage);
	void STATIC_PawnOnDamaged(struct FOnDamagedParams* Params);
	void SetSpawnEnergy();
	void SetSpawnMana();
	void SetSpawnHealth();
	float STATIC_GetProcChanceMultiplier();
	float STATIC_GetUIGroundSpeed();
	float STATIC_GetBackpedalPercent();
	bool STATIC_GetMinimapRequireLOS();
	float STATIC_GetHealBlock();
	float STATIC_GetDamageDealtFlat();
	float STATIC_GetDamageDealtToFrontlinePerc();
	float STATIC_GetDamageDealtPercShieldTarget();
	float STATIC_GetDamageDealtPercDeployableTarget();
	float STATIC_GetDamageDealtPerc(int nDamageType, bool bInHand);
	float STATIC_GetDamageCapPercCurHP();
	float STATIC_GetDamageCapPercMaxHP();
	float STATIC_GetProtectionCC();
	float STATIC_GetHealingTakenOthersScale();
	float STATIC_GetHealingTakenScale();
	float STATIC_GetHealingDealtScale();
	float STATIC_GetVisionRange();
	float STATIC_GetArmorHealth();
	float STATIC_GetMaxArmorHealth();
	float STATIC_GetMaxShieldHealth();
	float STATIC_GetMaxHealthWithoutPercentBuff();
	float STATIC_GetMaxEnergy();
	float STATIC_GetEnergy();
	float STATIC_GetEnergyRegen();
	float STATIC_GetManaRegen();
	float STATIC_GetHealthRegen();
	float STATIC_GetCombatDurationReduction();
	bool STATIC_IsLifeStealTarget(class ATgPawn* Target);
	float STATIC_GetUtilityPowerItem();
	float STATIC_GetMagicalPowerItem();
	float STATIC_GetPhysicalPowerItem();
	float STATIC_GetUtilityPowerBot();
	float STATIC_GetMagicalPowerBot();
	float STATIC_GetPhysicalPowerBot();
	float STATIC_GetUtilityPower();
	float STATIC_GetMagicalPower();
	float STATIC_GetPhysicalPower();
	void CalculateMountGroundAlignment();
	void STATIC_ResetMountGroundAlignment(bool bResetPrevious);
	void STATIC_UpdateMountGroundAlignment(float DeltaSeconds);
	void CacheMountLeanControl();
	void UpdateMountScale(bool bIsMounted);
	bool ShouldRagdollOnDeath(class UClass* m_DamageType);
	bool STATIC_HasDeathPostureAnimation();
	void ClientUpdateShardCount(int n_ShardCount);
	void ServerAcknowledgeShardPickup();
	bool ServerUpdateLockedTarget(class AActor* Locked);
	float STATIC_GetMaxPowerPoolValue(int nPacingType);
	float STATIC_GetCurrentPowerPoolValue(int nPacingType);
	void ConsumePowerPool(class ATgDevice* Dev, int nPacingType, float fAmount);
	bool STATIC_IsInFireLock();
	bool CanKnockbackAffectAC();
	float GetAirControl();
	void STATIC_OnSetPlayerLevel(class UTgSeqAct_SetPlayerLevel* Action);
	float STATIC_NativeGetCollisionRadius();
	float STATIC_NativeGetCollisionHeight();
	void STATIC_OnPostureChange();
	void STATIC_OnProjectileHitTarget(class ATgProjectile* HittingProjectile, const struct FVector& HitLocation, const struct FVector& HitNormal, unsigned char* bDestroyProjectile);
	void STATIC_OnProjectileExploded(class ATgProjectile* ExplodedProjectile, class AActor* HitActor, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_OnLevelUp();
	bool STATIC_NativeReplicatedEvent(const struct FName& VarName);
	struct FVector STATIC_GetTargetCenter();
	void CheckUiVolumeTriggers();
	class AActor* STATIC_GetActorFromCombatActor();
	class AActor* STATIC_GetPetOwner();
	bool STATIC_IsPet();
	TEnumAsByte<EGameplayDesignType> STATIC_GetDesignType();
	class ATgEffectManager* STATIC_GetEffectManager();
	void DisplayDebugProperty(TArray<struct FString>* sPropertyStrings, struct FString* sPropText, struct FString* sValueText);
	bool STATIC_IsMarkedForMarkShot();
	float STATIC_GetMarkedPercentInhand(class AActor* InstigatorPawn);
	float STATIC_GetMarkedPercent(class AActor* InstigatorPawn);
	int STATIC_GetPropIndex(int nPropId);
	float STATIC_GetPropCurrentValueByName(const struct FString& propName);
	float STATIC_GetPropCurrentValue(int nPropIndex);
	float STATIC_GetPropBaseValue(int nPropIndex);
	void STATIC_HandleNotificationsForAI(float fStatChange, class ATgPawn* InstigatorPawn);
	float STATIC_GetDamageToLeaveStealth();
	void TakeStealthDamage(float fDamage);
	int TakePersonalArmorDamage(float fDamage, class AController* InstigatedBy, class UClass* DamageType, const struct FImpactInfo& Impact, class AActor* DamageCauser, struct FExtraDamageInfo* ExtraInfo);
	bool ShieldDamageAppliesToHealth();
	int TakePersonalShieldDamage(float fDamage, class AController* InstigatedBy, class UClass* DamageType, const struct FImpactInfo& Impact, class AActor* DamageCauser, struct FExtraDamageInfo* ExtraInfo);
	bool CanUsePersonalShield();
	bool CanTakeShieldDamage();
	void TakeManaDamage(float fDamage, class AController* InstigatedBy, class UClass* DamageType, const struct FImpactInfo& Impact, const struct FExtraDamageInfo& ExtraInfo, class AActor* DamageCauser);
	bool CanTakeManaDamage();
	bool CanBeLifestealTarget();
	bool CanBeLifestealInstigator();
	bool WillHitSuccessfully(class AActor* aInstigator, const struct FImpactInfo& Impact);
	void TakeHealthDamage(float fDamage, class AController* InstigatedBy, class UClass* DamageType, const struct FImpactInfo& Impact, const struct FExtraDamageInfo& ExtraInfo, class AActor* DamageCauser);
	void STATIC_MitigateHealthDamage(class ATgPawn* pInstigator, class UTgEffectDamage* Effect, const struct FImpactInfo& Impact, bool bIsHeadshot, float* NewValue, float* fPercReduction);
	float STATIC_GetSpecialDamageTakenPercentAI();
	float STATIC_GetSpecialDamageDealtPercentAI();
	void BuffDamage(class AActor* Target, class UTgEffectDamage* Effect, const struct FImpactInfo& Impact, float fBaseDamage, float* fProratedAmount, struct FExtraDamageInfo* ExtraInfo);
	bool STATIC_IsImmuneToHealing();
	bool CanBeExecuted();
	bool STATIC_IsImmuneToDamage();
	bool STATIC_OnlyTakeHeadShots();
	bool CanTakeHeadShots();
	bool CanDealHeadShots();
	bool CanTakeHealthDamage();
	float STATIC_GetDiminishedGroundSpeed();
	void STATIC_GetAdditionalLifestealMultipliers(struct FDiminishedEffectInfo* DiminishingInfo, struct FImpactInfo* Impact);
	void STATIC_GetAdditionalDamageTakenMultipliers(class ATgDevice* damagingDevice, struct FDiminishedEffectInfo* DiminishingInfo, struct FImpactInfo* Impact);
	float STATIC_GetMaxShield();
	float STATIC_GetShieldHealth();
	float STATIC_GetMaxMana();
	float STATIC_GetMana();
	float STATIC_GetMaxHealth();
	float STATIC_GetHealth();
	bool STATIC_IsCinematicMode();
	void PostEmoteAkEvent(class UAkEvent* InAkEvent, TEnumAsByte<EEmote> Emote);
	void PostAkEvent(class UAkEvent* InAkEvent);
	class AReverbVolume* STATIC_GettReverbVolumeForAudioAltitude();
	class AReverbVolume* STATIC_GetCurrentReverbVolume();
	void STATIC_UpdateReverbVolume(const struct FVector& WorldLocation, class AReverbVolume* VolumeTouched);
	void SetAkPlayerHealthPercent(float fPercent);
	bool STATIC_MySpawnGatesAreOpen();
	class UPhysicalMaterial* TraceWorldPhysicalGeometry(const struct FVector& StartLoc, const struct FVector& EndLoc, struct FVector* TraceHitLocation);
	struct FVector STATIC_GetChargeDirection();
	void ReloadMeshAssemblies();
	void STATIC_GetMeshAssemblyToUse(int* nBodyAsmId, int* nCoreAsmId);
	void ForceUpdateUncompressedRemoteYaw();
	void SetUncompressedRemoteViewPitch(int Pitch);
	void SmoothCorrectionTranslationTick(float DeltaSeconds, bool bForce);
	void TryToPlayPainAkEvent();
	void UpdateRespawnBeaconReticule(bool bForce);
	bool AllowBoostedJump();
	void STATIC_GiveEnergy(float energy);
	bool STATIC_IsBattlegroundsDeadSpectator();
	bool ShouldBeFirstPersonThisTick(TEnumAsByte<ECameraPerspectiveType>* ePersectiveType);
	bool STATIC_IsThirdPersonForced();
	bool STATIC_IsConfused();
	bool STATIC_IsInOffensiveTween();
	bool STATIC_IsTweenBreakable(TEnumAsByte<ETweenState> tweenState);
	bool STATIC_IsPerformingOffensiveGrab();
	bool STATIC_IsInOffensiveGrab();
	bool STATIC_IsGrabBreakable(TEnumAsByte<EGrabState> tweenState);
	void ResetSkelControls(class USkeletalMeshComponent* SkelComp);
	struct FRotator TweenRelRotation(float fDeltaSeconds, const struct FRotator& currRel, const struct FRotator& targetRel);
	bool STATIC_IsStatTrackable();
	bool STATIC_IsGodDecoy();
	bool STATIC_IsGod();
	float AdjustRespawnTime(float InRespawnTime);
	void ForceUpdateComponents(bool bCollisionUpdate, bool bTransformOnly);
	void UpdateSpectatorStatUI();
	void UpdatePlayerStatUI();
	void PlayCustomAnimation(int nAnimResId, bool bFullBody, float fTime);
	bool STATIC_IsNonCombat();
	bool CanMove();
	void PlayUpperBodyAnim(const struct FName& AnimName, float Rate, float BlendInTime, float BlendOutTime, bool bLooping);
	float PlayFullBodyLoopingAnimWithTransition(const struct FName& TransitionAnimName, const struct FName& LoopingAnimName, float Rate, float BlendInTime, float BlendOutTime);
	bool PlayFullBodyAnim(const struct FName& AnimName, float Rate, float BlendInTime, float BlendOutTime, bool bLooping, bool bOverride, bool bBlendOutIfVelocityIsGreaterThanZero, bool bHideInHandDevice);
	bool STATIC_IsFriendlyWithLocalPawn();
	void RegainEnergyPool(float fDelta);
	void RegainManaPool(float fDelta);
	void RegainPools(float fDelta);
	void SyncMana();
	float STATIC_GetManaPercent();
	float STATIC_GetHealthPercent();
	void SetMeshComponentVectorValue(class UMeshComponent* theMesh, const struct FName& ScalarParam, struct FLinearColor* ColorValue);
	void SetMeshComponentScalarValue(class UMeshComponent* theMesh, const struct FName& ScalarParam, float ScalarValue);
	void SetMeshVectorValue(const struct FName& ScalarParam, struct FLinearColor* ColorValue);
	void SetMeshScalarValue(const struct FName& ScalarParam, float ScalarValue);
	void STATIC_KillDeployables(bool bAll, bool bNoKillProtected);
	struct FVector STATIC_GetLocation();
	bool STATIC_LocalPlayerHasLOS();
	bool STATIC_IsDeployableBlindedFrom(class AActor* Viewer);
	bool STATIC_IsDeployableObscuredFrom(class ATgPawn* Viewer);
	bool STATIC_IsInEnemyObscuringDeployable(class ATgPawn* Viewer);
	bool STATIC_IsInCommonEnemyObscuringDeployable(class ATgPawn* Viewer);
	bool STATIC_IsInFriendlyObscuringDeployable();
	class AActor* STATIC_GetATouchingVisibilityVolume();
	bool STATIC_IsInSameVisibilityVolumeBeacon(class ATgRespawnBeaconExit* Other);
	bool STATIC_IsInSameVisibilityVolume(class ATgPawn* Other);
	int FindVisibilityVolume(class AActor* VisVolume);
	int STATIC_NumVisibilityVolumesTouching();
	void RemoveDetectedFx();
	void PlayDetectedFx();
	bool STATIC_IsDetector();
	bool STATIC_IsHardRevealed(class ATgRepInfo_Player* Viewer);
	bool STATIC_IsHardStealthed();
	bool STATIC_IsStealthed(class ATgRepInfo_Player* Viewer);
	class ATgDevice* STATIC_GetCurrentInhandDevice();
	bool ShouldBlockFiringFrom1pSwitch();
	class ATgDevice* STATIC_GetDeviceById(int nDeviceId);
	class ATgDevice* STATIC_GetDeviceByInstanceId(int nDeviceInstanceId);
	void UpdatePhysicsAsset();
	void STATIC_OnPawnDied();
	void PlaySpawnFx();
	void PrepareIntro();
	void PlaySpecialEffectEvent(int PlaySpecialEffectIndex, const struct FVector& vLoc, const struct FVector& vHitNormal, class AActor* inActor);
	void PlayTeleportFx(int nTeleportState, const struct FVector& vLoc);
	void PlayCurrencyFx(class ATgRepInfo_Player* sourcePRI, int nCurrency, int nMsgId);
	float GetTerminalVelocity();
	void UpdateStealthMaterialBasedOnNearbyEnemies();
	void UpdateDropShadow();
	void STATIC_RecalculateMaterial(bool bIsFriendlyWithLocalPawn, bool bForce);
	void ForceRecalculateMaterial();
	bool STATIC_HandleAutofireDevices();
	bool CanBeAffectedByVortices();
	bool ShouldShowHudOverlay(class ATgPawn* PlayerPawn);
	bool STATIC_OverrideDistanceFadeRange();
	void CalcBlindingDeployableFadeValue(float fDeltaTime);
	void CalcObscuringDeployableFadeValue(float fDeltaTime);
	void CalcStealthFadeValue(float fDeltaTime);
	void CalcDistanceFadeValue(float fDeltaTime);
	void CalcVolumeFadeValue(float fDeltaTime);
	bool STATIC_IsHittable();
	bool IsInvisibleToAI();
	bool ShouldInHandDeviceBeHiddenThisTick();
	TEnumAsByte<ETgMeshVisibilityState> STATIC_GetMeshVisibilityStateThisTick();
	void PlaySoundCue(int nSoundCueId);
	void SetPhase(int nNewPhase);
	void UpdateHUDScores();
	void TrackDeath();
	void TrackKill(class ATgPawn* Killer);
	void UpdateEnemyAssists(class ATgPawn* Assister);
	void UpdateDamagers(class ATgPawn* Damager);
	void TrackDamageMitigated(int nAmount);
	void TrackDamageTaken(class ATgPawn* theInstigator, int nDamage, int nDamageType);
	void TrackSelfKill(int nDeviceModeID);
	void TrackTeamKill(int nDeviceModeID);
	void TrackSelfDamage(int nDeviceModeID, int nDamage);
	void TrackTeamDamage(int nDeviceModeID, int nDamage);
	void TrackReleaseTime(int nDeviceModeID, float fReleaseTime);
	void TrackHit(int nDeviceModeID, float fDistance, bool bHitPlayer);
	void RemoveTrackFired(int nDeviceModeID);
	void TrackCompleteKillInfo(int nKillerCharacterID, int nKillerDeviceModeID, int nVictimCharacterID, int nVictimDeviceModeID, const struct FVector& KillerLocation, const struct FVector& VictimLocation, const struct FVector& PetLocation, bool bPetKill);
	void TrackFired(int nDeviceModeID);
	void TrackBotHealing(int nDeviceModeID, float fDamage, float fMissingHealth, int nMaxHealth);
	void TrackSelfHealing(float fHealing, float fMissingHealth, int nMaxHealth);
	void TrackHealing(int nDeviceModeID, float fDamage, float fMissingHealth, int nMaxHealth);
	void TrackKilledBot(int nDeviceModeID);
	void TrackFromPlayerDeath(int nDeviceModeID);
	void TrackKilledPlayer(int nDeviceModeID);
	void TrackDamagedBot(class ATgPawn* TargetPawn, int nDeviceModeID, int nDamage, int nDamageType, bool bIsGod);
	void TrackDamagedPlayer(class ATgPawn* TargetPawn, int nDeviceModeID, int nDamage, int nDamageType, bool bInHand);
	void EndStats();
	void BeginStats();
	void StatsCleanup();
	void ValidateStatsTracker();
	void STATIC_ModifyAccuracyForReticleBloom(float* fAccuracy);
	float STATIC_GetAccuracyModifier(float ClientMovementTimeStamp);
	class ATgRepInfo_Player* STATIC_GetPRI();
	unsigned char STATIC_GetTaskForceNumber();
	void SetTaskForceNumber(int nTaskForce);
	void AdjustMeshTranslation(float fOffset);
	void STATIC_KillOwnedBots();
	void ReportPetDeath(class ATgPawn* PetPawn);
	bool STATIC_IsMyPet(class AActor* Other);
	void STATIC_KillPets();
	void STATIC_KillPet(class ATgPawn* PetPawn);
	void SetPetOwner(class ATgPawn* PetOwner);
	void AddPet(class ATgPawn* PetPawn);
	class UMeshComponent* CreateMeshComponent(int nMeshId, class UMeshComponent* DestComponent, bool bPartialFixup);
	class UTgSpecialFx* STATIC_GetSpecialFx(int nSpecialFxId);
	void SetMeshVisibility(bool bVisible);
	bool CanSeeActor(class AActor* Other);
	bool STATIC_IsJumpDisabled();
	float GetGravityZ();
	void AddRemoveAnimSet(class UAnimSet* pAnimSet, bool bAdd);
	void AddRemoveAnimSetList(TArray<class UAnimSet*> AnimSetList, bool bAdd);
	void CancelEmote(bool bVerifyNoRelevantEmotes, class UTgAnimNodeEmoteSequence* Exclude);
	bool STATIC_TermRagdoll();
	void STATIC_OnSpawnGatesOpened();
	void ShowCombo(int nPawnId, bool bCrit);
	void DrawClientDebug();
	bool STATIC_bIsEditor();
	void ReapplyLoadoutEffects(bool bKeepFiringMount, bool bForceRemoveEffects);
	void ReapplyLevelEffectGroups(int nPrevLevel, int nCurrentLevel, bool bPreserveParams);
	void FlashedEventCooldown(int nIndex, int nMode, float fCooldown);
	void FlashCancelPutAway(int nDeviceInstanceId);
	void FlashRetrieve(int nDeviceInstanceId, float fEquipTime);
	void FlashPutAway(int nDeviceInstanceId, float fEquipTime);
	void STATIC_FlashVaultAnim();
	void STATIC_FlashVault(bool bCancel);
	void FlashPawnHealed(struct FOnHealedParams* Params);
	void FlashKillOrAssist(class AActor* Target, bool bIsKill, int nComboCount);
	void FlashHitDirection(const struct FVector& vLocation, int nDamageAmount, class UClass* DamageType, const struct FVector& vInstigatorLocation, struct FExtraDamageInfo* ExtraInfo);
	void FlashTransitionOut(int nDeviceInstanceId, int nFireModeNum, float fTransitionPercent, float fTotalTransitionTime);
	void FlashTransitionIn(int nDeviceInstanceId, int nFireModeNum, float fTransitionPercent, float fTotalTransitionTime);
	void FlashPawnGeneric3(bool bIsSimulated);
	void FlashPawnGeneric2(bool bIsSimulated);
	void FlashPawnGeneric1(bool bIsSimulated);
	void FlashGeneric5(int nDeviceInstanceId, int nFireModeNum, bool bIsSimulated, unsigned char byExtraData);
	void FlashGeneric4(int nDeviceInstanceId, int nFireModeNum, bool bIsSimulated, unsigned char byExtraData);
	void FlashGeneric3(int nDeviceInstanceId, int nFireModeNum, bool bIsSimulated, unsigned char byExtraData);
	void FlashGeneric2(int nDeviceInstanceId, int nFireModeNum, bool bIsSimulated, unsigned char byExtraData);
	void FlashGeneric1(int nDeviceInstanceId, int nFireModeNum, bool bIsSimulated, unsigned char byExtraData);
	void FlashPetSuccessfulHit(int nFxID);
	void FlashSpawnSpecialFX(int nFxID, const struct FVector& vLocation, const struct FVector& vNormal);
	void FlashPlaySpecialEffect(int PlaySpecialEffectIndex, const struct FVector& vLocation, const struct FVector& vHitNormal, class AActor* inActor, bool bIsSimulated);
	void FlashLevelupFx();
	void STATIC_FlashTeleportFx(int nTeleportState, const struct FVector& vLocation);
	void FlashChangeMesh();
	void FlashDestruct(int nDeviceInstanceId, const struct FVector& vLocation);
	void FlashHitReaction();
	void FlashModeEquipDone(int nDeviceInstanceId, int nFireModeNum);
	void FlashEventUpdate();
	void FlashSuccessfulHit(int nDeviceInstanceId, int nFireModeNum, class AActor* Target, float DamageAmount, const struct FVector& HitLocation, const struct FVector& HitNormal, const struct FExtraDamageInfo& ExtraInfo);
	void FlashInterrupt(int nDeviceInstanceId);
	void FlashBlockDone(int nDeviceInstanceId, int nFireModeNum);
	void FlashBlockFx(int nDeviceInstanceId, int nFireModeNum);
	void FlashBlock(int nDeviceInstanceId, int nFireModeNum);
	void FlashCooldownDone(int nDeviceInstanceId, int nFireModeNum);
	void FlashCooldown(int nDeviceInstanceId, int nFireModeNum, float fCooldownTime);
	void STATIC_FlashInterruptReload(int nDeviceInstanceId);
	void FlashReload(int nDeviceInstanceId, float fReloadTime, int nAmmoRemaining, int nReloadAnimType);
	void FlashStartFireHold(int nDeviceInstanceId, int nFireModeNum, float fFireHoldTime);
	void FlashStartFire(int nDeviceInstanceId, int nFireModeNum, float RefireTime, class AActor* Target, int nAmmoRemaining);
	void FlashStopFire(int nDeviceInstanceId, int nFireModeNum);
	void FlashArcing(int nDeviceInstanceId, int nFireModeNum, const struct FVector& vNewLoc, const struct FVector& vOldLoc, class AActor* Target, int nEquipSlot, int nSocketIndex, bool bsuccesfulhit);
	void FlashFireNoSim(int nDeviceInstanceId, int nFireModeNum, const struct FVector& vNewLoc, int nEquipSlot, int nSocketIndex, bool bsuccesfulhit, float RefireTime);
	void FlashFireMulti(int nDeviceInstanceId, int nFireModeNum, const struct FVector& vAimStart, const struct FVector& vAimDir, TArray<float> hitRanges, float fMaxRange, int nSeed, float fSpreadAngle, int nEquipSlot, int nSocketIndex, bool bsuccesfulhit, float RefireTime);
	void FlashFire(int nDeviceInstanceId, int nFireModeNum, const struct FVector& vNewLoc, int nEquipSlot, int nSocketIndex, bool bsuccesfulhit, float RefireTime);
	void STATIC_FlashCustomSpray(int nInxex, const struct FVector& vOrigin, const struct FVector& vAim);
	void FlashCustomEmote(int nIndex);
	void FlashSpray(const struct FVector& vOrigin, const struct FVector& vAim);
	void FlashPlayEmoteExcludeOwner(TEnumAsByte<EEmote> Emote, int ExtraInfo);
	void FlashPlayEmote(TEnumAsByte<EEmote> Emote, int ExtraInfo);
	void FlashBuildUp(int nDeviceInstanceId, int nFireModeNum, int nEquipSlot, int nSocketIndex, float fBuildupTime);
	void FlashTargeting(int nDeviceInstanceId, int nFireModeNum, int nEquipSlot, int nSocketIndex, bool bSuccessfulHit);
	void FlashFireMode(int nDeviceInstanceId, int nFireModeNum);
	void FlashResetReplication();
	struct FVector STATIC_NativeCanvasProject(class UCanvas* CanvasToUse, const struct FVector& vLocation);
	int DrawNameText(class UCanvas* CanvasToUse, float StartX, float StartY, const struct FString& NameString, class UFont* NameFont, const struct FColor& NameColor, float Scale);
	int DrawScaledString(class UCanvas* CanvasToUse, float StartX, float StartY, const struct FString& NameString, class UFont* NameFont, const struct FColor& NameColor, float Scale);
	bool SpecialAOEImmunity(const struct FVector& AOECenter, class UTgDeviceFire* instigatingFiremode);
	void CrowdControlBreak();
	bool STATIC_IsCrowdControlImmune();
	bool STATIC_IsSuperiorCrowdControlImmune();
	bool STATIC_IsDamageOverTimeImmune();
	bool STATIC_IsDebuffImmune();
	void ResetProperties();
	void SetPropCurrentValue(int nPropIndex, float nNewValue);
	void SetProperty(int nPropIndex, float fNewValue);
	struct FTgPropertyInstance STATIC_GetPropertyById(int nPropId);
	struct FTgPropertyInstance STATIC_GetProperty(int nPropIndex);
	void AddProperty(int nPropId, float fBase, float fRaw, float FMin, float FMax);
	void STATIC_InitializeDefaultProps();
	bool ApplyPawnSetup();
	void DeviceFormChanged(bool bForceReload, bool bForceUpdateWeaponMesh);
	class UTgDeviceForm* CreateDeviceForm(const struct FEquipDeviceInfo& Info);
	class ATgDevice* FindEquippedTalentById(int nDeviceId);
	class ATgDevice* FindEquippedTalentByType(class UClass* DeviceClass);
	class ATgDevice* STATIC_GetCardByClass(class UClass* DeviceClass);
	class ATgDevice* STATIC_GetDeviceByEqPoint(int eEqPoint);
	void UpdateClientDevices(bool bForce);
	bool AreAnyOtherOffhandsLockingFiring(class ATgDevice* CurrentDevice);
	void UpdateShieldFX();
	void SetTargetActor(class AActor* Target);
	class ATgPawn* STATIC_GetTargetPawn();
	class AActor* STATIC_GetTargetActor();
	float STATIC_GetUnclampedLagPredictionTime();
	float STATIC_GetLagPredictionTime();
	bool IsPlayerMuted();
	bool STATIC_IsChatMuted();
	void STATIC_ServerRequestCustomEmote(int nIndex);
	void RequestCustomEmote(int nIndex);
	void STATIC_ServerRequestCustomSprayWithAim(int nIndex, const struct FVector& vOrigin, const struct FVector& vAim);
	void STATIC_RequestCustomSprayWithAim(int nIndex, const struct FVector& vOrigin, const struct FVector& vAim);
	void STATIC_RequestCustomSpray(int nIndex);
	void STATIC_ServerRequestSprayWithAim(const struct FVector& vOrigin, const struct FVector& vAim);
	void RequestSprayWithAim(const struct FVector& vOrigin, const struct FVector& vAim);
	void RequestSpray();
	void STATIC_ServerRequestEmote(TEnumAsByte<EEmote> Emote, int ExtraInfo, int nPriority, float fRelevance, float fPause);
	void RequestEmote(TEnumAsByte<EEmote> Emote, int ExtraInfo, int nPriority, float fRelevance, float fPause);
	bool CheckIsInItemShop();
	int STATIC_GetUISkillEqpSlotOverride(int nEquipSlot, bool bAltSlot);
	void STATIC_OnViewTargetChanged(class AActor* aNewViewTarget);
	bool STATIC_GetTurnRotatorOverride(int* nYawOffset);
	bool CanUnCrouch();
	bool CanEquip(class ATgDeployable* pDeployable, int* nErrorCode);
	unsigned char STATIC_GetEquippedTypeSlot(int nDeviceId);
	int STATIC_GetMeshOverrideForUC(int nMeshId);
	void STATIC_On3pTransitionEvent();
};


// Class TgGame.TgPawn_Biped
// 0x013C (0x2FB4 - 0x2E78)
class ATgPawn_Biped : public ATgPawn
{
public:
	struct FName                                       m_nmLeftFootBone;                                         // 0x2E78(0x0008) (Edit)
	struct FName                                       m_nmRightFootBone;                                        // 0x2E80(0x0008) (Edit)
	struct FName                                       m_nmLeftFootControlName;                                  // 0x2E88(0x0008) (Edit)
	struct FName                                       m_nmRightFootControlName;                                 // 0x2E90(0x0008) (Edit)
	float                                              m_fOldLocationZ;                                          // 0x2E98(0x0004)
	unsigned long                                      m_bEnableRightFootPlacement : 1;                          // 0x2E9C(0x0004)
	unsigned long                                      m_bEnableLeftFootPlacement : 1;                           // 0x2E9C(0x0004)
	unsigned long                                      m_bMayDisableFootIKFromAnimNodes : 1;                     // 0x2E9C(0x0004)
	unsigned long                                      m_bInitializedFootIKCachedNodeList : 1;                   // 0x2E9C(0x0004)
	unsigned long                                      m_bApplyLeftHandWeaponIK : 1;                             // 0x2E9C(0x0004)
	unsigned long                                      m_bSetHandIKStrengthFromAnimNodes : 1;                    // 0x2E9C(0x0004)
	unsigned long                                      m_bInitializedHandIKCachedNodeList : 1;                   // 0x2E9C(0x0004)
	unsigned long                                      c_bPlayingRefire : 1;                                     // 0x2E9C(0x0004)
	unsigned long                                      c_bRefireIsUpperBody : 1;                                 // 0x2E9C(0x0004)
	float                                              m_fZSmoothingRate;                                        // 0x2EA0(0x0004) (Const)
	float                                              m_fMaxFootPlacementDistSquared;                           // 0x2EA4(0x0004)
	class USkelControlFootPlacement*                   m_LeftLegControl;                                         // 0x2EA8(0x0008)
	class USkelControlFootPlacement*                   m_RightLegControl;                                        // 0x2EB0(0x0008)
	TArray<struct FName>                               m_FootIKZeroStrengthAnimNodeNameList;                     // 0x2EB8(0x0010) (NeedCtorLink)
	TArray<class UAnimNode*>                           m_FootIKZeroStrengthCachedNodeList;                       // 0x2EC8(0x0010) (NeedCtorLink)
	struct FVector                                     m_vPreviousRightFootPosition;                             // 0x2ED8(0x000C)
	struct FVector                                     m_vPreviousLeftFootPosition;                              // 0x2EE4(0x000C)
	float                                              m_fCachedRightTracedFloor;                                // 0x2EF0(0x0004)
	float                                              m_fCachedLeftTracedFloor;                                 // 0x2EF4(0x0004)
	float                                              m_fCachedRightFloorNormalZ;                               // 0x2EF8(0x0004)
	float                                              m_fCachedLeftFloorNormalZ;                                // 0x2EFC(0x0004)
	int                                                m_nCachedLeftFootBoneIndex;                               // 0x2F00(0x0004)
	int                                                m_nCachedRightFootBoneIndex;                              // 0x2F04(0x0004)
	struct FName                                       m_SkelControl_LeftHandName;                               // 0x2F08(0x0008)
	class USkelControlLimb*                            m_SkelControl_LeftHand;                                   // 0x2F10(0x0008)
	class USkelControlSingleBone*                      m_SkelControl_LeftHandRotate;                             // 0x2F18(0x0008)
	struct FName                                       m_SkelControl_RightHandName;                              // 0x2F20(0x0008)
	class USkelControlLimb*                            m_SkelControl_RightHand;                                  // 0x2F28(0x0008)
	class USkelControlSingleBone*                      m_SkelControl_RightHandRotate;                            // 0x2F30(0x0008)
	class USkelControlSingleBone*                      m_SkelControl_RightToLeftPropSwitch;                      // 0x2F38(0x0008)
	TArray<struct FName>                               m_HandIKFullStrengthAnimNodeNameList;                     // 0x2F40(0x0010) (NeedCtorLink)
	TArray<struct FName>                               m_HandIKZeroStrengthAnimNodeNameList;                     // 0x2F50(0x0010) (NeedCtorLink)
	TArray<class UAnimNode*>                           m_HandIKFullStengthCachedNodeList;                        // 0x2F60(0x0010) (NeedCtorLink)
	TArray<class UAnimNode*>                           m_HandIKZeroStrengthCachedNodeList;                       // 0x2F70(0x0010) (NeedCtorLink)
	class UMaterialInstanceConstant*                   m_FadeMaterialControllerBody;                             // 0x2F80(0x0008)
	struct FName                                       c_RefireBeginBlendAnimationName;                          // 0x2F88(0x0008)
	struct FName                                       c_RefireEndBlendAnimationName;                            // 0x2F90(0x0008)
	class UAnimSet*                                    c_RefireAnimSet;                                          // 0x2F98(0x0008)
	float                                              c_fRefireDuration;                                        // 0x2FA0(0x0004)
	float                                              c_fRefireEndDuration;                                     // 0x2FA4(0x0004)
	struct FVector                                     m_vAimAssistAnchorOffset;                                 // 0x2FA8(0x000C)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Biped");
		return ptr;
	}


	void GetAimFrictionExtent(float* Width, float* Height, struct FVector* Center);
	void Landed(const struct FVector& HitNormal, class AActor* FloorActor);
	bool CanTrackATarget();
	void SetAimTarget(float X, float Y, float Z);
	void STATIC_EnableFootControls(int foot, bool bDisable);
	void zpivot(float F);
	void CacheMainMeshReferences(class UTgSkeletalMeshComponent* smcomp);
	void PostBeginPlay();
	void EndRefireTimer();
	void EndRefire();
	void BeginRefire();
	bool STATIC_InitializeFootIKZeroStrengthAnimNodes(class USkeletalMeshComponent* SkelComp);
	bool STATIC_InitializeLeftHandIKAnimNodes(class USkeletalMeshComponent* SkelComp);
};


// Class TgGame.TgPawn_Character
// 0x0158 (0x310C - 0x2FB4)
class ATgPawn_Character : public ATgPawn_Biped
{
public:
	unsigned long                                      c_bUpdatePlayerStatUI : 1;                                // 0x2FB4(0x0004)
	unsigned long                                      m_bInHandFiring : 1;                                      // 0x2FB4(0x0004)
	unsigned long                                      r_bNearCapturePoint : 1;                                  // 0x2FB4(0x0004) (Net)
	unsigned long                                      r_bNearPayload : 1;                                       // 0x2FB4(0x0004) (Net)
	unsigned long                                      r_bNearSiegeMonster : 1;                                  // 0x2FB4(0x0004)
	unsigned long                                      r_bVisibleToEnemies : 1;                                  // 0x2FB4(0x0004) (Net)
	unsigned long                                      s_bAmmoReloadCheat : 1;                                   // 0x2FB4(0x0004)
	unsigned long                                      s_bAutomountProtection : 1;                               // 0x2FB4(0x0004)
	unsigned long                                      m_bAttemptingAirJump : 1;                                 // 0x2FB4(0x0004)
	unsigned long                                      m_bDelayingStopSpecialJumpFx : 1;                         // 0x2FB4(0x0004)
	unsigned long                                      m_bPendingBounce : 1;                                     // 0x2FB4(0x0004)
	unsigned long                                      s_bInitiatingJoin : 1;                                    // 0x2FB4(0x0004)
	unsigned long                                      s_bReplicateInhandAmmo : 1;                               // 0x2FB4(0x0004) (Const)
	unsigned long                                      c_bShouldTickThisFrame : 1;                               // 0x2FB4(0x0004)
	unsigned long                                      c_bShadowsVisible : 1;                                    // 0x2FB4(0x0004)
	unsigned long                                      c_bNeedsShadowLOSCheck : 1;                               // 0x2FB4(0x0004)
	float                                              m_fLastCapturePointReclaimedTime;                         // 0x2FB8(0x0004) (Transient)
	float                                              m_fMinReclaimPointTime;                                   // 0x2FBC(0x0004)
	float                                              c_fUpdateAltitudeRTPCDelay;                               // 0x2FC0(0x0004)
	float                                              m_fInHandStartFireTime;                                   // 0x2FC4(0x0004) (Transient)
	float                                              m_fInHandStopFireTime;                                    // 0x2FC8(0x0004) (Transient)
	float                                              m_fWallDamagePercent;                                     // 0x2FCC(0x0004)
	float                                              m_fSiegeDamagePercent;                                    // 0x2FD0(0x0004)
	float                                              r_fZoomAmt;                                               // 0x2FD4(0x0004) (Net)
	unsigned char                                      r_nCriticalHit;                                           // 0x2FD8(0x0001) (Net)
	unsigned char                                      UnknownData00[0x3];                                       // 0x2FD9(0x0003) MISSED OFFSET
	float                                              m_fMountZoomOverride;                                     // 0x2FDC(0x0004) (Edit)
	class ATgDeploy_BombKingStickyBomb*                r_StuckBombs[0x6];                                        // 0x2FE0(0x0008) (Net)
	int                                                m_nCharacterRole;                                         // 0x3010(0x0004)
	class UTgCustomCharacterComponent*                 m_CustomCharacterComponent;                               // 0x3014(0x0008) (Edit, ExportObject, Component, EditInline)
	class UPrimitiveComponent*                         m_MountedCollisionComponent;                              // 0x301C(0x0008) (Edit, ExportObject, Component, EditInline)
	class UPrimitiveComponent*                         m_MeshEncompassingCollisionComponent;                     // 0x3024(0x0008) (Edit, ExportObject, Component, EditInline)
	TArray<TScriptInterface<class UTgDeviceInterface_MoveSpeedMultiplier>> m_CachedMoveSpeedModDevices;                              // 0x302C(0x0010) (NeedCtorLink)
	TArray<TScriptInterface<class UTgDeviceInterface_AccelMultiplier>> m_CachedAccelModDevices;                                  // 0x303C(0x0010) (NeedCtorLink)
	TArray<TScriptInterface<class UTgDeviceInterface_DeployMod>> m_CachedDeployModDevices;                                 // 0x304C(0x0010) (NeedCtorLink)
	float                                              m_fCachedGroundProximity;                                 // 0x305C(0x0004)
	float                                              m_fCachedGroundProximityTimestamp;                        // 0x3060(0x0004)
	int                                                m_nAirJumps;                                              // 0x3064(0x0004)
	float                                              m_fAirJumpZSpeed;                                         // 0x3068(0x0004) (Edit)
	struct FVector                                     m_vBounceVelocity;                                        // 0x306C(0x000C)
	class ATgPawn_Character*                           m_JoinTargetLocal;                                        // 0x3078(0x0008)
	class ATgPawn_Character*                           m_JoinSourceLocal;                                        // 0x3080(0x0008)
	class ATgPawn_Character*                           r_JoinTarget;                                             // 0x3088(0x0008) (Net)
	struct FVector                                     r_vJoinSourceLocation;                                    // 0x3090(0x000C) (Net)
	struct FVector                                     r_vJoinTargetLocation;                                    // 0x309C(0x000C) (Net)
	float                                              r_fJoinTweenDuration;                                     // 0x30A8(0x0004) (Net)
	class ATgPawn_Character*                           r_JoinSource;                                             // 0x30AC(0x0008) (Net)
	TArray<struct FForceFaceTargetActor>               m_ForceFaceActors;                                        // 0x30B4(0x0010) (NeedCtorLink)
	int                                                r_nInHandCurrentAmmo;                                     // 0x30C4(0x0004) (Net)
	int                                                r_nInHandMaxAmmo;                                         // 0x30C8(0x0004) (Net)
	int                                                s_nOppressorMineStackCount;                               // 0x30CC(0x0004)
	float                                              c_fTickCatchup;                                           // 0x30D0(0x0004)
	struct FWeaponDOF                                  m_CurrentDOFSettings;                                     // 0x30D4(0x0028) (Edit)
	class ATgCollisionProxy_Capture*                   s_pCaptureProxy;                                          // 0x30FC(0x0008)
	float                                              c_fShadowsVisibleChangeTimer;                             // 0x3104(0x0004)
	float                                              c_fShadowsVisibleChangeDelay;                             // 0x3108(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Character");
		return ptr;
	}


	void STATIC_CollisionChanged();
	void STATIC_CreateCaptureProxy();
	bool ShouldCreateCaptureProxy();
	void Destroyed();
	bool STATIC_AdvancedTeleport(bool bFakeTeleport, struct FTeleportParams* Params, struct FVector* vTeleportLocation);
	void UpdateJoinSourceLocal();
	void RemoveJoinForcedView(class ATgPawn_Character* Source, class ATgPawn_Character* Target);
	void AddJoinForcedView(class ATgPawn_Character* Source, class ATgPawn_Character* Target);
	void TweenForJoinFinished();
	void TweenForJoin();
	void ClientUnjoinFromTarget();
	void ClientJoinToTarget();
	void UnjoinFromTarget();
	void STATIC_JoinToTarget(class ATgPawn_Character* Target, const struct FVector& SourceLocation, const struct FVector& TargetLocation, float TweenDuration);
	void StartPhysTween(const struct FVector& Target, float fTime, TEnumAsByte<ETweenState> tweenState, bool bCollideWithWorld, bool bRotateTowardsTarget);
	void AbortJoin();
	bool STATIC_IsJoined();
	void UpdateForcedRotation(float DeltaTime);
	bool STATIC_HasForcedRotation();
	void ClearOldForcedViewTargets();
	void STATIC_RemoveForcedViewTarget(class UObject* ForceRotationInstigator);
	void ClientRemoveForcedViewTarget(class UObject* ForceRotationInstigator);
	void STATIC_AddForcedViewTarget(class AActor* TargetActor, float InterpTime, float Duration, class UObject* ForceRotationInstigator, float HeightOffset);
	void ClientAddForcedViewTarget(class AActor* TargetActor, float InterpTime, float Duration, class UObject* ForceRotationInstigator, float HeightOffset);
	bool CanAddForcedViewTarget();
	int STATIC_GetNumAirJumps();
	void StopSpecialJumpFx();
	bool DoJump(bool bUpdating, float JumpZSpeed);
	bool CanAirJump();
	bool CheckPhysicsStateForJumping();
	bool STATIC_CannotJumpNow();
	void AutomountProtectionTimer();
	void StartAutomountProtectionTimer();
	void STATIC_RemoveStickyBombs();
	void STATIC_OnCeaseSpectatorViewTarget();
	void STATIC_OnBecameSpectatorViewTarget();
	void STATIC_PreTimeLapse(bool bPlayOfTheGame);
	void STATIC_OnStartTimelapseNewDeviceState();
	void StartWeaponZoomInterpolation(float fZoomAmt, float fInterpTime);
	void UpdateWeaponZoomEffects(float fZoomAmt);
	void SetWeaponZoom(float fZoomAmt);
	void STATIC_ForceUpdateAmmoAnim();
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_GetCameraZoomOverride(float* fZoom, float* fZoomDuration);
	void SetMountedCollision(bool IsActive);
	void STATIC_CreateMountMeshAndEffects(bool bPlayAnimFX);
	void StopMountingEffects();
	void ComposeCharacter(int Idx, int MeshAsmId);
	bool Died(class AController* Killer, class UClass* dmgType, const struct FVector& HitLocation);
	void PossessedBy(class AController* C, bool bVehicleTransition);
	void STATIC_OnInhandAmmoCountUpdated();
	void STATIC_UpdateShadowVisibility(float DeltaSeconds);
	void CleanUpShadowLOSRequest();
	void Tick(float DeltaSeconds);
	void STATIC_ReplicatedEvent(const struct FName& VarName);
	bool STATIC_IsViewPawn();
	void STATIC_ReceivedPropValues();
	void STATIC_HideHeadMesh();
	void ShowHeadMesh();
	bool STATIC_PostPawnSetup();
	void STATIC_OnRespawn();
	void PostPawnSetupServer();
	void CharacterPawnControllerSet();
	void ResetKillCombo();
	void STATIC_TakeDamage(int Damage, class AController* InstigatedBy, const struct FVector& HitLocation, const struct FVector& Momentum, class UClass* DamageType, const struct FTraceHitInfo& HitInfo, class AActor* DamageCauser);
	void PlayAnnouncerMatchStartCue();
	void PlaySpawnFx();
	void PlayIntroAnims();
	void PrepareIntro();
	void UpdateWeaponMesh(unsigned char EquipPoint, int DeviceID);
	void PostBeginPlay();
	void UpdateMountMeshCollision(int nMeshId);
	bool FindGround(float fCheckDist, float fCheckRadius, const struct FVector& vRayDir, struct FVector* vSourceLocation, struct FVector* vGroundLocation, struct FVector* vGroundNormal);
	void QueueBounce(struct FVector* vBounceVelocity);
	void TakeHealthDamage(float fDamage, class AController* InstigatedBy, class UClass* DamageType, const struct FImpactInfo& Impact, const struct FExtraDamageInfo& ExtraInfo, class AActor* DamageCauser);
	int STATIC_GetRole();
	float STATIC_GetGroundDistance();
	int STATIC_GetDefaultHeadMeshId();
	bool STATIC_OverrideDistanceFadeRange();
	float STATIC_GetBaseSpeed();
	float STATIC_GetDiminishedGroundSpeed();
	void UpdateAltitudeRTPC();
	void DropHealthNuggetTeamOnly(int nTaskForce, const struct FVector& SpawnVelocity, float fHealOverride, float fHoTOverride);
	void DropHealthNugget(const struct FVector& SpawnVelocity, float fHealOverride, float fHoTOverride);
	void DeviceAdjustHeal(struct FAdjustHealParams* Params, float* fHeal);
	void DeviceAdjustRadius(class ATgDevice* Dev, float* fRadius);
	void DeviceAdjustDamage(struct FAdjustDamageParams* Params, float* fDamage);
	void DeviceOnMiss(class ATgDevice* Dev);
	void DeviceOnReload(class ATgDevice* Dev);
	void DeviceOnKilled(class ATgDevice* Dev, float fDamage, struct FImpactInfo* Impact);
	void DeviceOnHealed(struct FOnHealedParams* Params);
	void DeviceOnDamaged(struct FOnDamagedParams* Params);
	void DeviceOnHitSpecial(class ATgDevice* Dev, int nHitSpecialSituationalType, struct FImpactInfo* Impact);
	void STATIC_DeviceOnHit(class ATgDevice* Dev, struct FImpactInfo* Impact);
	void STATIC_DeviceOnStopFire(class ATgDevice* Dev, bool WasInterrupted);
	void STATIC_DeviceOnStartFire(class ATgDevice* Dev);
	void STATIC_ProjectileOnFire(class ATgProjectile* Proj);
	void STATIC_DeviceOnFire(class ATgDevice* Dev);
	void STATIC_DeviceOnStopBuildup(class ATgDevice* Dev, bool WasInterrupted);
	void STATIC_DeviceOnStartBuildup(class ATgDevice* Dev);
	void DeviceOnHeld(class ATgDevice* pDevPrevious, class ATgDevice* pDevNext);
	void STATIC_PawnOnTeleported(class ATgSpawnTeleporterEntrance* From, class ATgSpawnTeleporterExit* To, const struct FVector& OriginalPawnLocation);
	void STATIC_PawnOnGetHealthNugget(class ATgDeploy_HealthNugget* nugget);
	void STATIC_PawnOnExitCombat();
	void STATIC_PawnOnEnterCombat();
	void STATIC_PawnOnRevive();
	void STATIC_PawnOnAssistedDown(class AActor* pVictim);
	void STATIC_PawnOnDowned(class AActor* pKiller, class AActor* pVictim);
	void STATIC_PawnOnAssisted(class AActor* pVictim);
	void STATIC_PawnOnKilled(class AActor* pKiller, class AActor* pVictim);
	void STATIC_PawnOnHealed(struct FOnHealedParams* Params);
	void STATIC_PawnOnDamaged(struct FOnDamagedParams* Params);
	void STATIC_GlobalOnPlayerDied(class ATgPawn_Character* Player);
	void CheckWaitForTeam();
	void TankRequestsHelp();
	void PlayMatchStartCue();
	void SpawnGuard();
	void STATIC_OnPawnDied();
	bool ApplyMonsterRewardEffects(class UTgInventoryObject* pItem, bool bRemove);
	bool ApplyItemEffects(class UTgInventoryObject* pItem, bool bRemove);
	void ReapplyLoadoutEffects(bool bKeepFiringMount, bool bForceRemoveEffects);
	void STATIC_OnHealingWell(bool bTouched);
	void STATIC_LoadDisconnectedPlayerState();
	void SetSpawnMana();
	bool ApplyPawnSetup();
};


// Class TgGame.TgPawn_Hunter
// 0x0000 (0x310C - 0x310C)
class ATgPawn_Hunter : public ATgPawn_Character
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Hunter");
		return ptr;
	}


	void DeviceAdjustCooldown(class ATgDevice* Dev, float* fCooldown);
	void DeviceAdjustDamage(struct FAdjustDamageParams* Params, float* fDamage);
};


// Class TgGame.TgPawn_LootGoblin
// 0x0080 (0x318C - 0x310C)
class ATgPawn_LootGoblin : public ATgPawn_Character
{
public:
	TEnumAsByte<EGoblinState>                          r_eCurrentState;                                          // 0x310C(0x0001) (Net)
	unsigned char                                      UnknownData00[0x3];                                       // 0x310D(0x0003) MISSED OFFSET
	float                                              m_fGoblinStateTimer;                                      // 0x3110(0x0004)
	float                                              m_fEscapeTimer;                                           // 0x3114(0x0004)
	float                                              m_fTotalDamage;                                           // 0x3118(0x0004)
	TArray<class ATgRoyaleObjective*>                  m_RoyaleObjectivesVisited;                                // 0x311C(0x0010) (NeedCtorLink)
	float                                              m_fSpawnTime;                                             // 0x312C(0x0004) (Config)
	float                                              m_fMovementTime;                                          // 0x3130(0x0004) (Config)
	float                                              m_fStopTime;                                              // 0x3134(0x0004) (Config)
	float                                              m_fStartEscapeTime;                                       // 0x3138(0x0004) (Config)
	float                                              m_fEscapeTime;                                            // 0x313C(0x0004) (Config)
	float                                              m_fDamageTime;                                            // 0x3140(0x0004) (Config)
	float                                              m_fMaxDamage;                                             // 0x3144(0x0004) (Config)
	TArray<struct FGoblinLootInfo>                     m_GoblinLootInfo;                                         // 0x3148(0x0010) (Config, NeedCtorLink)
	TArray<struct FGoblinLootInfo>                     m_GoblinFlinchLootInfo;                                   // 0x3158(0x0010) (Config, NeedCtorLink)
	class UTgEffectGroup*                              m_pNormalizerEffectGroup;                                 // 0x3168(0x0008)
	class UMaterialInstanceConstant*                   m_pMIC;                                                   // 0x3170(0x0008)
	struct FName                                       m_nWallEnableName;                                        // 0x3178(0x0008) (Const)
	struct FName                                       m_nWallPositionName;                                      // 0x3180(0x0008) (Const)
	unsigned long                                      m_bTickMaskingPlane : 1;                                  // 0x3188(0x0004)
	unsigned long                                      m_bHasDespawned : 1;                                      // 0x3188(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_LootGoblin");
		return ptr;
	}


	bool ShouldCreateCaptureProxy();
	bool ShouldScoreKill();
	void STATIC_DespawnLootGoblin();
	void STATIC_SetMaskingPlaneActive(bool bActive);
	bool STATIC_IsDebuffImmune();
	void DropInventory();
	bool CanTakeHealthDamage();
	void STATIC_PawnOnDamaged(struct FOnDamagedParams* Params);
	void STATIC_StateTimerFinished();
	void STATIC_SetGoblinState(TEnumAsByte<EGoblinState> eState);
	void STATIC_RecalculateMaterial(bool bIsFriendlyWithLocalPawn, bool bForce);
	bool ApplyPawnSetup();
};


// Class TgGame.TgPawn_Warrior
// 0x0000 (0x310C - 0x310C)
class ATgPawn_Warrior : public ATgPawn_Character
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Warrior");
		return ptr;
	}


	void DeviceAdjustCooldown(class ATgDevice* Dev, float* fCooldown);
	void DeviceAdjustDamage(struct FAdjustDamageParams* Params, float* fDamage);
	void STATIC_DeviceOnHit(class ATgDevice* Dev, struct FImpactInfo* Impact);
	float STATIC_GetHealingTakenScale();
};


// Class TgGame.TgPawn_Monster
// 0x0000 (0x2FB4 - 0x2FB4)
class ATgPawn_Monster : public ATgPawn_Biped
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Monster");
		return ptr;
	}


	bool AllowRagdoll();
	bool STATIC_IsMonster();
};


// Class TgGame.TgPawn_Pet
// 0x005C (0x2ED4 - 0x2E78)
class ATgPawn_Pet : public ATgPawn
{
public:
	float                                              m_fOwnerPhysPowerItemPercent;                             // 0x2E78(0x0004)
	float                                              m_fOwnerMagicalPowerItemPercent;                          // 0x2E7C(0x0004)
	float                                              m_fOwnerUltilityPowerItemPercent;                         // 0x2E80(0x0004)
	TEnumAsByte<EPetPhase>                             s_PetPhase;                                               // 0x2E84(0x0001)
	TEnumAsByte<EPetPosition>                          s_PetPosition;                                            // 0x2E85(0x0001)
	unsigned char                                      UnknownData00[0x2];                                       // 0x2E86(0x0002) MISSED OFFSET
	struct FRotator                                    s_LastPositionAdjustmentRotation;                         // 0x2E88(0x000C)
	struct FVector                                     s_InterpolatedPetPosition;                                // 0x2E94(0x000C)
	struct FVector                                     s_InterpolatedPetOwnerPosition;                           // 0x2EA0(0x000C)
	float                                              s_fPetPositionDistanceMultiplier;                         // 0x2EAC(0x0004)
	float                                              s_fOwnerVelocityTime;                                     // 0x2EB0(0x0004)
	float                                              s_fSmoothedMaxSpeed;                                      // 0x2EB4(0x0004)
	class UTgSpecialFx*                                c_BeamFX;                                                 // 0x2EB8(0x0008) (Transient)
	struct FRotator                                    r_InitialOrientation;                                     // 0x2EC0(0x000C) (Net)
	class UParticleSystemComponent*                    c_AimVisibilityMesh;                                      // 0x2ECC(0x0008) (ExportObject, Component, EditInline)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Pet");
		return ptr;
	}


	void STATIC_PlayDeathAnimation();
	void PlayDyingEffects();
	bool ShouldScoreKill();
	void SetAimVisibilityMesh();
	void STATIC_ReplicatedEvent(const struct FName& VarName);
	void PostBeginPlay();
	void PossessedBy(class AController* C, bool bVehicleTransition);
	void STATIC_DeviceOnHit(class ATgDevice* Dev, struct FImpactInfo* Impact);
	void DeviceOnDamaged(struct FOnDamagedParams* Params);
	void DeviceAdjustDamage(struct FAdjustDamageParams* Params, float* fDamage);
	void DeviceOnKilled(class ATgDevice* Dev, float fDamage, struct FImpactInfo* Impact);
	void STATIC_DeviceOnStopFire(class ATgDevice* Dev, bool WasInterrupted);
	bool CanSeeActor(class AActor* Other);
	void DirtyAttachmentTransforms();
	float STATIC_GetDefaultMeshScale();
	void CorrectLocationWhileChangingSize(float HeightDelta);
	void STATIC_GetSmallCollisionCylinderSize(float* Radius, float* Height);
	void STATIC_GetGiantCollisionCylinderSize(float* Radius, float* Height);
	bool STATIC_IsDamageOverTimeImmune();
	float STATIC_GetUtilityPowerItem();
	float STATIC_GetMagicalPowerItem();
	float STATIC_GetPhysicalPowerItem();
};


// Class TgGame.TgPawn_Turret
// 0x0020 (0x2EF4 - 0x2ED4)
class ATgPawn_Turret : public ATgPawn_Pet
{
public:
	unsigned long                                      r_bLockdownIsOn : 1;                                      // 0x2ED4(0x0004) (Net)
	unsigned long                                      r_bHasHealingStation : 1;                                 // 0x2ED4(0x0004) (Net)
	unsigned long                                      m_bFirstAidNuggetOverride : 1;                            // 0x2ED4(0x0004)
	int                                                m_nLockdownPostureID;                                     // 0x2ED8(0x0004)
	class ATgDevice*                                   m_SpawningDevice;                                         // 0x2EDC(0x0008)
	class UAkEvent*                                    m_TargetingNotificationAkEvent;                           // 0x2EE4(0x0008)
	class AActor*                                      m_PrevTargetActor;                                        // 0x2EEC(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Turret");
		return ptr;
	}


	bool Died(class AController* Killer, class UClass* dmgType, const struct FVector& HitLocation);
	void RagdollPawn();
	bool AllowRagdoll();
	void STATIC_PlayDeathAnimation();
	void STATIC_ReplicatedEvent(const struct FName& VarName);
	void PlayTargetingSound();
	void SetTargetActor(class AActor* Target);
	void ToggleHealingStationFX();
	void ToggleLockdownFX();
	void ToggleLockdownMode(bool bSetActive);
	void DropHealthNuggetTeamOnly(int nTaskForce, const struct FVector& SpawnVelocity, float fHealOverride, float fHoTOverride);
	void PostPawnSetupServer();
};


// Class TgGame.TgPawn_Turret_Flamethrower
// 0x0000 (0x2EF4 - 0x2EF4)
class ATgPawn_Turret_Flamethrower : public ATgPawn_Turret
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Turret_Flamethrower");
		return ptr;
	}

};


// Class TgGame.TgPawn_Turret_Flamethrower_Mini
// 0x0000 (0x2EF4 - 0x2EF4)
class ATgPawn_Turret_Flamethrower_Mini : public ATgPawn_Turret_Flamethrower
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Turret_Flamethrower_Mini");
		return ptr;
	}

};


// Class TgGame.TgPawn_Turret_Mega
// 0x0000 (0x2EF4 - 0x2EF4)
class ATgPawn_Turret_Mega : public ATgPawn_Turret
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Turret_Mega");
		return ptr;
	}

};


// Class TgGame.TgPawn_Structure
// 0x0008 (0x2E80 - 0x2E78)
class ATgPawn_Structure : public ATgPawn
{
public:
	float                                              s_fLastDamageTime;                                        // 0x2E78(0x0004)
	float                                              s_fDamageNotificationDelay;                               // 0x2E7C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Structure");
		return ptr;
	}


	void STATIC_SetMovementPhysics();
	void STATIC_PostDemoRewind();
	void STATIC_PlayDeathAnimation();
	bool Died(class AController* Killer, class UClass* dmgType, const struct FVector& HitLocation);
	void STATIC_TakeDamage(int Damage, class AController* InstigatedBy, const struct FVector& HitLocation, const struct FVector& Momentum, class UClass* DamageType, const struct FTraceHitInfo& HitInfo, class AActor* DamageCauser);
	void SendDeathAlert();
	void SendAttackAlert();
	bool CanMove();
};


// Class TgGame.TgSpectatorController
// 0x025C (0x1870 - 0x1614)
class ATgSpectatorController : public ATgPlayerController
{
public:
	TEnumAsByte<ESpectatorCameraMode>                  m_CameraMode;                                             // 0x1614(0x0001) (Transient)
	TEnumAsByte<ESpectatorCameraCycle>                 m_CurrentCycle;                                           // 0x1615(0x0001) (Transient)
	TEnumAsByte<ESpectatorCameraCycle>                 m_PendingCycle;                                           // 0x1616(0x0001) (Transient)
	TEnumAsByte<ESpecFlightMode>                       m_eHelicopterFlight;                                      // 0x1617(0x0001) (Transient)
	TEnumAsByte<ESpectatorMode>                        m_CurrentSpectatorMode;                                   // 0x1618(0x0001) (Transient)
	TEnumAsByte<ESpecZoomState>                        m_CurrentZoomState;                                       // 0x1619(0x0001) (Transient)
	unsigned char                                      UnknownData00[0x2];                                       // 0x161A(0x0002) MISSED OFFSET
	class ATgSpectatorTempCam*                         m_BookmarkCamera;                                         // 0x161C(0x0008) (Transient)
	struct FSpectatorBookmark                          m_Bookmarks[0xA];                                         // 0x1624(0x0030) (Transient)
	float                                              m_fDefaultTweenTime;                                      // 0x1804(0x0004)
	unsigned long                                      m_bOutlineCharacters : 1;                                 // 0x1808(0x0004) (Transient)
	unsigned long                                      m_bIsMapSquashed : 1;                                     // 0x1808(0x0004) (Transient)
	unsigned long                                      m_bIgnoreCullDistanceVolumes : 1;                         // 0x1808(0x0004) (Edit, Config)
	float                                              m_fNameplateFadeMinDist;                                  // 0x180C(0x0004) (Edit)
	float                                              m_fNameplateFadeMaxDist;                                  // 0x1810(0x0004) (Edit)
	float                                              m_fNameplateFadeMaxAmount;                                // 0x1814(0x0004) (Edit)
	float                                              m_fNameplateScaleMinDist;                                 // 0x1818(0x0004) (Edit)
	float                                              m_fNameplateScaleMaxDist;                                 // 0x181C(0x0004) (Edit)
	float                                              m_fNameplateScaleMaxAmount;                               // 0x1820(0x0004) (Edit)
	float                                              m_fInterpolateCameraDistance;                             // 0x1824(0x0004) (Edit)
	float                                              m_TimeLastTaskforceChange;                                // 0x1828(0x0004)
	int                                                m_TaskForceID;                                            // 0x182C(0x0004)
	int                                                m_NewTaskForceID;                                         // 0x1830(0x0004)
	int                                                m_TaskforceChangeCount;                                   // 0x1834(0x0004)
	struct FBroadcastChannel                           m_BroadcastChannels[0x4];                                 // 0x1838(0x0008)
	struct FVector                                     c_vMouseClickDeprojectionExtent;                          // 0x1858(0x000C) (Config)
	float                                              m_fOverviewCenterpointOffset;                             // 0x1864(0x0004) (Edit, Config)
	float                                              m_fMouseCursorVisibleTime;                                // 0x1868(0x0004) (Edit, Config)
	float                                              m_fRemainingCursorVisibleTime;                            // 0x186C(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSpectatorController");
		return ptr;
	}


	void SetViewTarget(class AActor* NewViewTarget, const struct FViewTargetTransitionParams& TransitionParams);
	class ATgPawn* STATIC_GetTgPawn();
	void SpectateTaskForceTeamMember(int PlayerIndex);
	bool STATIC_AttemptToSpectateTaskforce(int nTaskForceId);
	void SpectateTaskForceTripleDigit(int Input);
	void SpectatePlayerIndex(int TaskForceNum, int PlayerIndex);
	void UpdateBroadcastChannels();
	void ChangeZoomState(TEnumAsByte<ESpecZoomState> NewZoomState);
	void SpectateZoomOut(bool bEnabled);
	void SpectateZoomIn(bool bEnabled);
	void STATIC_GetActorListFrom2DCoordinate(const struct FVector2D& Coordinate, TArray<class AActor*>* ActorList);
	class APawn* STATIC_GetPawnFrom2DCoordinate(const struct FVector2D& Coordinate);
	void FlipOverviewSides();
	void SpecTest();
	void SquashMap();
	float STATIC_GetFOVAngle();
	void SetOutlineCharacters(bool bNewOutlineCharacters);
	void ToggleOutlineCharacters();
	struct FString StripClanTag(const struct FString& PlayerName);
	void DecreaseCameraSpeed();
	void STATIC_IncreaseCameraSpeeed();
	void CameraSpeed(float NewSpeed);
	void STATIC_GotoCinematicCam(const struct FString& sCamName);
	void SpecSetFlightMode(TEnumAsByte<ESpecFlightMode> sfm);
	void RecallSpectatorBookmark(int nNum);
	void SetSpectatorBookmark(int nNum);
	struct FViewTargetTransitionParams STATIC_GetSnapBlendParams();
	struct FViewTargetTransitionParams STATIC_GetDefaultBlendParams();
	struct FViewTargetTransitionParams STATIC_GetBlendParams(class AActor* Target);
	void SpecViewPlayer(const struct FString& PlayerName);
	void SpecViewAction();
	TEnumAsByte<ESpectatorCameraMode> STATIC_GetDefaultModeFor(class AActor* Target);
	TArray<class AActor*> STATIC_GetActionList();
	TArray<class AActor*> STATIC_GetOutermostTowerList();
	TArray<class AActor*> STATIC_GetPlayerList();
	TArray<class AActor*> STATIC_GetViewTargetListForMode(TEnumAsByte<ESpectatorCameraCycle> cycle);
	void CycleNext(bool bSkipIfPresent, bool bReverse);
	void SnapViewToLocation(const struct FVector& WorldLocation, bool bUseFocalPoint);
	void SetPendingOnDirectorMode();
	bool PingMap(const struct FVector& WorldLocation, TEnumAsByte<EPING_TYPE> Type, TArray<class AReplicationInfo*>* worldActorRepInfo);
	void SnapViewToHoverTarget(bool bUseAltView);
	void STATIC_LockedViewCam(bool bEnabled);
	bool STATIC_InterceptFlashInput(const struct FName& ButtonName, TEnumAsByte<EInputEvent> Event);
	void ClearPendingSpecCycle();
	void SetPendingSpecCycle(TEnumAsByte<ESpectatorCameraCycle> Mode);
	void ClientSetReadyState(bool bReadyToPlay);
	void ToggleSpectatorPlayerIcons();
	void SetSpectatorCameraMode(TEnumAsByte<ESpectatorCameraMode> Mode, bool bCameraTween);
	void SetNewSpectatorMode(TEnumAsByte<ESpectatorMode> NewMode);
	bool ShouldFlyFromInput();
	void UpdateViewTargetUI();
	void SpectatorSetViewTarget(class AActor* VT, const struct FViewTargetTransitionParams& TransitionParams);
	void SwitchCamera(const struct FString& sCamera);
	void SpectatorClearViewViewTarget();
	void ClientForwardToSpectatingMatch();
	void ForwardToSpectatingMatch();
	void PostBeginPlay();
	class ATgRepInfo_Player* STATIC_GetCurrentPRI();
	void SetNetTarget(const struct FQWord& qwId, int nTaskForce);
	class UClass* STATIC_GetHudClass(class UClass* pNewHudType);
};


// Class TgGame.TgDemoRecSpectator
// 0x0088 (0x18F8 - 0x1870)
class ATgDemoRecSpectator : public ATgSpectatorController
{
public:
	TArray<struct FSpectatorCommand>                   PendingCommands;                                          // 0x1870(0x0010) (NeedCtorLink)
	int                                                m_TimeIndex;                                              // 0x1880(0x0004)
	TArray<struct FDilationData>                       m_TimeDilations;                                          // 0x1884(0x0010) (NeedCtorLink)
	struct FPointer                                    m_pTgCallbackDevice;                                      // 0x1894(0x0008) (Native)
	int                                                m_1xTimeIndex;                                            // 0x189C(0x0004) (Transient)
	unsigned long                                      m_bIsPaused : 1;                                          // 0x18A0(0x0004) (Transient)
	unsigned long                                      m_bInStasis : 1;                                          // 0x18A0(0x0004) (Transient)
	unsigned long                                      m_bSpectatorMaster : 1;                                   // 0x18A0(0x0004) (Transient)
	unsigned long                                      m_bSyncWithMasterEnabled : 1;                             // 0x18A0(0x0004) (Transient)
	unsigned long                                      m_bIsSyncingWithMaster : 1;                               // 0x18A0(0x0004) (Transient)
	unsigned long                                      m_bAutoSlomo : 1;                                         // 0x18A0(0x0004) (Transient, Config)
	unsigned long                                      m_bReceiveCamSync : 1;                                    // 0x18A0(0x0004) (Transient, Config)
	int                                                m_nLastReceivedMasterFrame;                               // 0x18A4(0x0004) (Transient)
	float                                              m_fLastReceivedMasterTimeDilation;                        // 0x18A8(0x0004) (Transient)
	float                                              m_fLastReceievedRealTimeStamp;                            // 0x18AC(0x0004) (Transient)
	int                                                m_nSyncFrameThreshold;                                    // 0x18B0(0x0004) (Const, Config)
	int                                                m_nSyncFrameCheckThreshold;                               // 0x18B4(0x0004) (Const, Config)
	int                                                m_nSyncAheadFrameThreshold;                               // 0x18B8(0x0004) (Const, Config)
	int                                                m_nLastTimerValue;                                        // 0x18BC(0x0004) (Transient)
	class ATgSpectatorDirector*                        m_SpectatorDirector;                                      // 0x18C0(0x0008)
	class ATgCollisionProxy_SpectatorActionListener*   m_ActionListener;                                         // 0x18C8(0x0008) (Transient)
	float                                              m_fActionListenerRadius;                                  // 0x18D0(0x0004) (Transient, Config)
	float                                              m_fActionListenerHeight;                                  // 0x18D4(0x0004) (Transient, Config)
	int                                                m_nCurrentActionListenerRating;                           // 0x18D8(0x0004) (Transient)
	int                                                m_nActionListenerRatingThreshold;                         // 0x18DC(0x0004) (Transient, Config)
	float                                              m_fRemainingAutoSlomoTime;                                // 0x18E0(0x0004)
	float                                              m_fAutoSlomoExpirationTime;                               // 0x18E4(0x0004) (Transient, Config)
	int                                                m_nAutoSlomoSpeedIndex;                                   // 0x18E8(0x0004) (Transient, Config)
	int                                                m_nAutoSlomoNearbyPlayersNum;                             // 0x18EC(0x0004) (Transient, Config)
	float                                              m_fAutoSlomoFrequency;                                    // 0x18F0(0x0004) (Transient, Config)
	float                                              m_fRemainingAutoSlomoTimeoutTime;                         // 0x18F4(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDemoRecSpectator");
		return ptr;
	}


	void ReceiveCamSyncTarget(int PawnId, int SourcePlayerId);
	void SendCamSyncTarget();
	void SpectatorReceivedViewTarget(class AActor* VT);
	void SpectatorSetViewTarget(class AActor* VT, const struct FViewTargetTransitionParams& TransitionParams);
	void EnableCamSync(bool bEnabled);
	void TriggerAutoSlomo(float SlomoTime);
	void STATIC_OnActionListenerStartFire(class ATgPawn* FiringPawn, int nEquipSlot);
	void EnableAutoSlomo(bool bEnabled);
	void ToggleAutoSlomo();
	void SpecViewPlayer(const struct FString& PlayerName);
	bool PingMap(const struct FVector& WorldLocation, TEnumAsByte<EPING_TYPE> Type, TArray<class AReplicationInfo*>* worldActorRepInfo);
	void SetNewSpectatorMode(TEnumAsByte<ESpectatorMode> NewMode);
	void STATIC_FindNextClosestAssistedViewTarget();
	void STATIC_FindNearbyAssistedViewTarget();
	void DirectorModeToggle();
	void STATIC_PostDemoRewind();
	void CheckSpectatorMasterSlave();
	void ToggleSync();
	void EnableSync(bool bEnabled);
	bool STATIC_IsSyncedWithMaster(int Threshold);
	int STATIC_GetSyncTargetFrame();
	void SetSyncTargetFrame(int FrameNum, float TimeDilation);
	void RewindGraphs();
	void STATIC_PauseEx();
	bool SetSpectatorMasterSlave();
	bool CanFastForward();
	void STATIC_GoToFrame(float fPercent);
	void Rewind(int JumpAmount, int FrameNum);
	void DilateTime(float Amount, bool bForceReset);
	void Pause();
	void STATIC_Slomo(float NewTimeDilation);
	void PostBeginPlay();
	void STATIC_ReceivedPlayer();
	int STATIC_GetSpectatorTaskforceNumber();
	void StartAutoCombatLog();
	void ToggleThirdPersonView();
	void CreateManualRewindPoint();
	class UClass* STATIC_GetHudClass(class UClass* pNewHudType);
	void UnregisterEngineCallbacks();
	void RegisterEngineCallbacks();
	void UpdateCameraModeUI();
	bool UpdateSyncingUI();
	void UpdateTimeDilation();
	void RequestSync();
	void STATIC_OnSynced();
};


// Class TgGame.TgDemoRecSpectator_Debug
// 0x0010 (0x1908 - 0x18F8)
class ATgDemoRecSpectator_Debug : public ATgDemoRecSpectator
{
public:
	class UPlayer*                                     m_OriginalPlayer;                                         // 0x18F8(0x0008)
	class APlayerController*                           m_OriginalPlayerController;                               // 0x1900(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDemoRecSpectator_Debug");
		return ptr;
	}

};


// Class TgGame.TgPlayerInput
// 0x0218 (0x0510 - 0x02F8)
class UTgPlayerInput : public UPComPlayerInput
{
public:
	class ATgPlayerController*                         c_TgPC;                                                   // 0x02F8(0x0008)
	unsigned long                                      c_bASKeyCapture : 1;                                      // 0x0300(0x0004)
	unsigned long                                      c_bASSpecKeyCapture : 1;                                  // 0x0300(0x0004)
	unsigned long                                      c_bMiniMapPinging : 1;                                    // 0x0300(0x0004)
	unsigned long                                      c_bAutoRun : 1;                                           // 0x0300(0x0004)
	unsigned long                                      bEnableAimAssist : 1;                                     // 0x0300(0x0004) (Config)
	unsigned long                                      bDebugAimAssist : 1;                                      // 0x0300(0x0004) (Transient)
	unsigned long                                      m_bOldLookValid : 1;                                      // 0x0300(0x0004) (Transient)
	float                                              GamepadSensitivityX;                                      // 0x0304(0x0004) (Config, GlobalConfig)
	float                                              GamepadSensitivityY;                                      // 0x0308(0x0004) (Config, GlobalConfig)
	float                                              GyroSensitivityX;                                         // 0x030C(0x0004) (Config, GlobalConfig)
	float                                              GyroSensitivityY;                                         // 0x0310(0x0004) (Config, GlobalConfig)
	float                                              GyroTuningConstant;                                       // 0x0314(0x0004) (Config, GlobalConfig)
	float                                              fScopeSensitivity;                                        // 0x0318(0x0004) (Config, GlobalConfig)
	float                                              fADSSensitivity;                                          // 0x031C(0x0004) (Config, GlobalConfig)
	float                                              fGamepadADSSensitivyMult;                                 // 0x0320(0x0004) (Edit)
	float                                              fGamepadScopeSensitivyMult;                               // 0x0324(0x0004) (Edit)
	float                                              m_fMinScopeSensitivityMult;                               // 0x0328(0x0004)
	float                                              m_fMaxScopeSensitivityMult;                               // 0x032C(0x0004)
	float                                              m_fMinADSSensitivityMult;                                 // 0x0330(0x0004)
	float                                              m_fMaxADSSensitivityMult;                                 // 0x0334(0x0004)
	int                                                nAimAccelerationSet;                                      // 0x0338(0x0004) (Config, GlobalConfig)
	int                                                nAimAccelerationBoost;                                    // 0x033C(0x0004) (Config, GlobalConfig)
	float                                              fTurnSpeedAccelAmt;                                       // 0x0340(0x0004) (Transient)
	float                                              fLookUpSpeedAccelAmt;                                     // 0x0344(0x0004) (Transient)
	int                                                nAimAccelerationAlgorithm;                                // 0x0348(0x0004)
	float                                              fOldATurn;                                                // 0x034C(0x0004) (Transient)
	float                                              fOldALookUp;                                              // 0x0350(0x0004) (Transient)
	int                                                nAimAssistMagnetStrength;                                 // 0x0354(0x0004) (Config, GlobalConfig)
	int                                                nAimAssistFrictionStrength;                               // 0x0358(0x0004) (Config, GlobalConfig)
	int                                                nInnerDeadZoneSize;                                       // 0x035C(0x0004) (Config, GlobalConfig)
	int                                                nOuterDeadZoneSize;                                       // 0x0360(0x0004) (Config, GlobalConfig)
	class AActor*                                      BestAimAssistTarget;                                      // 0x0364(0x0008) (Transient)
	class UTgGameplayCurves*                           m_AimAssistCurves;                                        // 0x036C(0x0008)
	float                                              aTurnFinalValue;                                          // 0x0374(0x0004) (Transient)
	float                                              aLookUpFinalValue;                                        // 0x0378(0x0004) (Transient)
	TArray<struct FAimAssistTargetWeight>              m_AimAssistTargets;                                       // 0x037C(0x0010) (Transient, NeedCtorLink)
	struct FAimAssistTargetWeightVars                  TargetWeightVars;                                         // 0x038C(0x001C)
	struct FDebugAimAssist                             DebugAimAssistVals;                                       // 0x03A8(0x0124)
	struct FVector                                     m_vOldLookTarget;                                         // 0x04CC(0x000C) (Transient)
	struct FVector2D                                   m_vOldLockDelta;                                          // 0x04D8(0x0008) (Transient)
	struct FScriptDelegate                             __OnRawInputKey__Delegate;                                // 0x04E0(0x000C) (NeedCtorLink)
	unsigned char                                      UnknownData00[0x4];                                       // 0x04E0(0x0004) FIX WRONG TYPE SIZE OF PREVIOUS PROPERTY
	struct FScriptDelegate                             __OnInputAxis__Delegate;                                  // 0x04F0(0x000C) (NeedCtorLink)
	unsigned char                                      UnknownData01[0x4];                                       // 0x04F0(0x0004) FIX WRONG TYPE SIZE OF PREVIOUS PROPERTY
	struct FScriptDelegate                             __OnInputChar__Delegate;                                  // 0x0500(0x000C) (NeedCtorLink)
	unsigned char                                      UnknownData02[0x4];                                       // 0x0500(0x0004) FIX WRONG TYPE SIZE OF PREVIOUS PROPERTY

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPlayerInput");
		return ptr;
	}


	void UnbindCommand(const struct FString& Command, int nAlternate);
	void STATIC_UnbindCommandAll(const struct FString& Command);
	void STATIC_SetCommandBind(const struct FString& Command, int nAlternate, const struct FString& ExtendedBinding);
	void SetBindExtended(const struct FString& ExtendedBinding, const struct FString& Command);
	void SetMouseInput(bool bInvert, bool bSmooth, float fSensitivity);
	void SetGamepadSensitivity(float fAxisX, float fAxisY);
	void CancelAutoRun();
	void ToggleAutoRun();
	void SetAimAccelerationSet(int AimSet);
	void SetAimAccelerationAlgorithm(int Algorithm);
	float DetermineAimVectorAssistAngleDegrees(class AActor* InTarget, const struct FVector& InPawnFwd, const struct FVector& InTargetCenter, const struct FVector& InRealBoundsExtent, const struct FVector& InMaxBoundsExtent, const struct FVector& InProjectPlaneA, const struct FVector& InProjectPlaneB, const struct FVector& InDetermineAssistDirectionVector, float MaxAssistanceAngleToUse, bool bIsVertical);
	struct FRotator STATIC_ApplyAimVectorModification(class ATgDevice* InDevice, const struct FRotator& InRotation);
	float DetermineAimAssistCurveTime(const struct FVector& InPawnFwd, const struct FVector& InTargetCenter, const struct FVector& InMaxBoundsExtent, const struct FVector& InProjectPlaneA, const struct FVector& InProjectPlaneB, const struct FVector& InDetermineAssistDirectionVector);
	void DetermineExtentPercentLength(const struct FVector& InTargetCenter, const struct FVector& InMaxBoundsExtentNormal, float InMaxBoundsExtentLength, const struct FVector& InProjectPlaneA, const struct FVector& InProjectPlaneB, float InAimAssistValue, float* OutPositiveLength, float* OutNegativeLength);
	bool STATIC_HandleAimAssistForTarget(const TScriptInterface<class UTgCombatActor>& InTarget, float DeltaTime, struct FVector* InPawnFwd, struct FVector* InPawnRight, struct FVector* InPawnUp, float* HorizontalAssistAmount, float* VerticalAssistAmount);
	void STATIC_GetDesiredTrackingAim(float DeltaTime, float* TrackingX, float* TrackingY);
	float Sign(float InValue);
	void ApplyAimFrictionAndMagnet(float DeltaTime, float HorizontalAssistAmount, float VerticalAssistAmount, float DistanceToTarget, TArray<struct FAimAssistKeyframeData>* MagnetHorizKeyframeData, TArray<struct FAimAssistKeyframeData>* MagnetVertKeyframeData, TArray<struct FAimAssistKeyframeData>* FrictionKeyframeData, TArray<struct FAimAssistKeyframeData>* FrictionVertKeyframeData, struct FVector2D* AimAssistMagnetScale, struct FVector2D* AimAssistFrictionScale);
	void ApplyAimTracking(float DeltaTime, float HorizontalAssistAmount, float VerticalAssistAmount, float DistanceToTarget, TArray<struct FAimAssistKeyframeData>* TrackingAccHorizKeyframeData, TArray<struct FAimAssistKeyframeData>* TrackingAngleHorizKeyframeData, TArray<struct FAimAssistKeyframeData>* TrackingAccVertKeyframeData, TArray<struct FAimAssistKeyframeData>* TrackingAngleVertKeyframeData, struct FVector2D* AimAssistTrackingScale);
	void UpdateAimAssistTargetWeights(float DeltaTime);
	void SelectBestAimAssistTargetViaWeights(float* BestHorizontalAssistAmount, float* BestVerticalAssistAmount);
	void STATIC_HandleAimAssist(float DeltaTime, bool bTurnAimAssistConditionMet, bool bLookUpAimAssistConditionMet);
	void DrawAimAssistVals(const struct FString& assistName, int Index, float YL, class AHUD* HUD, float* YPos);
	void DisplayDebug(class AHUD* HUD, float* out_YL, float* out_YPos);
	void STATIC_HandleMovementInput(bool bIsMatchingInput, TEnumAsByte<EPlayerInputType> InputType, float* fAxisValue);
	void PlayerInput(float DeltaTime);
	void STATIC_AdjustMouseSensitivity(float FOVScale);
	float STATIC_GetADSSensitivity();
	float STATIC_GetScopeSensitivity();
	bool ShouldUseAimAssist();
	void PreProcessInput(float DeltaTime);
	TEnumAsByte<EDoubleClickDir> STATIC_CheckForDoubleClickMove(float DeltaTime);
	void Duck();
	bool STATIC_InputChar(int ControllerId, const struct FString& Unicode);
	bool STATIC_IsGyroInputAllowed();
	void PreProcessJoystickInput(float fDeltaTime);
	struct FKeyBind STATIC_GenerateKeybindFromButton(const struct FName& ButtonName);
	void SetKeyCaptureState(bool bSpectator, bool bCaptureKey);
	void ResetKeysToDefault();
	bool STATIC_OnInputChar(int ControllerId, const struct FString& Unicode);
	bool STATIC_OnInputAxis(int ControllerId, const struct FName& Key, float Delta, float DeltaTime);
	bool STATIC_OnRawInputKey(int ControllerId, const struct FName& Key, TEnumAsByte<EInputEvent> Event, float AmountDepressed);
	void STATIC_HandleAimLock(float DeltaTime, const struct FVector& AnchorLocation, float HorizontalAssistAmount, float VerticalAssistAmount, float targetDist, class ATgDevice* AimAssistDevice);
};


// Class TgGame.TgSpectatorInput
// 0x0004 (0x0514 - 0x0510)
class UTgSpectatorInput : public UTgPlayerInput
{
public:
	float                                              SpectatorSensitivity;                                     // 0x0510(0x0004) (Config)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSpectatorInput");
		return ptr;
	}


	void PlayerInput(float DeltaTime);
	void STATIC_AdjustMouseSensitivity(float FOVScale);
	void CheckIdleBreak();
};


// Class TgGame.TgSkeletalMeshActor_Loader
// 0x01A8 (0x04D4 - 0x032C)
class ATgSkeletalMeshActor_Loader : public ATgSkeletalMeshActor
{
public:
	struct FPointer                                    VfTable_ITgSkinnableInterface;                            // 0x032C(0x0008) (Const, Native, NoExport)
	class UTgMenuMeshInfo*                             m_PendingMeshInfo;                                        // 0x0334(0x0008) (Transient)
	class UTgMenuMeshInfo*                             m_CurrentMeshInfo;                                        // 0x033C(0x0008) (Transient)
	class UTgManifestGroup*                            c_AssetManifestGroup;                                     // 0x0344(0x0008) (ExportObject, NeedCtorLink, EditInline)
	struct FPointer                                    m_PendingBot;                                             // 0x034C(0x0008) (Native)
	struct FPointer                                    m_PendingSkin;                                            // 0x0354(0x0008) (Native)
	struct FPointer                                    m_PendingHead;                                            // 0x035C(0x0008) (Native)
	struct FPointer                                    m_PendingDevice;                                          // 0x0364(0x0008) (Native)
	struct FPointer                                    m_PendingDeviceSkin;                                      // 0x036C(0x0008) (Native)
	struct FPointer                                    m_PendingDeployable;                                      // 0x0374(0x0008) (Native)
	struct FPointer                                    m_PendingMarker;                                          // 0x037C(0x0008) (Native)
	TEnumAsByte<ELobbyAnimPose>                        m_PendingPose;                                            // 0x0384(0x0001) (Transient)
	TEnumAsByte<ELobbyAnimPose>                        m_CurrentPose;                                            // 0x0385(0x0001) (Transient)
	TEnumAsByte<EModelHighlightType>                   m_HighlightType;                                          // 0x0386(0x0001) (Transient)
	unsigned char                                      UnknownData00[0x1];                                       // 0x0387(0x0001) MISSED OFFSET
	struct FPointer                                    m_PendingMVPDevice;                                       // 0x0388(0x0008) (Native)
	struct FPointer                                    m_PendingContrailSkin;                                    // 0x0390(0x0008) (Native)
	struct FPointer                                    m_CurrentBot;                                             // 0x0398(0x0008) (Native)
	struct FPointer                                    m_CurrentSkin;                                            // 0x03A0(0x0008) (Native)
	struct FPointer                                    m_CurrentHead;                                            // 0x03A8(0x0008) (Native)
	struct FPointer                                    m_CurrentDevice;                                          // 0x03B0(0x0008) (Native)
	struct FPointer                                    m_CurrentDeviceSkin;                                      // 0x03B8(0x0008) (Native)
	struct FPointer                                    m_CurrentDeployable;                                      // 0x03C0(0x0008) (Native)
	struct FPointer                                    m_CurrentMarker;                                          // 0x03C8(0x0008) (Native)
	struct FPointer                                    m_CurrentMVPDevice;                                       // 0x03D0(0x0008) (Native)
	struct FPointer                                    m_CurrentContrailSkin;                                    // 0x03D8(0x0008) (Native)
	struct FPointer                                    m_SpawnedMarker;                                          // 0x03E0(0x0008) (Native)
	unsigned long                                      m_bWaitingForTextures : 1;                                // 0x03E8(0x0004) (Transient)
	unsigned long                                      m_bIsAsyncLoading : 1;                                    // 0x03E8(0x0004) (Transient)
	unsigned long                                      m_bAllowOverlays : 1;                                     // 0x03E8(0x0004) (Edit)
	unsigned long                                      m_bUsesPreviewMesh : 1;                                   // 0x03E8(0x0004) (Edit)
	unsigned long                                      m_bOverrideLightingChannels : 1;                          // 0x03E8(0x0004) (Edit)
	int                                                m_nAsyncLoadDelayTicksDefault;                            // 0x03EC(0x0004)
	int                                                m_nAsyncLoadDelayTicks;                                   // 0x03F0(0x0004) (Transient)
	class UPointLightComponent*                        m_PointLight;                                             // 0x03F4(0x0008) (ExportObject, Transient, Component, EditInline)
	TArray<class UTgSkeletalMeshComponent*>            m_ChildMeshes;                                            // 0x03FC(0x0010) (ExportObject, Transient, Component, NeedCtorLink, EditInline)
	TArray<class UTgSkeletalMeshComponent*>            m_SkinMeshes;                                             // 0x040C(0x0010) (ExportObject, Transient, Component, NeedCtorLink, EditInline)
	TArray<class UTgSkeletalMeshComponent*>            m_HeadMeshes;                                             // 0x041C(0x0010) (ExportObject, Transient, Component, NeedCtorLink, EditInline)
	TArray<class UTgSkeletalMeshComponent*>            m_WeaponMeshes;                                           // 0x042C(0x0010) (ExportObject, Transient, Component, NeedCtorLink, EditInline)
	class ULightEnvironmentComponent*                  m_AlternateLightEnvironmentTemplate;                      // 0x043C(0x0008) (ExportObject, Transient, Component, EditInline)
	TArray<class ULightEnvironmentComponent*>          m_AlternateLightEnvironments;                             // 0x0444(0x0010) (ExportObject, Transient, Component, NeedCtorLink, EditInline)
	class UMaterialInterface*                          m_OverlayMaterial;                                        // 0x0454(0x0008)
	class UTgCustomCharacterComponent*                 m_CustomCharacterComponent;                               // 0x045C(0x0008) (Edit, ExportObject, Component, EditInline)
	TArray<class UMaterialInstanceConstant*>           m_MeshReplacementMICs;                                    // 0x0464(0x0010) (NeedCtorLink)
	TArray<struct FLobbySMAMeterBus>                   m_MeterBusses;                                            // 0x0474(0x0010) (NeedCtorLink)
	struct FLightingChannelContainer                   m_LightingChannels;                                       // 0x0484(0x0004) (Edit, Const)
	TArray<class UTgAnimBlendByEmote*>                 m_EmoteBlendNodes;                                        // 0x0488(0x0010) (Transient, NeedCtorLink)
	TArray<class UTgAnimNodeEmoteSequence*>            m_EmoteSequenceNodes;                                     // 0x0498(0x0010) (Transient, NeedCtorLink)
	class UMaterialInstanceConstant*                   NonHighlightMaterial;                                     // 0x04A8(0x0008)
	class UAnimSet*                                    m_EmoteAnimSet;                                           // 0x04B0(0x0008) (Transient)
	class UAnimSet*                                    m_MVPAnimSet;                                             // 0x04B8(0x0008) (Transient)
	float                                              m_fEmoteLoopDelay;                                        // 0x04C0(0x0004)
	struct FScriptDelegate                             __OnMeshUpdated__Delegate;                                // 0x04C4(0x000C) (NeedCtorLink)
	unsigned char                                      UnknownData01[0x4];                                       // 0x04C4(0x0004) FIX WRONG TYPE SIZE OF PREVIOUS PROPERTY

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkeletalMeshActor_Loader");
		return ptr;
	}


	bool STATIC_PlayParticleEffect(class UAnimNotify_PlayParticleEffect* AnimNotifyData);
	void STATIC_PlayChildAnim(class UTgSkeletalMeshComponent* notifySource, const struct FName& AnimSeqName);
	void STATIC_EndTransition();
	void STATIC_BeginTransition(bool bPlayFx);
	void PreBeginPlay();
	void STATIC_PlayMVPTimer();
	void PlayEmoteTimer();
	void STATIC_PlaySkydiveAndLandTimer();
	void PlaySkydiveTimer();
	void STATIC_PlayDelayedEmoteLoop();
	void TeardownMeterBusses();
	void ReplaceMaterialInstances();
	void SetMaterialScalarParameterValue(const struct FName& szParameterName, float fValue, bool bSkin, bool bHead, bool bWeapon);
	void CancelEmote(bool bVerifyNoRelevantEmotes, class UTgAnimNodeEmoteSequence* Exclude);
	void STATIC_StopSkydiveAndLand();
	void STATIC_PlaySkydiveAndLand();
	void StopSkydive();
	void PlaySkydive();
	void StopMVP();
	void PlayMVP(int nDeviceId, bool bInstant);
	void StopEmote();
	void PlayEmote(int nDeviceId);
	void PlayLobbyAnim(TEnumAsByte<ELobbyAnimState> NewAnimState);
	void STATIC_RecalculateMaterial(bool bIsFriendlyWithLocalPawn, bool bForce);
	void ForceRecalculateMaterial();
	void CleanupForAssetSwap(bool bReset);
	void STATIC_SetActive(bool bActive);
	void AllManifestsLoaded();
	void ResetAnims();
	void Destroyed();
	void STATIC_OnMeshUpdated();
};


// Class TgGame.TgSkeletalMeshActor_FlagStand
// 0x0020 (0x04F4 - 0x04D4)
class ATgSkeletalMeshActor_FlagStand : public ATgSkeletalMeshActor_Loader
{
public:
	struct FString                                     m_FlagContentDataClassName;                               // 0x04D4(0x0010) (NeedCtorLink)
	class UTgFlagContentData*                          m_FlagContentData;                                        // 0x04E4(0x0008) (Transient)
	int                                                m_nGameTaskForce;                                         // 0x04EC(0x0004) (Edit)
	int                                                m_nTeamIndex;                                             // 0x04F0(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkeletalMeshActor_FlagStand");
		return ptr;
	}


	void PostBeginPlay();
	void PreBeginPlay();
	void ChangeTaskForceFlag(int nTaskForce, int nTeamIndex);
};


// Class TgGame.TgSkeletalMeshActor_LobbyBase
// 0x0020 (0x04F4 - 0x04D4)
class ATgSkeletalMeshActor_LobbyBase : public ATgSkeletalMeshActor_Loader
{
public:
	unsigned long                                      m_bPlayTransitionOutro : 1;                               // 0x04D4(0x0004) (Transient)
	struct FString                                     m_TransitionActorClassName;                               // 0x04D8(0x0010) (NeedCtorLink)
	int                                                m_nCharacterMastery;                                      // 0x04E8(0x0004) (Transient)
	class ATgMenuTransitionActor*                      m_TransitionActor;                                        // 0x04EC(0x0008) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkeletalMeshActor_LobbyBase");
		return ptr;
	}


	void Destroyed();
	void STATIC_EndTransition();
	void STATIC_BeginTransition(bool bPlayFx);
	void PostBeginPlay();
	void PreBeginPlay();
};


// Class TgGame.TgSkeletalMeshActor_Lobby
// 0x0074 (0x0568 - 0x04F4)
class ATgSkeletalMeshActor_Lobby : public ATgSkeletalMeshActor_LobbyBase
{
public:
	float                                              m_fSpawnOffsetYaw;                                        // 0x04F4(0x0004)
	float                                              m_fMaxSpawnRotation;                                      // 0x04F8(0x0004)
	float                                              m_fMinSpawnRotation;                                      // 0x04FC(0x0004)
	unsigned long                                      m_bAdjustMeshToGround : 1;                                // 0x0500(0x0004) (Edit)
	unsigned long                                      m_bCanBeRotated : 1;                                      // 0x0500(0x0004) (Edit)
	unsigned long                                      m_bEnablePostures : 1;                                    // 0x0500(0x0004) (Edit)
	int                                                m_CardMICBotIdPending;                                    // 0x0504(0x0004) (Transient)
	float                                              m_CardMICTransitionDesiredAlpha;                          // 0x0508(0x0004) (Transient)
	float                                              m_CardMICTransitionAlpha;                                 // 0x050C(0x0004) (Transient)
	class ATgSkeletalMeshActor_FlagStand*              m_FlagStandActor;                                         // 0x0510(0x0008) (Edit)
	class ATgSkeletalMeshActor_Pedestal*               m_PedestalActor;                                          // 0x0518(0x0008) (Edit)
	TArray<class UMaterialInstanceConstant*>           m_CardMICs;                                               // 0x0520(0x0010) (Edit, NeedCtorLink)
	TEnumAsByte<ETG_POSTURE>                           r_CurrentPosture;                                         // 0x0530(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0531(0x0003) MISSED OFFSET
	float                                              m_fRotationAmount;                                        // 0x0534(0x0004) (Transient)
	float                                              m_fDesiredRotationAmount;                                 // 0x0538(0x0004) (Transient)
	struct FRotator                                    m_rOriginalRotation;                                      // 0x053C(0x000C) (Transient)
	float                                              m_fSelectionGlowRemainingTime;                            // 0x0548(0x0004) (Transient)
	float                                              m_fSelectionGlowTotalTime;                                // 0x054C(0x0004)
	TArray<class UTgAnimBlendByPosture*>               m_PostureBlendNodes;                                      // 0x0550(0x0010) (Transient, NeedCtorLink)
	class UParticleSystemComponent*                    m_HighlightPSC;                                           // 0x0560(0x0008) (Edit, ExportObject, Component, EditInline)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkeletalMeshActor_Lobby");
		return ptr;
	}


	void STATIC_Highlight(bool bHighlight);
	void STATIC_OnSetSkelPosture(class UTgSeqAct_SetSkelPosture* Action);
	void SetActivePosture(TEnumAsByte<ETG_POSTURE> Posture);
	void STATIC_InitPostureNodes();
	void STATIC_PostInitAnimTree(class USkeletalMeshComponent* SkelComp);
	float STATIC_GetSpawnRotation();
	void Destroyed();
	void STATIC_EndTransition();
	void PostBeginPlay();
	void PreBeginPlay();
	void STATIC_ReplicatedEvent(const struct FName& VarName);
	void AllManifestsLoaded();
	void AdjustMeshToGround();
	void RotateModel(float fValue, bool bSnap);
	void STATIC_SetActive(bool bActive);
};


// Class TgGame.TgSkeletalMeshActor_Pedestal
// 0x001D (0x0585 - 0x0568)
class ATgSkeletalMeshActor_Pedestal : public ATgSkeletalMeshActor_Lobby
{
public:
	struct FPointer                                    m_DefaultBot;                                             // 0x0568(0x0008) (Native, Transient)
	TArray<class AActor*>                              m_DefaultPedestalActors;                                  // 0x0570(0x0010) (Edit, NeedCtorLink)
	unsigned long                                      m_bUsingDefaultPedestal : 1;                              // 0x0580(0x0004) (Transient)
	TEnumAsByte<EPedestalType>                         m_PedestalType;                                           // 0x0584(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkeletalMeshActor_Pedestal");
		return ptr;
	}


	void STATIC_EndTransition();
	void SwitchToDefaultPedestal(TEnumAsByte<ELobbyAnimPose> animPose);
};


// Class TgGame.TgSkeletalMeshActor_Leash
// 0x0030 (0x035C - 0x032C)
class ATgSkeletalMeshActor_Leash : public ATgSkeletalMeshActorSpawnable
{
public:
	class USkeletalMeshComponent*                      m_StartMesh;                                              // 0x032C(0x0008) (ExportObject, Component, EditInline)
	struct FName                                       m_StartBoneName;                                          // 0x0334(0x0008)
	class USkeletalMeshComponent*                      m_EndMesh;                                                // 0x033C(0x0008) (ExportObject, Component, EditInline)
	struct FName                                       m_EndBoneName;                                            // 0x0344(0x0008)
	class USkelControlSingleBone*                      m_StartControl;                                           // 0x034C(0x0008)
	class USkelControlSingleBone*                      m_EndControl;                                             // 0x0354(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkeletalMeshActor_Leash");
		return ptr;
	}

};


// Class TgGame.TgSkeletalMeshComponent
// 0x00B8 (0x086C - 0x07B4)
class UTgSkeletalMeshComponent : public USkeletalMeshComponent
{
public:
	unsigned long                                      c_bFxApplied : 1;                                         // 0x07B4(0x0004)
	unsigned long                                      c_bIsFemale : 1;                                          // 0x07B4(0x0004)
	TArray<class UTgSpecialFx*>                        c_FxList;                                                 // 0x07B8(0x0010) (NeedCtorLink)
	TArray<class UTgSpecialFx*>                        c_DatabaseFxList;                                         // 0x07C8(0x0010) (NeedCtorLink)
	TArray<struct FFx_AssemblyData>                    c_FxAssemblyData;                                         // 0x07D8(0x0010) (NeedCtorLink)
	int                                                m_nAssemblyId;                                            // 0x07E8(0x0004)
	TArray<class UTgSkeletalMeshComponent*>            m_ChildMeshes;                                            // 0x07EC(0x0010) (ExportObject, Component, NeedCtorLink, EditInline)
	struct FVector                                     FPCTranslation;                                           // 0x07FC(0x000C)
	struct FRotator                                    FPCRotation;                                              // 0x0808(0x000C)
	struct FVector                                     FPCScale;                                                 // 0x0814(0x000C)
	int                                                c_AudioGroupId;                                           // 0x0820(0x0004)
	int                                                c_nForceUpdateAttachmentsInTick;                          // 0x0824(0x0004)
	TArray<class UTgHeadShotComponent*>                c_HeadShotComponents;                                     // 0x0828(0x0010) (ExportObject, Component, NeedCtorLink, EditInline)
	TArray<struct FAnimNotifyParticleCacheEntry>       AnimNotifyPlayParticleEffectEntries;                      // 0x0838(0x0010) (Transient, Component, AlwaysInit, NeedCtorLink)
	int                                                m_nMaterialStackId;                                       // 0x0848(0x0004)
	TArray<struct FMaterialStackInstance>              m_MaterialStack;                                          // 0x084C(0x0010) (NeedCtorLink)
	TArray<struct FMeshAccessoryStorage>               m_MeshAccessoryStorage;                                   // 0x085C(0x0010) (Component, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkeletalMeshComponent");
		return ptr;
	}


	void CachePSC(class UParticleSystemComponent* PSC, const struct FAnimNotifyParticleCacheEntry& CacheEntry, class UAnimNotify_PlayParticleEffect* AnimNotifyData);
	class UParticleSystemComponent* GetPSCForPlayParticleEffect(class UAnimNotify_PlayParticleEffect* AnimNotifyData);
	bool STATIC_GetAnimNotifyParticleCacheEntryFor(class UAnimNotify_PlayParticleEffect* AnimNotifyData, struct FAnimNotifyParticleCacheEntry* CacheEntry);
	void FxPushMaterialToWeaponMesh(const struct FName& nmGroup);
	bool PopMaterial(int nMaterialHandle);
	int PushMaterialManual(TArray<class UMaterialInstanceConstant*> MICs, int nPriority);
	int PushMaterial(class UMaterialInterface* MI, TEnumAsByte<EMaterialParamHarvestType> eParamHarvestType, int nPriority);
	void SetForceUpdateAttachmentsInTick(bool bSet);
	class UAnimTree* STATIC_GetAnimTree();
	void STATIC_SetParentAnimComponent(class USkeletalMeshComponent* NewParentAnimComp);
	void OnMeshSetHidden(bool bHidden);
	void STATIC_RecalculateFx();
	void STATIC_ActivateWhileAliveFx(bool bOn, const struct FName& nmDisplayGroup);
	void STATIC_ActivateOnWhenDeployedFx(bool bOn);
	float STATIC_GetCurrentDeployPercentage();
	void STATIC_SwapMaterial(class UMaterialInterface* MI, bool bNoParamReaping);
	class UMaterialInterface* GetDefaultMaterial(int nIndex);
	void STATIC_SetDefaultSkin(int nIndex);
	class UObject* FxActivateIndependant(const struct FName& nmGroup, int nMode, const struct FVector& HitLocation, const struct FVector& HitNormal, int nSocketIndex, int nEquipSlot, bool bUseSocketOverride, TArray<struct FParticleSysParam> Params);
	void FxSpawnSound(const struct FName& nmGroup, int nMode, const struct FVector& SoundLocation, int nSocketIndex, int nEquipSlot);
	void FxSpawnEmitter(const struct FName& nmGroup, int nMode, const struct FVector& HitLocation, const struct FVector& HitNormal, int nSocketIndex, int nEquipSlot);
	void FxSpawnTracer(const struct FName& nmGroup, int nMode, const struct FVector& HitLocation, int nSocketIndex, int nEquipSlot);
	void FxDeactivateAll(int nEquipSlot);
	void FxDeactivateGroup(const struct FName& nmGroup, int nMode, int nSocketIndex, int nEquipSlot);
	class UObject* FxActivateGroup(const struct FName& nmGroup, int nMode, int nSocketIndex, int nEquipSlot, bool bIgnoreRelevancy, bool bFromEffectForm, bool bSkipWeapon);
	TArray<class UObject*> FxGetAll(const struct FName& nmGroup, int nMode, int nIndex, int nSocketIndex, int nEquipSlot);
	class UObject* FxGet(const struct FName& nmGroup, int nMode, int nIndex, int nSocketIndex, int nEquipSlot);
	void FxRemove(class UObject* Fx);
	void FxAdd(class UObject* Fx);
	void EndRagdoll();
	void InitRagdoll();
};


// Class TgGame.TgSkeletalMeshComponent_Weapon
// 0x0020 (0x088C - 0x086C)
class UTgSkeletalMeshComponent_Weapon : public UTgSkeletalMeshComponent
{
public:
	struct FName                                       m_nmFire;                                                 // 0x086C(0x0008) (Const)
	struct FName                                       m_nmFireLoop;                                             // 0x0874(0x0008) (Const)
	struct FName                                       m_nmFireLoopTailSound;                                    // 0x087C(0x0008) (Const)
	unsigned long                                      m_bDoNotPlayFireParticlesIfHidden : 1;                    // 0x0884(0x0004)
	unsigned long                                      m_bKillFiringLoopParticlesOnHidden : 1;                   // 0x0884(0x0004) (Const)
	unsigned long                                      m_bCanPlayFireParticles : 1;                              // 0x0884(0x0004) (Const)
	unsigned long                                      m_bCanPlayFireLoopParticles : 1;                          // 0x0884(0x0004) (Const)
	unsigned long                                      m_bCanPlayFireSounds : 1;                                 // 0x0884(0x0004) (Const)
	unsigned long                                      m_bCanPlayFireLoopSounds : 1;                             // 0x0884(0x0004) (Const)
	int                                                m_nFireLoopActiveBitMask;                                 // 0x0888(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkeletalMeshComponent_Weapon");
		return ptr;
	}


	void STATIC_SetParentAnimComponent(class USkeletalMeshComponent* NewParentAnimComp);
	void StopFireLoop(int nEquipSlot, int nFireMode);
	void PlayFireLoop(int nEquipSlot, int nFireMode);
	void STATIC_GetAllFireLoopParticleSystemComponents(int nEquipSlot, int nFireMode, TArray<class UParticleSystemComponent*>* FireLoopParticles);
	bool STATIC_IsFireLoopActivated(int nEquipSlot);
	bool STATIC_IsFireLoopActive(int nEquipSlot, int nFireMode);
	void StopFire(bool bForce, int nEquipSlot, int nFireMode);
	void PlayFire(int nEquipSlot, int nFireMode);
	void SetCanPlaySoundFlags(bool bFire, bool bFireLoop);
	void SetCanPlayParticleFlags(bool bFire, bool bFireLoop, bool bDoNotPlayIfHidden);
	void SetFireLoopDisplayGroup(const struct FName& nmFire, const struct FName& nmFireLoopTail);
	void SetFireDisplayGroup(const struct FName& nmFire);
	void CompleteInitialization();
};


// Class TgGame.TgStaticMeshActor
// 0x0000 (0x02A4 - 0x02A4)
class ATgStaticMeshActor : public AStaticMeshActor
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgStaticMeshActor");
		return ptr;
	}

};


// Class TgGame.TgStaticMeshActor_PantheonMIC
// 0x0048 (0x02EC - 0x02A4)
class ATgStaticMeshActor_PantheonMIC : public ATgStaticMeshActor
{
public:
	class UMaterialInstanceConstant*                   MICOverrides[0x8];                                        // 0x02A4(0x0008) (Edit)
	int                                                m_nGameTaskForce;                                         // 0x02E4(0x0004) (Edit)
	int                                                m_nTeamIndex;                                             // 0x02E8(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgStaticMeshActor_PantheonMIC");
		return ptr;
	}


	void PreBeginPlay();
	void ChangePantheonMIC(int nTaskForce, int nTeamIndex);
};


// Class TgGame.TgStaticMeshActor_CapturePoint
// 0x005C (0x0300 - 0x02A4)
class ATgStaticMeshActor_CapturePoint : public AStaticMeshActor
{
public:
	struct FLinearColor                                UncontestedCaptureColor;                                  // 0x02A4(0x0010) (Edit, Const)
	struct FLinearColor                                FriendlyCaptureColor;                                     // 0x02B4(0x0010) (Edit, Const)
	struct FLinearColor                                EnemyCaptureColor;                                        // 0x02C4(0x0010) (Edit, Const)
	struct FName                                       EmissiveColorParameterName;                               // 0x02D4(0x0008) (Edit, Const)
	struct FName                                       CapturePercentParameterName;                              // 0x02DC(0x0008) (Edit, Const)
	TArray<class UMaterialInterface*>                  InitialMaterialList;                                      // 0x02E4(0x0010) (Transient, NeedCtorLink)
	unsigned long                                      bInstancedAllMaterials : 1;                               // 0x02F4(0x0004) (Const)
	int                                                CurrentCaptureStatus;                                     // 0x02F8(0x0004)
	float                                              CurrentCapturePercent;                                    // 0x02FC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgStaticMeshActor_CapturePoint");
		return ptr;
	}


	void SetCaptureStatus(int nCaptureStatus, float fPercent);
	void SetCapturePercent(float fNewPercent, float bRampTime);
	void SetEmissiveColor(const struct FLinearColor& NewColor, float fPercent, float fRampTime);
};


// Class TgGame.TgStaticMeshActor_TeamColor
// 0x0024 (0x02C8 - 0x02A4)
class ATgStaticMeshActor_TeamColor : public AStaticMeshActor
{
public:
	int                                                nTaskForce;                                               // 0x02A4(0x0004) (Edit, Const)
	struct FName                                       TeamColoringParameterName;                                // 0x02A8(0x0008) (Edit, Const)
	unsigned long                                      bInvertColoringParameter : 1;                             // 0x02B0(0x0004) (Edit, Const)
	unsigned long                                      bInstancedAllMaterials : 1;                               // 0x02B0(0x0004) (Const)
	unsigned char                                      bFriendlyWithLocalPlayer;                                 // 0x02B4(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x02B5(0x0003) MISSED OFFSET
	TArray<class UMaterialInterface*>                  InitialMaterialList;                                      // 0x02B8(0x0010) (Transient, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgStaticMeshActor_TeamColor");
		return ptr;
	}


	void NotifyLocalPlayerTeamReceived();
	void UpdateFriendlyFlag();
	void STATIC_RecalculateMaterial(bool bIsFriendlyWithLocalPawn, bool bForce);
	void ForceRecalculateMaterial();
};


// Class TgGame.TgStaticMeshActorTargeting
// 0x0000 (0x02A4 - 0x02A4)
class ATgStaticMeshActorTargeting : public AStaticMeshActor
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgStaticMeshActorTargeting");
		return ptr;
	}

};


// Class TgGame.TgStaticMeshComponent
// 0x0038 (0x0348 - 0x0310)
class UTgStaticMeshComponent : public UStaticMeshComponent
{
public:
	unsigned long                                      c_bFxApplied : 1;                                         // 0x0310(0x0004)
	TArray<class UTgSpecialFx*>                        c_FxList;                                                 // 0x0314(0x0010) (NeedCtorLink)
	TArray<class UTgSpecialFx*>                        c_DatabaseFxList;                                         // 0x0324(0x0010) (NeedCtorLink)
	TArray<struct FFx_AssemblyData>                    c_FxAssemblyData;                                         // 0x0334(0x0010) (NeedCtorLink)
	int                                                m_nAssemblyId;                                            // 0x0344(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgStaticMeshComponent");
		return ptr;
	}


	void STATIC_RecalculateFx();
	void OnMeshSetHidden(bool bHidden);
	class UMaterialInterface* GetDefaultMaterial(int nIndex);
	void STATIC_SetDefaultSkin(int nIndex);
	void STATIC_SwapMaterial(class UMaterialInterface* MI, bool bNoParamReaping);
	class UObject* FxActivateIndependant(const struct FName& nmGroup, int nMode, const struct FVector& HitLocation, const struct FVector& HitNormal, int nSocketIndex, int nEquipSlot, bool bUseSocketOverride, TArray<struct FParticleSysParam> Params);
	void FxSpawnSound(const struct FName& nmGroup, int nMode, const struct FVector& SoundLocation, int nSocketIndex, int nEquipSlot);
	void FxSpawnEmitter(const struct FName& nmGroup, int nMode, const struct FVector& HitLocation, const struct FVector& HitNormal, int nSocketIndex, int nEquipSlot);
	void FxSpawnTracer(const struct FName& nmGroup, int nMode, const struct FVector& HitLocation, int nSocketIndex, int nEquipSlot);
	void FxDeactivateAll(int nEquipSlot);
	void FxDeactivateGroup(const struct FName& nmGroup, int nMode, int nSocketIndex, int nEquipSlot);
	class UObject* FxActivateGroup(const struct FName& nmGroup, int nMode, int nSocketIndex, int nEquipSlot, bool bIgnoreRelevancy, bool bFromEffectForm, bool bSkipWeapon);
	TArray<class UObject*> FxGetAll(const struct FName& nmGroup, int nMode, int nIndex, int nSocketIndex, int nEquipSlot);
	class UObject* FxGet(const struct FName& nmGroup, int nMode, int nIndex, int nSocketIndex, int nEquipSlot);
	void FxRemove(class UObject* Fx);
	void FxAdd(class UObject* Fx);
};


// Class TgGame.TgSubtitledMessages
// 0x004C (0x00AC - 0x0060)
class UTgSubtitledMessages : public UObject
{
public:
	struct FQueuedSubtitle                             CurrentSubtitle;                                          // 0x0060(0x0024) (NeedCtorLink)
	TArray<struct FQueuedSubtitle>                     QueuedSubtitles;                                          // 0x0084(0x0010) (NeedCtorLink)
	class ATgPlayerController*                         OwnerPC;                                                  // 0x0094(0x0008) (Transient)
	class UAudioComponent*                             PlayingSubtitleAC;                                        // 0x009C(0x0008) (ExportObject, Transient, Component, EditInline)
	unsigned long                                      bFinishedSubtitle : 1;                                    // 0x00A4(0x0004)
	float                                              SubtitleFailsafeTime;                                     // 0x00A8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSubtitledMessages");
		return ptr;
	}


	void STATIC_PlaySubtitleSoundCue(class USoundCue* CueToPlay);
	void Destroyed();
	void Init();
	void SubtitleFailsafe();
	void SubtitledCueEnded(class UAudioComponent* AC);
	void PlaySubtitledMessage(int MessageId, bool PlayImmediately, bool FlushOthers, class UAkEvent* CustomShutdownEvent);
};


// Class TgGame.TgAIBehaviorObject
// 0x0004 (0x0064 - 0x0060)
class UTgAIBehaviorObject : public UObject
{
public:
	int                                                NodeToken;                                                // 0x0060(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorObject");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorComment
// 0x0000 (0x0064 - 0x0064)
class UTgAIBehaviorComment : public UTgAIBehaviorObject
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorComment");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorNode
// 0x0030 (0x0094 - 0x0064)
class UTgAIBehaviorNode : public UTgAIBehaviorObject
{
public:
	class UTgAIBehaviorNode*                           Parent;                                                   // 0x0064(0x0008) (DuplicateTransient)
	float                                              InvTickFrequency;                                         // 0x006C(0x0004)
	struct FString                                     TitleName;                                                // 0x0070(0x0010) (NeedCtorLink)
	struct FString                                     FriendlyName;                                             // 0x0080(0x0010) (Edit, AlwaysInit, NeedCtorLink)
	unsigned long                                      bShownInMenu : 1;                                         // 0x0090(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorNode");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorAction : public UTgAIBehaviorNode
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_PlayVGS
// 0x0008 (0x009C - 0x0094)
class UTgAIBehaviorAction_PlayVGS : public UTgAIBehaviorAction
{
public:
	int                                                VoicePackId;                                              // 0x0094(0x0004) (Edit)
	int                                                VgsId;                                                    // 0x0098(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_PlayVGS");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorComposite
// 0x0024 (0x00B8 - 0x0094)
class UTgAIBehaviorComposite : public UTgAIBehaviorNode
{
public:
	TArray<class UTgAIBehaviorNode*>                   Children;                                                 // 0x0094(0x0010) (EditFixedSize, AlwaysInit, NeedCtorLink, EditInline)
	TArray<int>                                        ChildrenIndices;                                          // 0x00A4(0x0010) (Transient, AlwaysInit, NeedCtorLink)
	unsigned long                                      bCompleteOnAll : 1;                                       // 0x00B4(0x0004) (Edit, Const, EditConst)
	unsigned long                                      bFailsOnAll : 1;                                          // 0x00B4(0x0004) (Edit, Const, EditConst)
	unsigned long                                      bRetryFailedChild : 1;                                    // 0x00B4(0x0004) (Edit, Const, EditConst)
	unsigned long                                      bFixedChildrenSize : 1;                                   // 0x00B4(0x0004) (Const, EditConst)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorComposite");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorComposite_Gated
// 0x0000 (0x00B8 - 0x00B8)
class UTgAIBehaviorComposite_Gated : public UTgAIBehaviorComposite
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorComposite_Gated");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorComposite_Random
// 0x0018 (0x00D0 - 0x00B8)
class UTgAIBehaviorComposite_Random : public UTgAIBehaviorComposite
{
public:
	TArray<float>                                      ChildWeights;                                             // 0x00B8(0x0010) (Edit, EditFixedSize, NeedCtorLink, EditInline)
	float                                              ChildFreezeTime;                                          // 0x00C8(0x0004) (Edit)
	unsigned long                                      bRandomizeOnComplete : 1;                                 // 0x00CC(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorComposite_Random");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorComposite_Sequence
// 0x0004 (0x00BC - 0x00B8)
class UTgAIBehaviorComposite_Sequence : public UTgAIBehaviorComposite
{
public:
	unsigned long                                      bStopOnRunningChild : 1;                                  // 0x00B8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorComposite_Sequence");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorComposite_Parallel
// 0x0000 (0x00BC - 0x00BC)
class UTgAIBehaviorComposite_Parallel : public UTgAIBehaviorComposite_Sequence
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorComposite_Parallel");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorComposite_SequenceScripted
// 0x0004 (0x00BC - 0x00B8)
class UTgAIBehaviorComposite_SequenceScripted : public UTgAIBehaviorComposite
{
public:
	unsigned long                                      bFreezeOnLast : 1;                                        // 0x00B8(0x0004) (Edit)
	unsigned long                                      bIsLooping : 1;                                           // 0x00B8(0x0004) (Edit)
	unsigned long                                      bFirstChildIsResetTest : 1;                               // 0x00B8(0x0004) (Edit)
	unsigned long                                      bResetSequenceOnFailure : 1;                              // 0x00B8(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorComposite_SequenceScripted");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorComposite_SubTree
// 0x0008 (0x00C0 - 0x00B8)
class UTgAIBehaviorComposite_SubTree : public UTgAIBehaviorComposite
{
public:
	class UTgAIBehaviorTree*                           ChildTree;                                                // 0x00B8(0x0008) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorComposite_SubTree");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition
// 0x0001 (0x0095 - 0x0094)
class UTgAIBehaviorCondition : public UTgAIBehaviorNode
{
public:
	TEnumAsByte<EBehaviorComparison>                   ComparisonOperator;                                       // 0x0094(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_CombatTargetHasEffectCategory
// 0x000F (0x00A4 - 0x0095)
class UTgAIBehaviorCondition_CombatTargetHasEffectCategory : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	unsigned long                                      bEffectGroupCategoryCheckInstigator : 1;                  // 0x0098(0x0004) (Edit)
	int                                                EffectCategoryId;                                         // 0x009C(0x0004) (Edit)
	int                                                EffectGroupId;                                            // 0x00A0(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_CombatTargetHasEffectCategory");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_HasEffectCategory
// 0x000B (0x00A0 - 0x0095)
class UTgAIBehaviorCondition_HasEffectCategory : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	int                                                EffectCategoryId;                                         // 0x0098(0x0004) (Edit)
	int                                                EffectGroupId;                                            // 0x009C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_HasEffectCategory");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_InteractTargetOfType
// 0x0008 (0x009D - 0x0095)
class UTgAIBehaviorCondition_InteractTargetOfType : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	int                                                ByteAlignment;                                            // 0x0098(0x0004) (Edit)
	TEnumAsByte<EInteractTargetType>                   InteractTargetType;                                       // 0x009C(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_InteractTargetOfType");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorSensor
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorSensor : public UTgAIBehaviorNode
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorSensor");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorTree
// 0x0028 (0x00BC - 0x0094)
class UTgAIBehaviorTree : public UTgAIBehaviorNode
{
public:
	class UTgAIBehaviorComposite*                      ChildNode;                                                // 0x0094(0x0008)
	TArray<class UTgAIBehaviorSensor*>                 SensorNodes;                                              // 0x009C(0x0010) (AlwaysInit, NeedCtorLink)
	TArray<class UTgAIUtilitySet*>                     UtilitySets;                                              // 0x00AC(0x0010) (AlwaysInit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorTree");
		return ptr;
	}

};


// Class TgGame.TgAIUtility
// 0x0028 (0x00BC - 0x0094)
class UTgAIUtility : public UTgAIBehaviorNode
{
public:
	TEnumAsByte<EUtilityType>                          UtilityType;                                              // 0x0094(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	TArray<TEnumAsByte<EBotBehaviorState>>             IgnoreBehaviorState;                                      // 0x0098(0x0010) (Edit, AlwaysInit, NeedCtorLink)
	TArray<TEnumAsByte<EBotBehaviorState>>             RejctBehaviorState;                                       // 0x00A8(0x0010) (Edit, AlwaysInit, NeedCtorLink)
	int                                                ParentIndex;                                              // 0x00B8(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIUtility");
		return ptr;
	}

};


// Class TgGame.TgAIUtilitySet
// 0x0024 (0x00B8 - 0x0094)
class UTgAIUtilitySet : public UTgAIBehaviorNode
{
public:
	TEnumAsByte<EAIAnnotationType>                     AnnotationType;                                           // 0x0094(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	TArray<class UTgAIUtility*>                        Functions;                                                // 0x0098(0x0010) (EditFixedSize, AlwaysInit, NeedCtorLink, EditInline)
	TArray<class UTgAIUtility*>                        Filters;                                                  // 0x00A8(0x0010) (EditFixedSize, AlwaysInit, NeedCtorLink, EditInline)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIUtilitySet");
		return ptr;
	}

};


// Class TgGame.TgAIController
// 0x01AC (0x068C - 0x04E0)
class ATgAIController : public AGameAIController
{
public:
	class ATgPawn*                                     m_pOwner;                                                 // 0x04E0(0x0008) (Transient)
	struct FVector                                     m_vSpawnLocation;                                         // 0x04E8(0x000C) (Transient)
	struct FRotator                                    m_rSpawnDirection;                                        // 0x04F4(0x000C) (Transient)
	class ATgBotFactory*                               m_pFactory;                                               // 0x0500(0x0008) (Transient)
	int                                                m_nFactorySpawnGroup;                                     // 0x0508(0x0004) (Transient)
	struct FPointer                                    m_pBot;                                                   // 0x050C(0x0008) (Const, Native, Transient)
	struct FPointer                                    m_pSettings;                                              // 0x0514(0x0008) (Const, Native, Transient)
	struct FPointer                                    m_pSkin;                                                  // 0x051C(0x0008) (Const, Native, Transient)
	int                                                m_iAssignedLane;                                          // 0x0524(0x0004) (Transient)
	unsigned char                                      UnknownData00[0x48];                                      // 0x0528(0x0048) UNKNOWN PROPERTY: MapProperty TgGame.TgAIController.m_SeePawnCache
	float                                              LastSeePawnCacheTime;                                     // 0x0570(0x0004) (Transient)
	float                                              SeePawnClearTime;                                         // 0x0574(0x0004) (Transient)
	class ATgPawn*                                     m_pLastAttacker;                                          // 0x0578(0x0008) (Transient)
	class UTgAISquad*                                  m_Squad;                                                  // 0x0580(0x0008) (Transient)
	float                                              LastDamageTakenTime;                                      // 0x0588(0x0004) (Transient)
	struct FVector                                     LastDamageTakenPosition;                                  // 0x058C(0x000C) (Transient)
	unsigned char                                      UnknownData01[0x48];                                      // 0x0598(0x0048) UNKNOWN PROPERTY: MapProperty TgGame.TgAIController.m_LoSCache
	float                                              LastLoSCacheTime;                                         // 0x05E0(0x0004) (Transient)
	TEnumAsByte<EHavokNavigationMeshType>              m_eNavmeshType;                                           // 0x05E4(0x0001) (Transient)
	TEnumAsByte<EPhysics>                              WalkingPhysics;                                           // 0x05E5(0x0001)
	unsigned char                                      UnknownData02[0x2];                                       // 0x05E6(0x0002) MISSED OFFSET
	float                                              m_fAILevelUpSecs;                                         // 0x05E8(0x0004)
	float                                              VisionDistance;                                           // 0x05EC(0x0004)
	float                                              VisionDistanceBonus;                                      // 0x05F0(0x0004)
	unsigned long                                      bUsesObstacleAvoidance : 1;                               // 0x05F4(0x0004)
	unsigned long                                      bIsPaused : 1;                                            // 0x05F4(0x0004) (Transient)
	unsigned long                                      bIsAIFrozen : 1;                                          // 0x05F4(0x0004) (Transient)
	class UTgAIObstacleAvoidance*                      ObstacleAvoidance;                                        // 0x05F8(0x0008) (Transient)
	float                                              ObstacleAvoidanceGridPointSize;                           // 0x0600(0x0004)
	float                                              ObstacleAvoidanceGridExtents;                             // 0x0604(0x0004)
	struct FVector                                     SpreadLocation;                                           // 0x0608(0x000C) (Transient)
	class ATgRepInfo_Player*                           CachedPRI;                                                // 0x0614(0x0008) (Transient)
	unsigned char                                      UnknownData03[0x48];                                      // 0x061C(0x0048) UNKNOWN PROPERTY: MapProperty TgGame.TgAIController.DeviceTargetingCache
	float                                              LastCheckStuckTime;                                       // 0x0664(0x0004) (Transient)
	float                                              CheckStuckTime;                                           // 0x0668(0x0004) (Transient)
	struct FVector                                     LastCachedStuckPosition;                                  // 0x066C(0x000C) (Transient)
	float                                              LastCheckFlungTime;                                       // 0x0678(0x0004) (Transient)
	float                                              CheckFlungTime;                                           // 0x067C(0x0004) (Transient)
	struct FVector                                     LastCachedFlungPosition;                                  // 0x0680(0x000C) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIController");
		return ptr;
	}


	void NotifyWeaponFired(class AWeapon* W, unsigned char FireMode);
	void STATIC_NotifyDamagedTarget(class ATgPawn* TargetPawn);
	void STATIC_DeviceOnStopFire(class ATgDevice* Dev, bool WasInterrupted);
	void STATIC_DeviceOnHit(class ATgDevice* Dev, struct FImpactInfo* Impact);
	void STATIC_ProjectileOnFire(class ATgProjectile* Proj);
	void STATIC_DeviceOnFire(class ATgDevice* Dev);
	void STATIC_DeviceOnStartFire(class ATgDevice* Dev);
	void STATIC_DeviceOnStopBuildup(class ATgDevice* Dev, bool WasInterrupted);
	void STATIC_DeviceOnStartBuildup(class ATgDevice* Dev);
	void STATIC_OnEnterCombat();
	void STATIC_OnExitCombat();
	void NotifyTakeHit(class AController* InstigatedBy, const struct FVector& HitLocation, int Damage, class UClass* DamageType, const struct FVector& Momentum);
	void STATIC_NotifyKilledBy(class AController* Killer);
	void SetActionlessPause(bool bOn);
	void STATIC_OnSetTaskforce(class UTgSeqAct_SetTaskforce* Action);
	void STATIC_OnTriggerBots(class UTgSeqAct_TriggerBots* Action);
	void PawnDied(class APawn* P);
	void STATIC_Suicide();
	void STATIC_Despawn();
	void Destroyed();
	void STATIC_CleanupPRI();
	void InitPlayerReplicationInfo();
	void STATIC_Possess(class APawn* inPawn, bool bVehicleTransition);
	void PostBeginPlay();
	bool CanSpreadOut();
	void ClearSpreadLocation();
	void SetSpreadLocation(struct FVector* SpreadLoc);
	void Evade();
	void SquadEvade();
	void SquadTargetChanged();
	void UpdateTargetingList(TArray<struct FImpactInfo> ImpactList, unsigned char EquipSlot);
	float STATIC_GetMaxDeviceRange();
	float STATIC_GetVisionDistance();
	struct FVector CalculateLobIntersection(const struct FVector& targetPos, const struct FVector& targetVel, const struct FVector& sourcePos, const struct FVector& sourceVel, float projVel);
	bool STATIC_LineCheckPassThrough(const struct FVector& vLocation, class AActor* pTarget, const struct FVector& vTarget);
	bool STATIC_LineCheckEx(const struct FVector& vLocation, class AActor* pTarget, const struct FVector& vTarget);
	bool LineCheck(const struct FVector& vLocation, class AActor* pTarget);
	bool STATIC_LineCheckVisibility(class AActor* pTarget, class AActor* pSource);
	bool STATIC_LineCheckMovement(class AActor* pTarget, class AActor* pSource);
	void SetTaskForceNumber(int nTaskForce);
	int STATIC_GetTaskForceNumber();
	void AddThreat(class ATgPawn* attacker, float fAmount);
	bool STATIC_IsDeviceReady(TEnumAsByte<ETG_EQUIP_POINT> DeviceSlot);
	bool STATIC_AtLocation(const struct FVector& vLocation);
};


// Class TgGame.TgAIController_Behavior
// 0x0280 (0x090C - 0x068C)
class ATgAIController_Behavior : public ATgAIController
{
public:
	TArray<struct FDeferredNode>                       DeferredNodes;                                            // 0x068C(0x0010) (Transient, AlwaysInit, NeedCtorLink)
	int                                                BlackboardType;                                           // 0x069C(0x0004) (Transient)
	struct FName                                       BehaviorTreeAsName;                                       // 0x06A0(0x0008)
	struct FPointer                                    SensorTree;                                               // 0x06A8(0x0008) (Native, Transient)
	struct FPointer                                    SensorDynamicMemory;                                      // 0x06B0(0x0008) (Native, Transient)
	struct FPointer                                    SensorStaticMemory;                                       // 0x06B8(0x0008) (Native, Transient)
	struct FPointer                                    WorkerTree;                                               // 0x06C0(0x0008) (Native, Transient)
	struct FPointer                                    WorkerTreeCachedStatus;                                   // 0x06C8(0x0008) (Native, Transient)
	struct FPointer                                    WorkerDynamicMemory;                                      // 0x06D0(0x0008) (Native, Transient)
	struct FPointer                                    WorkerStaticMemory;                                       // 0x06D8(0x0008) (Native, Transient)
	int                                                SensorNodeCount;                                          // 0x06E0(0x0004) (Transient)
	int                                                WorkerNodeCount;                                          // 0x06E4(0x0004) (Transient)
	float                                              LastUpdateTime;                                           // 0x06E8(0x0004) (Transient)
	TArray<struct FBehaviorStateData>                  CachedNodeData;                                           // 0x06EC(0x0010) (Transient, AlwaysInit, NeedCtorLink)
	float                                              m_fCooldownModifier;                                      // 0x06FC(0x0004)
	float                                              m_fLeadAccuracy;                                          // 0x0700(0x0004)
	float                                              m_fDegreeMissedMagnitude;                                 // 0x0704(0x0004)
	float                                              m_fMissLikelihood;                                        // 0x0708(0x0004)
	class UTgAILocalPositionSolver*                    LocalRepulsorSolver;                                      // 0x070C(0x0008) (Transient)
	class UClass*                                      LocalRepulsorSolverClass;                                 // 0x0714(0x0008)
	TArray<int>                                        m_IgnoredDeployableIds;                                   // 0x071C(0x0010) (NeedCtorLink)
	struct FNavigationQueueEntry                       CurrentNavigation;                                        // 0x072C(0x002C) (Transient)
	float                                              NavigationSearchModifier;                                 // 0x0758(0x0004) (Transient)
	float                                              NavigationSearchModifier_Max;                             // 0x075C(0x0004)
	float                                              NavigationSearchModifier_Min;                             // 0x0760(0x0004)
	float                                              TimeStuck;                                                // 0x0764(0x0004) (Transient)
	struct FFollowLaneState                            FollowLaneForwardState;                                   // 0x0768(0x0008)
	struct FFollowLaneState                            FollowLaneReverseState;                                   // 0x0770(0x0008)
	unsigned long                                      bIsAlive : 1;                                             // 0x0778(0x0004) (Transient)
	unsigned long                                      m_bPaused : 1;                                            // 0x0778(0x0004) (Transient)
	unsigned long                                      bIsRotationLocked : 1;                                    // 0x0778(0x0004) (Transient)
	unsigned long                                      bIsStunned : 1;                                           // 0x0778(0x0004) (Transient)
	unsigned long                                      bInHostileAbility : 1;                                    // 0x0778(0x0004) (Transient)
	unsigned long                                      bIsSafeToRecall : 1;                                      // 0x0778(0x0004) (Transient)
	unsigned long                                      bInEnemyTowerRadius : 1;                                  // 0x0778(0x0004) (Transient)
	unsigned long                                      bInFriendlyTowerRadius : 1;                               // 0x0778(0x0004) (Transient)
	unsigned long                                      bInEnemyMinotaurRadius : 1;                               // 0x0778(0x0004) (Transient)
	unsigned long                                      bInFriendlyMinotaurRadius : 1;                            // 0x0778(0x0004) (Transient)
	unsigned long                                      bIsTargetOfEnemyTowerOrMinotaur : 1;                      // 0x0778(0x0004) (Transient)
	unsigned long                                      bCombatTargetInEnemyTowerRadius : 1;                      // 0x0778(0x0004) (Transient)
	unsigned long                                      bCombatTargetInFriendlyTowerRadius : 1;                   // 0x0778(0x0004) (Transient)
	unsigned long                                      bCombatTargetInEnemyMinotaurRadius : 1;                   // 0x0778(0x0004) (Transient)
	unsigned long                                      bCombatTargetInFriendlyMinotaurRadius : 1;                // 0x0778(0x0004) (Transient)
	unsigned long                                      bCombatTargetIsTargetOfFriendlyTowerOrMinotaur : 1;       // 0x0778(0x0004) (Transient)
	unsigned long                                      bIsAtFortress : 1;                                        // 0x0778(0x0004) (Transient)
	unsigned long                                      bIsAtEnemyFortress : 1;                                   // 0x0778(0x0004) (Transient)
	unsigned long                                      bIsAtCachedRallyPoint : 1;                                // 0x0778(0x0004) (Transient)
	unsigned long                                      bBtDebugSpawnPaused : 1;                                  // 0x0778(0x0004)
	unsigned long                                      bBtDebugPaused : 1;                                       // 0x0778(0x0004) (Transient)
	unsigned long                                      bBtDebugStep : 1;                                         // 0x0778(0x0004) (Transient)
	unsigned long                                      bBtDebugClientOverlay : 1;                                // 0x0778(0x0004) (Transient)
	struct FVector                                     NextFearDirection;                                        // 0x077C(0x000C) (Transient)
	float                                              PawnCollisionHeight;                                      // 0x0788(0x0004) (Transient)
	float                                              PawnCollisionRadius;                                      // 0x078C(0x0004) (Transient)
	float                                              DeviceRanges[0x14];                                       // 0x0790(0x0004) (Transient)
	class AActor*                                      CombatTarget;                                             // 0x07E0(0x0008) (Transient)
	class ATgPawn*                                     CombatTargetAsPawn;                                       // 0x07E8(0x0008) (Transient)
	int                                                EnemyMinionsInEnemyTowerRadius;                           // 0x07F0(0x0004) (Transient)
	int                                                FriendlyMinionsInEnemyTowerRadius;                        // 0x07F4(0x0004) (Transient)
	int                                                EnemyMinionsInFriendlyTowerRadius;                        // 0x07F8(0x0004) (Transient)
	int                                                FriendlyMinionsInFriendlyTowerRadius;                     // 0x07FC(0x0004) (Transient)
	int                                                EnemyGodsInEnemyTowerRadius;                              // 0x0800(0x0004) (Transient)
	int                                                FriendlyGodsInEnemyTowerRadius;                           // 0x0804(0x0004) (Transient)
	int                                                EnemyGodsInFriendlyTowerRadius;                           // 0x0808(0x0004) (Transient)
	int                                                FriendlyGodsInFriendlyTowerRadius;                        // 0x080C(0x0004) (Transient)
	float                                              HealthOfNearestEnemyTower;                                // 0x0810(0x0004) (Transient)
	float                                              HealthOfNearestFriendlyTower;                             // 0x0814(0x0004) (Transient)
	class AActor*                                      LaneMoveTarget;                                           // 0x0818(0x0008) (Transient)
	TArray<class AActor*>                              VisibleActorsToAvoid;                                     // 0x0820(0x0010) (Transient, AlwaysInit, NeedCtorLink)
	TArray<class ATgPawn*>                             CachedTowers;                                             // 0x0830(0x0010) (Transient, AlwaysInit, NeedCtorLink)
	TArray<class ATgPawn_Character*>                   CachedGods;                                               // 0x0840(0x0010) (Transient, AlwaysInit, NeedCtorLink)
	TArray<class AController*>                         EnemyControllersInSightRadius;                            // 0x0850(0x0010) (Transient, NeedCtorLink)
	TArray<class AController*>                         FriendlyControllersInSightRadius;                         // 0x0860(0x0010) (Transient, NeedCtorLink)
	TEnumAsByte<EBotDifficultyLevel>                   Difficulty;                                               // 0x0870(0x0001) (Transient)
	TEnumAsByte<EUseDeviceAimType>                     LastUseDeviceAimType;                                     // 0x0871(0x0001) (Transient)
	unsigned char                                      UnknownData00[0x2];                                       // 0x0872(0x0002) MISSED OFFSET
	struct FVector                                     TargetLastKnownLocation;                                  // 0x0874(0x000C) (Transient)
	class ATgAIAnnotation*                             CurrentAssaultPoint;                                      // 0x0880(0x0008) (Transient)
	float                                              m_fUnstuckJumpFrequency;                                  // 0x0888(0x0004)
	float                                              m_fLastUnstuckJumpTime;                                   // 0x088C(0x0004) (Transient)
	TArray<struct FIncomingDamageEntry>                IncomingDamage;                                           // 0x0890(0x0010) (Transient, NeedCtorLink)
	class ATgAIVolume*                                 CachedRallyVolume;                                        // 0x08A0(0x0008) (Transient)
	int                                                RandomRallyPointIndex;                                    // 0x08A8(0x0004) (Transient)
	struct FVector                                     AlliedFortressLookDir;                                    // 0x08AC(0x000C) (Transient)
	struct FVector                                     EnemyFortressLookDir;                                     // 0x08B8(0x000C) (Transient)
	class ATgFortressVolume*                           AlliedFortress;                                           // 0x08C4(0x0008) (Transient)
	class ATgFortressVolume*                           EnemyFortress;                                            // 0x08CC(0x0008) (Transient)
	struct FVector                                     StrafeDir;                                                // 0x08D4(0x000C) (Transient)
	float                                              LastStrafeDirUpdate;                                      // 0x08E0(0x0004) (Transient)
	float                                              StrafeDirUpdateTime;                                      // 0x08E4(0x0004) (Transient)
	class UClass*                                      UtilityHandleClass;                                       // 0x08E8(0x0008)
	class UTgAIUtilityHandle*                          UtilityHandle;                                            // 0x08F0(0x0008) (Transient)
	class AActor*                                      EscortActor;                                              // 0x08F8(0x0008) (Transient)
	float                                              EscortMinDistance;                                        // 0x0900(0x0004) (Transient)
	float                                              EscortMaxDistance;                                        // 0x0904(0x0004) (Transient)
	int                                                m_nDevicesLockingInput;                                   // 0x0908(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIController_Behavior");
		return ptr;
	}


	void UnpauseFromDuration();
	void STATIC_PauseForDuration(float PauseDuration);
	bool STATIC_IsPaused();
	void SetPaused(bool bPaused);
	void GameHasEnded(class AActor* EndGameFocus, bool bIsWinner);
	void PawnDied(class APawn* P);
	struct FRotator GetAdjustedAimFor(class AWeapon* W, const struct FVector& StartFireLoc);
	struct FRotator CalcGaussianInaccuracy(float StdDev);
	struct FRotator CalcUniformInaccuracy(float DegMissed);
	float STATIC_GetLeadAccuracy();
	float STATIC_GetCooldownModifier();
	float STATIC_GetAngleToTarget();
	void STATIC_DeviceOnStopFire(class ATgDevice* Dev, bool WasInterrupted);
	bool StopFireDevice(TEnumAsByte<ETG_EQUIP_POINT> DeviceSlot, bool bForce);
	bool STATIC_CancelFiring();
	bool STATIC_FireDevice(TEnumAsByte<ETG_EQUIP_POINT> DeviceSlot, bool bContinuousFire, TEnumAsByte<EUseDeviceAimType> aimType);
	struct FVector CalculateAim(bool bHeadShot);
	float STATIC_GetCooldownIncrease();
	void Stun(bool bStun, TEnumAsByte<EStunType> eType);
	void UpdateDeviceRanges();
	void STATIC_OnPathfindTerminated();
	void STATIC_OnPathfindFailed();
	void StopNavigation();
	void ClearNavigation();
	void AddLocationToNavigationQueue(int NodeToken, const struct FVector& TargetLocation, bool bLookAtTarget, bool bMustHaveLOS, float DistanceTolerance);
	void AddActorToNavigationQueue(int NodeToken, class AActor* TargetActor, bool bLookAtTarget, bool bMustHaveLOS, float DistanceTolerance, bool bStopNavOnReachedDestination);
	bool STATIC_HasVisibilityToPoint(struct FVector* TestPoint);
	void STATIC_ResetBlackboard();
	void STATIC_Possess(class APawn* inPawn, bool bVehicleTransition);
	void Destroyed();
	void PostBeginPlay();
	void PreBeginPlay();
	bool STATIC_IsDeployableIgnored(class ATgDeployable* pDeployable);
	void STATIC_IgnoreDeployable(class ATgDeployable* pDeployable);
	void STATIC_LoadBehaviorTree(const struct FName& TreeName);
	void ResetBehaviorTree();
	void CleanupBehaviorTree();
	void SpawnDebuggerWindow();
	void Debug_Reset();
	void Debug_Resume();
	void Debug_Step();
	void Debug_Pause();
	void UpdatePawnDebug();
};


// Class TgGame.TgAIController_BehaviorGod
// 0x0030 (0x093C - 0x090C)
class ATgAIController_BehaviorGod : public ATgAIController_Behavior
{
public:
	struct FPointer                                    VfTable_ITgPaladinsController;                            // 0x090C(0x0008) (Const, Native, NoExport)
	float                                              WaitForSpawnSecs;                                         // 0x0914(0x0004)
	int                                                PlayerID;                                                 // 0x0918(0x0004) (Transient)
	unsigned long                                      bCanPurchaseItems : 1;                                    // 0x091C(0x0004) (Transient)
	unsigned long                                      bCanPurchaseSkills : 1;                                   // 0x091C(0x0004) (Transient)
	unsigned long                                      bRespawnAtOriginalLocation : 1;                           // 0x091C(0x0004)
	float                                              CurrentGoldRemainder;                                     // 0x0920(0x0004) (Transient)
	int                                                CurrentGold;                                              // 0x0924(0x0004) (Transient)
	float                                              CurrentXPRemainder;                                       // 0x0928(0x0004) (Transient)
	int                                                CurrentXP;                                                // 0x092C(0x0004) (Transient)
	struct FVector                                     GeometricMean;                                            // 0x0930(0x000C) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIController_BehaviorGod");
		return ptr;
	}


	class ATgPawn* STATIC_GetTgPawn();
	void ResetUlt();
	void SetCredits(int nCreditsAmount);
	int STATIC_GetCredits();
	void PostBeginPlay();
	struct FRotator GetAdjustedAimFor(class AWeapon* Weap, const struct FVector& StartFireLoc);
	void STATIC_CopyPropertiesTo(class AController* C);
	void STATIC_Possess(class APawn* inPawn, bool bVehicleTransition);
	void STATIC_LiveRespawn(bool bResetHealth, bool bResetDevices);
	void STATIC_Revive();
	void InitPlayerReplicationInfo();
	int STATIC_GetTaskForceNumber();
	void SetRewardValues(int XP, int nCredits, class AActor* Source, TEnumAsByte<ERewardValueType> RewardType, bool bFlankKill);
	void SetStartingProperties();
	void SetBotPlayerId();
	bool STATIC_OnRespawnRuleChanged();
	float StartReviveTimer();
	void PurchaseBurnCards();
	void PurchaseSkills();
	int STATIC_GetSkillPointsAvailable();
	bool STATIC_HaveBasicSkillsBeenActivated();
	bool CanAllocateSkillPoint(int DeviceID, class ATgDevice* aDevice);
	void PurchaseItems();
};


// Class TgGame.TgAIController_BehaviorGodDisconnected
// 0x0004 (0x0940 - 0x093C)
class ATgAIController_BehaviorGodDisconnected : public ATgAIController_BehaviorGod
{
public:
	unsigned long                                      bInitialController : 1;                                   // 0x093C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIController_BehaviorGodDisconnected");
		return ptr;
	}


	void STATIC_Possess(class APawn* inPawn, bool bVehicleTransition);
	void InitPlayerReplicationInfo();
};


// Class TgGame.TgAIController_BehaviorRoyale
// 0x0074 (0x09B0 - 0x093C)
class ATgAIController_BehaviorRoyale : public ATgAIController_BehaviorGod
{
public:
	struct FVector                                     m_vDropLocation;                                          // 0x093C(0x000C) (Transient)
	class AActor*                                      m_InteractTarget;                                         // 0x0948(0x0008) (Transient)
	float                                              m_fOpenedChestTime;                                       // 0x0950(0x0004) (Transient)
	float                                              m_fMoveToFogCenterTime;                                   // 0x0954(0x0004) (Transient)
	float                                              m_fFogCenterThrottleTime;                                 // 0x0958(0x0004)
	TArray<class ATgDeploy_LootCrate*>                 NearbyChests;                                             // 0x095C(0x0010) (Transient, NeedCtorLink)
	TArray<class ATgDeploy_Pickup*>                    NearbyItems;                                              // 0x096C(0x0010) (Transient, NeedCtorLink)
	unsigned long                                      m_bIsPathingStuck : 1;                                    // 0x097C(0x0004)
	unsigned long                                      m_bSafeFromFog : 1;                                       // 0x097C(0x0004)
	float                                              m_fUnstuckTime;                                           // 0x0980(0x0004)
	int                                                m_nLastRoundNotSafeFromFog;                               // 0x0984(0x0004)
	float                                              m_fTimeCombatTargetUntrackable;                           // 0x0988(0x0004)
	float                                              m_fUntrackableDuration;                                   // 0x098C(0x0004)
	float                                              m_fUntrackableMovementDelta;                              // 0x0990(0x0004)
	struct FVector                                     m_vLastCombatTargetLocation;                              // 0x0994(0x000C)
	TArray<struct FDifficultyConfig>                   m_DifficultyConfigs;                                      // 0x09A0(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIController_BehaviorRoyale");
		return ptr;
	}


	void STATIC_Possess(class APawn* inPawn, bool bVehicleTransition);
	void STATIC_OnPathfindTerminated();
	void STATIC_OnPathfindFailed();
	bool STATIC_HasVisibilityFromHead(const struct FVector& vTarget);
	void STATIC_SetUnstuck();
	TArray<class ATgDeploy_Pickup*> STATIC_GetCachedNearbyItems(float fRadius);
	TArray<class ATgDeploy_LootCrate*> STATIC_GetCachedNearbyChests(float fRadius);
	void STATIC_SetDifficultyConfig(const struct FDifficultyConfig& NewConfig);
	struct FDifficultyConfig STATIC_GetDifficultyConfig();
};


// Class TgGame.TgAIController_BehaviorLaneNpc
// 0x000C (0x0918 - 0x090C)
class ATgAIController_BehaviorLaneNpc : public ATgAIController_Behavior
{
public:
	class AActor*                                      GoalTarget;                                               // 0x090C(0x0008) (Transient)
	unsigned long                                      bDespawnOnLoseCombatTarget : 1;                           // 0x0914(0x0004) (Transient)
	unsigned long                                      bIsBehindSquad : 1;                                       // 0x0914(0x0004) (Transient)
	unsigned long                                      bTooFarFromLane : 1;                                      // 0x0914(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIController_BehaviorLaneNpc");
		return ptr;
	}


	bool CanSpreadOut();
};


// Class TgGame.TgAIController_BehaviorMapNpc
// 0x0030 (0x093C - 0x090C)
class ATgAIController_BehaviorMapNpc : public ATgAIController_Behavior
{
public:
	TArray<struct FThreatEntry>                        ThreatList;                                               // 0x090C(0x0010) (Transient, AlwaysInit, NeedCtorLink)
	unsigned long                                      bThreatListDecays : 1;                                    // 0x091C(0x0004) (Transient)
	unsigned long                                      bOutsideLeash : 1;                                        // 0x091C(0x0004) (Transient)
	unsigned long                                      bHadCombatTarget : 1;                                     // 0x091C(0x0004) (Transient)
	float                                              LeashDistance;                                            // 0x0920(0x0004) (Transient)
	class AVolume*                                     LeashVolume;                                              // 0x0924(0x0008) (Transient)
	TArray<class ATgPawn*>                             LeashActors;                                              // 0x092C(0x0010) (Transient, AlwaysInit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIController_BehaviorMapNpc");
		return ptr;
	}


	void STATIC_NotifyKilledBy(class AController* Killer);
	void SquadTargetChanged();
	void SquadEvade();
	void Evade();
	bool CanSpreadOut();
	void ClearThreatList();
	void AddThreat(class ATgPawn* attacker, float ThreatLevel);
};


// Class TgGame.TgAIController_BehaviorChaosJuggernaut
// 0x0000 (0x093C - 0x093C)
class ATgAIController_BehaviorChaosJuggernaut : public ATgAIController_BehaviorMapNpc
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIController_BehaviorChaosJuggernaut");
		return ptr;
	}

};


// Class TgGame.TgAIController_BehaviorPet
// 0x0008 (0x0914 - 0x090C)
class ATgAIController_BehaviorPet : public ATgAIController_Behavior
{
public:
	class AActor*                                      OwnerCombatTarget;                                        // 0x090C(0x0008) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIController_BehaviorPet");
		return ptr;
	}

};


// Class TgGame.TgAIController_BehaviorPet_LongTerm
// 0x0000 (0x0914 - 0x0914)
class ATgAIController_BehaviorPet_LongTerm : public ATgAIController_BehaviorPet
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIController_BehaviorPet_LongTerm");
		return ptr;
	}

};


// Class TgGame.TgAIController_BehaviorPetRanged
// 0x0000 (0x0914 - 0x0914)
class ATgAIController_BehaviorPetRanged : public ATgAIController_BehaviorPet
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIController_BehaviorPetRanged");
		return ptr;
	}

};


// Class TgGame.TgAIInfluenceMap
// 0x0038 (0x0098 - 0x0060)
class UTgAIInfluenceMap : public UObject
{
public:
	struct FPointer                                    VfTable_FTickableObject;                                  // 0x0060(0x0008) (Const, Native, NoExport)
	TArray<int>                                        Influences;                                               // 0x0068(0x0010) (Transient, NeedCtorLink)
	struct FPointer                                    FalloffTable;                                             // 0x0078(0x0008) (Native, Transient)
	class UHavokNavMeshGrid*                           InfluenceGrid;                                            // 0x0080(0x0008) (Const, Native, Transient)
	float                                              TickFrequency;                                            // 0x0088(0x0004)
	float                                              InvTickFrequency;                                         // 0x008C(0x0004) (Transient)
	float                                              Decay;                                                    // 0x0090(0x0004)
	float                                              Momentum;                                                 // 0x0094(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIInfluenceMap");
		return ptr;
	}


	void RegisterInfluence(const struct FVector& StartPosition, int PackedInfluence, bool Additive, float Radius);
	void Init();
};


// Class TgGame.TgAIInfluenceMapRenderingComponent
// 0x0010 (0x0260 - 0x0250)
class UTgAIInfluenceMapRenderingComponent : public UHavokNavigationRenderingComponent
{
public:
	class UTgAIInfluenceMap*                           InfluenceMap;                                             // 0x0250(0x0008) (Transient)
	class UTexture2DDynamic*                           InfluenceMapTexture;                                      // 0x0258(0x0008) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIInfluenceMapRenderingComponent");
		return ptr;
	}

};


// Class TgGame.TgAILocalPositionSolver
// 0x0040 (0x00A0 - 0x0060)
class UTgAILocalPositionSolver : public UObject
{
public:
	struct FPointer                                    VfTable_IInterface_ActorPathConstraints;                  // 0x0060(0x0008) (Const, Native, NoExport)
	TArray<struct FDefaultRepulsorData>                DefaultWeights;                                           // 0x0068(0x0010) (NeedCtorLink)
	class ATgAIController_Behavior*                    OuterController;                                          // 0x0078(0x0008) (Transient)
	float                                              LastQueryTime;                                            // 0x0080(0x0004) (Transient)
	struct FVector                                     LastQueryPoint;                                           // 0x0084(0x000C) (Transient)
	struct FVector                                     LastSolvePoint;                                           // 0x0090(0x000C) (Transient)
	unsigned long                                      bSolveDistanceThreshold : 1;                              // 0x009C(0x0004)
	unsigned long                                      bSolveWeights : 1;                                        // 0x009C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAILocalPositionSolver");
		return ptr;
	}


	void STATIC_SolveConstraints(const struct FVector& InitialPosition, float MaxDistance, struct FVector* OutDesiredPosition);
};


// Class TgGame.TgAIObstacleAvoidance
// 0x0060 (0x00C0 - 0x0060)
class UTgAIObstacleAvoidance : public UObject
{
public:
	struct FPointer                                    ObstacleGrid;                                             // 0x0060(0x0008) (Native, Transient)
	struct FObstacleQueryCache                         CachedAvoidance;                                          // 0x0068(0x002C) (Transient, NeedCtorLink)
	TArray<class ABlockingVolume*>                     CachedBlockers;                                           // 0x0094(0x0010) (Transient, AlwaysInit, NeedCtorLink)
	TArray<class ALandscape*>                          CachedLandscapes;                                         // 0x00A4(0x0010) (Transient, AlwaysInit, NeedCtorLink)
	class ATgAIController_Behavior*                    OuterController;                                          // 0x00B4(0x0008) (Transient)
	unsigned long                                      bRenderingIsDirty : 1;                                    // 0x00BC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIObstacleAvoidance");
		return ptr;
	}


	void TestObstacleAvoidance(int TestType);
	void STATIC_Reset();
	void Init(float GridPointSize, float GridExtents);
	TEnumAsByte<EObstacleAvoidanceStatus> GetNextMoveLocation(struct FVector* TargetPoint, struct FVector* IntermediatePoint, float* ArrivalDistance);
	bool FindPath(TArray<class AActor*>* ActorsToAvoid, struct FVector* TargetPoint, struct FVector* UpdatedTargetPoint);
};


// Class TgGame.TgAIObstacleAvoidanceRenderingComponent
// 0x0008 (0x0254 - 0x024C)
class UTgAIObstacleAvoidanceRenderingComponent : public UPrimitiveComponent
{
public:
	class UTgAIObstacleAvoidance*                      ObstacleAvoidance;                                        // 0x024C(0x0008) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIObstacleAvoidanceRenderingComponent");
		return ptr;
	}

};


// Class TgGame.TgAISquad
// 0x0048 (0x00A8 - 0x0060)
class UTgAISquad : public UObject
{
public:
	struct FPointer                                    VfTable_FTickableObject;                                  // 0x0060(0x0008) (Const, Native, NoExport)
	unsigned long                                      s_bOpen : 1;                                              // 0x0068(0x0004)
	unsigned long                                      s_bShouldSpread : 1;                                      // 0x0068(0x0004)
	TArray<class ATgAIController*>                     s_MemberList;                                             // 0x006C(0x0010) (NeedCtorLink)
	class ATgBotFactory*                               s_Factory;                                                // 0x007C(0x0008)
	class AActor*                                      s_CurrentTarget;                                          // 0x0084(0x0008)
	TArray<class AActor*>                              s_TargetList;                                             // 0x008C(0x0010) (NeedCtorLink)
	class AController*                                 s_LastKiller;                                             // 0x009C(0x0008)
	float                                              s_fNextSpreadTime;                                        // 0x00A4(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAISquad");
		return ptr;
	}


	void STATIC_OnSquadCreated();
	void STATIC_NotifyEvade();
	void STATIC_NotifyTargetChanged();
	void Evade();
	void SuggestEvade();
	void UpdateTargetList(float DeltaTime);
	void DropTarget(class AActor* TargetToDrop);
	void SuggestDropTarget(class AActor* TargetToDrop, class ATgAIController* requester);
	class ATgPawn* STATIC_GetTargetPawn();
	class AActor* STATIC_GetTarget();
	void SetTarget(class AActor* NewTarget);
	void SuggestTarget(class AActor* NewTarget, class ATgAIController* requester);
	struct FBox STATIC_GetSquadBounds();
	void SpreadSquad();
	void SquadDied();
	bool STATIC_MergeWith(class UTgAISquad* squad);
	void STATIC_MemberKilledBy(class AController* Killer);
	void STATIC_RemoveMember(class ATgAIController* aic, bool bDied);
	void STATIC_AddMember(class ATgAIController* aic);
	bool STATIC_IsOpen();
	void CloseSquad();
	void STATIC_OpenSquad();
};


// Class TgGame.TgAISquad_Minion
// 0x0008 (0x00B0 - 0x00A8)
class UTgAISquad_Minion : public UTgAISquad
{
public:
	float                                              s_fNextClusterTime;                                       // 0x00A8(0x0004)
	float                                              s_fNextMergeTime;                                         // 0x00AC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAISquad_Minion");
		return ptr;
	}


	void CheckForMerge();
	void ClusterSquad();
};


// Class TgGame.TgAISquad_Monster
// 0x0000 (0x00A8 - 0x00A8)
class UTgAISquad_Monster : public UTgAISquad
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAISquad_Monster");
		return ptr;
	}


	void DropTarget(class AActor* TargetToDrop);
};


// Class TgGame.TgAISquad_MonsterBehaviorTree
// 0x0010 (0x00B8 - 0x00A8)
class UTgAISquad_MonsterBehaviorTree : public UTgAISquad
{
public:
	struct FName                                       BehaviorTreeAsName;                                       // 0x00A8(0x0008)
	class ATgAIController_BehaviorMapNpc*              Controller;                                               // 0x00B0(0x0008) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAISquad_MonsterBehaviorTree");
		return ptr;
	}


	void STATIC_OnSquadCreated();
	class ATgPawn* STATIC_GetTargetPawn();
	class AActor* STATIC_GetTarget();
	void Evade();
	void SquadDied();
	void UpdateTargetList(float DeltaTime);
	void DropTarget(class AActor* TargetToDrop);
	void SuggestDropTarget(class AActor* TargetToDrop, class ATgAIController* requester);
	void SetTarget(class AActor* NewTarget);
	void SuggestTarget(class AActor* NewTarget, class ATgAIController* requester);
	class ATgAIController_BehaviorMapNpc* SpawnController();
};


// Class TgGame.TgAIUtilityHandle
// 0x0122 (0x0182 - 0x0060)
class UTgAIUtilityHandle : public UObject
{
public:
	struct FUtilitySet                                 UtilitySets[0x2];                                         // 0x0060(0x0048)
	struct FUtilityPair                                FilteredAnnotationPoints[0x2];                            // 0x00F0(0x0048)
	TEnumAsByte<EBotBehaviorState>                     eBehaviorState;                                           // 0x0180(0x0001)
	TEnumAsByte<ERangeType>                            AssaultRangeType;                                         // 0x0181(0x0001)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIUtilityHandle");
		return ptr;
	}


	void ComputeUtilities();
	class ATgAIAnnotation* STATIC_GetBestAnnotationPoint(TEnumAsByte<EAIAnnotationType> AnnotationType);
};


// Class TgGame.TgMinionGoal
// 0x0014 (0x038C - 0x0378)
class ATgMinionGoal : public ANavigationPoint
{
public:
	int                                                m_nLaneNum;                                               // 0x0378(0x0004) (Edit)
	int                                                m_nTaskForce;                                             // 0x037C(0x0004) (Edit)
	class ATgActionPoint*                              m_EndPoint;                                               // 0x0380(0x0008) (Edit)
	unsigned long                                      m_bUseForFinalDestination : 1;                            // 0x0388(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgMinionGoal");
		return ptr;
	}


	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
};


// Class TgGame.TgMinionGoal_Aphrodite
// 0x0000 (0x038C - 0x038C)
class ATgMinionGoal_Aphrodite : public ATgMinionGoal
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgMinionGoal_Aphrodite");
		return ptr;
	}


	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
};


// Class TgGame.TgCameraModifier_LobbyCameraTransition
// 0x0018 (0x0098 - 0x0080)
class UTgCameraModifier_LobbyCameraTransition : public UCameraModifier
{
public:
	class ATgLobbyCamera*                              SourceCamera;                                             // 0x0080(0x0008)
	class ATgLobbyCamera*                              DestinationCamera;                                        // 0x0088(0x0008)
	TEnumAsByte<ECameraTransType>                      TransitionType;                                           // 0x0090(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0091(0x0003) MISSED OFFSET
	float                                              fSlideDistance;                                           // 0x0094(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCameraModifier_LobbyCameraTransition");
		return ptr;
	}


	bool STATIC_RemoveCameraModifier(class ACamera* Camera);
	void STATIC_DisableModifier(bool bImmediate);
	void STATIC_RemoveCameraModifierAsEvent(class ACamera* Cam);
	void STATIC_AddCameraModifierAsEvent(class ACamera* Cam);
	bool ModifyCamera(class ACamera* Camera, float DeltaTime, struct FTPOV* OutPOV);
};


// Class TgGame.TgCameraModifier_LobbyFade
// 0x0000 (0x0080 - 0x0080)
class UTgCameraModifier_LobbyFade : public UCameraModifier
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCameraModifier_LobbyFade");
		return ptr;
	}


	bool ModifyCamera(class ACamera* Camera, float DeltaTime, struct FTPOV* OutPOV);
};


// Class TgGame.TgCameraModule
// 0x0008 (0x0068 - 0x0060)
class UTgCameraModule : public UObject
{
public:
	class ATgPlayerCamera*                             PlayerCamera;                                             // 0x0060(0x0008) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCameraModule");
		return ptr;
	}


	void ZoomOut();
	void ZoomIn();
	void STATIC_BecomeViewTarget(class ATgPlayerController* PC);
	void ProcessInput(class UPlayerInput* PlayerInput, float DeltaTime);
	void STATIC_UpdateCamera(class APawn* P, class ATgPlayerCamera* CameraActor, float DeltaTime, struct FTViewTarget* OutVT);
	void STATIC_OnTweenOutEnd();
	void STATIC_OnBecomeInActive(class UTgCameraModule* NewCamera);
	void STATIC_OnBecomeActive(class UTgCameraModule* OldCamera);
	void Init();
};


// Class TgGame.TgCameraModule_Free
// 0x0014 (0x007C - 0x0068)
class UTgCameraModule_Free : public UTgCameraModule
{
public:
	float                                              CamAltitude;                                              // 0x0068(0x0004)
	float                                              DesiredCamAltitude;                                       // 0x006C(0x0004)
	float                                              MaxCamAltitude;                                           // 0x0070(0x0004)
	float                                              MinCamAltitude;                                           // 0x0074(0x0004)
	float                                              CamZoomIncrement;                                         // 0x0078(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCameraModule_Free");
		return ptr;
	}


	void ZoomOut();
	void ZoomIn();
	void STATIC_BecomeViewTarget(class ATgPlayerController* PC);
	void STATIC_UpdateCamera(class APawn* P, class ATgPlayerCamera* CameraActor, float DeltaTime, struct FTViewTarget* OutVT);
	struct FVector STATIC_GetCamLocationOffset(class APawn* P);
	void ProcessInput(class UPlayerInput* PlayerInput, float DeltaTime);
};


// Class TgGame.TgCameraModule_GroundTarget
// 0x0000 (0x007C - 0x007C)
class UTgCameraModule_GroundTarget : public UTgCameraModule_Free
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCameraModule_GroundTarget");
		return ptr;
	}


	void ZoomOut();
	void ZoomIn();
	void STATIC_UpdateCamera(class APawn* P, class ATgPlayerCamera* CameraActor, float DeltaTime, struct FTViewTarget* OutVT);
	struct FVector STATIC_GetCamLocationOffset(class APawn* P);
};


// Class TgGame.TgCameraModule_Server
// 0x0000 (0x0068 - 0x0068)
class UTgCameraModule_Server : public UTgCameraModule
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCameraModule_Server");
		return ptr;
	}

};


// Class TgGame.TgCameraModule_Spectator
// 0x0034 (0x009C - 0x0068)
class UTgCameraModule_Spectator : public UTgCameraModule
{
public:
	int                                                WorldViewPitch;                                           // 0x0068(0x0004) (Edit)
	struct FTPOV                                       OldViewpoint;                                             // 0x006C(0x0024) (Transient)
	float                                              RemainingBlendTime;                                       // 0x0090(0x0004) (Transient)
	float                                              TotalBlendTime;                                           // 0x0094(0x0004) (Transient)
	unsigned long                                      bCollideWorld : 1;                                        // 0x0098(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCameraModule_Spectator");
		return ptr;
	}


	void BlendCameraToLocation(const struct FVector& NewLocation, float BlendTime, bool bUseFocalPoint);
	void STATIC_OnBecomeInActive(class UTgCameraModule* NewCamera);
	void STATIC_OnBecomeActive(class UTgCameraModule* OldCamera);
	void DecreaseCameraSpeed();
	void STATIC_IncreaseCameraSpeeed();
	void ZoomOut();
	void ZoomIn();
	float STATIC_GetFOVAngle();
	void STATIC_UpdateCamera(class APawn* P, class ATgPlayerCamera* CameraActor, float DeltaTime, struct FTViewTarget* OutVT);
};


// Class TgGame.TgCameraModule_SpectatorOverview
// 0x009C (0x0138 - 0x009C)
class UTgCameraModule_SpectatorOverview : public UTgCameraModule_Spectator
{
public:
	struct FRotator                                    WorldViewRotation;                                        // 0x009C(0x000C) (Edit)
	float                                              FOV;                                                      // 0x00A8(0x0004) (Edit, Config)
	float                                              TargetZoomedFOV;                                          // 0x00AC(0x0004)
	float                                              ZoomIncrement;                                            // 0x00B0(0x0004) (Edit, Config)
	float                                              MinZoom;                                                  // 0x00B4(0x0004) (Edit, Config)
	float                                              MaxZoom;                                                  // 0x00B8(0x0004) (Edit, Config)
	float                                              ZoomInterpTime;                                           // 0x00BC(0x0004) (Edit, Config)
	struct FVector                                     CurrentSpringLocation;                                    // 0x00C0(0x000C)
	float                                              PawnTargetSpringDamping;                                  // 0x00CC(0x0004) (Edit, Config)
	float                                              FreeCamSpringDamping;                                     // 0x00D0(0x0004) (Edit, Config)
	float                                              IgnoreSpringDistance;                                     // 0x00D4(0x0004) (Edit, Config)
	TArray<struct FCameraPitchInfo>                    CameraPitchData;                                          // 0x00D8(0x0010) (Edit, NeedCtorLink)
	unsigned long                                      bFlippedSides : 1;                                        // 0x00E8(0x0004) (Edit)
	unsigned long                                      bJustBecameActive : 1;                                    // 0x00E8(0x0004)
	unsigned long                                      bAutoZoomEnabled : 1;                                     // 0x00E8(0x0004) (Edit, Config)
	float                                              OverviewCameraInfluenceDist;                              // 0x00EC(0x0004) (Edit)
	TArray<class ATgOverviewCameraActor*>              OverviewCameras;                                          // 0x00F0(0x0010) (NeedCtorLink)
	struct FVector                                     ObstacleTransparentExtent;                                // 0x0100(0x000C) (Edit)
	float                                              fMinAutoZoomFOVAngle;                                     // 0x010C(0x0004) (Edit, Config)
	float                                              fMaxAutoZoomFOVAngle;                                     // 0x0110(0x0004) (Edit, Config)
	float                                              fMinAutoZoomDistance;                                     // 0x0114(0x0004) (Edit, Config)
	float                                              fMaxAutoZoomDistance;                                     // 0x0118(0x0004) (Edit, Config)
	float                                              fAutoZoomDetectionRadius;                                 // 0x011C(0x0004) (Edit, Config)
	float                                              fAutoZoomInSpeed;                                         // 0x0120(0x0004) (Edit, Config)
	float                                              fAutoZoomOutSpeed;                                        // 0x0124(0x0004) (Edit, Config)
	float                                              fAutoZoomInLockOutTime;                                   // 0x0128(0x0004) (Edit, Config)
	float                                              fAutoZoomOutLockOutTime;                                  // 0x012C(0x0004) (Edit, Config)
	float                                              m_RemainingAutoZoomInLockOutTime;                         // 0x0130(0x0004) (Transient)
	float                                              m_RemainingAutoZoomOutLockOutTime;                        // 0x0134(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCameraModule_SpectatorOverview");
		return ptr;
	}


	void FlipSides();
	float STATIC_GetFOVAngle();
	void ZoomOut();
	void ZoomIn();
	void STATIC_UpdateCamera(class APawn* P, class ATgPlayerCamera* CameraActor, float DeltaTime, struct FTViewTarget* OutVT);
	void STATIC_OverridePawnTargetLocation(class ATgPawn* TgP, struct FVector* TargetLocation);
	void BlendCameraToLocation(const struct FVector& NewLocation, float BlendTime, bool bUseFocalPoint);
	void STATIC_OnBecomeInActive(class UTgCameraModule* NewCamera);
	void STATIC_OnBecomeActive(class UTgCameraModule* OldCamera);
	void ClearObstacleTransparency();
	void CheckObstacleTransparency();
	bool UpdateAutoZoom(float DeltaTime);
	struct FRotator STATIC_GetWorldViewRotation();
};


// Class TgGame.TgCameraModule_ThirdPerson
// 0x0164 (0x01CC - 0x0068)
class UTgCameraModule_ThirdPerson : public UTgCameraModule
{
public:
	struct FVector                                     vBasePivotLocation;                                       // 0x0068(0x000C)
	struct FVector                                     vBaseCameraOffset;                                        // 0x0074(0x000C)
	struct FVector                                     vDownCameraOffset;                                        // 0x0080(0x000C)
	struct FVector                                     vDevADSCameraOffset;                                      // 0x008C(0x000C)
	unsigned long                                      bOverrideDevADSCameraOffset : 1;                          // 0x0098(0x0004)
	unsigned long                                      bForce3PView : 1;                                         // 0x0098(0x0004)
	struct FVector                                     vForcedCameraOffset;                                      // 0x009C(0x000C)
	struct FVector                                     vCurrentCameraOffset;                                     // 0x00A8(0x000C)
	struct FVector                                     vPreviousCameraOffset;                                    // 0x00B4(0x000C)
	float                                              fCameraOffsetLerpDurationToForced;                        // 0x00C0(0x0004)
	float                                              fCameraOffsetLerpDurationToBase;                          // 0x00C4(0x0004)
	float                                              fCameraOffsetLerpTimer;                                   // 0x00C8(0x0004)
	float                                              fZoomFactorInterp;                                        // 0x00CC(0x0004)
	float                                              fZoomFactor;                                              // 0x00D0(0x0004)
	float                                              fZoomStep;                                                // 0x00D4(0x0004)
	float                                              fZoomMax;                                                 // 0x00D8(0x0004)
	float                                              fMountZoomMax;                                            // 0x00DC(0x0004)
	float                                              fZoomMin;                                                 // 0x00E0(0x0004)
	struct FVector2D                                   fZoom3pPercentFromTo;                                     // 0x00E4(0x0008)
	float                                              fZoomDuration;                                            // 0x00EC(0x0004)
	float                                              fZoomDurationOverride;                                    // 0x00F0(0x0004)
	float                                              fZoomUsedTime;                                            // 0x00F4(0x0004) (Transient)
	TEnumAsByte<ECameraPerspectiveType>                ePreviousPerspectiveType;                                 // 0x00F8(0x0001)
	TEnumAsByte<ECameraPerspectiveType>                ePerspectiveType;                                         // 0x00F9(0x0001)
	unsigned char                                      UnknownData00[0x2];                                       // 0x00FA(0x0002) MISSED OFFSET
	struct FVector                                     vSkydiveCameraOffset;                                     // 0x00FC(0x000C) (Edit)
	float                                              fSkydiveCameraAlpha;                                      // 0x0108(0x0004)
	float                                              fSkydiveCameraBlendSpeed;                                 // 0x010C(0x0004) (Edit)
	struct FVector                                     vCatapultCameraOffset;                                    // 0x0110(0x000C) (Edit)
	float                                              fCatapultCameraAlpha;                                     // 0x011C(0x0004)
	float                                              fCatapultCameraBlendSpeed;                                // 0x0120(0x0004) (Edit)
	struct FVector                                     vCatapultLocation;                                        // 0x0124(0x000C)
	struct FVector                                     vCrouchCameraOffset;                                      // 0x0130(0x000C) (Edit)
	float                                              fCrouchCameraAlpha;                                       // 0x013C(0x0004)
	float                                              fCrouchCameraBlendSpeed;                                  // 0x0140(0x0004) (Edit)
	struct FVector                                     vChickenCameraOffset;                                     // 0x0144(0x000C) (Edit)
	float                                              fChickenCameraAlpha;                                      // 0x0150(0x0004)
	float                                              fChickenCameraBlendSpeed;                                 // 0x0154(0x0004) (Edit)
	struct FVector                                     vMountCameraOffset;                                       // 0x0158(0x000C)
	float                                              fMountCameraAlpha;                                        // 0x0164(0x0004)
	float                                              fMountCameraBlendSpeed;                                   // 0x0168(0x0004) (Edit)
	float                                              fWallCollisionRecoverSpeed;                               // 0x016C(0x0004) (Edit)
	float                                              f_WallCollisionAlpha;                                     // 0x0170(0x0004)
	struct FVector                                     vServerCorrectionDelta;                                   // 0x0174(0x000C)
	struct FVector                                     vAvgServerCorrectionDelta;                                // 0x0180(0x000C)
	struct FVector                                     vLastDesiredLocation;                                     // 0x018C(0x000C)
	struct FServerCorrectionSmoothingParams            CorrectionSmoothing;                                      // 0x0198(0x0020)
	float                                              m_fCollisionHeightInterpSpeed;                            // 0x01B8(0x0004) (Edit)
	float                                              m_fCollisionHeightZ;                                      // 0x01BC(0x0004)
	struct FVector                                     TeamRoyaleZeppelinViewOffset;                             // 0x01C0(0x000C) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCameraModule_ThirdPerson");
		return ptr;
	}


	void ZoomOut();
	void ZoomIn();
	void STATIC_BecomeViewTarget(class ATgPlayerController* PC);
	void UpdateAverageServerCorrection(float DeltaTime);
	void UpdateServerCorrectionFromMovement(const struct FVector& DesiredLocation);
	struct FVector SmoothServerCorrection(class ATgPawn* TgP, const struct FVector& DesiredLocation, float DeltaTime);
	void STATIC_UpdateCamera(class APawn* P, class ATgPlayerCamera* CameraActor, float DeltaTime, struct FTViewTarget* OutVT);
	struct FVector STATIC_GetCamLocationWithOffset(class ATgPawn* ViewPawn, float DeltaTime, class ATgPlayerCamera* CameraActor, struct FTViewTarget* OutVT);
	void UpdateCameraZoom(class ATgPawn* TgP, float DeltaTime);
	float STATIC_GetZoomDuration();
	float STATIC_GetCurrent3pPercent();
	struct FRotator STATIC_GetWorldRotation(class ATgPlayerCamera* CameraActor);
	void ApplyAdditionalCameraRotation(class ATgPawn* ViewPawn, struct FRotator* rCameraRotation);
	void Apply3pCamTranslationOffsets(const struct FVector& vCamAttachLocation, class ATgPawn* ViewPawn, struct FVector* vPivotLocation, struct FVector* vCameraSpaceTranslation);
	bool Set3pCamAttachLocation(class ATgPawn* ViewPawn, struct FVector* vCamAttachLocation);
	struct FVector STATIC_GetCamRawOffset(class AActor* ViewTarget);
	void STATIC_OnTweenOutEnd();
	void STATIC_OnBecomeActive(class UTgCameraModule* OldCamera);
};


// Class TgGame.TgCameraShake
// 0x0015 (0x010D - 0x00F8)
class UTgCameraShake : public UCameraShake
{
public:
	float                                              m_fShakeScale;                                            // 0x00F8(0x0004) (Edit)
	unsigned long                                      m_bDoControllerVibration : 1;                             // 0x00FC(0x0004) (Edit)
	unsigned long                                      m_bRadialShake : 1;                                       // 0x00FC(0x0004) (Edit)
	unsigned long                                      m_bOrientTowardRadialEpicenter : 1;                       // 0x00FC(0x0004) (Edit)
	float                                              m_fRadialShake_InnerRadius;                               // 0x0100(0x0004) (Edit)
	float                                              m_fRadialShake_OuterRadius;                               // 0x0104(0x0004) (Edit)
	float                                              m_fRadialShake_Falloff;                                   // 0x0108(0x0004) (Edit)
	TEnumAsByte<ECameraAnimPlaySpace>                  m_PlaySpace;                                              // 0x010C(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCameraShake");
		return ptr;
	}

};


// Class TgGame.TgLobbyCamera
// 0x0091 (0x04B1 - 0x0420)
class ATgLobbyCamera : public ACameraActor
{
public:
	class ATgSkeletalMeshActor_Lobby*                  m_ViewTarget;                                             // 0x0420(0x0008) (Edit)
	TArray<class ATgSkeletalMeshActor_Lobby*>          m_FriendlyTargets;                                        // 0x0428(0x0010) (Edit, NeedCtorLink)
	TArray<class ATgSkeletalMeshActor_Lobby*>          m_EnemyTargets;                                           // 0x0438(0x0010) (Edit, NeedCtorLink)
	struct FVector                                     m_RenderCenterPointOffset;                                // 0x0448(0x000C) (Edit)
	unsigned long                                      m_bActive : 1;                                            // 0x0454(0x0004) (Transient)
	unsigned long                                      m_bAdjustCameraToTarget : 1;                              // 0x0454(0x0004) (Edit)
	unsigned long                                      m_bFirstCameraEyeCheck : 1;                               // 0x0454(0x0004)
	int                                                m_nPosition;                                              // 0x0458(0x0004) (Transient)
	float                                              m_fRemainingTweenTime;                                    // 0x045C(0x0004)
	float                                              m_fTotalTweenTime;                                        // 0x0460(0x0004)
	struct FTPOV                                       m_TweenSourcePOV;                                         // 0x0464(0x0024) (Transient)
	float                                              m_fLateralOffsetMultiplier;                               // 0x0488(0x0004) (Edit)
	float                                              m_fHorizontalOffsetMultiplier;                            // 0x048C(0x0004) (Edit)
	float                                              m_fViewLateralOffsetMultiplier;                           // 0x0490(0x0004) (Edit)
	float                                              m_fViewHorizontalOffsetMultiplier;                        // 0x0494(0x0004) (Edit)
	float                                              m_fMaxAdjustSpeedTranslation;                             // 0x0498(0x0004) (Edit)
	float                                              m_fMaxAdjustSpeedRotation;                                // 0x049C(0x0004) (Edit)
	struct FVector                                     m_vViewOffset;                                            // 0x04A0(0x000C) (Edit)
	float                                              m_fFirstCameraEyeCheckTimestamp;                          // 0x04AC(0x0004)
	TEnumAsByte<ELobbyCameraTag>                       m_CameraTag;                                              // 0x04B0(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgLobbyCamera");
		return ptr;
	}


	void GetCameraView(float DeltaTime, bool bOnlyFOV, struct FTPOV* OutPOV);
	void STATIC_GetActorEyesViewPoint(struct FVector* out_Location, struct FRotator* out_Rotation);
	void StartTween(float TweenTime);
	void SetPosition(int nPosition);
	void TriggerKismetActivationEvent(bool bActive, int nPosition);
	void ClearEnemyTargets();
	void ClearFriendlyTargets();
	void STATIC_SetActive(bool bActive);
};


// Class TgGame.TgLobbyCaptureActor
// 0x0008 (0x0298 - 0x0290)
class ATgLobbyCaptureActor : public ASceneCapture2DActor
{
public:
	class ATgSkeletalMeshActor_Lobby*                  m_ViewTarget;                                             // 0x0290(0x0008) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgLobbyCaptureActor");
		return ptr;
	}

};


// Class TgGame.TgObserver_ViewTargetChanged
// 0x0000 (0x0060 - 0x0060)
class UTgObserver_ViewTargetChanged : public UInterface
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgObserver_ViewTargetChanged");
		return ptr;
	}


	void STATIC_OnViewTargetChanged(class AActor* aNewViewTarget);
};


// Class TgGame.TgOverviewCameraActor
// 0x0004 (0x0424 - 0x0420)
class ATgOverviewCameraActor : public ACameraActor
{
public:
	unsigned long                                      m_bFlipped : 1;                                           // 0x0420(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgOverviewCameraActor");
		return ptr;
	}

};


// Class TgGame.TgPlayerCamera
// 0x0298 (0x089C - 0x0604)
class ATgPlayerCamera : public ACamera
{
public:
	class ATgPlayerController*                         PlayerOwner;                                              // 0x0604(0x0008)
	class UTgCameraModule*                             CurrentCameraMod;                                         // 0x060C(0x0008) (Edit, EditInline)
	class UClass*                                      DefaultCameraModuleClass;                                 // 0x0614(0x0008)
	TArray<class UTgCameraModule*>                     CameraModuleList;                                         // 0x061C(0x0010) (NeedCtorLink)
	struct FRotator                                    CamAngle;                                                 // 0x062C(0x000C)
	unsigned long                                      m_bIsLowHealth : 1;                                       // 0x0638(0x0004)
	unsigned long                                      bTweening : 1;                                            // 0x0638(0x0004)
	unsigned long                                      bInterpolatingFOV : 1;                                    // 0x0638(0x0004)
	unsigned long                                      m_bPlayingHeal : 1;                                       // 0x0638(0x0004)
	struct FVector                                     CameraLocationLocalToTarget;                              // 0x063C(0x000C)
	unsigned char                                      UnknownData00[0x8];                                       // 0x0648(0x0008) MISSED OFFSET
	struct FQuat                                       CameraRotationLocalToTarget;                              // 0x0650(0x0010)
	float                                              fTweenStart;                                              // 0x0660(0x0004)
	float                                              fTweenDuration;                                           // 0x0664(0x0004)
	class UTgCameraModule*                             LastCameraMod;                                            // 0x0668(0x0008)
	float                                              fFOVInterpStartTimestamp;                                 // 0x0670(0x0004)
	float                                              fFOVInterpStartValue;                                     // 0x0674(0x0004)
	float                                              fFOVInterpEndTimestamp;                                   // 0x0678(0x0004)
	float                                              fLastAppliedFOV;                                          // 0x067C(0x0004)
	float                                              m_fCollisionTraceExtent;                                  // 0x0680(0x0004)
	class ATgEmitter_CameraEffect_LowHealth*           m_LowHealthCameraEffect;                                  // 0x0684(0x0008)
	class ATgEmitter_CameraEffect_Bleed*               m_BleedCameraEffect;                                      // 0x068C(0x0008)
	class ATgEmitter_CameraEffect_Daze*                m_DazeCameraEffect;                                       // 0x0694(0x0008)
	class ATgEmitter_CameraEffect_Fire*                m_FireCameraEffect;                                       // 0x069C(0x0008)
	class ATgEmitter_CameraEffect_Freeze*              m_FreezeCameraEffect;                                     // 0x06A4(0x0008)
	class ATgEmitter_CameraEffect_Heal*                m_HealCameraEffect;                                       // 0x06AC(0x0008)
	class ATgEmitter_CameraEffect_Knockback*           m_KnockbackCameraEffect;                                  // 0x06B4(0x0008)
	class ATgEmitter_CameraEffect_Mark*                m_MarkCameraEffect;                                       // 0x06BC(0x0008)
	class ATgEmitter_CameraEffect_Poison*              m_PoisonCameraEffect;                                     // 0x06C4(0x0008)
	class ATgEmitter_CameraEffect_Venom*               m_VenomCameraEffect;                                      // 0x06CC(0x0008)
	class ATgEmitter_CameraEffect_Root*                m_RootCameraEffect;                                       // 0x06D4(0x0008)
	class ATgEmitter_CameraEffect_Slow*                m_SlowCameraEffect;                                       // 0x06DC(0x0008)
	class ATgEmitter_CameraEffect_Stun*                m_StunCameraEffect;                                       // 0x06E4(0x0008)
	class ATgEmitter_CameraEffect_Hidden*              m_HiddenCameraEffect;                                     // 0x06EC(0x0008)
	class ATgEmitter_CameraEffect_Hidden*              m_GrassCameraEffect;                                      // 0x06F4(0x0008)
	class ATgEmitter_CameraEffect_Teleport*            m_TeleportCameraEffect;                                   // 0x06FC(0x0008)
	class ATgEmitter_CameraEffect_PreTeleport*         m_PreTeleportCameraEffect;                                // 0x0704(0x0008)
	class ATgEmitter_CameraEffect_CCImmune*            m_CCImmuneCameraEffect;                                   // 0x070C(0x0008)
	class ATgEmitter_CameraEffect_Cripple*             m_CrippleCameraEffect;                                    // 0x0714(0x0008)
	class ATgEmitter_CameraEffect_Revealed*            m_RevealedCameraEffect;                                   // 0x071C(0x0008)
	class ATgEmitter_CameraEffect*                     m_WeatherCameraEffect;                                    // 0x0724(0x0008)
	class ATgWeatherVolume*                            m_CurrentWeatherVolume;                                   // 0x072C(0x0008)
	TArray<class ATgEmitter_CameraEffect*>             m_CameraEffects;                                          // 0x0734(0x0010) (Transient, NeedCtorLink)
	int                                                m_nCameraEffectIdCounter;                                 // 0x0744(0x0004)
	class UClass*                                      m_HealthDamageCameraEffectClasses[0x8];                   // 0x0748(0x0008)
	class UClass*                                      m_ShieldDamageCameraEffectClasses[0x8];                   // 0x0788(0x0008)
	struct FPropertyDecayState                         m_HealthDamageFXState[0x8];                               // 0x07C8(0x000C)
	struct FPropertyDecayState                         m_HealingFXState;                                         // 0x0828(0x000C)
	struct FPropertyDecayParams                        m_HealthDamageFXParams;                                   // 0x0834(0x0014)
	struct FPropertyDecayParams                        m_HealingFXParams;                                        // 0x0848(0x0014)
	float                                              m_fAccumulateHealing;                                     // 0x085C(0x0004)
	float                                              m_fSecondsSinceLastHealFXUpdate;                          // 0x0860(0x0004)
	float                                              m_fHealFXUpdatePeriod;                                    // 0x0864(0x0004)
	float                                              m_fBloodHazeIntensity;                                    // 0x0868(0x0004)
	float                                              m_fHealingFXHalflifeAccumulation;                         // 0x086C(0x0004)
	float                                              m_fHealingFXHalflifeImpulse;                              // 0x0870(0x0004)
	float                                              m_fHealingFXReliefFactor;                                 // 0x0874(0x0004)
	float                                              m_fHealingFXAccumulationMix;                              // 0x0878(0x0004)
	float                                              m_fHealingFXVisibleThreshold;                             // 0x087C(0x0004)
	float                                              m_fHealingCritFXThreshold;                                // 0x0880(0x0004)
	float                                              m_fHealthDamageFXHalflifeAccumulation;                    // 0x0884(0x0004)
	float                                              m_fHealthDamageFXHalflifeImpulse;                         // 0x0888(0x0004)
	float                                              m_fHealthDamageFXPainFactor;                              // 0x088C(0x0004)
	float                                              m_fHealthDamageFXAccumulationMix;                         // 0x0890(0x0004)
	float                                              m_fHealthDamageCritFXThreshold;                           // 0x0894(0x0004)
	float                                              m_fHealthDamageCritFXAccumulationMix;                     // 0x0898(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPlayerCamera");
		return ptr;
	}


	void TakeHit(const struct FVector& Direction, float fDamageAmount, class UClass* DamageType, struct FExtraDamageInfo* ExtraInfo);
	bool CheckCrit(int ScreenLocation);
	float STATIC_MixProperty(const struct FPropertyDecayState& PropState, const struct FPropertyDecayParams& PropParams);
	void UpdateDecay(const struct FPropertyDecayParams& PropParams, float fPropertyCurrent, struct FPropertyDecayState* PropState);
	void PlayDamageCameraEffect(TEnumAsByte<EDamageEffectScreenLocation> ScreenLocation, float fDamageAmount, bool bCritical);
	class ATgEmitter_CameraEffect* FindCameraEffect(class UClass* CameraEffectClass);
	void STATIC_RemoveCameraEffect(class ATgEmitter_CameraEffect* CameraEffect);
	class ATgEmitter_CameraEffect* STATIC_AddCameraEffect(class UParticleSystem* Template, TArray<struct FFx_Sound> SoundList, TEnumAsByte<ECameraEffectVisiblity> EffectVisibility);
	void PlayWeather(class UParticleSystem* Template, class ATgWeatherVolume* SourceVolume);
	void PlayRevealed(bool bEnabled);
	void PlayGrass(bool bEnabled, class UParticleSystem* Template);
	void PlayHidden(bool bEnabled, class UParticleSystem* Template);
	void PlayTeleportFx();
	void PlayPreTeleportFX();
	void PlayMark(bool bEnabled);
	void PlayDaze(bool bEnabled);
	void PlayStun(bool bEnabled);
	void PlaySlow(bool bEnabled);
	void PlayRoot(bool bEnabled);
	void PlayCrippled(bool bEnabled);
	void PlayVenom(bool bEnabled);
	void PlayPoisoned(bool bEnabled);
	void PlayKnockback(bool bEnabled);
	void STATIC_PlayHeal(float fHealAmount);
	void Tick(float DeltaSeconds);
	void STATIC_PlayCCImmuneEffects(bool bEnabled);
	void PlayFreeze(bool bEnabled);
	void PlayOnFire(bool bEnabled);
	void PlayBleed(bool bEnabled);
	void PlayLowHealth(bool bEnabled);
	float STATIC_GetFOVInterpZoomPct();
	float STATIC_AdjustFOV(float DeltaTime);
	void ApplyFOVModification(float* FOV);
	void FillCameraCache(struct FTPOV* NewPOV);
	void UpdateCameraLocalToTarget();
	void GetViewLocalToTarget(class AActor* InViewTarget, struct FVector* LocalViewLocation, struct FQuat* LocalViewRotation);
	void STATIC_UpdateCamera(float DeltaTime);
	void ZoomOut();
	void ZoomIn();
	void ProcessInput(class UPlayerInput* PlayerInput, float DeltaTime);
	void EndLastCameraTween();
	void STATIC_UpdateViewTarget(float DeltaTime, struct FTViewTarget* OutVT);
	class UTgCameraModule* STATIC_CreateCamera(class UClass* CameraClass);
	class UTgCameraModule* SwitchCameras(class UClass* CameraClass, float fTweenTime);
	float STATIC_GetFOVAngle();
	void STATIC_InterpolateFOV(float NewFOV, float InterpolationTime);
	void STATIC_SetFOV(float NewFOV);
	void STATIC_ResetFOV();
	void STATIC_InitializeFor(class APlayerController* PC);
	void PostBeginPlay();
	float STATIC_LambdaFromHalflife(float fHalflife);
	void STATIC_CheckViewTarget(struct FTViewTarget* VT);
	void ClearPenetrationList();
	void CheckPenetration(const struct FVector& CheckLocation, float CheckRadius);
	void CameraTrace(const struct FVector& End, const struct FVector& Start, class AActor* Target, struct FVector* HitLocation, struct FVector* HitNormal, float* HitTime);
};


// Class TgGame.TgSpectatorCamera
// 0x0030 (0x08CC - 0x089C)
class ATgSpectatorCamera : public ATgPlayerCamera
{
public:
	struct FViewTargetTransitionParams                 m_DefaultBlendParams;                                     // 0x089C(0x0010)
	struct FViewTargetTransitionParams                 m_SnapBlendParams;                                        // 0x08AC(0x0010)
	class UCameraAnim*                                 m_CinematicAnim;                                          // 0x08BC(0x0008)
	class UCameraAnimInst*                             m_AnimInstance;                                           // 0x08C4(0x0008) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSpectatorCamera");
		return ptr;
	}


	void EndCinematicAnim();
	void StartCinematicAnim();
	void DoUpdateCamera(float DeltaTime);
};


// Class TgGame.TgPlayOfTheGameCamera
// 0x0068 (0x0488 - 0x0420)
class ATgPlayOfTheGameCamera : public ACameraActor
{
public:
	class ATgSkeletalMeshActor_Loader*                 m_ViewTarget;                                             // 0x0420(0x0008) (Edit)
	unsigned long                                      m_bActive : 1;                                            // 0x0428(0x0004) (Transient)
	float                                              m_fRemainingTweenTime;                                    // 0x042C(0x0004)
	float                                              m_fTotalTweenTime;                                        // 0x0430(0x0004)
	struct FTPOV                                       m_TweenSourcePOV;                                         // 0x0434(0x0024) (Transient)
	struct FVector                                     m_vRelativeLocation;                                      // 0x0458(0x000C)
	struct FVector                                     m_vRelativeRotation;                                      // 0x0464(0x000C)
	struct FVector                                     m_vRelativeLocationOffset;                                // 0x0470(0x000C) (Edit)
	struct FVector                                     m_vRelativeRotationOffset;                                // 0x047C(0x000C) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPlayOfTheGameCamera");
		return ptr;
	}


	void STATIC_ApplyPostProcessOverrides();
	void GetCameraView(float DeltaTime, bool bOnlyFOV, struct FTPOV* OutPOV);
	void StartTween(float TweenTime);
	void UpdateTransform();
	void STATIC_SetActive(bool bActive);
};


// Class TgGame.TgBlockingVolume
// 0x0000 (0x02C0 - 0x02C0)
class ATgBlockingVolume : public ABlockingVolume
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgBlockingVolume");
		return ptr;
	}

};


// Class TgGame.TgBossBlockDynamicVolume
// 0x0000 (0x02C4 - 0x02C4)
class ATgBossBlockDynamicVolume : public ADynamicBlockingVolume
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgBossBlockDynamicVolume");
		return ptr;
	}

};


// Class TgGame.TgBossBlockVolume
// 0x0000 (0x02C0 - 0x02C0)
class ATgBossBlockVolume : public ABlockingVolume
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgBossBlockVolume");
		return ptr;
	}

};


// Class TgGame.TgBotEncounterVolume
// 0x0014 (0x02D0 - 0x02BC)
class ATgBotEncounterVolume : public AVolume
{
public:
	TArray<class ATgBotFactory*>                       m_Factories;                                              // 0x02BC(0x0010) (Edit, Const, NeedCtorLink)
	int                                                m_nPlayers;                                               // 0x02CC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgBotEncounterVolume");
		return ptr;
	}


	void STATIC_CheckTouching();
	void PostBeginPlay();
};


// Class TgGame.TgCameraVolume
// 0x0008 (0x02C4 - 0x02BC)
class ATgCameraVolume : public AVolume
{
public:
	class ACameraActor*                                AssociatedCamera;                                         // 0x02BC(0x0008) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCameraVolume");
		return ptr;
	}

};


// Class TgGame.TgDeviceVolume
// 0x0025 (0x02E1 - 0x02BC)
class ATgDeviceVolume : public AVolume
{
public:
	unsigned long                                      bPainCausing : 1;                                         // 0x02BC(0x0004) (Edit)
	unsigned long                                      BACKUP_bPainCausing : 1;                                  // 0x02BC(0x0004)
	unsigned long                                      s_bDeviceActive : 1;                                      // 0x02BC(0x0004)
	class AInfo*                                       PainTimer;                                                // 0x02C0(0x0008)
	class AController*                                 DamageInstigator;                                         // 0x02C8(0x0008)
	int                                                m_nMapObjectId;                                           // 0x02D0(0x0004) (Edit, EditConst)
	int                                                s_nDeviceId;                                              // 0x02D4(0x0004) (Edit)
	class UTgDeviceFire*                               s_DeviceFireMode;                                         // 0x02D8(0x0008)
	unsigned char                                      s_nTaskForce;                                             // 0x02E0(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceVolume");
		return ptr;
	}


	int STATIC_GetSupportedTaskforce();
	void STATIC_OnSetTaskforce(class UTgSeqAct_SetTaskforce* Action);
	void STATIC_ApplyHit(class AActor* Target);
	void OnSetDamageInstigator(class USeqAct_SetDamageInstigator* Action);
	bool CanCausePainTo(class AActor* Other);
	void STATIC_CausePainTo(class AActor* Other);
	void UnTouch(class AActor* Other);
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_TimerPop(class ATgDeviceVolumeInfo* T);
	void OnToggle(class USeqAct_Toggle* inAction);
	void STATIC_Reset();
	void PostBeginPlay();
	bool SetupDevice();
};


// Class TgGame.TgDeviceVolume_Pulse
// 0x001D (0x02D9 - 0x02BC)
class ATgDeviceVolume_Pulse : public AVolume
{
public:
	class AController*                                 DamageInstigator;                                         // 0x02BC(0x0008)
	int                                                m_nMapObjectId;                                           // 0x02C4(0x0004) (Edit, EditConst)
	int                                                s_nDeviceId;                                              // 0x02C8(0x0004) (Edit)
	class UTgDeviceFire*                               m_FireMode;                                               // 0x02CC(0x0008)
	int                                                s_nTeamNumber;                                            // 0x02D4(0x0004)
	unsigned char                                      s_nTaskForce;                                             // 0x02D8(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceVolume_Pulse");
		return ptr;
	}


	struct FImpactInfo CalcDeviceFire(const struct FVector& StartTrace, const struct FVector& EndTrace, TArray<struct FImpactInfo>* ImpactList);
	void FindTouchingActorsFromScript();
	void STATIC_Fire();
	void STATIC_TurnOff();
	void TurnOn();
	void OnToggle(class USeqAct_Toggle* inAction);
	void OnSetDamageInstigator(class USeqAct_SetDamageInstigator* Action);
	void PostBeginPlay();
	bool SetupDevice();
};


// Class TgGame.TgEndOfWorldVolume
// 0x0000 (0x02C0 - 0x02C0)
class ATgEndOfWorldVolume : public ABlockingVolume
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEndOfWorldVolume");
		return ptr;
	}

};


// Class TgGame.TgHeightFog
// 0x0008 (0x0288 - 0x0280)
class ATgHeightFog : public AInfo
{
public:
	class UHeightFogComponent*                         FogComponent;                                             // 0x0280(0x0008) (ExportObject, Component, EditInline)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgHeightFog");
		return ptr;
	}

};


// Class TgGame.TgHelpAlertVolume
// 0x0014 (0x02D0 - 0x02BC)
class ATgHelpAlertVolume : public AVolume
{
public:
	int                                                TaskForceNumber;                                          // 0x02BC(0x0004) (Edit)
	TArray<int>                                        GameTipIdList;                                            // 0x02C0(0x0010) (Edit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgHelpAlertVolume");
		return ptr;
	}


	void UnTouch(class AActor* Other);
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void RemoveGameTips(class ATgPlayerController* aPC);
	void AddGameTips(class ATgPlayerController* aPC);
};


// Class TgGame.TgIndoorVolume
// 0x0000 (0x02BC - 0x02BC)
class ATgIndoorVolume : public AVolume
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgIndoorVolume");
		return ptr;
	}


	void UnTouch(class AActor* Other);
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
};


// Class TgGame.TgInvalidObjectiveVolume
// 0x0000 (0x02BC - 0x02BC)
class ATgInvalidObjectiveVolume : public AVolume
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvalidObjectiveVolume");
		return ptr;
	}

};


// Class TgGame.TgItemShopVolume
// 0x0004 (0x02C0 - 0x02BC)
class ATgItemShopVolume : public AVolume
{
public:
	int                                                TaskforceIndex;                                           // 0x02BC(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgItemShopVolume");
		return ptr;
	}


	void SetPurchaseFlag(class AActor* Other, bool bCanPurchase);
	int STATIC_GetSupportedTaskforce();
	void UnTouch(class AActor* Other);
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
};


// Class TgGame.TgMapBoundsVolume
// 0x0008 (0x02C4 - 0x02BC)
class ATgMapBoundsVolume : public AVolume
{
public:
	class UTexture2D*                                  MinimapImage;                                             // 0x02BC(0x0008) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgMapBoundsVolume");
		return ptr;
	}


	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
};


// Class TgGame.TgMissionListVolume
// 0x0014 (0x02D0 - 0x02BC)
class ATgMissionListVolume : public AVolume
{
public:
	int                                                m_nMapObjectId;                                           // 0x02BC(0x0004) (Edit, EditConst)
	int                                                s_nQueueTableId;                                          // 0x02C0(0x0004) (Edit)
	int                                                s_nQueueTableMsgId;                                       // 0x02C4(0x0004) (Edit)
	class ATeleporter*                                 m_Teleporter;                                             // 0x02C8(0x0008) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgMissionListVolume");
		return ptr;
	}

};


// Class TgGame.TgModifyPawnPropertiesVolume
// 0x0020 (0x02DC - 0x02BC)
class ATgModifyPawnPropertiesVolume : public AVolume
{
public:
	int                                                m_nMapObjectId;                                           // 0x02BC(0x0004) (Edit, EditConst)
	unsigned long                                      m_bDisableJump : 1;                                       // 0x02C0(0x0004) (Edit)
	unsigned long                                      m_bDisableBlockActors : 1;                                // 0x02C0(0x0004) (Edit)
	unsigned long                                      m_bDisableHanging : 1;                                    // 0x02C0(0x0004) (Edit)
	unsigned long                                      m_bDisableAllDevices : 1;                                 // 0x02C0(0x0004) (Edit)
	unsigned long                                      m_bTriggerUseEvent : 1;                                   // 0x02C0(0x0004) (Edit)
	unsigned long                                      m_bOneWayMovement : 1;                                    // 0x02C0(0x0004) (Edit)
	struct FRotator                                    m_vOnewWay;                                               // 0x02C4(0x000C)
	class UArrowComponent*                             m_DirArrow;                                               // 0x02D0(0x0008) (ExportObject, Component, EditInline)
	int                                                s_nLootTableId;                                           // 0x02D8(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgModifyPawnPropertiesVolume");
		return ptr;
	}


	void UnTouch(class AActor* Other);
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void PostBeginPlay();
	void Used(class AActor* Other);
	void STATIC_LoadObjectConfig();
};


// Class TgGame.TgNamedAreaVolume
// 0x0024 (0x02E0 - 0x02BC)
class ATgNamedAreaVolume : public AVolume
{
public:
	int                                                m_nMessageId;                                             // 0x02BC(0x0004) (Edit)
	struct FString                                     m_PreviewText;                                            // 0x02C0(0x0010) (Edit, EditConst, NeedCtorLink)
	TArray<class ATgPlayerStartRoyale*>                m_PlayerStarts;                                           // 0x02D0(0x0010) (Edit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgNamedAreaVolume");
		return ptr;
	}


	void UnTouch(class AActor* Other);
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	struct FString STATIC_GetAreaNameString();
};


// Class TgGame.TgObjectiveVolume
// 0x0000 (0x02BC - 0x02BC)
class ATgObjectiveVolume : public AVolume
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgObjectiveVolume");
		return ptr;
	}


	void UnTouch(class AActor* Other);
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void ClearCurrentObjective();
	void SetCurrentObjective(class AActor* Other);
	bool STATIC_IsObjective(class AActor* Other);
};


// Class TgGame.TgPlayerBlockingVolume
// 0x0000 (0x02C0 - 0x02C0)
class ATgPlayerBlockingVolume : public ABlockingVolume
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPlayerBlockingVolume");
		return ptr;
	}

};


// Class TgGame.TgPlayerCountVolume
// 0x0020 (0x02DC - 0x02BC)
class ATgPlayerCountVolume : public AVolume
{
public:
	int                                                PlayerCountTarget;                                        // 0x02BC(0x0004) (Edit)
	int                                                TaskForceNumber;                                          // 0x02C0(0x0004) (Edit)
	int                                                MessageId;                                                // 0x02C4(0x0004) (Edit)
	TArray<class APawn*>                               Players;                                                  // 0x02C8(0x0010) (NeedCtorLink)
	unsigned long                                      Enabled : 1;                                              // 0x02D8(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPlayerCountVolume");
		return ptr;
	}


	int STATIC_GetCount();
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_Update(class ATgPawn* Other);
};


// Class TgGame.TgPortal
// 0x001C (0x0300 - 0x02E4)
class ATgPortal : public APortal
{
public:
	unsigned long                                      bUpdateRotation : 1;                                      // 0x02E4(0x0004) (Edit)
	unsigned long                                      bCheckOverlap : 1;                                        // 0x02E4(0x0004) (Edit)
	unsigned long                                      bResetVelocity : 1;                                       // 0x02E4(0x0004) (Edit)
	unsigned long                                      bCheckTaskForce : 1;                                      // 0x02E4(0x0004) (Edit)
	int                                                nTaskForce;                                               // 0x02E8(0x0004) (Edit)
	class USoundCue*                                   TeleportSoundCue;                                         // 0x02EC(0x0008) (Edit)
	float                                              FadeInTime;                                               // 0x02F4(0x0004) (Edit)
	float                                              VolumeMultiplier;                                         // 0x02F8(0x0004) (Edit)
	float                                              PitchMultiplier;                                          // 0x02FC(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPortal");
		return ptr;
	}


	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
};


// Class TgGame.TgPostProcessVolume
// 0x0024 (0x0470 - 0x044C)
class ATgPostProcessVolume : public APostProcessVolume
{
public:
	class UMaterialInterface*                          m_Material;                                               // 0x044C(0x0008) (Edit)
	TEnumAsByte<ESceneDepthPriorityGroup>              m_SceneDPG;                                               // 0x0454(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0455(0x0003) MISSED OFFSET
	class UMaterialInstanceConstant*                   m_MaterialMIC;                                            // 0x0458(0x0008)
	float                                              m_FadeInTime;                                             // 0x0460(0x0004) (Edit)
	float                                              m_FadeOutTime;                                            // 0x0464(0x0004) (Edit)
	struct FName                                       m_FadeScalarParameterName;                                // 0x0468(0x0008) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPostProcessVolume");
		return ptr;
	}


	void PostBeginPlay();
};


// Class TgGame.TgSpawnGate
// 0x001C (0x02E0 - 0x02C4)
class ATgSpawnGate : public ADynamicBlockingVolume
{
public:
	TEnumAsByte<ESpawnGateType>                        m_eSpawnGateType;                                         // 0x02C4(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x02C5(0x0003) MISSED OFFSET
	class AEmitter*                                    m_StandardEmitter;                                        // 0x02C8(0x0008) (Edit)
	class ATgEmitter_TeamColor*                        m_TeamColoredEmitter;                                     // 0x02D0(0x0008) (Edit)
	unsigned long                                      m_bStartActive : 1;                                       // 0x02D8(0x0004) (Edit)
	unsigned long                                      m_bGateOpen : 1;                                          // 0x02D8(0x0004)
	int                                                m_nCurrentTaskforce;                                      // 0x02DC(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSpawnGate");
		return ptr;
	}


	void ToggleTeamColors();
	void Deactivate();
	void STATIC_Activate();
	void PostBeginPlay();
	int STATIC_GetCurrentTaskforce();
};


// Class TgGame.TgSpawnTeleporterEntrance
// 0x0004 (0x02C0 - 0x02BC)
class ATgSpawnTeleporterEntrance : public AVolume
{
public:
	unsigned long                                      bEnabled : 1;                                             // 0x02BC(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSpawnTeleporterEntrance");
		return ptr;
	}


	void OnToggle(class USeqAct_Toggle* Action);
	void Touch(class AActor* WantsTeleport, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void TeleportToExit(class ATgPawn* TgP, class ATgSpawnTeleporterEntrance* From, const struct FExitInfo& To);
	struct FExitInfo FindExit(class ATgPawn* TgP, TArray<class ATgSpawnTeleporterExit*>* Exits);
	bool STATIC_CanTeleport(class AActor* Other);
	int CompareExitInfo(const struct FExitInfo& EI1, const struct FExitInfo& EI2);
};


// Class TgGame.TgTeleportPlayerVolume
// 0x000C (0x02C8 - 0x02BC)
class ATgTeleportPlayerVolume : public AVolume
{
public:
	TEnumAsByte<ETgTeleportVolumeType>                 TeleportLocation;                                         // 0x02BC(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x02BD(0x0003) MISSED OFFSET
	int                                                nMessageId;                                               // 0x02C0(0x0004) (Edit)
	unsigned long                                      bTeleportBots : 1;                                        // 0x02C4(0x0004) (Edit)
	unsigned long                                      bTeleportPlayers : 1;                                     // 0x02C4(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgTeleportPlayerVolume");
		return ptr;
	}


	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
};


// Class TgGame.TgVisibilityVolume
// 0x0010 (0x02CC - 0x02BC)
class ATgVisibilityVolume : public AVolume
{
public:
	class UParticleSystem*                             m_PlayerCameraParticleSystem;                             // 0x02BC(0x0008) (Edit)
	class UParticleSystem*                             m_PlayerCameraInvisibleParticleSystem;                    // 0x02C4(0x0008) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgVisibilityVolume");
		return ptr;
	}


	void UnTouch(class AActor* Other);
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
};


// Class TgGame.TgAudioConversations
// 0x0020 (0x0080 - 0x0060)
class UTgAudioConversations : public UObject
{
public:
	TArray<struct FVoxConversation>                    m_Conversations;                                          // 0x0060(0x0010) (Config, NeedCtorLink)
	unsigned long                                      m_bInitialized : 1;                                       // 0x0070(0x0004)
	unsigned long                                      m_bTF1Conversed : 1;                                      // 0x0070(0x0004)
	unsigned long                                      m_bTF2Conversed : 1;                                      // 0x0070(0x0004)
	class ATgRepInfo_Game*                             m_GRI;                                                    // 0x0074(0x0008)
	int                                                m_nConversationAttemptsRemaining;                         // 0x007C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAudioConversations");
		return ptr;
	}

};


// Class TgGame.TgCapturePoint
// 0x0090 (0x0310 - 0x0280)
class ATgCapturePoint : public AActor
{
public:
	class ATgCollisionProxy_Cylinder*                  s_CollisionProxy;                                         // 0x0280(0x0008)
	class ATgRepInfo_CapturePoint*                     r_RepInfo;                                                // 0x0288(0x0008) (Net)
	float                                              m_fCollisionProxyRadius;                                  // 0x0290(0x0004) (Edit, Const)
	float                                              m_fCollisionProxyHeight;                                  // 0x0294(0x0004) (Edit, Const)
	float                                              m_fBaseTransitionSpeed;                                   // 0x0298(0x0004) (Const)
	float                                              m_fTransitionSpeedBuff;                                   // 0x029C(0x0004) (Const)
	float                                              m_fCurrentTransitionSpeed;                                // 0x02A0(0x0004) (Transient)
	class UTgSeqEvent_ControlPointOwnershipChange*     c_OwnershipChangedKismetNode;                             // 0x02A4(0x0008) (Transient)
	class ATgBotFactory_PointCapture*                  s_BotSpawners[0x2];                                       // 0x02AC(0x0008) (Edit)
	class ATgBotFactory_PointCapture*                  m_CurrentBotSpawners[0x2];                                // 0x02BC(0x0008) (Transient)
	class ATgBotFactory_PointCapture*                  s_NeutralBotSpawner;                                      // 0x02CC(0x0008) (Edit)
	int                                                m_CapturePointIndex;                                      // 0x02D4(0x0004) (Edit, Const)
	float                                              s_fReplenishBotTime;                                      // 0x02D8(0x0004) (Edit, Const)
	float                                              s_fRemainingReplenishBotTime;                             // 0x02DC(0x0004) (Transient)
	float                                              s_fFriendlyReplenishBuffPct;                              // 0x02E0(0x0004)
	float                                              m_fRegenUpdateTimer;                                      // 0x02E4(0x0004)
	float                                              m_fOwnedManaRegen;                                        // 0x02E8(0x0004) (Const)
	float                                              m_fOwnedHealthRegen;                                      // 0x02EC(0x0004) (Const)
	class ATgGame_Mission*                             s_GameInfo;                                               // 0x02F0(0x0008) (Transient)
	int                                                m_nTF1Count;                                              // 0x02F8(0x0004) (Transient)
	int                                                m_nTF2Count;                                              // 0x02FC(0x0004) (Transient)
	float                                              m_fLastEnemyKillVoxTimestamp;                             // 0x0300(0x0004) (Transient)
	int                                                m_nLaneNumber;                                            // 0x0304(0x0004) (Edit)
	class USpriteComponent*                            m_WorldIconSprite;                                        // 0x0308(0x0008) (Edit, ExportObject, Component, EditInline)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCapturePoint");
		return ptr;
	}


	void STATIC_OnGetTaskForceNumber(class UTgSeqAct_GetTaskForceNumber* Action);
	void UpdateLockEffects();
	void OnToggle(class USeqAct_Toggle* Action);
	void STATIC_OnNearbyEnemyPlayerDied(class ATgPawn* DeadPawn);
	void Destroyed();
	void STATIC_OnTaskForceControlChanged(int NewTaskForce);
	int STATIC_GetCapturePointIndex();
	void SpawnBotsForCurrentTaskForce();
	void STATIC_OnBotDied(int DeadBotTaskForce);
	void STATIC_OnPointReclaimed();
	void STATIC_OnPointCaptureOwnershipChanged(int NewTaskForceOwner, int PreviousTaskForceOwner);
	void STATIC_NearbyPawnsUpdated();
	void STATIC_CollisionProxyOnUnTouch(class AActor* Other);
	void STATIC_CollisionProxyOnTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void PostBeginPlay();
	void PreBeginPlay();
	void SpawnNeutralBot();
	void STATIC_TakeDamage(int Damage, class AController* InstigatedBy, const struct FVector& HitLocation, const struct FVector& Momentum, class UClass* DamageType, const struct FTraceHitInfo& HitInfo, class AActor* DamageCauser);
	void AlertPointChanged();
};


// Class TgGame.TgCatapultActor
// 0x00E8 (0x03D0 - 0x02E8)
class ATgCatapultActor : public ASkeletalMeshActor
{
public:
	struct FName                                       m_SeatSocketName;                                         // 0x02E8(0x0008)
	int                                                m_nUIMapIndex;                                            // 0x02F0(0x0004)
	class ATgPawn*                                     r_DriverPawn;                                             // 0x02F4(0x0008) (Net, Transient)
	float                                              m_fLaunchTime;                                            // 0x02FC(0x0004) (Edit)
	struct FVector                                     m_vLaunchVelocity;                                        // 0x0300(0x000C) (Edit)
	float                                              m_fRotationSpeed;                                         // 0x030C(0x0004) (Edit)
	float                                              m_fTriggerRadius;                                         // 0x0310(0x0004) (Edit)
	float                                              m_fTriggerHeight;                                         // 0x0314(0x0004) (Edit)
	class ATgCollisionProxy_Cylinder*                  m_TriggerCylinder;                                        // 0x0318(0x0008) (Transient)
	unsigned char                                      r_nFlashFire;                                             // 0x0320(0x0001) (Net, Transient)
	unsigned char                                      c_nCachedFlashFire;                                       // 0x0321(0x0001) (Transient)
	unsigned char                                      UnknownData00[0x2];                                       // 0x0322(0x0002) MISSED OFFSET
	unsigned long                                      r_bIsFiring : 1;                                          // 0x0324(0x0004) (Net, Transient)
	unsigned long                                      c_bIsRotating : 1;                                        // 0x0324(0x0004) (Transient)
	unsigned long                                      m_bIsPlayingFireAnim : 1;                                 // 0x0324(0x0004) (Transient)
	class USkelControlWheel*                           c_WheelControls[0x4];                                     // 0x0328(0x0008) (Transient)
	float                                              c_WheelSpinSpeed;                                         // 0x0348(0x0004) (Edit)
	float                                              c_SimulatedRotationSpeed;                                 // 0x034C(0x0004) (Edit)
	struct FRotator                                    c_SavedRotation;                                          // 0x0350(0x000C) (Transient)
	struct FRotator                                    c_TargetRotation;                                         // 0x035C(0x000C) (Transient)
	float                                              m_fLaunchPowerLevel;                                      // 0x0368(0x0004) (Transient)
	TArray<class UTgSpecialFx*>                        c_MovementFXList;                                         // 0x036C(0x0010) (Transient, NeedCtorLink)
	TArray<struct FName>                               c_MovementFXSocketList;                                   // 0x037C(0x0010) (NeedCtorLink)
	class UTgSpecialFx*                                c_SeatIndicatorFX;                                        // 0x038C(0x0008) (Transient)
	class UTgSpecialFx*                                c_AimIndicatorFX;                                         // 0x0394(0x0008) (Transient)
	class UTgSpecialFx*                                c_TurnStartAudFX;                                         // 0x039C(0x0008) (Transient)
	class UTgSpecialFx*                                c_TurnStopAudFX;                                          // 0x03A4(0x0008) (Transient)
	class UTgSpecialFx*                                c_DriverEnterAudFX;                                       // 0x03AC(0x0008) (Transient)
	float                                              m_fRotationLockoutTime;                                   // 0x03B4(0x0004) (Edit)
	float                                              m_fRemainingRotationLockoutTime;                          // 0x03B8(0x0004) (Transient)
	int                                                c_nYawFXDeadzone;                                         // 0x03BC(0x0004)
	int                                                c_nYawOffset;                                             // 0x03C0(0x0004) (Transient)
	struct FVector                                     m_vRelativeSeatLoc;                                       // 0x03C4(0x000C) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCatapultActor");
		return ptr;
	}


	void STATIC_OnStopLaunchAnim();
	void STATIC_PlayLaunchAnim();
	void STATIC_PropelPawn();
	void STATIC_FinishLaunch();
	void STATIC_StartLaunch(float PowerLevel);
	bool CanPawnLeave();
	void STATIC_SetDriver(class ATgPawn* P);
	void STATIC_OnProxyUnTouch(class AActor* Other);
	void STATIC_OnProxyTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_PostInitAnimTree(class USkeletalMeshComponent* SkelComp);
	void PostBeginPlay();
	void STATIC_ReplicatedEvent(const struct FName& VarName);
	void STATIC_NativePostBeginPlay();
};


// Class TgGame.TgGame
// 0x014C (0x0628 - 0x04DC)
class ATgGame : public AFrameworkGame
{
public:
	class UClass*                                      m_ContentPackageReference;                                // 0x04DC(0x0008)
	TEnumAsByte<EGAME_WIN_STATE>                       m_GameWinState;                                           // 0x04E4(0x0001)
	TEnumAsByte<ETG_GAME_TYPE>                         m_GameType;                                               // 0x04E5(0x0001)
	unsigned char                                      UnknownData00[0x2];                                       // 0x04E6(0x0002) MISSED OFFSET
	float                                              m_fSpawnProtectionTime;                                   // 0x04E8(0x0004)
	float                                              m_fMaxRepawnTime;                                         // 0x04EC(0x0004)
	float                                              m_fUnpauseCountdownRemaining;                             // 0x04F0(0x0004)
	int                                                s_nBotPlayerCount;                                        // 0x04F4(0x0004)
	unsigned long                                      s_bSpawnOfflinePawns : 1;                                 // 0x04F8(0x0004)
	unsigned long                                      s_bGameInitialized : 1;                                   // 0x04F8(0x0004)
	unsigned long                                      s_bGameEndMissionProcessed : 1;                           // 0x04F8(0x0004)
	unsigned long                                      s_bMissionSealed : 1;                                     // 0x04F8(0x0004)
	unsigned long                                      m_bForceUsePRISpawnPoint : 1;                             // 0x04F8(0x0004) (Const)
	unsigned long                                      m_bRewardCalculated : 1;                                  // 0x04F8(0x0004)
	unsigned long                                      m_bStatsCanTie : 1;                                       // 0x04F8(0x0004)
	unsigned long                                      m_bStatsIsSymmetric : 1;                                  // 0x04F8(0x0004)
	unsigned long                                      m_bIsTutorialGametype : 1;                                // 0x04F8(0x0004)
	unsigned long                                      m_bIsPracticeGametype : 1;                                // 0x04F8(0x0004)
	unsigned long                                      m_bEnableHeadShots : 1;                                   // 0x04F8(0x0004) (Config, GlobalConfig)
	unsigned long                                      m_bAlliances : 1;                                         // 0x04F8(0x0004) (Config)
	unsigned long                                      m_bPlayOfTheGameLocked : 1;                               // 0x04F8(0x0004)
	unsigned long                                      m_bSpawnDisconnectedPlayersStunned : 1;                   // 0x04F8(0x0004)
	unsigned long                                      m_bPlayersCanOnlyDieOnce : 1;                             // 0x04F8(0x0004)
	unsigned long                                      m_bUseKillEmotes : 1;                                     // 0x04F8(0x0004)
	unsigned long                                      m_bNotifyKillCombos : 1;                                  // 0x04F8(0x0004)
	unsigned long                                      m_bFirstBloodAwarded : 1;                                 // 0x04F8(0x0004)
	int                                                s_nNextActorInstanceId;                                   // 0x04FC(0x0004)
	int                                                s_nNextProjectileInstanceId;                              // 0x0500(0x0004)
	TArray<class ATgAIVolume*>                         s_AIVolumes;                                              // 0x0504(0x0010) (AlwaysInit, NeedCtorLink)
	TArray<int>                                        s_Taskforce1AIVolumesIndices;                             // 0x0514(0x0010) (AlwaysInit, NeedCtorLink)
	TArray<int>                                        s_Taskforce2AIVolumesIndices;                             // 0x0524(0x0010) (AlwaysInit, NeedCtorLink)
	TArray<class ATgFortressVolume*>                   s_FortressVolumes;                                        // 0x0534(0x0010) (AlwaysInit, NeedCtorLink)
	unsigned char                                      UnknownData01[0x48];                                      // 0x0544(0x0048) UNKNOWN PROPERTY: MapProperty TgGame.TgGame.s_AIAnnotations
	TArray<class ATgDeviceVolume*>                     s_DeviceVolumes;                                          // 0x058C(0x0010) (AlwaysInit, NeedCtorLink)
	TArray<class ATgActorFactory*>                     s_ActorFactories;                                         // 0x059C(0x0010) (NeedCtorLink)
	float                                              s_fXPModifier;                                            // 0x05AC(0x0004)
	float                                              m_fGlobalCooldownTime;                                    // 0x05B0(0x0004) (Const, Config)
	TArray<int>                                        m_ClientLogins;                                           // 0x05B4(0x0010) (AlwaysInit, NeedCtorLink)
	float                                              m_fOcclusionCalcPeriod;                                   // 0x05C4(0x0004) (Config)
	float                                              m_fOcclusionMaxDeviation;                                 // 0x05C8(0x0004) (Config)
	float                                              m_fReadyPercent;                                          // 0x05CC(0x0004) (Config)
	struct FPlayOfTheGameInfo                          m_PlayOfTheGame;                                          // 0x05D0(0x000C)
	float                                              m_fPlayOfTheGameLength;                                   // 0x05DC(0x0004)
	float                                              m_fPlayOfTheGameIntroBufferLength;                        // 0x05E0(0x0004)
	float                                              m_fPlayOfTheGameOuttroBufferLength;                       // 0x05E4(0x0004)
	TArray<struct FPlayOfTheGameEventConfig>           m_PlayOfTheGameEventConfigs;                              // 0x05E8(0x0010) (NeedCtorLink)
	TArray<class ATgSpawnTeleporterExit*>              m_PlayerSpawnExits;                                       // 0x05F8(0x0010) (NeedCtorLink)
	TArray<class UPlayer*>                             m_ReadyPlayers;                                           // 0x0608(0x0010) (NeedCtorLink)
	TArray<struct FCachedTalentTree>                   s_TalentTrees;                                            // 0x0618(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame");
		return ptr;
	}


	void STATIC_OnPawnDied(class ATgPawn* Victim, class AController* Killer);
	void STATIC_AddPotGEventToAllPlayers(TEnumAsByte<EPlayOfTheGameEventType> potgEvent);
	int STATIC_GetTaskForceForPlayer(class AController* Player);
	class APlayerStart* FindBestPlayerStart(class AController* Player, TArray<class APlayerStart*>* PlayerStartPoints);
	bool FindValidSpawnPoints(class ATgPawn* TgP, TArray<class ATgSpawnTeleporterExit*>* ValidExits);
	int STATIC_GetCurrentLane();
	int STATIC_GetGameSpawnPhase(class ATgPawn* TgP);
	void SetEnableHeadshots(bool bEnable);
	void STATIC_KickIdler(class APlayerController* PC);
	void STATIC_ClearPauseAfterCountdown();
	void STATIC_ClearPause();
	bool STATIC_SetPause(class APlayerController* PC, const struct FScriptDelegate& CanUnpauseDelegate);
	bool PreventDeath(class APawn* KilledPawn, class AController* Killer, class UClass* DamageType, const struct FVector& HitLocation);
	bool STATIC_CanSpectate(class APlayerController* Viewer, class APlayerReplicationInfo* ViewTarget);
	void STATIC_PostCommitMapChange();
	void STATIC_PostLogin(class APlayerController* NewPlayer);
	bool FindInactivePRI(class APlayerController* PC);
	void STATIC_AddInactivePRI(class APlayerReplicationInfo* PRI, class APlayerController* PC);
	void STATIC_StartMatch();
	void STATIC_GotoGameRunningState();
	bool STATIC_ShouldSpawnAtStartSpot(class AController* Player);
	bool STATIC_ChangeTeam(class AController* Other, int Num, bool bNewTeam);
	float STATIC_RatePlayerStart(class APlayerStart* P, unsigned char Team, class AController* Player);
	float STATIC_RatePlayerStartPoint(class APlayerStart* P, class AController* Player);
	class ANavigationPoint* FindPlayerGroupStart(class AController* Player, int groupNumber, unsigned char InTeam, const struct FString& IncomingName);
	class ANavigationPoint* FindPlayerStart(class AController* Player, unsigned char InTeam, const struct FString& IncomingName);
	class ANavigationPoint* STATIC_GetReviveLocation(class AController* Player, struct FVector* OutLocation, struct FRotator* OutRotation);
	class ANavigationPoint* STATIC_FindPlayerStartPoint(class AController* Player, const struct FString& SpawnTagName);
	void STATIC_SetPlayerDefaults(class APawn* PlayerPawn);
	void STATIC_AddDefaultInventory(class APawn* PlayerPawn);
	void STATIC_RestartPlayer(class AController* aPlayer);
	void STATIC_AllPlayersEndGame(class AActor* EndGameFocus);
	class APawn* STATIC_SpawnDefaultPawnFor(class AController* NewPlayer, class ANavigationPoint* StartSpot);
	void STATIC_StartBots();
	void STATIC_InitGame(const struct FString& Options, struct FString* ErrorMessage);
	void STATIC_Reset();
	int STATIC_GetNextProjectileInstanceId();
	int STATIC_GetNextActorInstanceId();
	void InitGameReplicationInfo();
	void PostBeginPlay();
	void PreBeginPlay();
	bool STATIC_IsFlankKill(struct FScoreKillData* Data);
	bool STATIC_GetScoreKillData(class AController* Killer, class AController* Other, struct FScoreKillData* Data);
	void ScoreKillAchievements(struct FScoreKillData* Data);
	void ScoreKillGameType(struct FScoreKillData* Data);
	void ScoreKillCommon(struct FScoreKillData* Data);
	void STATIC_ScoreKill(class AController* Killer, class AController* Other);
	void STATIC_MarkAsReady(class UPlayer* P);
	void STATIC_InitPlayOfTheGameConfig();
	void STATIC_LockPlayOfTheGame(bool bLocked);
	void ResetPlayOfTheGame();
	void CachePlayOfTheGame();
	float STATIC_GetWeightedPlayOfTheGameEventRating(class ATgRepInfo_Player* PRI, int nIndex);
	bool ConsiderForBestPlayOfTheGame(class ATgRepInfo_Player* PRI);
	bool CanSpoolCredits();
	void SendPauseNotification(class APlayerController* PC);
	void EndUnpauseCountdown();
	void BeginUnpauseCountdown(float fSeconds);
	bool STATIC_AllowPausing(class APlayerController* PC);
	void ResetStats();
	void STATIC_NotifyPostCommitMapChange();
	struct FString STATIC_GetGameVersion();
	float GetRespawnTime(int TaskForceNum);
	float STATIC_GetActualRespawnTime(int TaskForceNum);
	void BotDied(class ATgAIController* aic);
	void PlayerDied(class ATgPlayerController* PC);
	bool SpawnDefaultBotPlayers(bool bStartPaused, TArray<struct FTgAIBotPlayersToSpawn>* BotPlayersToSpawn);
	bool SwapToNewAIController(class AController* C, class ATgPawn_Character* TgPawn);
	void EnsureHeadPrecache(int nHeadId);
	void EnsureDevicePrecache(int nDeviceId, int nDeviceSkinId);
	void EnsureBotPrecache(int nBotId, int nSkinId, int nHeadId, int nDeviceSkinId);
	class ATgPawn* SpawnTemplatePlayer(class ATgPlayerController* pTgPC, int nProfileId, int nSkinId, int nWeaponSkinId, int nHeadSkinId);
	class ATgPawn* SpawnBotPawn(class ATgAIController* pTgAI, const struct FVector& vLocation, const struct FRotator& rRotation, bool bIgnoreCollision, class ATgPawn* pOwnerPawn, float fDeploySecs);
	class ATgPawn* SpawnBotById(int nBotId, int nSkinId, int nHeadId, int nWeaponSkinId, const struct FVector& vLocation, const struct FRotator& rRotation, class ATgBotFactory* pFactory, bool bIgnoreCollision, class ATgPawn* pOwnerPawn, class UTgDeviceFire* deviceFire, float fDeployAnimLength, const struct FName& ControllerClassName, const struct FName& BehaviorTreeName);
	bool FinishEndMission();
	bool BeginEndMission(bool bClearNextMapGame, class AActor* EndMissionFocus, float fDelayOverride);
	int STATIC_GetWinningTaskforce();
	class ATgPawn* SpawnPlayerCharacter(class AController* C, const struct FVector& vLocation);
	void STATIC_InitGameRepInfo();
	void STATIC_LoadGameConfig();
};


// Class TgGame.TgCharacterPerformance
// 0x00A4 (0x06CC - 0x0628)
class ATgCharacterPerformance : public ATgGame
{
public:
	class UPComPerformanceCaptureBase*                 BasePerformanceCapture;                                   // 0x0628(0x0008) (Transient)
	TEnumAsByte<EPComPerformanceCaptureState>          CurrentCaptureState;                                      // 0x0630(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0631(0x0003) MISSED OFFSET
	struct FString                                     CharacterInput;                                           // 0x0634(0x0010) (NeedCtorLink)
	struct FString                                     SetInput;                                                 // 0x0644(0x0010) (NeedCtorLink)
	int                                                CurrentCharacterIndex;                                    // 0x0654(0x0004)
	int                                                CurrentSkinIndex;                                         // 0x0658(0x0004)
	TArray<class ATgSkeletalMeshActor_Loader*>         CharacterPlacements;                                      // 0x065C(0x0010) (Transient, NeedCtorLink)
	TArray<struct FString>                             CharactersToTest;                                         // 0x066C(0x0010) (Transient, NeedCtorLink)
	TArray<int>                                        AllSkinIDs;                                               // 0x067C(0x0010) (NeedCtorLink)
	TArray<struct FDeviceToCharacterID>                DeviceToCharacterIDPairs;                                 // 0x068C(0x0010) (NeedCtorLink)
	TArray<struct FPComPerformanceCaptureStatsPerSkin> StatsPerSkin;                                             // 0x069C(0x0010) (NeedCtorLink)
	TArray<class ATgPawn*>                             CharacterPawns;                                           // 0x06AC(0x0010) (NeedCtorLink)
	class UTgManifestGroup*                            ManifestGroup;                                            // 0x06BC(0x0008)
	struct FPointer                                    CharacterPerformanceUtility;                              // 0x06C4(0x0008) (Native)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCharacterPerformance");
		return ptr;
	}


	void PrintAllSkins();
	void STATIC_DoNextAction();
	class ATgPawn* SpawnBotByIdForPerformance(int nBotId, int nSkinId, int nHeadId, int nDeviceId, const struct FVector& vLocation, const struct FRotator& rRotation);
	void SpawnCharacters();
	void STATIC_MoveCameraToNode();
	void CollectCharacterPlacementsAndSkins();
	void PostBeginPlay();
};


// Class TgGame.TgGame_Mission
// 0x011C (0x0744 - 0x0628)
class ATgGame_Mission : public ATgGame
{
public:
	unsigned long                                      m_bSpawnInTaskForceArea : 1;                              // 0x0628(0x0004)
	unsigned long                                      s_bPreGuardianPhasePulsed : 1;                            // 0x0628(0x0004)
	unsigned long                                      s_bGuardianPhasePulsed : 1;                               // 0x0628(0x0004)
	unsigned long                                      s_bWasSurrendered : 1;                                    // 0x0628(0x0004)
	unsigned long                                      m_bSurrenderAvailable : 1;                                // 0x0628(0x0004)
	unsigned long                                      m_bAllowAutoUpgrades : 1;                                 // 0x0628(0x0004)
	unsigned long                                      m_bUsePlayerCharacterIntros : 1;                          // 0x0628(0x0004)
	TEnumAsByte<EGameTimerState>                       m_eTimerState;                                            // 0x062C(0x0001)
	TEnumAsByte<EGameTimerState>                       m_eTimerStatePaused;                                      // 0x062D(0x0001)
	unsigned char                                      UnknownData00[0x2];                                       // 0x062E(0x0002) MISSED OFFSET
	float                                              m_fMissionTime;                                           // 0x0630(0x0004)
	float                                              m_fSecondaryMissionTime;                                  // 0x0634(0x0004)
	float                                              m_fWaitingForPlayersTime;                                 // 0x0638(0x0004) (Const)
	float                                              m_fSetupTime;                                             // 0x063C(0x0004) (Config)
	float                                              m_fPausedAtTime;                                          // 0x0640(0x0004)
	float                                              m_fGameMissionTime;                                       // 0x0644(0x0004)
	float                                              s_MissionTimeAccumulator;                                 // 0x0648(0x0004)
	TArray<class UPlayer*>                             s_ReadyPlayers;                                           // 0x064C(0x0010) (NeedCtorLink)
	int                                                s_nReadyMercs;                                            // 0x065C(0x0004)
	float                                              m_fTickCreditsFreq;                                       // 0x0660(0x0004) (Config)
	float                                              m_fCreditsToGivePerTick;                                  // 0x0664(0x0004) (Config)
	int                                                m_nStartingCurrency;                                      // 0x0668(0x0004)
	int                                                m_nStartingLevel;                                         // 0x066C(0x0004)
	int                                                m_nWinBonusXp;                                            // 0x0670(0x0004)
	int                                                m_nWinPlayerXp;                                           // 0x0674(0x0004)
	int                                                m_nLosePlayerXp;                                          // 0x0678(0x0004)
	float                                              m_fGodXpCoefficient;                                      // 0x067C(0x0004)
	float                                              m_fGodXpCoefficientLoss;                                  // 0x0680(0x0004)
	float                                              m_fGodXpWinBonus;                                         // 0x0684(0x0004)
	float                                              m_fFreeVIPWinPoints;                                      // 0x0688(0x0004)
	float                                              m_fFreeVIPLossPoints;                                     // 0x068C(0x0004)
	float                                              m_fFreeVIPPerMinute;                                      // 0x0690(0x0004)
	float                                              m_fPaidVIPWinPoints;                                      // 0x0694(0x0004)
	float                                              m_fPaidVIPLossPoints;                                     // 0x0698(0x0004)
	float                                              m_fPaidVIPPerMinute;                                      // 0x069C(0x0004)
	float                                              m_fBaseTokens;                                            // 0x06A0(0x0004)
	int                                                m_nKillTokens;                                            // 0x06A4(0x0004)
	struct FSurrenderData                              s_SurrenderData[0x2];                                     // 0x06A8(0x0024) (NeedCtorLink)
	float                                              m_fSurrenderTime;                                         // 0x06F0(0x0004)
	int                                                m_XPRadius;                                               // 0x06F4(0x0004)
	float                                              m_MinionKillerBonus;                                      // 0x06F8(0x0004)
	float                                              m_BasePlayerGoldReward;                                   // 0x06FC(0x0004)
	float                                              m_fFirstBloodGoldReward;                                  // 0x0700(0x0004)
	float                                              m_fBasePlayerAssistGoldRewardMultipler;                   // 0x0704(0x0004)
	float                                              m_fBasePlayerAssistXpRewardMultipler;                     // 0x0708(0x0004)
	float                                              m_fBaseNPCAssistGoldRewardMultipler;                      // 0x070C(0x0004)
	float                                              m_fBaseNPCAssistXpRewardMultipler;                        // 0x0710(0x0004)
	int                                                m_nPIESpawnTable;                                         // 0x0714(0x0004)
	int                                                m_nTargetPlayerCountForMercs;                             // 0x0718(0x0004)
	TArray<struct FTgAIBotPlayersToSpawn>              m_MercsToSpawn;                                           // 0x071C(0x0010) (NeedCtorLink)
	TArray<class ATgMinionGoal*>                       m_MinionGoals;                                            // 0x072C(0x0010) (Transient, NeedCtorLink)
	int                                                m_nDebugExtraCharXp;                                      // 0x073C(0x0004)
	int                                                m_nDebugExtraBPXp;                                        // 0x0740(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_Mission");
		return ptr;
	}


	TEnumAsByte<EGameTimerState> STATIC_GetMissionTimerStatus();
	float STATIC_GetPlayerWaitTime();
	float STATIC_GetSetupTime();
	void STATIC_SendSecondaryMissionTimerNotify(TEnumAsByte<EMissionTimerState> eState, float fRemainingSecs);
	void STATIC_SendMissionTimerNotify(TEnumAsByte<EMissionTimerState> eState, float fRemainingSecs);
	void STATIC_MissionTimeIncrement(float fInc);
	void STATIC_MissionTimerModify(bool bPause, int nNewTime);
	float STATIC_ElapsedTime();
	bool STATIC_MissionTimerActive();
	void STATIC_ChangeTimerState(TEnumAsByte<EGameTimerState> eTimerState);
	void STATIC_AllPlayersReady();
	void STATIC_MissionTimer();
	void STATIC_MissionTimerPause();
	void STATIC_MissionTimerStop();
	void STATIC_MissionTimerStart();
	void SetSecondaryMissionTime(float fTime);
	void SetMissionTime(float fTime);
	void STATIC_KeepClientsInSync();
	bool StartGameTimer();
	void STATIC_TgTimer(struct FString* sTimerCommand);
	void STATIC_QuickEndGame(int nWinnerTF);
	bool STATIC_CheckScore(class APlayerReplicationInfo* Scorer);
	void UpdateLockedPointStatus();
	void STATIC_OnPointCaptureOwnershipChanged(class ATgCapturePoint* Point, int NewTaskForceOwner, int PreviousTaskForceOwner);
	void STATIC_AddObjectiveScore(class APlayerReplicationInfo* Scorer, int Score);
	void STATIC_StartMatch();
	void STATIC_PostLogin(class APlayerController* NewPlayer);
	void PostBeginPlay();
	void SpawnBots();
	void CheckMercenaries();
	void STATIC_NativeUpdateTimerState();
	float STATIC_GetMinIntroWait();
	void CapturePointReclaimed(class ATgPawn_Character* PC);
	void CapturedPoint(class ATgPawn_Character* PC);
	void EndGameBySurrender(int SurrenderingTaskForce);
	void SurrenderComplete(int nTaskForce);
	void SurrenderCompleteTimer2();
	void SurrenderCompleteTimer1();
	void PlayerSurrender(int nPlayerId, bool bSurrender);
	void AllPlayersRecall();
	void AllPlayersFullVitals();
	void AllPlayersRevive();
	void STATIC_MarkAsReady(class UPlayer* P);
	float STATIC_MissionTimeElapsed();
	float STATIC_MissionTimeRemaining();
	void UpdateMissionTimerEventWinVar();
	void SendMissionTimerEvent(int nEventId);
	class ATgPawn* SpawnPlayerCharacter(class AController* C, const struct FVector& vLocation);
	void SpoolCredits();
	void STATIC_LoadGameConfig();
	bool BeginEndMission(bool bClearNextMapGame, class AActor* EndMissionFocus, float fDelayOverride);
};


// Class TgGame.TgGame_RoyaleBase
// 0x0054 (0x0798 - 0x0744)
class ATgGame_RoyaleBase : public ATgGame_Mission
{
public:
	class ATgLootManager*                              m_pLootManager;                                           // 0x0744(0x0008)
	float                                              m_fMapSize;                                               // 0x074C(0x0004)
	float                                              m_fZeppelinDist;                                          // 0x0750(0x0004)
	struct FVector                                     m_vZeppelinMapOriginShift;                                // 0x0754(0x000C)
	TArray<int>                                        m_nDisenchantValues;                                      // 0x0760(0x0010) (Config, NeedCtorLink)
	int                                                m_nLootLifespan;                                          // 0x0770(0x0004) (Config)
	int                                                m_nItemDropLimit;                                         // 0x0774(0x0004) (Config)
	float                                              m_fForgeTime;                                             // 0x0778(0x0004) (Config)
	float                                              m_fZeppelinInitialSpawnHeight;                            // 0x077C(0x0004) (Config)
	unsigned long                                      m_bDeployPlayers : 1;                                     // 0x0780(0x0004) (Config)
	unsigned long                                      m_bZeppelinSpawn : 1;                                     // 0x0780(0x0004) (Config)
	unsigned long                                      m_bDestroyZeppelinsAfterDeploy : 1;                       // 0x0780(0x0004) (Config)
	float                                              m_fZeppelinAirSpeed;                                      // 0x0784(0x0004) (Config)
	float                                              m_fDeployRange;                                           // 0x0788(0x0004) (Config)
	float                                              m_fZeppelinOriginSpawnOffset;                             // 0x078C(0x0004) (Config)
	float                                              m_fZeppelinRangeSpawnOffset;                              // 0x0790(0x0004) (Config)
	int                                                m_nMaxShards;                                             // 0x0794(0x0004) (Config)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_RoyaleBase");
		return ptr;
	}


	bool STATIC_HasCaptureObjectives();
	void DeployPlayers(bool bPreselect);
	void STATIC_NativePostBeginPlay();
};


// Class TgGame.TgGame_Royale
// 0x0228 (0x09C0 - 0x0798)
class ATgGame_Royale : public ATgGame_RoyaleBase
{
public:
	int                                                m_nConvergeRoundNum;                                      // 0x0798(0x0004)
	unsigned char                                      m_eFogState;                                              // 0x079C(0x0001)
	unsigned char                                      m_eGameState;                                             // 0x079D(0x0001)
	TEnumAsByte<EPlayerDisconnectMode>                 m_eDisconnectPlayerMode;                                  // 0x079E(0x0001)
	unsigned char                                      UnknownData00[0x1];                                       // 0x079F(0x0001) MISSED OFFSET
	float                                              m_fDeltaTime;                                             // 0x07A0(0x0004)
	float                                              m_fFogStateTimer;                                         // 0x07A4(0x0004)
	float                                              m_fRemainingGameTime;                                     // 0x07A8(0x0004)
	unsigned long                                      m_bFogStateTimerEnabled : 1;                              // 0x07AC(0x0004)
	unsigned long                                      m_bFogRoamingEnabled : 1;                                 // 0x07AC(0x0004)
	unsigned long                                      m_bFogPreConvergedEnabled : 1;                            // 0x07AC(0x0004)
	unsigned long                                      m_bLTEActive : 1;                                         // 0x07AC(0x0004)
	unsigned long                                      m_bMatchCompositionLoaded : 1;                            // 0x07AC(0x0004)
	unsigned long                                      m_bAllVendorsLoaded : 1;                                  // 0x07AC(0x0004)
	unsigned long                                      m_bLootGoblinEnabled : 1;                                 // 0x07AC(0x0004) (Config)
	unsigned long                                      m_bUseFog : 1;                                            // 0x07AC(0x0004) (Config)
	unsigned long                                      m_bUseShiftingFog : 1;                                    // 0x07AC(0x0004) (Config)
	unsigned long                                      m_bUseStats : 1;                                          // 0x07AC(0x0004) (Config)
	unsigned long                                      m_bUseRespawns : 1;                                       // 0x07AC(0x0004) (Config)
	unsigned long                                      m_bInitialCircle : 1;                                     // 0x07AC(0x0004) (Config)
	float                                              m_fGameStateTimer;                                        // 0x07B0(0x0004)
	class ATgDevice*                                   m_pFogDevice;                                             // 0x07B4(0x0008)
	class ATgDevice*                                   m_pChickenLifeDrainDevice;                                // 0x07BC(0x0008)
	TArray<struct FRoyaleStart>                        m_pIslandStartsA;                                         // 0x07C4(0x0010) (NeedCtorLink)
	TArray<struct FRoyaleStart>                        m_pIslandStartsB;                                         // 0x07D4(0x0010) (NeedCtorLink)
	TArray<struct FRoyaleStart>                        m_pIslandStartsC;                                         // 0x07E4(0x0010) (NeedCtorLink)
	TArray<struct FRoyaleStart>                        m_pIslandStartsD;                                         // 0x07F4(0x0010) (NeedCtorLink)
	TArray<struct FRoyaleStart>                        m_pPlayerStarts;                                          // 0x0804(0x0010) (NeedCtorLink)
	TArray<struct FRoyaleStart>                        m_pTeamStarts;                                            // 0x0814(0x0010) (NeedCtorLink)
	TArray<class ATgDropPoint*>                        m_pDropPoints;                                            // 0x0824(0x0010) (NeedCtorLink)
	unsigned char                                      UnknownData01[0x48];                                      // 0x0834(0x0048) UNKNOWN PROPERTY: MapProperty TgGame.TgGame_Royale.m_pTournamentObjectives
	TArray<TEnumAsByte<EObjectiveSize>>                m_pAvailableObjectiveSizes;                               // 0x087C(0x0010) (Native)
	TArray<struct FCloseChestData>                     m_pCloseChests;                                           // 0x088C(0x0010) (NeedCtorLink)
	TArray<struct FTgDeployableFactoryGroupList>       m_AllGroupDeployableFactories;                            // 0x089C(0x0010) (NeedCtorLink)
	TArray<class ATgNamedAreaVolume*>                  m_AllNamedAreaVolumes;                                    // 0x08AC(0x0010) (NeedCtorLink)
	TArray<class ATgInvalidObjectiveVolume*>           m_AllInvalidObjectiveVolumes;                             // 0x08BC(0x0010) (NeedCtorLink)
	class ATgRoyaleConvergeActor*                      m_pConvergeActor;                                         // 0x08CC(0x0008)
	TArray<class ATgForgeObjective*>                   m_pForges;                                                // 0x08D4(0x0010) (NeedCtorLink)
	TArray<class ATgRoyaleObjective*>                  m_AllConvergeObjectives;                                  // 0x08E4(0x0010) (NeedCtorLink)
	TArray<class ATgRoyaleObjective*>                  m_InitialObjectives;                                      // 0x08F4(0x0010) (NeedCtorLink)
	TArray<class ATgRoyaleObjective*>                  m_LegendaryChestDropObjectives;                           // 0x0904(0x0010) (NeedCtorLink)
	TArray<struct FVector>                             m_EpicenterLocations;                                     // 0x0914(0x0010) (NeedCtorLink)
	float                                              m_fGameWaitTime;                                          // 0x0924(0x0004) (Config)
	float                                              m_fGameReadyTime;                                         // 0x0928(0x0004) (Config)
	float                                              m_fGameDeployTime;                                        // 0x092C(0x0004) (Config)
	float                                              m_fGameCompleteTime;                                      // 0x0930(0x0004) (Config)
	float                                              m_fZeppelinMinTime;                                       // 0x0934(0x0004) (Config)
	float                                              m_fZeppelinMaxTime;                                       // 0x0938(0x0004) (Config)
	float                                              m_fInitialFogSpawnTime;                                   // 0x093C(0x0004) (Config)
	float                                              m_fInitialConvergeRadius;                                 // 0x0940(0x0004) (Config)
	TArray<struct FRoyaleRoundInfo>                    m_RoyaleRounds;                                           // 0x0944(0x0010) (Config, NeedCtorLink)
	TArray<struct FTgDeployableFactoryGroupSpawnData>  m_LootSpawnData;                                          // 0x0954(0x0010) (Config, NeedCtorLink)
	float                                              m_fMaxConvergeDistFromOrigin;                             // 0x0964(0x0004) (Config)
	float                                              m_fAutoDeployWaitTime;                                    // 0x0968(0x0004) (Config)
	int                                                m_nChickenReward;                                         // 0x096C(0x0004) (Config)
	float                                              m_fDismountDamage;                                        // 0x0970(0x0004) (Config)
	float                                              m_fChestCloseTime;                                        // 0x0974(0x0004) (Config)
	float                                              m_fAllowedGameTime;                                       // 0x0978(0x0004) (Config)
	float                                              m_fInitArmorPercent;                                      // 0x097C(0x0004) (Config)
	float                                              m_fForgeActivePercent;                                    // 0x0980(0x0004) (Config)
	float                                              m_fDisconnectedPlayerKillTime;                            // 0x0984(0x0004) (Config)
	float                                              m_fLootZeppelinRunningTime;                               // 0x0988(0x0004) (Config)
	float                                              m_fShiftingFogSpeed;                                      // 0x098C(0x0004) (Config)
	float                                              m_fReviveTotalTime;                                       // 0x0990(0x0004) (Config)
	int                                                m_nPlayerLives;                                           // 0x0994(0x0004) (Config)
	int                                                m_fSpawnLootGoblinRunningTime;                            // 0x0998(0x0004) (Config)
	int                                                m_nLootGoblinBotId;                                       // 0x099C(0x0004) (Config)
	int                                                m_nLootGoblinTaskForce;                                   // 0x09A0(0x0004) (Config)
	int                                                m_nLootGoblinSpawnTime;                                   // 0x09A4(0x0004) (Config)
	TArray<class ATgPawn_LootGoblin*>                  m_pSpawnedLootGoblins;                                    // 0x09A8(0x0010) (NeedCtorLink)
	float                                              m_fPlayerStartManaPercent;                                // 0x09B8(0x0004) (Config)
	int                                                m_nFogChanceToEndOnForges;                                // 0x09BC(0x0004) (Config)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_Royale");
		return ptr;
	}


	bool SpawnZeppelin();
	void StartZeppelinTimer();
	void SpawnZeppelinTimer();
	bool STATIC_SpawnGoblin();
	void StartGoblinTimer();
	void STATIC_SpawnGoblinTimer();
	class ATgRoyaleObjective* STATIC_GetNextRoyaleObjective();
	class ANavigationPoint* FindPlayerStart(class AController* Player, unsigned char InTeam, const struct FString& IncomingName);
	void STATIC_OnPawnDied(class ATgPawn* Victim, class AController* Killer);
	void STATIC_AllPlayersEndGame(class AActor* EndGameFocus);
	void STATIC_OnStartGame();
	void STATIC_OnGameStateChanged();
	void STATIC_FromNativeRestartPlayer(class AController* aPlayer);
	void SpawnLootChests();
	void CacheGameObjects();
	void STATIC_GetMapBounds();
	void SetGRIValues();
	void PostBeginPlay();
	void ClearTournamentObjectives();
	void AddTournamentObjective(class ATgTournamentObjective* pTournamentObjective);
	void STATIC_SetPawnRank(class ATgRepInfo_Player* pPRI, int nRank);
	int CalculateRamainingTaskforcesCnt(int nRankOffset);
	void CalculateTaskforceRank(class ATgRepInfo_TaskForce* pTaskForce, int nRankOffset);
	void CalculatePlayers();
	void DeployPlayers(bool bPreselect);
	void CalculateKillstreakModifier(class ATgPawn* pPawn);
	class ANavigationPoint* STATIC_NativeFindPlayerStart(class AController* Player, unsigned char InTeam);
	class ANavigationPoint* FindRegionStart(unsigned char eTeamNum);
	class ANavigationPoint* FindTeamStart(unsigned char eTeamNum);
	bool SwapToNewAIController(class AController* C, class ATgPawn_Character* pPawn);
	float GetRespawnTime(int TaskForceNum);
	void STATIC_RequestDeploy(class ATgRepInfo_Player* pPRI, bool bPreselect);
	void STATIC_NativeOnPawnDied(class ATgPawn* Victim, class AController* Killer);
	bool STATIC_GetScoreKillData(class AController* Killer, class AController* Other, struct FScoreKillData* Data);
	void ScoreKillCommon(struct FScoreKillData* Data);
	void ScoreDownedCommon(struct FScoreKillData* Data);
	void ScoreDowned(class AController* Killer, class AController* Other);
	void UpdateMapBounds(class ATgMapBoundsVolume* pMapBounds);
	bool FindSetup();
	void STATIC_SetupDisconnectMode();
	void STATIC_NativePostBeginPlay();
	void STATIC_MarkAsReady(class UPlayer* P);
};


// Class TgGame.TgGame_RealmWars
// 0x0000 (0x09C0 - 0x09C0)
class ATgGame_RealmWars : public ATgGame_Royale
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_RealmWars");
		return ptr;
	}


	bool STATIC_CanSpectate(class APlayerController* Viewer, class APlayerReplicationInfo* ViewTarget);
	void STATIC_NativeOnPawnDied(class ATgPawn* Victim, class AController* Killer);
	void STATIC_SetupDisconnectMode();
};


// Class TgGame.TgGame_RoyaleEx
// 0x0000 (0x09C0 - 0x09C0)
class ATgGame_RoyaleEx : public ATgGame_Royale
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_RoyaleEx");
		return ptr;
	}

};


// Class TgGame.TgGame_RoyaleFactions
// 0x0000 (0x09C0 - 0x09C0)
class ATgGame_RoyaleFactions : public ATgGame_Royale
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_RoyaleFactions");
		return ptr;
	}

};


// Class TgGame.TgGame_RoyalePVE
// 0x0000 (0x09C0 - 0x09C0)
class ATgGame_RoyalePVE : public ATgGame_Royale
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_RoyalePVE");
		return ptr;
	}


	bool STATIC_HasCaptureObjectives();
};


// Class TgGame.TgGame_RoyaleScrimmage
// 0x004C (0x0A0C - 0x09C0)
class ATgGame_RoyaleScrimmage : public ATgGame_Royale
{
public:
	unsigned long                                      m_bFoundSetup : 1;                                        // 0x09C0(0x0004)
	unsigned char                                      UnknownData00[0x48];                                      // 0x09C4(0x0048) UNKNOWN PROPERTY: MapProperty TgGame.TgGame_RoyaleScrimmage.m_TeamColorMap

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_RoyaleScrimmage");
		return ptr;
	}


	void SetGRIValues();
	void ScoreKillCommon(struct FScoreKillData* Data);
	bool FindSetup();
	void STATIC_NativePostBeginPlay();
};


// Class TgGame.TgGame_RoyaleStorm
// 0x0028 (0x09E8 - 0x09C0)
class ATgGame_RoyaleStorm : public ATgGame_Royale
{
public:
	int                                                m_nTickets;                                               // 0x09C0(0x0004) (Config)
	float                                              m_fCanyonOriginSpawnOffset;                               // 0x09C4(0x0004) (Config)
	float                                              m_fCanyonHalfWidth;                                       // 0x09C8(0x0004) (Config)
	float                                              m_fZepplinSpawnRadius;                                    // 0x09CC(0x0004) (Config)
	class ATgRoyaleConvergeActor*                      m_pConvergeActor2;                                        // 0x09D0(0x0008)
	class ATgRoyaleConvergeActor*                      m_pCanyonEdge1;                                           // 0x09D8(0x0008)
	class ATgRoyaleConvergeActor*                      m_pCanyonEdge2;                                           // 0x09E0(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_RoyaleStorm");
		return ptr;
	}


	class ANavigationPoint* STATIC_NativeFindPlayerStart(class AController* Player, unsigned char InTeam);
	float GetRespawnTime(int TaskForceNum);
	void STATIC_NativeOnPawnDied(class ATgPawn* Victim, class AController* Killer);
	bool FindSetup();
};


// Class TgGame.TgGame_RoyaleTournament
// 0x0030 (0x09F0 - 0x09C0)
class ATgGame_RoyaleTournament : public ATgGame_Royale
{
public:
	TArray<struct FTournamentRound>                    m_pBracketRounds;                                         // 0x09C0(0x0010) (AlwaysInit, NeedCtorLink)
	int                                                m_nTotalRounds;                                           // 0x09D0(0x0004)
	int                                                m_nCurrentRound;                                          // 0x09D4(0x0004)
	TEnumAsByte<EObjectiveSize>                        m_eCurrentRoundSize;                                      // 0x09D8(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x09D9(0x0003) MISSED OFFSET
	TArray<class ATgRepInfo_TaskForce*>                m_pRemainingTeams;                                        // 0x09DC(0x0010) (AlwaysInit, NeedCtorLink)
	int                                                m_nBetweenRoundWait;                                      // 0x09EC(0x0004) (Config)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_RoyaleTournament");
		return ptr;
	}


	void CleanUpBracket(bool bRemoveFogs);
	void TransitionToNextRound();
	void STATIC_ResetFogActors(int nRound);
	void DeployPlayers(bool bPreselect);
	void STATIC_NativeOnPawnDied(class ATgPawn* Victim, class AController* Killer);
	void STATIC_NativePostBeginPlay();
	void CheckForRoundEnd();
	void CacheRemainingTeams();
	void STATIC_PrepareNewRound();
};


// Class TgGame.TgGame_RoyaleTutorial
// 0x0044 (0x07DC - 0x0798)
class ATgGame_RoyaleTutorial : public ATgGame_RoyaleBase
{
public:
	struct FVector                                     c_vZeppelinSpawnLoc;                                      // 0x0798(0x000C) (Config)
	float                                              c_fZeppelinSpawnRot;                                      // 0x07A4(0x0004) (Config)
	float                                              c_fAutoDeployTime;                                        // 0x07A8(0x0004) (Config)
	unsigned long                                      m_bDisenchantEnabled : 1;                                 // 0x07AC(0x0004)
	unsigned long                                      m_bMountEnabled : 1;                                      // 0x07AC(0x0004)
	unsigned long                                      m_bDisplayPrompt : 1;                                     // 0x07AC(0x0004)
	unsigned long                                      m_bClearObjGroup : 1;                                     // 0x07AC(0x0004)
	unsigned long                                      m_bShowTooltip : 1;                                       // 0x07AC(0x0004)
	unsigned long                                      m_bTooltipLeftPosition : 1;                               // 0x07AC(0x0004)
	unsigned long                                      m_bTutorialCompleted : 1;                                 // 0x07AC(0x0004)
	struct FString                                     m_sPromptCommand;                                         // 0x07B0(0x0010) (NeedCtorLink)
	int                                                m_nPromptMessageId;                                       // 0x07C0(0x0004)
	int                                                m_nCurrentObjMessageId;                                   // 0x07C4(0x0004)
	int                                                m_nTooltipMessageId;                                      // 0x07C8(0x0004)
	TArray<class ATgForgeObjective*>                   m_pForgeObjectives;                                       // 0x07CC(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_RoyaleTutorial");
		return ptr;
	}


	class ANavigationPoint* FindPlayerStart(class AController* Player, unsigned char InTeam, const struct FString& IncomingName);
	void STATIC_OnPawnDied(class ATgPawn* Victim, class AController* Killer);
	void STATIC_FromNativeRestartPlayer(class AController* aPlayer);
	void STATIC_GetMapBounds();
	void SetGRIValues();
	void PostBeginPlay();
	void EndTutorial();
	void DeployPlayers(bool bPreselect);
	void UpdateMapBounds(class ATgMapBoundsVolume* pMapBounds);
	void STATIC_NativePostBeginPlay();
};


// Class TgGame.TgGameTipManager
// 0x0054 (0x02D4 - 0x0280)
class ATgGameTipManager : public AActor
{
public:
	TArray<struct FTipSavedState>                      m_TipSavedState;                                          // 0x0280(0x0010) (Config, GlobalConfig, NeedCtorLink)
	TArray<struct FGameTipInfo>                        m_GameTipQueue;                                           // 0x0290(0x0010) (NeedCtorLink)
	TArray<struct FGameTipInfo>                        m_GameTipWorldQueue;                                      // 0x02A0(0x0010) (NeedCtorLink)
	TArray<struct FGameTipInfo>                        m_GameTipSpecialQueue;                                    // 0x02B0(0x0010) (NeedCtorLink)
	unsigned long                                      m_bIsActive : 1;                                          // 0x02C0(0x0004)
	class UTgAudioComponent*                           m_AudioComponent;                                         // 0x02C4(0x0008) (ExportObject, Component, EditInline)
	int                                                m_nActiveTip;                                             // 0x02CC(0x0004)
	int                                                m_nPlaySoundTip;                                          // 0x02D0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGameTipManager");
		return ptr;
	}


	int GameTipQueueSort(const struct FGameTipInfo& A, const struct FGameTipInfo& B);
	void PostBeginPlay();
	void SortGameTipQueue(int nGameTipType);
	void ClearSavedDataForNewRound();
	void STATIC_SetActive();
	void UnsuppressAllGameTips();
	void CompleteHelpText(int nGameTipId);
	void SuppressHelpText(int nGameTipId);
	void RemoveHelpText(int nGameTipId, bool bDoNotSuppress);
	void DismissHelpText(int nGameTipId, bool bDoNotSuppress);
	bool RequestHelpText(int nGameTipId, bool bIsFriend, bool bWaitForDismiss, const struct FVector& SpawnLocation, class ATgHelpTipActor** OutHelpTipActor);
	bool STATIC_IsSuppressed(int nGameTipId);
};


// Class TgGame.TgHelpTipActor
// 0x0030 (0x02B0 - 0x0280)
class ATgHelpTipActor : public AActor
{
public:
	struct FString                                     m_strTitle;                                               // 0x0280(0x0010) (NeedCtorLink)
	struct FString                                     m_strTip;                                                 // 0x0290(0x0010) (NeedCtorLink)
	int                                                m_nGameTipId;                                             // 0x02A0(0x0004)
	float                                              m_fAlpha;                                                 // 0x02A4(0x0004) (Transient)
	float                                              m_fAlphaNearDistanceSq;                                   // 0x02A8(0x0004)
	float                                              m_fAlphaFarDistanceSq;                                    // 0x02AC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgHelpTipActor");
		return ptr;
	}


	void Remove(bool bSuppress);
};


// Class TgGame.TgMinimapManager
// 0x006C (0x00CC - 0x0060)
class UTgMinimapManager : public UObject
{
public:
	TEnumAsByte<ETgMapTeam>                            m_LocalTeam;                                              // 0x0060(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0061(0x0003) MISSED OFFSET
	unsigned char                                      UnknownData01[0x48];                                      // 0x0061(0x0048) UNKNOWN PROPERTY: MapProperty TgGame.TgMinimapManager.m_EntityMap
	unsigned long                                      m_bShouldDisableVisionRange : 1;                          // 0x00AC(0x0004)
	unsigned long                                      m_bSkipWorldGeometryLOS : 1;                              // 0x00AC(0x0004)
	unsigned long                                      m_bRequiresVisionUpdate : 1;                              // 0x00AC(0x0004)
	float                                              m_fFogOfWarAreaRevealTime;                                // 0x00B0(0x0004)
	float                                              m_fUpdateTimer;                                           // 0x00B4(0x0004)
	float                                              m_fLastEntityUpdateTime;                                  // 0x00B8(0x0004)
	TArray<class AReplicationInfo*>                    m_ReferencedRepInfos;                                     // 0x00BC(0x0010) (AlwaysInit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgMinimapManager");
		return ptr;
	}


	void STATIC_InitForTaskforce(class ATgRepInfo_TaskForce* tf);
	void ForceUpdate(class AReplicationInfo* ri);
	void RemoveAllEntities();
	void UpdateThreaded();
	void STATIC_Update(bool bForce);
};


// Class TgGame.TgObjective
// 0x0030 (0x02B0 - 0x0280)
class ATgObjective : public AActor
{
public:
	int                                                r_nControllingTaskForceIndex;                             // 0x0280(0x0004) (Net)
	int                                                r_nControllingTaskForceCount;                             // 0x0284(0x0004) (Net)
	TEnumAsByte<EObjectiveStatus>                      r_eStatus;                                                // 0x0288(0x0001) (Net)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0289(0x0003) MISSED OFFSET
	class UTgSpecialFx*                                m_InWordIndicatorFX;                                      // 0x028C(0x0008)
	class UTgSpecialFx*                                m_ForegroundIndicatorFX;                                  // 0x0294(0x0008)
	int                                                m_nActiveAlertId;                                         // 0x029C(0x0004) (Edit)
	int                                                m_nPendingActiveAlertId;                                  // 0x02A0(0x0004) (Edit)
	int                                                m_nInactiveAlertId;                                       // 0x02A4(0x0004) (Edit)
	int                                                m_nWaypointMessageOverride;                               // 0x02A8(0x0004) (Edit)
	unsigned long                                      m_bTriggerEventsOnClientAsWell : 1;                       // 0x02AC(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgObjective");
		return ptr;
	}


	void STATIC_OnControllingStatusChanged();
	void STATIC_OnSetStatus();
	void SetStatus(TEnumAsByte<EObjectiveStatus> NewStatus);
	void STATIC_ReplicatedEvent(const struct FName& VarName);
};


// Class TgGame.TgForgeObjective
// 0x00F4 (0x03A4 - 0x02B0)
class ATgForgeObjective : public ATgObjective
{
public:
	TArray<struct FForgeUse>                           m_Used;                                                   // 0x02B0(0x0010) (NeedCtorLink)
	TArray<struct FForgeUse>                           m_Upgraded;                                               // 0x02C0(0x0010) (NeedCtorLink)
	struct ATgForgeObjective_FForgeItem                r_Items[0x8];                                             // 0x02D0(0x000C) (Net, Config)
	struct ATgForgeObjective_FForgeItem                r_Upgrades[0x8];                                          // 0x0330(0x000C) (Net, Config)
	int                                                r_nUpgrades;                                              // 0x0390(0x0004) (Net)
	int                                                r_nOwningTeam;                                            // 0x0394(0x0004) (Net)
	int                                                s_nPlayerCountA;                                          // 0x0398(0x0004)
	int                                                s_nPlayerCountB;                                          // 0x039C(0x0004)
	unsigned long                                      s_bAllowCapture : 1;                                      // 0x03A0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgForgeObjective");
		return ptr;
	}


	void STATIC_UpdateOwningTeam(int nTeam, int nCount);
	void UnTouch(class AActor* Other);
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void PostBeginPlay();
	bool STATIC_StartUpgradeItem(class ATgRepInfo_Player* pPRI, int nIndex, int nState, int nDurationOverride);
	bool StartForgeItem(class ATgRepInfo_Player* pPRI, int nIndex, int nState, int nDurationOverride);
	void AddUse(class ATgRepInfo_Player* pPRI, int nIndex, int nState);
	void STATIC_NativePostBeginPlay();
	void ForgeComplete();
};


// Class TgGame.TgForgeObjective_Tournament
// 0x0004 (0x03A8 - 0x03A4)
class ATgForgeObjective_Tournament : public ATgForgeObjective
{
public:
	unsigned long                                      m_bIsUsable : 1;                                          // 0x03A4(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgForgeObjective_Tournament");
		return ptr;
	}


	void UnTouch(class AActor* Other);
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_SetUsable(bool bUsable);
};


// Class TgGame.TgRealmCapturePoint
// 0x0050 (0x0300 - 0x02B0)
class ATgRealmCapturePoint : public ATgObjective
{
public:
	int                                                r_nUniqueCapturePointId;                                  // 0x02B0(0x0004) (Net)
	class UTgAnimNodeSlot*                             m_CustomAnimNode;                                         // 0x02B4(0x0008) (Transient)
	int                                                c_MICStatus;                                              // 0x02BC(0x0004)
	class ATgHelpTipActor*                             m_HelpTip;                                                // 0x02C0(0x0008)
	TArray<class ATgStaticMeshActor_CapturePoint*>     CapturePointMeshActors;                                   // 0x02C8(0x0010) (Edit, NeedCtorLink)
	TArray<class AVolume*>                             m_Volumes;                                                // 0x02D8(0x0010) (Edit, NeedCtorLink)
	float                                              m_fContestDuration;                                       // 0x02E8(0x0004) (Edit)
	float                                              m_fContestTimer;                                          // 0x02EC(0x0004)
	TArray<class ATgPawn_Character*>                   m_TouchingChampions;                                      // 0x02F0(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgRealmCapturePoint");
		return ptr;
	}


	void Destroyed();
	int STATIC_GetControllingPlayerCount();
	void UnTouch(class AActor* Other);
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void SpawnHelpTip();
	void ShowPathfinder(bool bEnabled);
	void STATIC_OnSetStatus();
	void Tick(float DeltaTime);
	void PostBeginPlay();
	void PreBeginPlay();
	void STATIC_ReplicatedEvent(const struct FName& VarName);
	bool STATIC_IsContested();
	int STATIC_GetNumOnPoint(int nTaskForce);
	bool CanAddPawnCaptureList(class ATgPawn_Character* pPawn);
	bool CanPawnCapture(class ATgPawn_Character* pPawn);
};


// Class TgGame.TgRepInfo_CapturePoint
// 0x0024 (0x02A4 - 0x0280)
class ATgRepInfo_CapturePoint : public AReplicationInfo
{
public:
	class ATgCapturePoint*                             r_OwningCapturePoint;                                     // 0x0280(0x0008) (Net)
	int                                                r_nUniqueCapturePointId;                                  // 0x0288(0x0004) (Net)
	int                                                r_nControlledByTaskForce;                                 // 0x028C(0x0004) (Net)
	float                                              r_fOwnershipPct;                                          // 0x0290(0x0004) (Net)
	unsigned char                                      r_nTransitionDirection;                                   // 0x0294(0x0001) (Net)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0295(0x0003) MISSED OFFSET
	unsigned long                                      r_bIsLocked : 1;                                          // 0x0298(0x0004) (Net)
	class UTgSeqEvent_ControlPointOwnershipPercent*    c_OwnershipPercentKismetNode;                             // 0x029C(0x0008) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgRepInfo_CapturePoint");
		return ptr;
	}


	int STATIC_GetCapturePointIndex();
	void STATIC_OnOwnershipPctChanged();
	void STATIC_OnTaskForceControlChanged();
	void PostBeginPlay();
	void STATIC_ReplicatedEvent(const struct FName& VarName);
	struct FVector STATIC_GetCurrentLocation();
};


// Class TgGame.TgRepInfo_Deployable
// 0x0060 (0x02E0 - 0x0280)
class ATgRepInfo_Deployable : public AReplicationInfo
{
public:
	int                                                r_nHealthCurrent;                                         // 0x0280(0x0004) (Net)
	int                                                r_nHealthMaximum;                                         // 0x0284(0x0004) (Net)
	float                                              r_fDeployMaxHealthPCT;                                    // 0x0288(0x0004) (Net)
	int                                                r_nDeployableId;                                          // 0x028C(0x0004) (Net)
	int                                                r_nUniqueDeployableId;                                    // 0x0290(0x0004) (Net)
	float                                              r_fLifespanInitial;                                       // 0x0294(0x0004) (Net)
	float                                              r_fLifespanSync;                                          // 0x0298(0x0004) (Net)
	class ATgDeployable*                               r_DeployableOwner;                                        // 0x029C(0x0008) (Net)
	class ATgRepInfo_Player*                           r_InstigatorInfo;                                         // 0x02A4(0x0008) (Net)
	class ATgRepInfo_TaskForce*                        r_TaskforceInfo;                                          // 0x02AC(0x0008) (Net)
	unsigned long                                      r_bOwnedByTaskforce : 1;                                  // 0x02B4(0x0004) (Net)
	unsigned long                                      c_bReceivedOwner : 1;                                     // 0x02B4(0x0004)
	unsigned long                                      r_bMinimapOnlyOwnerSee : 1;                               // 0x02B4(0x0004) (Net)
	unsigned long                                      r_bInDestroyedState : 1;                                  // 0x02B4(0x0004) (Net)
	unsigned long                                      c_bShowHUDLifespanTimer : 1;                              // 0x02B4(0x0004)
	struct FVector                                     r_ApproxLocation;                                         // 0x02B8(0x000C) (Net)
	struct FTG_HUD_INFO                                c_HudInfo;                                                // 0x02C4(0x0004)
	unsigned char                                      r_bVisibleOnMap[0x3];                                     // 0x02C8(0x0001) (Net)
	TEnumAsByte<EDeployableOverlayIcon>                r_eDeployableOverlayIcon;                                 // 0x02CB(0x0001) (Net)
	TEnumAsByte<EDeployableOverlayState>               r_eDeployableOverlayState;                                // 0x02CC(0x0001) (Net)
	unsigned char                                      UnknownData00[0x3];                                       // 0x02CD(0x0003) MISSED OFFSET
	float                                              r_fVisionRange;                                           // 0x02D0(0x0004) (Net)
	int                                                r_nDeployableOverlayDisplayMask;                          // 0x02D4(0x0004) (Net)
	float                                              r_fDeployableOverlayEnemyViewDist;                        // 0x02D8(0x0004) (Net)
	float                                              c_fBarragePercent;                                        // 0x02DC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgRepInfo_Deployable");
		return ptr;
	}


	void SetHUDOverlayEnemyViewDist(float enemyViewDist);
	void SetHUDOverlayState(TEnumAsByte<EDeployableOverlayState> dos);
	void SetHUDOverlayIcon(TEnumAsByte<EDeployableOverlayIcon> doi);
	void SetHUDOverlayDisplayMask(int dodm);
	void STATIC_LifespanTimer();
	void UpdateLifespanTimer();
	void SyncLifespanTimer();
	void StartLifespanTimer(float fTime);
	void UpdateDeployableLocation();
	void ReceivedDeployableOwner();
	void STATIC_ReplicatedEvent(const struct FName& VarName);
	void Destroyed();
	void PostBeginPlay();
	void CheckNotifyGroupChanged();
	bool STATIC_IsVisibleToLocalPlayer();
	bool STATIC_IsVisibleToPlayer(class ATgRepInfo_Player* PRI);
	bool STATIC_IsVisibleToMapTeam(TEnumAsByte<ETgMapTeam> MAPTEAM);
	bool STATIC_IsVisibleToAnEnemyTeam();
	void UpdateMapVisibility(TEnumAsByte<ETgMapTeam> MAPTEAM, unsigned char bVisible, float fVisionRange, bool bDetected);
	float GetMaxLifespan();
	float STATIC_GetLifespan();
	int STATIC_GetCurrentMaxHealth();
	int STATIC_GetCurrentHealth();
	struct FVector STATIC_GetCurrentLocation();
	void SetTaskForce(class ATgRepInfo_TaskForce* tf);
	class ATgRepInfo_TaskForce* STATIC_GetTaskForce();
};


// Class TgGame.TgRepInfo_Portal
// 0x000C (0x02EC - 0x02E0)
class ATgRepInfo_Portal : public ATgRepInfo_Deployable
{
public:
	class ATgRepInfo_Portal*                           r_TwinDRI;                                                // 0x02E0(0x0008) (Net)
	unsigned long                                      c_bMasterEntity : 1;                                      // 0x02E8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgRepInfo_Portal");
		return ptr;
	}

};


// Class TgGame.TgRepInfo_Factory
// 0x0030 (0x02B0 - 0x0280)
class ATgRepInfo_Factory : public AReplicationInfo
{
public:
	TEnumAsByte<EReplicatedFactoryState>               s_FactoryState;                                           // 0x0280(0x0001)
	TEnumAsByte<EReplicatedFactoryState>               r_FactoryState[0x3];                                      // 0x0281(0x0001) (Net)
	unsigned char                                      r_bVisibleOnMap[0x3];                                     // 0x0284(0x0001) (Net)
	unsigned char                                      r_bRespawnVisible[0x3];                                   // 0x0287(0x0001) (Net)
	TEnumAsByte<EMinimapFactoryType>                   r_MinimapType;                                            // 0x028A(0x0001) (Net)
	unsigned char                                      UnknownData00[0x1];                                       // 0x028B(0x0001) MISSED OFFSET
	class ATgActorFactory*                             r_FactoryOwner;                                           // 0x028C(0x0008) (Net)
	class ATgRepInfo_TaskForce*                        r_TaskforceInfo;                                          // 0x0294(0x0008) (Net)
	int                                                r_nFactoryId;                                             // 0x029C(0x0004) (Net)
	class AReplicationInfo*                            r_LastSpawnedRepInfo;                                     // 0x02A0(0x0008) (Net)
	float                                              r_fRespawnDelay;                                          // 0x02A8(0x0004) (Net)
	float                                              r_fRespawnTimer;                                          // 0x02AC(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgRepInfo_Factory");
		return ptr;
	}


	void StopRespawnTimer();
	void UpdateRespawnTimer();
	void StartRespawnTimer(float fSeconds);
	void UpdateInWorldIndicators();
	void Destroyed();
	void STATIC_ReplicatedEvent(const struct FName& VarName);
	void PostBeginPlay();
	void STATIC_InitFor(class ATgActorFactory* Factory);
	float STATIC_GetRespawnElapsedPercent();
	bool STATIC_IsVisibleToLocalPlayer();
	void UpdateMapVisibility(TEnumAsByte<ETgMapTeam> MAPTEAM, unsigned char bVisible, float fVisionRange, bool bDetected);
};


// Class TgGame.TgRepInfo_Game
// 0x045C (0x0744 - 0x02E8)
class ATgRepInfo_Game : public AGameReplicationInfo
{
public:
	TArray<struct FGraphData>                          m_GraphData;                                              // 0x02E8(0x0010) (NeedCtorLink)
	struct FGraphData                                  r_LastDataPoint;                                          // 0x02F8(0x000C)
	float                                              m_GraphUpdateWaitTime;                                    // 0x0304(0x0004)
	TEnumAsByte<ETG_GAME_TYPE>                         r_GameType;                                               // 0x0308(0x0001) (Net)
	TEnumAsByte<EHUDType>                              r_eHUDType;                                               // 0x0309(0x0001) (Net)
	TEnumAsByte<EINITIALIZEABLE_BOOL>                  r_eTalentsEnabled;                                        // 0x030A(0x0001) (Net)
	TEnumAsByte<EMissionTimerState>                    r_nMissionTimerState;                                     // 0x030B(0x0001) (Net)
	TEnumAsByte<EGameTimerState>                       r_eGameTimerState;                                        // 0x030C(0x0001) (Net)
	TEnumAsByte<EMissionTimerState>                    r_nRoundLimitTimerState;                                  // 0x030D(0x0001) (Net)
	TEnumAsByte<EMissionTimerState>                    r_nSecondaryTimerState;                                   // 0x030E(0x0001) (Net)
	unsigned char                                      r_nLastRoundAttacker;                                     // 0x030F(0x0001) (Net)
	unsigned char                                      r_nLastRoundWinner;                                       // 0x0310(0x0001) (Net)
	TEnumAsByte<EFlagState>                            r_FlagState[0x2];                                         // 0x0311(0x0001) (Net)
	TEnumAsByte<EGameEnvironmentRule>                  r_GameEnvironmentRule;                                    // 0x0313(0x0001) (Net)
	TEnumAsByte<EGameRespawnRule>                      r_GameRespawnRule;                                        // 0x0314(0x0001) (Net)
	TEnumAsByte<EGameMode>                             r_GameMode;                                               // 0x0315(0x0001) (Net)
	unsigned char                                      UnknownData00[0x2];                                       // 0x0316(0x0002) MISSED OFFSET
	unsigned long                                      r_bIsMission : 1;                                         // 0x0318(0x0004) (Net)
	unsigned long                                      r_bGameHasSetup : 1;                                      // 0x0318(0x0004) (Net)
	unsigned long                                      r_bGameAllowsAchievements : 1;                            // 0x0318(0x0004) (Net)
	unsigned long                                      r_bAllowSpawnGuardDuringDeviceFire : 1;                   // 0x0318(0x0004) (Net)
	unsigned long                                      r_bBlockCreditGain : 1;                                   // 0x0318(0x0004) (Net)
	unsigned long                                      r_bBlockEnergyGain : 1;                                   // 0x0318(0x0004) (Net)
	unsigned long                                      r_bDisablePlayerMovement : 1;                             // 0x0318(0x0004) (Net)
	unsigned long                                      r_bOvertime : 1;                                          // 0x0318(0x0004) (Net)
	unsigned long                                      r_bCapturePointOvertime : 1;                              // 0x0318(0x0004) (Net)
	unsigned long                                      r_bLimitBurnCardsToOnePerCategory : 1;                    // 0x0318(0x0004) (Net)
	unsigned long                                      r_bRoundEnding : 1;                                       // 0x0318(0x0004) (Net)
	unsigned long                                      r_bFadeOutAtRoundEnd : 1;                                 // 0x0318(0x0004) (Net)
	unsigned long                                      r_bIntroPlayed : 1;                                       // 0x0318(0x0004) (Net)
	unsigned long                                      r_bUsePointsMode : 1;                                     // 0x0318(0x0004) (Net)
	unsigned long                                      r_bUltimatesLocked : 1;                                   // 0x0318(0x0004) (Net)
	unsigned long                                      r_bSuddenDeath : 1;                                       // 0x0318(0x0004) (Net)
	unsigned long                                      r_bEnableDistanceFOW : 1;                                 // 0x0318(0x0004) (Net)
	unsigned long                                      r_bSpawnGatesOpen : 1;                                    // 0x0318(0x0004) (Net)
	unsigned long                                      r_bAttackersSpawnGatesOpen : 1;                           // 0x0318(0x0004) (Net)
	unsigned long                                      r_bDefendersSpawnGatesOpen : 1;                           // 0x0318(0x0004) (Net)
	unsigned long                                      r_bForwardProgress : 1;                                   // 0x0318(0x0004) (Net)
	unsigned long                                      r_bServerFlagSprint : 1;                                  // 0x0318(0x0004) (Net)
	unsigned long                                      r_bServerFlagMinimapTeamVisibility : 1;                   // 0x0318(0x0004) (Net)
	unsigned long                                      r_bForce3P : 1;                                           // 0x0318(0x0004) (Net)
	unsigned long                                      r_bForce1P : 1;                                           // 0x0318(0x0004) (Net)
	unsigned long                                      r_bForceOutOfCombatSprint : 1;                            // 0x0318(0x0004) (Net)
	unsigned long                                      r_bAutoMelee : 1;                                         // 0x0318(0x0004) (Net)
	unsigned long                                      r_bShowProjectileProximityDistance : 1;                   // 0x0318(0x0004) (Net)
	unsigned long                                      r_bDisableProjectileProximityDistance : 1;                // 0x0318(0x0004) (Net)
	unsigned long                                      r_bShowHeadMesh : 1;                                      // 0x0318(0x0004) (Net)
	unsigned long                                      r_bUseInstantFireMeshTrace : 1;                           // 0x0318(0x0004) (Net, Config)
	unsigned long                                      r_bAllowWeaponLagPrediction : 1;                          // 0x0318(0x0004) (Net, Config)
	unsigned long                                      r_bSiegeEngineRequiresAlliesToMove : 1;                   // 0x031C(0x0004) (Net)
	unsigned long                                      r_bSiegeEngineMovementPaused : 1;                         // 0x031C(0x0004) (Net)
	unsigned long                                      r_bSiegeEngineMovementPausedAfterDamagingGate : 1;        // 0x031C(0x0004) (Net)
	unsigned long                                      r_bFogConverging : 1;                                     // 0x031C(0x0004) (Net)
	unsigned long                                      r_bFogEnded : 1;                                          // 0x031C(0x0004) (Net)
	unsigned long                                      r_bCheckpoint1Reached : 1;                                // 0x031C(0x0004) (Net)
	unsigned long                                      r_bCheckpoint2Reached : 1;                                // 0x031C(0x0004) (Net)
	unsigned long                                      r_bEnableHeadshots : 1;                                   // 0x031C(0x0004) (Net)
	unsigned long                                      r_bAllowPlayerMounting : 1;                               // 0x031C(0x0004) (Net)
	unsigned long                                      r_bKillCamEnabled : 1;                                    // 0x031C(0x0004) (Net)
	unsigned long                                      r_bAttackersKillCamEnabled : 1;                           // 0x031C(0x0004) (Net)
	unsigned long                                      r_bDefendersKillCamEnabled : 1;                           // 0x031C(0x0004) (Net)
	unsigned long                                      r_bBlockKillCam : 1;                                      // 0x031C(0x0004) (Net)
	unsigned long                                      r_bIsFirstRound : 1;                                      // 0x031C(0x0004) (Net)
	unsigned long                                      r_bSpawnGatesOpenedAtLeastOnce : 1;                       // 0x031C(0x0004) (Net)
	unsigned long                                      r_bDeploying : 1;                                         // 0x031C(0x0004) (Net)
	unsigned long                                      r_bUseRespawns : 1;                                       // 0x031C(0x0004) (Net)
	unsigned long                                      m_bNameplatesRequireLOS : 1;                              // 0x031C(0x0004)
	unsigned long                                      m_bTeamVGS : 1;                                           // 0x031C(0x0004)
	unsigned long                                      r_bAlliances : 1;                                         // 0x031C(0x0004) (Net)
	float                                              r_fMissionRemainingTime;                                  // 0x0320(0x0004) (Net)
	int                                                r_nMissionTimerStateChange;                               // 0x0324(0x0004) (Net)
	float                                              r_fMissionTime;                                           // 0x0328(0x0004) (Net)
	float                                              c_fMissionTime;                                           // 0x032C(0x0004)
	float                                              c_fMissionTimeSeconds;                                    // 0x0330(0x0004)
	float                                              c_fAIBotDelaySeconds;                                     // 0x0334(0x0004)
	float                                              r_fRoundLimitElapsed;                                     // 0x0338(0x0004) (Net)
	float                                              r_fRoundLimitDuration;                                    // 0x033C(0x0004) (Net)
	float                                              r_fSecondaryRemainingTime;                                // 0x0340(0x0004) (Net)
	int                                                r_nSecondaryTimerStateChange;                             // 0x0344(0x0004) (Net)
	float                                              r_fSecondaryTime;                                         // 0x0348(0x0004) (Net)
	float                                              c_fSecondaryMissionTime;                                  // 0x034C(0x0004)
	float                                              c_fSecondaryMissionTimeSeconds;                           // 0x0350(0x0004)
	float                                              r_fCapturePointOvertimeStartDuration;                     // 0x0354(0x0004) (Net)
	int                                                r_nCapturePointOvertimeStateChange;                       // 0x0358(0x0004) (Net)
	float                                              r_fPayloadOvertimeStartDuration;                          // 0x035C(0x0004) (Net)
	int                                                r_nPayloadOvertimeStateChange;                            // 0x0360(0x0004) (Net)
	float                                              r_fTF1PayloadPushDistance;                                // 0x0364(0x0004) (Net)
	int                                                r_nPurchaseTime;                                          // 0x0368(0x0004) (Net)
	float                                              m_fPurchaseTimer;                                         // 0x036C(0x0004)
	int                                                r_nGlobalItemPurchaseOverride;                            // 0x0370(0x0004) (Net)
	int                                                r_nGlobalLoadoutChangeOverride;                           // 0x0374(0x0004) (Net)
	class ATgRepInfo_TaskForce*                        r_AttackingTaskForce;                                     // 0x0378(0x0008) (Net)
	class ATgRepInfo_TaskForce*                        r_CapturingTaskForce;                                     // 0x0380(0x0008) (Net)
	int                                                r_nChaosRemainingAttackDefendTime;                        // 0x0388(0x0004) (Net)
	class ATgRepInfo_TaskForce*                        r_Winner;                                                 // 0x038C(0x0008) (Net)
	float                                              r_fPhysicsThreshold;                                      // 0x0394(0x0004) (Net)
	struct FString                                     r_sQueueName;                                             // 0x0398(0x0010) (Net, NeedCtorLink)
	int                                                r_nPlayOfTheGamePawnId;                                   // 0x03A8(0x0004) (Net)
	int                                                r_nPlayOfTheGameMapLane;                                  // 0x03AC(0x0004) (Net)
	float                                              r_fPlayOfTheGameTimeStamp;                                // 0x03B0(0x0004) (Net)
	class ATgPlayOfTheGameCamera*                      c_PlayOfTheGameCamera;                                    // 0x03B4(0x0008)
	TArray<class ATgDeployable*>                       m_Deployables;                                            // 0x03BC(0x0010) (Transient, AlwaysInit, NeedCtorLink)
	TArray<class ATgProjectile*>                       m_Projectiles;                                            // 0x03CC(0x0010) (Transient, AlwaysInit, NeedCtorLink)
	TArray<class ATgDestructible*>                     m_Destructibles;                                          // 0x03DC(0x0010) (Transient, AlwaysInit, NeedCtorLink)
	TArray<class ATgRepInfo_Deployable*>               m_DRIArray;                                               // 0x03EC(0x0010) (Transient, AlwaysInit, NeedCtorLink)
	TArray<class ATgRepInfo_CapturePoint*>             m_CPRIArray;                                              // 0x03FC(0x0010) (Transient, AlwaysInit, NeedCtorLink)
	TArray<class ATgRealmCapturePoint*>                m_CapturePoints;                                          // 0x040C(0x0010) (Transient, AlwaysInit, NeedCtorLink)
	TArray<class ATgDeployable*>                       m_MovableProjBlockers;                                    // 0x041C(0x0010) (Transient, AlwaysInit, NeedCtorLink)
	int                                                r_nCurrentCheckpoint[0x2];                                // 0x042C(0x0004) (Net, Transient)
	int                                                c_nNextClientOnlyProjectileInstanceId;                    // 0x0434(0x0004) (Transient)
	class ATgPawn*                                     r_SquadTarget1;                                           // 0x0438(0x0008)
	class ATgPawn*                                     r_SquadTarget2;                                           // 0x0440(0x0008)
	float                                              r_fLastSquadTargetUpdate1;                                // 0x0448(0x0004)
	float                                              r_fLastSquadTargetUpdate2;                                // 0x044C(0x0004)
	float                                              r_fSpeedScale;                                            // 0x0450(0x0004) (Net)
	float                                              r_fPayloadProgressPercent;                                // 0x0454(0x0004) (Net)
	float                                              r_fCheckpoint1Percent;                                    // 0x0458(0x0004) (Net)
	float                                              r_fCheckpoint2Percent;                                    // 0x045C(0x0004) (Net)
	float                                              r_fServerFlagDamageMultiplier;                            // 0x0460(0x0004)
	float                                              r_fServerFlagGroundSpeedModifier;                         // 0x0464(0x0004)
	float                                              r_fServerFlagAutoHealingMultiplier;                       // 0x0468(0x0004)
	float                                              r_fFogDensity;                                            // 0x046C(0x0004) (Net)
	float                                              r_fFogStartDistance;                                      // 0x0470(0x0004) (Net)
	float                                              r_fFogObscureDistance;                                    // 0x0474(0x0004) (Net)
	class AExponentialHeightFog*                       c_Fog;                                                    // 0x0478(0x0008)
	int                                                r_nPersistentTextID;                                      // 0x0480(0x0004) (Net)
	int                                                r_nRemainingObjectiveTime;                                // 0x0484(0x0004) (Net)
	int                                                r_nTotalObjectiveTime;                                    // 0x0488(0x0004) (Net)
	float                                              r_fPlayerViewDistance;                                    // 0x048C(0x0004) (Net)
	float                                              r_fVisibilityVolumeViewDistance;                          // 0x0490(0x0004)
	float                                              r_fPushTimer;                                             // 0x0494(0x0004)
	float                                              r_fWeaponMaxLagCompensation;                              // 0x0498(0x0004) (Net)
	float                                              m_fVaultImmuneToSiegeEngineHealth;                        // 0x049C(0x0004)
	float                                              r_fConvergeDistance;                                      // 0x04A0(0x0004) (Net)
	float                                              r_fConvergeStartDistance;                                 // 0x04A4(0x0004) (Net)
	float                                              r_fFogConvergeInterval;                                   // 0x04A8(0x0004) (Net)
	float                                              r_fFinalFogDirection;                                     // 0x04AC(0x0004) (Net)
	int                                                r_nTaskForcePushSuccessful;                               // 0x04B0(0x0004) (Net)
	int                                                r_nTaskForceDefenseSuccessful;                            // 0x04B4(0x0004) (Net)
	int                                                r_nMapLane;                                               // 0x04B8(0x0004) (Net)
	float                                              r_fGlobalFrictionFalling;                                 // 0x04BC(0x0004) (Net)
	float                                              r_fGlobalFrictionFlying;                                  // 0x04C0(0x0004) (Net)
	TArray<class ATgForgeObjective*>                   c_pForges;                                                // 0x04C4(0x0010) (NeedCtorLink)
	TArray<class ATgCatapultActor*>                    c_pCatapults;                                             // 0x04D4(0x0010) (NeedCtorLink)
	struct FBotDifficultyDebugData                     r_DifficultyDebugData;                                    // 0x04E4(0x0064) (Net)
	int                                                r_nStartTime;                                             // 0x0548(0x0004) (Net)
	int                                                r_nDeployTime;                                            // 0x054C(0x0004) (Net)
	int                                                r_nPrepareTime;                                           // 0x0550(0x0004) (Net)
	int                                                r_nDeathFogTime;                                          // 0x0554(0x0004) (Net)
	int                                                r_nRemainingTime;                                         // 0x0558(0x0004) (Net)
	int                                                r_nPreConvergeTime;                                       // 0x055C(0x0004) (Net)
	int                                                r_nConvergeTime;                                          // 0x0560(0x0004) (Net)
	int                                                r_nTeamsTotal;                                            // 0x0564(0x0004) (Net)
	int                                                r_nTeamsAlive;                                            // 0x0568(0x0004) (Net)
	int                                                r_nPlayersAlive;                                          // 0x056C(0x0004) (Net)
	int                                                r_nPlayersTotal;                                          // 0x0570(0x0004) (Net)
	float                                              r_fReviveTotalTime;                                       // 0x0574(0x0004) (Net)
	class ATgRoyaleConvergeActor*                      r_pFog;                                                   // 0x0578(0x0008) (Net)
	float                                              r_ScrimmageX;                                             // 0x0580(0x0004) (Net)
	float                                              r_ScrimmageY;                                             // 0x0584(0x0004) (Net)
	float                                              m_fMaxSilhouetteRange;                                    // 0x0588(0x0004)
	struct FInitialFogInfo                             r_InitialFogInfo;                                         // 0x058C(0x0010) (Net)
	struct FLeaderboardTeam                            m_LeaderboardTeams[0x3];                                  // 0x059C(0x0048) (Net, NeedCtorLink)
	int                                                r_nDisenchantValues[0x4];                                 // 0x0674(0x0004) (Net)
	int                                                r_nPlayers[0x2];                                          // 0x0684(0x0004) (Net)
	class ATgTeamRoyaleZeppelin*                       r_pTeamZeppelins[0x2];                                    // 0x068C(0x0008) (Net)
	struct FVector                                     r_vTeamZeppelinSpawnLoc;                                  // 0x069C(0x000C) (Net)
	struct FRotator                                    r_rTeamZeppelinSpawnRot;                                  // 0x06A8(0x000C) (Net)
	unsigned char                                      UnknownData01[0x48];                                      // 0x06B4(0x0048) UNKNOWN PROPERTY: MapProperty TgGame.TgRepInfo_Game.m_TeamWaypoints
	unsigned char                                      UnknownData02[0x48];                                      // 0x06FC(0x0048) UNKNOWN PROPERTY: MapProperty TgGame.TgRepInfo_Game.m_TeamPings

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgRepInfo_Game");
		return ptr;
	}


	bool AllowPlayerMounting();
	class ATgPawn_Character* STATIC_GetClosestPawnCharacter(const struct FVector& Target, class ATgPawn_Character* ignoreTarget, bool godsOnly);
	class ATgPawn_LootGoblin* STATIC_GetLootGoblinByPawnId(int nPawnId);
	TArray<class ATgPawn_Character*> STATIC_GetAllPawnCharacters();
	void STATIC_AddPotGEventToAllPlayers(TEnumAsByte<EPlayOfTheGameEventType> potgEvent);
	void SetEnableHeadshots(bool bEnable);
	void ProcessMissionTimerEvent(int nEventId, unsigned char nAttackingTaskForce, unsigned char nWinningTaskForce);
	void SendPayloadMissionEvent(int nEventId, class ATgRepInfo_TaskForce* attackingTaskForce, class ATgRepInfo_TaskForce* WinningTaskForce);
	float STATIC_GetMissionTime();
	void DecrementPoints(int nTaskForce, int nValue);
	void SetUsePointsMode(bool bValue, int nValue);
	bool FlagIsDown(int TeamIndex);
	void SetFlagDown(int TeamIndex);
	bool FlagIsHeldEnemy(int TeamIndex);
	void SetFlagHeldEnemy(int TeamIndex);
	bool FlagIsHeldFriendly(int TeamIndex);
	void SetFlagHeldFriendly(int TeamIndex);
	bool FlagsAreHome();
	bool FlagIsHome(int TeamIndex);
	void SetFlagHome(int TeamIndex);
	int STATIC_GetNextClientOnlyProjectileInstanceId();
	void RemoveDestructible(class ATgDestructible* Dest);
	void AddDestructible(class ATgDestructible* Dest);
	void RemoveCapturePoint(class ATgRealmCapturePoint* pPoint);
	void AddCapturePoint(class ATgRealmCapturePoint* pPoint);
	void RemoveCPRI(class ATgRepInfo_CapturePoint* CPRI);
	void AddCPRI(class ATgRepInfo_CapturePoint* CPRI);
	void RemoveDRI(class ATgRepInfo_Deployable* DRI);
	void AddDRI(class ATgRepInfo_Deployable* DRI);
	void STATIC_MissionTimeUpdateAllClients();
	void UpdateMissionTimer(bool bForcePrimary, bool bForceSecondary);
	void STATIC_InitSecondaryMissionTime();
	void STATIC_InitMissionTime();
	void PostBeginPlay();
	void UpdateAttackingTaskforce(class ATgRepInfo_TaskForce* NewAttackingTaskForce);
	void UpdateFog();
	void SetGameMode(TEnumAsByte<EGameMode> Mode);
	void GameEnvironmentRuleUpdated();
	void SetGameRespawnRule(TEnumAsByte<EGameRespawnRule> Rule);
	void SetGameEnvironmentRule(TEnumAsByte<EGameEnvironmentRule> Rule);
	void STATIC_HideHeadMesh();
	void ShowHeadMesh();
	void STATIC_ReplicatedEvent(const struct FName& VarName);
	int STATIC_GetHighestTaskForceId();
	int STATIC_GetCountOfTaskForcesWithPlayers();
	class ATgTeamRoyaleZeppelin* STATIC_GetZeppelinForTeam(int nTaskForce);
	class ATgTeamRoyaleZeppelin* STATIC_GetZeppelinForPawn(class ATgPawn* PlayerPawn);
	class ATgTeamRoyaleZeppelin* STATIC_GetZeppelinForPlayer(class ATgPlayerController* PlayerController);
	void STATIC_RegisterCatapult(class ATgCatapultActor* pCatapult);
	void RegisterForge(class ATgObjective* pObjective);
	bool AllowHeadShots();
	void RecalcRespawnTimers();
	bool SiegeEngineRequiresAlliesToMove();
	TEnumAsByte<EMAP_LANE> STATIC_GetLane(int nLane, class ATgRepInfo_TaskForce* tfri);
	class ATgProj_Simulated* SpawnSimulatedProjectile(int nProjectileInstanceId, int nFireModeId, class AActor* pOwner, const struct FVector& vLocation, const struct FVector& vRotation, int nProjectileIdOverride, bool bPredictStartLocationBasedOnPing, class UTgDeviceFire* FireMode);
	class ATgProj_Simulated* STATIC_GetSimulatedProjectile(int nProjectileId);
	class ATgProj_Simulated* STATIC_GetClientSpawnedProjectile(int ClientFireRequestId);
	void DefendersSpawnGatesOpenChanged();
	void AttackersSpawnGatesOpenChanged();
	void SpawnGatesOpenChanged();
	void GameTypeSet();
	void GameStateChanged();
	void UpdateGameTransitionUI();
	void UpdateGameScoreUI();
	void UpdateGameClockUI();
	bool CheckIsParty(class ATgRepInfo_Player* A, class ATgRepInfo_Player* B);
	bool STATIC_CheckIsEnemy(class AActor* A, class AActor* B);
	class ATgRepInfo_TaskForce* STATIC_GetDefendingTaskForce();
	class ATgRepInfo_TaskForce* STATIC_GetAttackingTaskForce();
	void STATIC_GetOpposingTeamsPawns(class ATgPawn* instigatingPawn, TArray<class ATgPawn_Character*>* enemyPawns);
	int STATIC_GetNumNearbyPlayers(int nTaskForceNum, const struct FVector& vLocation, float fDist);
	bool TaskForceEnumerate(bool bPlayerOnly, class ATgRepInfo_TaskForce** rpTaskForce, int* rnTaskForceNum);
	class ATgRepInfo_TaskForce* CreateTaskForce(int nTaskForceNum);
	class ATgRepInfo_TaskForce* STATIC_GetTaskForce(int nTaskForceNum, bool bCreate);
	class ATgRepInfo_TaskForce* STATIC_GetTaskForceFor(class AActor* Actor);
	class ATgRepInfo_Player* STATIC_GetPRIFromID(int nPRIID);
	class ATgProjectile* STATIC_GetProjectile(int nIndex);
	class ATgDeployable* STATIC_GetDeployable(int nIndex);
	int STATIC_GetDeployableCount();
};


// Class TgGame.TgRepInfo_Game_BattleRoyale
// 0x0000 (0x0744 - 0x0744)
class ATgRepInfo_Game_BattleRoyale : public ATgRepInfo_Game
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgRepInfo_Game_BattleRoyale");
		return ptr;
	}


	void PostBeginPlay();
};


// Class TgGame.TgRepInfo_Game_RoyaleScrimmage
// 0x0000 (0x0744 - 0x0744)
class ATgRepInfo_Game_RoyaleScrimmage : public ATgRepInfo_Game_BattleRoyale
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgRepInfo_Game_RoyaleScrimmage");
		return ptr;
	}


	bool CheckIsParty(class ATgRepInfo_Player* A, class ATgRepInfo_Player* B);
};


// Class TgGame.TgRepInfo_Game_RoyaleStorm
// 0x0024 (0x0768 - 0x0744)
class ATgRepInfo_Game_RoyaleStorm : public ATgRepInfo_Game_BattleRoyale
{
public:
	int                                                r_nTickets[0x2];                                          // 0x0744(0x0004) (Net)
	struct FVector                                     r_vCanyonOrigin;                                          // 0x074C(0x000C) (Net)
	float                                              r_fCanyonDirection;                                       // 0x0758(0x0004) (Net)
	float                                              r_fCanyonWidth;                                           // 0x075C(0x0004) (Net)
	float                                              r_fConvergeWidth1;                                        // 0x0760(0x0004) (Net)
	float                                              r_fConvergeWidth2;                                        // 0x0764(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgRepInfo_Game_RoyaleStorm");
		return ptr;
	}

};


// Class TgGame.TgRepInfo_Game_RoyaleTournament
// 0x0028 (0x076C - 0x0744)
class ATgRepInfo_Game_RoyaleTournament : public ATgRepInfo_Game
{
public:
	int                                                r_nFogCount;                                              // 0x0744(0x0004) (Net)
	unsigned long                                      r_bInForgeStage : 1;                                      // 0x0748(0x0004) (Net)
	class ATgRoyaleConvergeActor*                      r_pAllFogs[0x4];                                          // 0x074C(0x0008) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgRepInfo_Game_RoyaleTournament");
		return ptr;
	}


	void STATIC_ReplicatedEvent(const struct FName& VarName);
	void STATIC_UpdateForgeStage(bool bInForgeStage);
	void ClientClearAllFogs();
	void ClearAllFogs();
	bool ContainsFog(class ATgRoyaleConvergeActor* pFogActor);
	void AddFog(class ATgRoyaleConvergeActor* pFogActor);
	void AddFogUnique(class ATgRoyaleConvergeActor* pFogActor);
};


// Class TgGame.TgRepInfo_Game_TeamDeathMatch
// 0x0008 (0x074C - 0x0744)
class ATgRepInfo_Game_TeamDeathMatch : public ATgRepInfo_Game
{
public:
	int                                                c_nLeadingTeam;                                           // 0x0744(0x0004)
	int                                                c_nLeadingTeamScoreAmount;                                // 0x0748(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgRepInfo_Game_TeamDeathMatch");
		return ptr;
	}

};


// Class TgGame.TgRepInfo_Player
// 0x0DD8 (0x1258 - 0x0480)
class ATgRepInfo_Player : public APlayerReplicationInfo
{
public:
	int                                                r_nPlayerId;                                              // 0x0480(0x0004) (Net)
	int                                                r_nPawnId;                                                // 0x0484(0x0004) (Net)
	int                                                r_nPlayerGameID;                                          // 0x0488(0x0004) (Net)
	int                                                m_nUIDisplayIndex;                                        // 0x048C(0x0004)
	float                                              c_fLastUpdateTime;                                        // 0x0490(0x0004)
	int                                                r_nSupportWins;                                           // 0x0494(0x0004) (Net)
	int                                                r_nDamageWins;                                            // 0x0498(0x0004) (Net)
	int                                                r_nFlankWins;                                             // 0x049C(0x0004) (Net)
	int                                                r_nFrontlineWins;                                         // 0x04A0(0x0004) (Net)
	int                                                r_nEquippedTitleId;                                       // 0x04A4(0x0004) (Net)
	int                                                r_nHealthCurrent;                                         // 0x04A8(0x0004) (Net)
	int                                                r_nHealthMaximum;                                         // 0x04AC(0x0004) (Net)
	int                                                r_nPowerCurrent;                                          // 0x04B0(0x0004) (Net)
	int                                                r_nPowerMaximum;                                          // 0x04B4(0x0004) (Net)
	int                                                r_nPacingType;                                            // 0x04B8(0x0004) (Net)
	int                                                r_nShieldCurrent;                                         // 0x04BC(0x0004) (Net)
	int                                                r_nShieldMaximum;                                         // 0x04C0(0x0004) (Net)
	class ATgRepInfo_Player*                           r_MasterPrep;                                             // 0x04C4(0x0008) (Net)
	class ATgRepInfo_TaskForce*                        r_TaskForce;                                              // 0x04CC(0x0008) (Net)
	int                                                r_nPartyId;                                               // 0x04D4(0x0004) (Net)
	class ATgTeamPlayerStart*                          r_SpawnPoint;                                             // 0x04D8(0x0008) (Net)
	float                                              r_fReviveSecs;                                            // 0x04E0(0x0004) (Net)
	float                                              r_fReviveSecsTotal;                                       // 0x04E4(0x0004) (Net)
	unsigned long                                      r_bMapHasLoaded : 1;                                      // 0x04E8(0x0004) (Net)
	unsigned long                                      r_bHasBeenSeenByEnemyTeam : 1;                            // 0x04E8(0x0004) (Net)
	unsigned long                                      r_bSilhouettesBlocked : 1;                                // 0x04E8(0x0004) (Net)
	unsigned long                                      r_bExtendedSilhouetteRange : 1;                           // 0x04E8(0x0004) (Net)
	unsigned long                                      r_bSpeakingEmote : 1;                                     // 0x04E8(0x0004) (Net)
	unsigned long                                      r_bPlayingAnnouncer : 1;                                  // 0x04E8(0x0004) (Net)
	unsigned long                                      c_bSpeaking : 1;                                          // 0x04E8(0x0004)
	unsigned long                                      r_bDropped : 1;                                           // 0x04E8(0x0004) (Net)
	unsigned long                                      s_bFirstDrop : 1;                                         // 0x04E8(0x0004)
	unsigned long                                      r_bForceNotBot : 1;                                       // 0x04E8(0x0004) (Net)
	unsigned long                                      r_bDisconnected : 1;                                      // 0x04E8(0x0004) (Net)
	unsigned long                                      c_bIsDying : 1;                                           // 0x04E8(0x0004)
	unsigned long                                      r_IsRevealed : 1;                                         // 0x04E8(0x0004) (Net)
	unsigned long                                      r_bIsStealthed : 1;                                       // 0x04E8(0x0004) (Net)
	unsigned long                                      r_bIsVolumeStealthed : 1;                                 // 0x04E8(0x0004)
	unsigned long                                      r_bUltimateIsReady : 1;                                   // 0x04E8(0x0004) (Net)
	unsigned long                                      r_bCanUpgradeLegendary : 1;                               // 0x04E8(0x0004) (Net)
	unsigned long                                      s_bAutoSelectCards : 1;                                   // 0x04E8(0x0004)
	unsigned long                                      c_bTrackedProjectileIdsJustChanged : 1;                   // 0x04E8(0x0004)
	unsigned long                                      r_bBigHeadModeActive : 1;                                 // 0x04E8(0x0004) (Net)
	unsigned char                                      r_nSurrenderVote;                                         // 0x04EC(0x0001) (Net)
	unsigned char                                      r_bVisibleOnMap[0x3];                                     // 0x04ED(0x0001) (Net)
	unsigned char                                      r_nVisibilityMask;                                        // 0x04F0(0x0001) (Net)
	unsigned char                                      r_nFlashUpdateAmmo;                                       // 0x04F1(0x0001) (Net)
	TEnumAsByte<EDeployableOverlayIcon>                r_eDeployableOverlayIcon;                                 // 0x04F2(0x0001) (Net)
	TEnumAsByte<EDeployableOverlayState>               r_eDeployableOverlayState;                                // 0x04F3(0x0001) (Net)
	TEnumAsByte<EDeployableOverlayIcon>                c_eDeployableOverlayIconOverride;                         // 0x04F4(0x0001)
	TEnumAsByte<EDeployableOverlayState>               c_eDeployableOverlayStateOverride;                        // 0x04F5(0x0001)
	TEnumAsByte<EGAME_MODE_INSTRUCTION>                r_eCurrentGameModeInstruction;                            // 0x04F6(0x0001) (Net)
	TEnumAsByte<EPlayerDeployState>                    r_PlayerDeployState;                                      // 0x04F7(0x0001) (Net)
	TArray<class ATgRepInfo_Player*>                   m_PRIArray;                                               // 0x04F8(0x0010) (NeedCtorLink)
	TArray<class ATgRepInfo_Deployable*>               m_DRIArray;                                               // 0x0508(0x0010) (NeedCtorLink)
	class ATgRepInfo_Player*                           c_PriorMasterPrep;                                        // 0x0518(0x0008)
	class ATgRepInfo_TaskForce*                        c_PriorTaskForce;                                         // 0x0520(0x0008)
	int                                                c_fLastHealth;                                            // 0x0528(0x0004)
	float                                              c_fLastDamageTime;                                        // 0x052C(0x0004)
	float                                              r_fVisionRange;                                           // 0x0530(0x0004) (Net)
	struct FString                                     r_ClanTag;                                                // 0x0534(0x0010) (Net, AlwaysInit, NeedCtorLink)
	struct FString                                     c_PlayerNameWithTag;                                      // 0x0544(0x0010) (AlwaysInit, NeedCtorLink)
	float                                              c_fBarragePercent;                                        // 0x0554(0x0004)
	float                                              m_fSyncAnnouncerFailsafe;                                 // 0x0558(0x0004)
	int                                                r_nRemainingLives;                                        // 0x055C(0x0004) (Net)
	int                                                m_DeployPostureId;                                        // 0x0560(0x0004)
	float                                              m_fMaxPingTime;                                           // 0x0564(0x0004)
	struct FSimulatedProjectileOverrides               r_SimProjOverrides[0x8];                                  // 0x0568(0x0018) (Net)
	int                                                r_PlayerItems[0x9];                                       // 0x0628(0x0004) (Net)
	int                                                r_Scores[0x16];                                           // 0x064C(0x0004) (Net)
	struct FDeviceTeamInfo                             r_PlayerDevices[0x14];                                    // 0x06A4(0x0028) (Net)
	struct FAmmoCount                                  r_PlayerDeviceAmmo[0x14];                                 // 0x09C4(0x0004) (Net)
	struct FAppliedStatEffect                          r_AppliedStatEffects[0x6];                                // 0x0A14(0x000C) (Net)
	float                                              r_fStatEffectsDisableTimeStamp[0x6];                      // 0x0A5C(0x0004) (Net)
	float                                              r_fStatEffectsDisableDuration[0x6];                       // 0x0A74(0x0004) (Net)
	int                                                r_nNextOpenStatEffect;                                    // 0x0A8C(0x0004) (Net)
	int                                                r_nLastEquippedStatEffect;                                // 0x0A90(0x0004) (Net)
	struct FMarkedTargetInfo                           r_MarkedTargets[0x5];                                     // 0x0A94(0x0008) (Net)
	float                                              c_fLastSpeakingTime;                                      // 0x0ABC(0x0004)
	int                                                r_nCredits;                                               // 0x0AC0(0x0004) (Net)
	int                                                r_nEarnedCredits;                                         // 0x0AC4(0x0004) (Net)
	int                                                r_nXp;                                                    // 0x0AC8(0x0004) (Net)
	int                                                r_nLevel;                                                 // 0x0ACC(0x0004) (Net)
	int                                                r_nPlayerScore;                                           // 0x0AD0(0x0004) (Net)
	int                                                r_nCardHealth;                                            // 0x0AD4(0x0004) (Net)
	int                                                r_nCardDamage;                                            // 0x0AD8(0x0004) (Net)
	int                                                r_nPowerLevel;                                            // 0x0ADC(0x0004) (Net)
	int                                                r_nPowerLevelCount;                                       // 0x0AE0(0x0004) (Net)
	int                                                r_nProfileId;                                             // 0x0AE4(0x0004) (Net)
	int                                                r_nSkinId;                                                // 0x0AE8(0x0004) (Net)
	int                                                r_nVoicePackId;                                           // 0x0AEC(0x0004) (Net)
	int                                                r_nKillstreak;                                            // 0x0AF0(0x0004) (Net)
	int                                                r_nHeadSkinId;                                            // 0x0AF4(0x0004) (Net)
	int                                                r_nWeaponSkinId;                                          // 0x0AF8(0x0004) (Net)
	int                                                r_nMountSkinId;                                           // 0x0AFC(0x0004) (Net)
	int                                                r_nMarkerSkinId;                                          // 0x0B00(0x0004) (Net)
	int                                                r_nAssistScore;                                           // 0x0B04(0x0004) (Net)
	class ATgPawn*                                     r_PawnOwner;                                              // 0x0B08(0x0008) (Net)
	int                                                r_nLaneId;                                                // 0x0B10(0x0004) (Net)
	int                                                s_KillOrDeathStreakModifier;                              // 0x0B14(0x0004)
	struct FsPingInfo                                  r_PingInfo[0x4];                                          // 0x0B18(0x0020) (Net)
	struct FVector                                     c_DeathLocation;                                          // 0x0B98(0x000C)
	struct FVector                                     s_vDeathLocation;                                         // 0x0BA4(0x000C)
	struct FTG_HUD_INFO                                c_HudInfo;                                                // 0x0BB0(0x0004)
	float                                              r_fUltReadyInSecs;                                        // 0x0BB4(0x0004) (Net)
	int                                                r_nUltimateCharge;                                        // 0x0BB8(0x0004) (Net)
	int                                                r_nRequiredUltimateCharge;                                // 0x0BBC(0x0004) (Net)
	int                                                r_nPassiveMode;                                           // 0x0BC0(0x0004) (Net)
	int                                                r_nShards;                                                // 0x0BC4(0x0004) (Net)
	int                                                r_nNuggets;                                               // 0x0BC8(0x0004) (Net)
	int                                                r_nPendingShards;                                         // 0x0BCC(0x0004) (Net)
	int                                                r_nColorIndex;                                            // 0x0BD0(0x0004) (Net)
	int                                                r_nPerkCountKit;                                          // 0x0BD4(0x0004) (Net)
	int                                                r_nPerkCountArmor;                                        // 0x0BD8(0x0004) (Net)
	int                                                r_nPerkCountWeapon;                                       // 0x0BDC(0x0004) (Net)
	int                                                r_nPerkCountGeneral;                                      // 0x0BE0(0x0004) (Net)
	int                                                r_nCardsToDraw;                                           // 0x0BE4(0x0004) (Net)
	int                                                r_nDrawnCards[0x5];                                       // 0x0BE8(0x0004) (Net)
	int                                                r_nDrawnPlayer[0x5];                                      // 0x0BFC(0x0004) (Net)
	float                                              s_fScoreTakenPool;                                        // 0x0C10(0x0004)
	float                                              s_fScoreDamagePool;                                       // 0x0C14(0x0004)
	float                                              s_fScoreCapturePool;                                      // 0x0C18(0x0004)
	float                                              s_fScoreHealingPool;                                      // 0x0C1C(0x0004)
	float                                              s_fScoreMitigatedPool;                                    // 0x0C20(0x0004)
	float                                              s_fScoreTakenThreshold;                                   // 0x0C24(0x0004)
	float                                              s_fScoreDamageThreshold;                                  // 0x0C28(0x0004)
	float                                              s_fScoreCaptureThreshold;                                 // 0x0C2C(0x0004)
	float                                              s_fScoreHealingThreshold;                                 // 0x0C30(0x0004)
	float                                              s_fScoreMitigatedThreshold;                               // 0x0C34(0x0004)
	TArray<struct FDeckCardData>                       s_CardDeckTier1;                                          // 0x0C38(0x0010) (NeedCtorLink)
	TArray<struct FDeckCardData>                       s_CardDeckTier2;                                          // 0x0C48(0x0010) (NeedCtorLink)
	TArray<struct FDeckCardData>                       s_CardDeckTier3;                                          // 0x0C58(0x0010) (NeedCtorLink)
	TArray<struct FDeckCardData>                       s_CardDeckTier4;                                          // 0x0C68(0x0010) (NeedCtorLink)
	TArray<struct FDeckCardData>                       s_CardDeckTier5;                                          // 0x0C78(0x0010) (NeedCtorLink)
	struct FTgAbilityInfo                              r_GeneralAbilityInfo;                                     // 0x0C88(0x0044) (Net)
	struct FTgAbilityInfo                              r_ArmorAbilityInfo;                                       // 0x0CCC(0x0044) (Net)
	class ATgRepInfo_Player*                           s_LastKillerPRI;                                          // 0x0D10(0x0008)
	TArray<struct FPlayOfTheGameEventData>             s_PlayOfTheGameEventList;                                 // 0x0D18(0x0010) (NeedCtorLink)
	TArray<struct FPlayOfTheGameEventCounter>          s_PlayOfTheGameEventCounters;                             // 0x0D28(0x0010) (NeedCtorLink)
	int                                                r_nDeployableOverlayDisplayMask;                          // 0x0D38(0x0004) (Net)
	float                                              r_fDeployableOverlayEnemyViewDist;                        // 0x0D3C(0x0004) (Net)
	int                                                c_nDeployableOverlayDisplayMaskOverride;                  // 0x0D40(0x0004)
	float                                              c_fDeployableOverlayEnemyViewDistOverride;                // 0x0D44(0x0004)
	int                                                r_TrackedProjectileIds[0xF];                              // 0x0D48(0x0004) (Net)
	struct FTrackedProjectileInitData                  r_TrackedProjectilesInitData[0xF];                        // 0x0D84(0x0030) (Net)
	struct FTrackedProjectileUpdateData                r_TrackedProjectilesUpdateData[0xF];                      // 0x1054(0x001C) (Net)
	int                                                r_nRank;                                                  // 0x11F8(0x0004) (Net)
	struct FVector                                     r_vDeploy;                                                // 0x11FC(0x000C) (Net)
	struct FVector                                     r_vWaypoint;                                              // 0x1208(0x000C) (Net)
	struct FVector                                     r_vPingLocation;                                          // 0x1214(0x000C) (Net)
	struct FRotator                                    r_rPingRotation;                                          // 0x1220(0x000C) (Net)
	class ATgEmitterSpawnable*                         m_WaypointEmitter;                                        // 0x122C(0x0008)
	class ATgEmitterSpawnable*                         m_PingEmitter;                                            // 0x1234(0x0008)
	struct FVector                                     r_vLocation;                                              // 0x123C(0x000C) (Net)
	struct FRotator                                    r_rRotation;                                              // 0x1248(0x000C) (Net)
	int                                                r_nNumViewingPlayers;                                     // 0x1254(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgRepInfo_Player");
		return ptr;
	}


	float STATIC_GetDeployableOverlayEnemyViewDist();
	TEnumAsByte<EDeployableOverlayState> STATIC_GetDeployableOverlayState();
	TEnumAsByte<EDeployableOverlayIcon> STATIC_GetDeployableOverlayIcon();
	int STATIC_GetDeployableOverlayDisplayMask();
	void STATIC_StartSkydive();
	void SetPlayerDeployState(TEnumAsByte<EPlayerDeployState> NewState);
	void SetHUDOverlayEnemyViewDist(float enemyViewDist);
	void SetHUDOverlayState(TEnumAsByte<EDeployableOverlayState> dos);
	void SetHUDOverlayIcon(TEnumAsByte<EDeployableOverlayIcon> doi);
	void SetHUDOverlayDisplayMask(int dodm);
	bool STATIC_GetSimProjOverrides(int nFireModeId, float* fRange, float* fRemoteProximity, float* fSpeed, float* fGravityScale, float* fFireAngle);
	void ValidateSimProj(int nIndex);
	int FindSimProjOverrideIndex(int nFireModeId);
	void SetSimProjFireAngle(int nFireModeId, float fFireAngle);
	void SetSimProjGravityScale(int nFireModeId, float fGravityScale);
	void SetSimProjDist(int nFireModeId, float fDist);
	void SetSimProjRemoteProximity(int nFireModeId, float fRemoteProximity);
	void SetSimProjSpeed(int nFireModeId, float fSpeed);
	void SetSpawnPoint(class ATgTeamPlayerStart* SpawnPoint);
	void STATIC_OnDeath();
	void TransferMinionOwnershipTo(class ATgRepInfo_Player* NewOwner);
	void CopyProperties(class APlayerReplicationInfo* PRI);
	void OverrideWith(class APlayerReplicationInfo* PRI);
	class APlayerReplicationInfo* Duplicate();
	bool STATIC_ShouldBroadCastWelcomeMessage(bool bExiting);
	class ATgPawn* FindLocalPlayerPawn();
	class APlayerController* FindLocalController();
	void STATIC_ReplicatedEvent(const struct FName& VarName);
	void STATIC_PeerDisconnected();
	void ClearWaypointPingWorldFX();
	void STATIC_UpdateWaypointPingWorldFx();
	void STATIC_ServerUpdateWaypointPing(const struct FVector& vLocation, const struct FRotator& rRotation);
	void UpdateWaypointPing(const struct FVector& vLocation, const struct FRotator& rRotation);
	void ServerUpdateWaypoint(const struct FVector& vLocation);
	void UpdateWaypointWorldFx();
	void UpdateWaypoint(const struct FVector& vLocation);
	void UpdatedTaskForce();
	void UpdatedApproxLocation();
	void UpdatedHealthCurrent();
	unsigned char STATIC_GetTaskForceNumber();
	void UpdateShield(int nCurrentShield, int nMaxShield);
	void UpdatePower(int nCurrentPower, int nMaxPower);
	void UpdateHealth(int nCurrentHealth, int nMaxHealth);
	void UpdatePlayerLives();
	void UpdatePlayerLocation();
	void UpdateIdAndProfile();
	void Timer();
	void RecalculateTeamColor();
	void STATIC_ClientInitialize(class AController* C);
	void STATIC_SetAnnouncerPlaying(bool bPlaying);
	void PopulateGeneralAbilities();
	void PostBeginPlay();
	bool STATIC_IsConnectedToMatch();
	void ClientReactivateBigHeadMode();
	void ClientHandleStatEffectsChanged();
	bool CanApplyStatEffect(int nDeviceId);
	bool AddStatEffect(int nEffectGroupID, int nDeviceId, float fDamageDeactivateDuration);
	void AdjustShards(int nShardDelta);
	void UpdatePlayerItems();
	void ClientAllPlayersReady();
	void UpdateStarterIslandActorTicking();
	void ClientSetAnnouncerPlaying(bool bPlaying);
	int STATIC_GetMarkedTargetCount(int nPawnId);
	void RemoveMarkedTarget(int nPawnId, int nCount);
	void AddMarkedTarget(int nPawnId, int nCount);
	void AddPlayOfTheGameEvent(TEnumAsByte<EPlayOfTheGameEventType> Type, float Amount);
	void DrawNewCards(int nPrevPower);
	bool STATIC_LoadCardDeck(bool bDefault);
	void UpdatePlayerNameWithTag();
	void UpdatePlayerReady();
	void UpdateSurrenderVoting();
	void ClientUpdateItemStoreItems();
	bool SetTaskForceNumber(unsigned char nTaskForce, bool bForce);
	void UpdateMapVisibility(TEnumAsByte<ETgMapTeam> MAPTEAM, unsigned char bVisible, float fVisionRange, bool bDetected);
	void UpdatePingInfo(class ATgRepInfo_Player* pingedPri, const struct FVector& pingedLoc, TEnumAsByte<EPING_TYPE> Type);
	void CheckPingingList();
	bool STATIC_IsVisibleToLocalPlayer();
	bool STATIC_IsVisibleToPlayer(class ATgRepInfo_Player* PRI);
	bool STATIC_IsVisibleToMapTeam(TEnumAsByte<ETgMapTeam> MAPTEAM);
	bool STATIC_IsVisibleToAnEnemyTeam();
	bool STATIC_HasBeenSeenByEnemyTeam();
	void UpdateFX();
	void UpdatePlayerTaskforceUI();
	void UpdateWinsPerRole();
	void UpdatePlayerInfoUI();
	void UpdateSpectatorUI();
	struct FString STATIC_GetPlayerNameForMsgDisplay(bool bBaseNameOnly);
	void UpdateUltimateIsReady(float fCooldownSecs);
	bool STATIC_IsHardStealthedClient();
	bool STATIC_IsStealthedClient();
	struct FRotator STATIC_GetCurrentRotation();
	struct FVector STATIC_GetCurrentLocation();
	int STATIC_GetCurrentMaxShield();
	int STATIC_GetCurrentShield();
	int STATIC_GetCurrentMaxPower();
	int STATIC_GetCurrentPower();
	int STATIC_GetCurrentMaxHealth();
	int STATIC_GetCurrentHealth();
	void CheckMembership();
	void RemoveMinion(class AReplicationInfo* pRepInfo);
	void AddMinion(class AReplicationInfo* pRepInfo);
	void STATIC_SetTeam(class ATgRepInfo_TaskForce* pNewTeamRep);
	void UpdateBroadcastedItems(class ATgInventoryManager* InvMgr);
	void UpdateLevel();
	void UpdateScoreboard();
	int STATIC_GetPlayerId();
	bool STATIC_IsMinionOf(class ATgRepInfo_Player* PossibleOwner);
	bool STATIC_IsGodDecoy();
	bool STATIC_IsGod();
	bool STATIC_IsBotNotDisconnected();
	bool IsBot();
	bool STATIC_IsFriendlyWithLocalPlayer();
};


// Class TgGame.TgRepInfo_TaskForce
// 0x0078 (0x0318 - 0x02A0)
class ATgRepInfo_TaskForce : public ATeamInfo
{
public:
	int                                                r_nTeamId;                                                // 0x02A0(0x0004) (Net)
	int                                                r_nAlliance;                                              // 0x02A4(0x0004) (Net)
	unsigned long                                      r_bSpectator : 1;                                         // 0x02A8(0x0004) (Net)
	struct FResurrectionInfo                           r_ResurrectionInfo;                                       // 0x02AC(0x0008) (Net)
	class ATgTeamRoyaleZeppelin*                       r_TeamZeppelin;                                           // 0x02B4(0x0008) (Net)
	int                                                s_nColorIndex;                                            // 0x02BC(0x0004)
	int                                                s_nGodVisionMask;                                         // 0x02C0(0x0004)
	class ANavigationPoint*                            s_NavTeamDeploy;                                          // 0x02C4(0x0008)
	int                                                r_nScore;                                                 // 0x02CC(0x0004) (Net)
	int                                                r_nScorePercent;                                          // 0x02D0(0x0004) (Net)
	unsigned char                                      r_nTaskForce;                                             // 0x02D4(0x0001) (Net)
	unsigned char                                      UnknownData00[0x3];                                       // 0x02D5(0x0003) MISSED OFFSET
	float                                              r_fSecondaryScore;                                        // 0x02D8(0x0004) (Net)
	struct FFoundLootGoblinInfo                        r_FoundLootGoblinInfo;                                    // 0x02DC(0x000C) (Net)
	TArray<class ATgRepInfo_Factory*>                  m_Factories;                                              // 0x02E8(0x0010) (NeedCtorLink)
	TArray<class ATgRepInfo_Player*>                   m_TeamBots;                                               // 0x02F8(0x0010) (NeedCtorLink)
	TArray<class ATgRepInfo_Player*>                   m_TeamPlayers;                                            // 0x0308(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgRepInfo_TaskForce");
		return ptr;
	}


	void STATIC_NotifyScoreChange();
	class ATgPlayerController* FindLocalPlayerController();
	void UpdateKismetOnScore();
	void STATIC_ReplicatedEvent(const struct FName& VarName);
	void STATIC_ReceivedFoundLootGoblinInfo();
	void STATIC_ReceivedTaskForceNumber();
	void STATIC_ReceivedScoringChanges();
	void STATIC_RemoveFromTeam(class AController* Other);
	void STATIC_PostDemoRewind();
	void STATIC_PostInit();
	void STATIC_GetPlayersByDistance(const struct FVector& fromVector, float dwDist, TArray<class ATgRepInfo_Player*>* List);
	void STATIC_GetPlayers(TArray<class ATgRepInfo_Player*>* List);
	void TeamRemoveFrom(class AController* Other);
	int STATIC_GetFirstAlivePlayerIndex();
	int STATIC_GetAliveAndActivePlayerCount();
	int STATIC_GetActivePlayerCount();
	int STATIC_GetNumAlivePlayers();
	int STATIC_GetTaskForceRank();
	int GetPlayerCount();
	class ATgRepInfo_Player* CycleFrom(class ATgRepInfo_Player* pFrom, bool bForward);
	class ATgRepInfo_Player* STATIC_GetPlayerById(int nPawnId);
	class ATgRepInfo_Player* STATIC_GetPlayer(int nIndex);
};


// Class TgGame.TgRoyaleConvergeActor
// 0x0054 (0x02D4 - 0x0280)
class ATgRoyaleConvergeActor : public AActor
{
public:
	float                                              m_fTargetConvergeRadiusSize;                              // 0x0280(0x0004)
	float                                              m_fConvergeRadiusSize;                                    // 0x0284(0x0004)
	struct FConvergeInfo                               r_vConvergeRepInfo;                                       // 0x0288(0x0008) (Net)
	class ATgSurvivalFogVolumeDensityInfo*             m_FogActor;                                               // 0x0290(0x0008)
	float                                              m_fConvergeRadiusSpeed;                                   // 0x0298(0x0004)
	float                                              m_ConvergeLocationSpeed;                                  // 0x029C(0x0004)
	struct FVector                                     r_vConvergeLocation;                                      // 0x02A0(0x000C) (Net)
	unsigned long                                      m_bIsConverging : 1;                                      // 0x02AC(0x0004) (Net)
	unsigned long                                      m_bIsExpanding : 1;                                       // 0x02AC(0x0004) (Net)
	unsigned long                                      c_bFirstConvergence : 1;                                  // 0x02AC(0x0004)
	unsigned long                                      m_bIsShifting : 1;                                        // 0x02AC(0x0004)
	unsigned long                                      m_bUpdateTranslation : 1;                                 // 0x02AC(0x0004)
	class UStaticMeshComponent*                        m_StaticMeshComponent;                                    // 0x02B0(0x0008) (ExportObject, Component, EditInline)
	float                                              m_fLastConvergeTimestamp;                                 // 0x02B8(0x0004)
	float                                              m_fConvergeUpdateRate;                                    // 0x02BC(0x0004)
	class ATgMobileAmbientSound*                       c_aSoundActor;                                            // 0x02C0(0x0008)
	class UAkEvent*                                    c_akDeathField;                                           // 0x02C8(0x0008)
	float                                              m_fShiftingRemainingTime;                                 // 0x02D0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgRoyaleConvergeActor");
		return ptr;
	}


	void SetConvergeRTPC(float fSignedDist);
	void SetConvergeRepInfo(float TargetConvergeRadius, float CurrentConvergeRadius);
	void STATIC_ReplicatedEvent(const struct FName& VarName);
	void UpdateSoundActorLocation(const struct FVector& vLoc);
	void PostBeginPlay();
	void PostConvergeFinished();
	void STATIC_NativeInitialize();
};


// Class TgGame.TgRoyaleConvergeActor_Plane
// 0x0004 (0x02D8 - 0x02D4)
class ATgRoyaleConvergeActor_Plane : public ATgRoyaleConvergeActor
{
public:
	int                                                r_nConvergeSide;                                          // 0x02D4(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgRoyaleConvergeActor_Plane");
		return ptr;
	}

};


// Class TgGame.TgRoyaleObjective
// 0x0000 (0x0280 - 0x0280)
class ATgRoyaleObjective : public AActor
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgRoyaleObjective");
		return ptr;
	}

};


// Class TgGame.TgDropPoint
// 0x0000 (0x0280 - 0x0280)
class ATgDropPoint : public ATgRoyaleObjective
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDropPoint");
		return ptr;
	}

};


// Class TgGame.TgTournamentObjective
// 0x002C (0x02AC - 0x0280)
class ATgTournamentObjective : public ATgRoyaleObjective
{
public:
	class ATgDropPoint*                                m_pDropPointA;                                            // 0x0280(0x0008) (Edit)
	class ATgDropPoint*                                m_pDropPointB;                                            // 0x0288(0x0008) (Edit)
	float                                              m_fFogRadius;                                             // 0x0290(0x0004) (Edit)
	float                                              m_fZeppelinDropHeight;                                    // 0x0294(0x0004) (Edit)
	TEnumAsByte<EObjectiveSize>                        m_ObjectiveSize;                                          // 0x0298(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0299(0x0003) MISSED OFFSET
	class ATgBotFactory*                               m_pBotFactory;                                            // 0x029C(0x0008) (Edit)
	class USpriteComponent*                            BadSprite;                                                // 0x02A4(0x0008) (Const, ExportObject, Transient, Component, EditInline)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgTournamentObjective");
		return ptr;
	}


	void STATIC_UpdateEditorValidation();
	void STATIC_UpdateEditorDropHeight();
	void STATIC_UpdateEditorFogRadius();
};


// Class TgGame.TgSurvivalFogVolumeDensityInfo
// 0x0028 (0x02BC - 0x0294)
class ATgSurvivalFogVolumeDensityInfo : public AFogVolumeSphericalDensityInfo
{
public:
	unsigned long                                      m_bFogOn : 1;                                             // 0x0294(0x0004)
	float                                              m_fTargetStartDistance;                                   // 0x0298(0x0004)
	float                                              m_fPreviousStartDistance;                                 // 0x029C(0x0004)
	float                                              m_fFogUpdateTimestamp;                                    // 0x02A0(0x0004)
	float                                              m_fFogUpdateInterval;                                     // 0x02A4(0x0004)
	float                                              m_fConvergenceRate;                                       // 0x02A8(0x0004)
	float                                              m_fFadeInRate;                                            // 0x02AC(0x0004)
	float                                              m_fFadeOutRate;                                           // 0x02B0(0x0004)
	class UFogVolumeSphericalDensityComponent*         SphericalDensityComponent;                                // 0x02B4(0x0008) (ExportObject, Component, EditInline)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSurvivalFogVolumeDensityInfo");
		return ptr;
	}


	void Tick(float DeltaTime);
	void ConvergeFog(float fNewStartDistance, float interval, bool bForce);
	void ToggleFog(bool bOn);
	void PostBeginPlay();
};


// Class TgGame.TgAchievement
// 0x0030 (0x0090 - 0x0060)
class UTgAchievement : public UObject
{
public:
	class ATgPlayerController*                         Controller;                                               // 0x0060(0x0008)
	unsigned long                                      m_bCustomValue3IsBotId : 1;                               // 0x0068(0x0004) (Const)
	unsigned long                                      m_bAwardsAllowTriggering : 1;                             // 0x0068(0x0004)
	int                                                m_nBotId;                                                 // 0x006C(0x0004)
	int                                                m_nActivityId;                                            // 0x0070(0x0004)
	int                                                m_nCustomValue1;                                          // 0x0074(0x0004)
	int                                                m_nCustomValue2;                                          // 0x0078(0x0004)
	int                                                m_nCustomValue3;                                          // 0x007C(0x0004)
	int                                                m_nCustomValue4;                                          // 0x0080(0x0004)
	int                                                m_nCustomValue5;                                          // 0x0084(0x0004)
	int                                                m_nCurrentProgress;                                       // 0x0088(0x0004)
	int                                                m_nCurrentTarget;                                         // 0x008C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement");
		return ptr;
	}


	void StopTracking();
	bool BelongsToBot(int BotId);
	float STATIC_GetCustomValue5();
	float STATIC_GetCustomValue4();
	float STATIC_GetCustomValue3();
	float STATIC_GetCustomValue2();
	float STATIC_GetCustomValue1();
};


// Class TgGame.TgAchievement_BetweenTheEyes
// 0x0000 (0x0090 - 0x0090)
class UTgAchievement_BetweenTheEyes : public UTgAchievement
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_BetweenTheEyes");
		return ptr;
	}

};


// Class TgGame.TgAchievement_BigSpender
// 0x0000 (0x0090 - 0x0090)
class UTgAchievement_BigSpender : public UTgAchievement
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_BigSpender");
		return ptr;
	}

};


// Class TgGame.TgAchievement_BulletSponge
// 0x0004 (0x0094 - 0x0090)
class UTgAchievement_BulletSponge : public UTgAchievement
{
public:
	int                                                m_nDamageShielded;                                        // 0x0090(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_BulletSponge");
		return ptr;
	}

};


// Class TgGame.TgAchievement_ChampionKill
// 0x0000 (0x0090 - 0x0090)
class UTgAchievement_ChampionKill : public UTgAchievement
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_ChampionKill");
		return ptr;
	}

};


// Class TgGame.TgAchievement_KillAsClass
// 0x0000 (0x0090 - 0x0090)
class UTgAchievement_KillAsClass : public UTgAchievement_ChampionKill
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_KillAsClass");
		return ptr;
	}

};


// Class TgGame.TgAchievement_KillsInMatch
// 0x0000 (0x0090 - 0x0090)
class UTgAchievement_KillsInMatch : public UTgAchievement_ChampionKill
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_KillsInMatch");
		return ptr;
	}

};


// Class TgGame.TgAchievement_CounterAirDefense
// 0x0000 (0x0090 - 0x0090)
class UTgAchievement_CounterAirDefense : public UTgAchievement
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_CounterAirDefense");
		return ptr;
	}

};


// Class TgGame.TgAchievement_Damage
// 0x0004 (0x0094 - 0x0090)
class UTgAchievement_Damage : public UTgAchievement
{
public:
	float                                              m_fDamageDealt;                                           // 0x0090(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_Damage");
		return ptr;
	}

};


// Class TgGame.TgAchievement_Disenchant
// 0x0000 (0x0090 - 0x0090)
class UTgAchievement_Disenchant : public UTgAchievement
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_Disenchant");
		return ptr;
	}

};


// Class TgGame.TgAchievement_DoubleKill
// 0x0000 (0x0090 - 0x0090)
class UTgAchievement_DoubleKill : public UTgAchievement
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_DoubleKill");
		return ptr;
	}

};


// Class TgGame.TgAchievement_DownAsClass
// 0x0000 (0x0090 - 0x0090)
class UTgAchievement_DownAsClass : public UTgAchievement
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_DownAsClass");
		return ptr;
	}

};


// Class TgGame.TgAchievement_DownFromDistance
// 0x0000 (0x0090 - 0x0090)
class UTgAchievement_DownFromDistance : public UTgAchievement
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_DownFromDistance");
		return ptr;
	}

};


// Class TgGame.TgAchievement_EnvironmentalDeath
// 0x0000 (0x0090 - 0x0090)
class UTgAchievement_EnvironmentalDeath : public UTgAchievement
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_EnvironmentalDeath");
		return ptr;
	}

};


// Class TgGame.TgAchievement_FirstClass
// 0x0000 (0x0090 - 0x0090)
class UTgAchievement_FirstClass : public UTgAchievement
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_FirstClass");
		return ptr;
	}

};


// Class TgGame.TgAchievement_ForgeDevice
// 0x0000 (0x0090 - 0x0090)
class UTgAchievement_ForgeDevice : public UTgAchievement
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_ForgeDevice");
		return ptr;
	}

};


// Class TgGame.TgAchievement_FromTheGrave
// 0x0004 (0x0094 - 0x0090)
class UTgAchievement_FromTheGrave : public UTgAchievement
{
public:
	int                                                KillerPawnId;                                             // 0x0090(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_FromTheGrave");
		return ptr;
	}

};


// Class TgGame.TgAchievement_GainShards
// 0x0000 (0x0090 - 0x0090)
class UTgAchievement_GainShards : public UTgAchievement
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_GainShards");
		return ptr;
	}

};


// Class TgGame.TgAchievement_GearedOut
// 0x0000 (0x0090 - 0x0090)
class UTgAchievement_GearedOut : public UTgAchievement
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_GearedOut");
		return ptr;
	}

};


// Class TgGame.TgAchievement_HardCarry
// 0x0004 (0x0094 - 0x0090)
class UTgAchievement_HardCarry : public UTgAchievement
{
public:
	int                                                nKills;                                                   // 0x0090(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_HardCarry");
		return ptr;
	}

};


// Class TgGame.TgAchievement_Headshot
// 0x0004 (0x0094 - 0x0090)
class UTgAchievement_Headshot : public UTgAchievement
{
public:
	int                                                m_nHeadshotsWithoutMissing;                               // 0x0090(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_Headshot");
		return ptr;
	}

};


// Class TgGame.TgAchievement_KillAfterRoundEnd
// 0x0000 (0x0090 - 0x0090)
class UTgAchievement_KillAfterRoundEnd : public UTgAchievement
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_KillAfterRoundEnd");
		return ptr;
	}

};


// Class TgGame.TgAchievement_KillEndStreak
// 0x0000 (0x0090 - 0x0090)
class UTgAchievement_KillEndStreak : public UTgAchievement
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_KillEndStreak");
		return ptr;
	}

};


// Class TgGame.TgAchievement_KillFromLowHealth
// 0x0000 (0x0090 - 0x0090)
class UTgAchievement_KillFromLowHealth : public UTgAchievement
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_KillFromLowHealth");
		return ptr;
	}

};


// Class TgGame.TgAchievement_KillWithDevice
// 0x0000 (0x0090 - 0x0090)
class UTgAchievement_KillWithDevice : public UTgAchievement
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_KillWithDevice");
		return ptr;
	}

};


// Class TgGame.TgAchievement_LastOneStanding
// 0x0000 (0x0090 - 0x0090)
class UTgAchievement_LastOneStanding : public UTgAchievement
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_LastOneStanding");
		return ptr;
	}

};


// Class TgGame.TgAchievement_MatchRank
// 0x0000 (0x0090 - 0x0090)
class UTgAchievement_MatchRank : public UTgAchievement
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_MatchRank");
		return ptr;
	}

};


// Class TgGame.TgAchievement_OpenChest
// 0x0000 (0x0090 - 0x0090)
class UTgAchievement_OpenChest : public UTgAchievement
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_OpenChest");
		return ptr;
	}

};


// Class TgGame.TgAchievement_PickupDevice
// 0x0000 (0x0090 - 0x0090)
class UTgAchievement_PickupDevice : public UTgAchievement
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_PickupDevice");
		return ptr;
	}

};


// Class TgGame.TgAchievement_PlaceInGame
// 0x0000 (0x0090 - 0x0090)
class UTgAchievement_PlaceInGame : public UTgAchievement
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_PlaceInGame");
		return ptr;
	}

};


// Class TgGame.TgAchievement_PlayGameAsClass
// 0x0000 (0x0090 - 0x0090)
class UTgAchievement_PlayGameAsClass : public UTgAchievement
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_PlayGameAsClass");
		return ptr;
	}

};


// Class TgGame.TgAchievement_QuestionsLater
// 0x0014 (0x00A4 - 0x0090)
class UTgAchievement_QuestionsLater : public UTgAchievement
{
public:
	unsigned long                                      bTakenDamageYet : 1;                                      // 0x0090(0x0004)
	unsigned long                                      bHasHitAllEnemies : 1;                                    // 0x0090(0x0004)
	TArray<int>                                        EnemyPawnsHit;                                            // 0x0094(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_QuestionsLater");
		return ptr;
	}

};


// Class TgGame.TgAchievement_Revive
// 0x0000 (0x0090 - 0x0090)
class UTgAchievement_Revive : public UTgAchievement
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_Revive");
		return ptr;
	}

};


// Class TgGame.TgAchievement_Showoff
// 0x0000 (0x0090 - 0x0090)
class UTgAchievement_Showoff : public UTgAchievement
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_Showoff");
		return ptr;
	}

};


// Class TgGame.TgAchievement_Sniper
// 0x0000 (0x0090 - 0x0090)
class UTgAchievement_Sniper : public UTgAchievement
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_Sniper");
		return ptr;
	}

};


// Class TgGame.TgAchievement_SpeakYourMind
// 0x0000 (0x0090 - 0x0090)
class UTgAchievement_SpeakYourMind : public UTgAchievement
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_SpeakYourMind");
		return ptr;
	}

};


// Class TgGame.TgAchievement_SurgeonGeneral
// 0x0004 (0x0094 - 0x0090)
class UTgAchievement_SurgeonGeneral : public UTgAchievement
{
public:
	int                                                m_nHealing;                                               // 0x0090(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_SurgeonGeneral");
		return ptr;
	}

};


// Class TgGame.TgAchievement_Survivor
// 0x0000 (0x0090 - 0x0090)
class UTgAchievement_Survivor : public UTgAchievement
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_Survivor");
		return ptr;
	}

};


// Class TgGame.TgAchievement_TeamRank
// 0x0000 (0x0090 - 0x0090)
class UTgAchievement_TeamRank : public UTgAchievement
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_TeamRank");
		return ptr;
	}

};


// Class TgGame.TgAchievement_Unstoppable
// 0x0004 (0x0094 - 0x0090)
class UTgAchievement_Unstoppable : public UTgAchievement
{
public:
	unsigned long                                      m_bReachedKillstreak : 1;                                 // 0x0090(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_Unstoppable");
		return ptr;
	}

};


// Class TgGame.TgAchievement_Wanderer
// 0x0014 (0x00A4 - 0x0090)
class UTgAchievement_Wanderer : public UTgAchievement
{
public:
	struct FVector                                     m_vLastPlayerLocation;                                    // 0x0090(0x000C)
	unsigned long                                      m_bLastLocationValid : 1;                                 // 0x009C(0x0004)
	float                                              m_fDistanceAccumulator;                                   // 0x00A0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_Wanderer");
		return ptr;
	}

};


// Class TgGame.TgDatabaseIDs
// 0x0000 (0x0060 - 0x0060)
class UTgDatabaseIDs : public UObject
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDatabaseIDs");
		return ptr;
	}

};


// Class TgGame.TgCallbackContainer
// 0x00D8 (0x0138 - 0x0060)
class UTgCallbackContainer : public UObject
{
public:
	struct FMultiMap_Mirror                            m_RegisteredCallbacks;                                    // 0x0060(0x0048) (Const, Native)
	struct FMap_Mirror                                 m_RegisteredCallbacksByHandle;                            // 0x00A8(0x0048) (Const, Native)
	struct FMap_Mirror                                 m_CallbackHandles;                                        // 0x00F0(0x0048) (Const, Native)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCallbackContainer");
		return ptr;
	}

};


// Class TgGame.TgCallbackInterface
// 0x0000 (0x0060 - 0x0060)
class UTgCallbackInterface : public UInterface
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCallbackInterface");
		return ptr;
	}

};


// Class TgGame.TgChampionTickManager
// 0x0064 (0x00C4 - 0x0060)
class UTgChampionTickManager : public UObject
{
public:
	int                                                m_nCurrentFrame;                                          // 0x0060(0x0004)
	int                                                m_nNextID;                                                // 0x0064(0x0004)
	class ATgPlayerController*                         m_CachedPlayerController;                                 // 0x0068(0x0008)
	unsigned long                                      m_bTickThrottlingEnabled : 1;                             // 0x0070(0x0004) (Config)
	float                                              m_fGuaranteedTickDistance;                                // 0x0074(0x0004) (Config)
	int                                                m_nTickGroupCount;                                        // 0x0078(0x0004) (Config)
	unsigned char                                      UnknownData00[0x48];                                      // 0x007C(0x0048) UNKNOWN PROPERTY: MapProperty TgGame.TgChampionTickManager.c_ChampionEntries

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgChampionTickManager");
		return ptr;
	}


	void PrepTick(float fDeltaTime);
	void Initialize();
};


// Class TgGame.TgGameplayCurveOwner
// 0x0000 (0x0060 - 0x0060)
class UTgGameplayCurveOwner : public UInterface
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGameplayCurveOwner");
		return ptr;
	}


	bool UseRangeFalloffCurve();
	class UTgGameplayCurvesSet* STATIC_GetCurrentGameplayCurveSet(TEnumAsByte<ECurveSetTypes> Type);
};


// Class TgGame.TgGameplayCurves
// 0x002C (0x008C - 0x0060)
class UTgGameplayCurves : public UObject
{
public:
	TArray<class UTgGameplayCurvesSet*>                CurveSets;                                                // 0x0060(0x0010) (Edit, NeedCtorLink, NoClear, EditInline)
	TArray<class UTgGameplayCurves*>                   InheritedCurves;                                          // 0x0070(0x0010) (Edit, NeedCtorLink, NoClear, EditInline, EditInlineUse)
	unsigned long                                      bShowInheritedCurves : 1;                                 // 0x0080(0x0004) (Edit, Transient)
	unsigned long                                      bInheritedCurvesShareEditorTab : 1;                       // 0x0080(0x0004) (Edit, Transient)
	class UInterpCurveEdSetup*                         CurveEdSetup;                                             // 0x0084(0x0008) (ExportObject)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGameplayCurves");
		return ptr;
	}


	bool STATIC_GetPrimaryDistributionValueByType(TEnumAsByte<ECurveSetTypes> curveType, float T, float* Value);
	class UTgGameplayCurvesSet* STATIC_GetCurvesSetByType(TEnumAsByte<ECurveSetTypes> curveType);
};


// Class TgGame.TgGameplayCurvesSet
// 0x0001 (0x0061 - 0x0060)
class UTgGameplayCurvesSet : public UObject
{
public:
	TEnumAsByte<ECurveSetTypes>                        CurveSetType;                                             // 0x0060(0x0001) (Edit, Const, EditConst)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGameplayCurvesSet");
		return ptr;
	}


	bool STATIC_GetPrimaryDistributionValue(float T, float* Value);
	float STATIC_GetDistributionValue(float T, struct FRawDistributionFloat* Distribution);
};


// Class TgGame.TgGameplayCurvesSet_AimAcceleration
// 0x0013 (0x0074 - 0x0061)
class UTgGameplayCurvesSet_AimAcceleration : public UTgGameplayCurvesSet
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0061(0x0003) MISSED OFFSET
	TArray<class UTgAimAccelerationCurves*>            AimAccelerationCurves;                                    // 0x0064(0x0010) (Edit, NeedCtorLink, NoClear, EditInline)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGameplayCurvesSet_AimAcceleration");
		return ptr;
	}


	void UpdateAimAcceleration(float DeltaTime, int CurveSetToUse, int AccelerationBoost, int Algorithm, float SensitivityX, float SensitivityY, float* TurnSpeedX, float* TurnSpeedY, float* aTurn, float* aLookUp, float* OldATurn, float* OldALookUp);
};


// Class TgGame.TgGameplayCurvesSet_AimAssistBounds
// 0x0057 (0x00B8 - 0x0061)
class UTgGameplayCurvesSet_AimAssistBounds : public UTgGameplayCurvesSet
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0061(0x0003) MISSED OFFSET
	struct FRawDistributionFloat                       BoundsScaleHorizByDistance;                               // 0x0064(0x0024) (Edit, Component, NeedCtorLink)
	struct FRawDistributionFloat                       BoundsScaleVertByDistance;                                // 0x0088(0x0024) (Edit, Component, NeedCtorLink)
	unsigned long                                      bUseHorizCurveForVert : 1;                                // 0x00AC(0x0004) (Edit)
	float                                              fBaseHorizMultiplier;                                     // 0x00B0(0x0004) (Edit)
	float                                              fBaseVertMultiplier;                                      // 0x00B4(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGameplayCurvesSet_AimAssistBounds");
		return ptr;
	}


	void STATIC_GetBoundsScale(float fDistance, float* fHorizBoundsScale, float* fVertBoundsScale);
};


// Class TgGame.TgGameplayCurvesSet_AimAssistKeyframes
// 0x015B (0x01BC - 0x0061)
class UTgGameplayCurvesSet_AimAssistKeyframes : public UTgGameplayCurvesSet
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0061(0x0003) MISSED OFFSET
	struct FAimAssistKeyframeDebugVals                 DebugVals;                                                // 0x0064(0x0104) (Transient)
	unsigned long                                      bSaveDebugVals : 1;                                       // 0x0168(0x0004) (Transient)
	TArray<class UTgAimAssistKeyframe*>                HorizMagnetKeyframes;                                     // 0x016C(0x0010) (Edit, NeedCtorLink, NoClear, EditInline)
	TArray<class UTgAimAssistKeyframe*>                VertMagnetKeyframes;                                      // 0x017C(0x0010) (Edit, NeedCtorLink, NoClear, EditInline)
	TArray<class UTgAimAssistKeyframe*>                FrictionKeyframes;                                        // 0x018C(0x0010) (Edit, NeedCtorLink, NoClear, EditInline)
	TArray<class UTgAimAssistKeyframe*>                TrackingByAccuracyKeyframes;                              // 0x019C(0x0010) (Edit, NeedCtorLink, NoClear, EditInline)
	TArray<class UTgAimAssistKeyframe*>                TrackingByAngleKeyframes;                                 // 0x01AC(0x0010) (Edit, NeedCtorLink, NoClear, EditInline)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGameplayCurvesSet_AimAssistKeyframes");
		return ptr;
	}


	float STATIC_GetInterpValBetweenFrames(float Time, float inKeyTime, float outKeyTime);
	bool STATIC_GetKeyframeByName(const struct FName& KeyframeName, TArray<class UTgAimAssistKeyframe*>* keyframesToCheck, class UTgAimAssistKeyframe** outKeyframe);
	bool STATIC_GetKeyframesToUse(float Distance, TArray<struct FAimAssistKeyframeData>* keyframeData, TArray<class UTgAimAssistKeyframe*>* keyframesToCheck, class UTgAimAssistKeyframe** keyframe1, class UTgAimAssistKeyframe** keyframe2, float* keyframe1Dist, float* keyframe2Dist);
	float STATIC_GetKeyframeDistributionValue(float T, class UTgAimAssistKeyframe** keyframe);
	float STATIC_GetStrengthScaling(int Strength);
	float STATIC_GetAimAssistValue(float assistValue, float Distance, TArray<struct FAimAssistKeyframeData>* keyframeData, TArray<class UTgAimAssistKeyframe*>* keyframesToCheck);
	void SaveDebugInfo(bool bShouldSave);
	float STATIC_GetVertTrackingValue(float assistValue, float desiredTurnAmtPerSec, float Distance, TArray<struct FAimAssistKeyframeData>* VertTrackingByAccuracyKeyframeData, TArray<struct FAimAssistKeyframeData>* VertTrackingByAngleKeyframeData);
	float STATIC_GetHorizTrackingValue(float assistValue, float desiredTurnAmtPerSec, float Distance, TArray<struct FAimAssistKeyframeData>* HorizTrackingByAccuracyKeyframeData, TArray<struct FAimAssistKeyframeData>* HorizTrackingByAngleKeyframeData);
	float STATIC_GetFrictionValue(float assistValue, float Distance, bool bVertical, int Strength, TArray<struct FAimAssistKeyframeData>* FrictionKeyframeData);
	float STATIC_GetVertMagnetValue(float assistValue, float Distance, int Strength, TArray<struct FAimAssistKeyframeData>* MagnetVertKeyframeData);
	float STATIC_GetHorizMagnetValue(float assistValue, float Distance, int Strength, TArray<struct FAimAssistKeyframeData>* MagnetHorizKeyframeData);
};


// Class TgGame.TgGameplayCurvesSet_AimAssistLocking
// 0x0073 (0x00D4 - 0x0061)
class UTgGameplayCurvesSet_AimAssistLocking : public UTgGameplayCurvesSet
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0061(0x0003) MISSED OFFSET
	struct FRawDistributionFloat                       RelativeLockStrengthHoriz;                                // 0x0064(0x0024) (Edit, Component, NeedCtorLink)
	struct FRawDistributionFloat                       RelativeLockStrengthVert;                                 // 0x0088(0x0024) (Edit, Component, NeedCtorLink)
	struct FRawDistributionFloat                       RelativeLockStrengthByDist;                               // 0x00AC(0x0024) (Edit, Component, NeedCtorLink)
	float                                              fGlobalLockStrength;                                      // 0x00D0(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGameplayCurvesSet_AimAssistLocking");
		return ptr;
	}


	float STATIC_GetAimLockStrengthMultiplier(float fDist, float fBoundPos, bool bIsVert);
};


// Class TgGame.TgGameplayCurvesSet_BulletMagnetOverDist
// 0x004C (0x00AD - 0x0061)
class UTgGameplayCurvesSet_BulletMagnetOverDist : public UTgGameplayCurvesSet
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0061(0x0003) MISSED OFFSET
	struct FRawDistributionFloat                       BulletMagnetDegOverDist;                                  // 0x0064(0x0024) (Edit, Component, NeedCtorLink)
	struct FRawDistributionFloat                       BulletMagnetMaxDegOverDist;                               // 0x0088(0x0024) (Edit, Component, NeedCtorLink)
	TEnumAsByte<EPaladinsBulletMagnetType>             BulletMagnetActiveType;                                   // 0x00AC(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGameplayCurvesSet_BulletMagnetOverDist");
		return ptr;
	}


	float STATIC_GetBulletMagnetStrength(const struct FVector& vCurrent, const struct FVector& vToTarget, float fDist);
};


// Class TgGame.TgGameplayCurvesSet_DamageFalloff
// 0x002B (0x008C - 0x0061)
class UTgGameplayCurvesSet_DamageFalloff : public UTgGameplayCurvesSet
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0061(0x0003) MISSED OFFSET
	struct FRawDistributionFloat                       DamageFalloff;                                            // 0x0064(0x0024) (Edit, Component, NeedCtorLink)
	unsigned long                                      bIsRangeNormalized : 1;                                   // 0x0088(0x0004) (Edit)
	unsigned long                                      bExcludeEffectiveRange : 1;                               // 0x0088(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGameplayCurvesSet_DamageFalloff");
		return ptr;
	}

};


// Class TgGame.TgGameplayCurvesSet_DamageFalloffAOE
// 0x002B (0x008C - 0x0061)
class UTgGameplayCurvesSet_DamageFalloffAOE : public UTgGameplayCurvesSet
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0061(0x0003) MISSED OFFSET
	struct FRawDistributionFloat                       DamageFalloff;                                            // 0x0064(0x0024) (Edit, Component, NeedCtorLink)
	unsigned long                                      bIsRangeNormalized : 1;                                   // 0x0088(0x0004) (Edit)
	unsigned long                                      bExcludeEffectiveRange : 1;                               // 0x0088(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGameplayCurvesSet_DamageFalloffAOE");
		return ptr;
	}

};


// Class TgGame.TgGameplayCurvesSet_HitReactions
// 0x006F (0x00D0 - 0x0061)
class UTgGameplayCurvesSet_HitReactions : public UTgGameplayCurvesSet
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0061(0x0003) MISSED OFFSET
	struct FRawDistributionFloat                       ReactionStrengthOverTime;                                 // 0x0064(0x0024) (Edit, Component, NeedCtorLink)
	struct FRawDistributionFloat                       ReactionStrengthOverTimeDelayed;                          // 0x0088(0x0024) (Edit, Component, NeedCtorLink)
	struct FRawDistributionFloat                       ReactionStrengthByDamage;                                 // 0x00AC(0x0024) (Edit, Component, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGameplayCurvesSet_HitReactions");
		return ptr;
	}

};


// Class TgGame.TgGameplayCurvesSet_PositionFromPitch
// 0x004B (0x00AC - 0x0061)
class UTgGameplayCurvesSet_PositionFromPitch : public UTgGameplayCurvesSet
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0061(0x0003) MISSED OFFSET
	struct FRawDistributionFloat                       ForwardTranslation;                                       // 0x0064(0x0024) (Edit, Component, NeedCtorLink)
	struct FRawDistributionFloat                       UpTranslation;                                            // 0x0088(0x0024) (Edit, Component, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGameplayCurvesSet_PositionFromPitch");
		return ptr;
	}


	struct FVector STATIC_GetTranslationFromPitch(float fPitch);
};


// Class TgGame.TgGameplayCurvesSet_Recoil
// 0x0024 (0x0085 - 0x0061)
class UTgGameplayCurvesSet_Recoil : public UTgGameplayCurvesSet
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0061(0x0003) MISSED OFFSET
	TArray<class UTgRecoilKeyframe*>                   HorizRecoil;                                              // 0x0064(0x0010) (Edit, NeedCtorLink, NoClear, EditInline)
	TArray<class UTgRecoilKeyframe*>                   VertRecoil;                                               // 0x0074(0x0010) (Edit, NeedCtorLink, NoClear, EditInline)
	TEnumAsByte<EPaladinsRecoilType>                   RecoilType;                                               // 0x0084(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGameplayCurvesSet_Recoil");
		return ptr;
	}


	float STATIC_GetInterpValBetweenFrames(float Time, float inKeyTime, float outKeyTime);
	bool STATIC_GetRecoilValue(float firingTime, float randInput, float* recoilAmt, TArray<class UTgRecoilKeyframe*>* keyframesToCheck);
	bool STATIC_GetVertRecoilValue(float firingTime, float randInput, float* recoilAmt);
	bool STATIC_GetHorizRecoilValue(float firingTime, float randInput, float* recoilAmt);
};


// Class TgGame.TgGameplayCurvesSet_RecoilSimple
// 0x009C (0x00FD - 0x0061)
class UTgGameplayCurvesSet_RecoilSimple : public UTgGameplayCurvesSet
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0061(0x0003) MISSED OFFSET
	struct FRawDistributionFloat                       HorizRecoil1;                                             // 0x0064(0x0024) (Edit, Component, NeedCtorLink)
	struct FRawDistributionFloat                       HorizRecoil2;                                             // 0x0088(0x0024) (Edit, Component, NeedCtorLink)
	struct FRawDistributionFloat                       VertRecoil1;                                              // 0x00AC(0x0024) (Edit, Component, NeedCtorLink)
	struct FRawDistributionFloat                       VertRecoil2;                                              // 0x00D0(0x0024) (Edit, Component, NeedCtorLink)
	float                                              GamepadHorizRecoilMultiplier;                             // 0x00F4(0x0004) (Edit)
	float                                              GamepadVertRecoilMultiplier;                              // 0x00F8(0x0004) (Edit)
	TEnumAsByte<EPaladinsRecoilType>                   RecoilType;                                               // 0x00FC(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGameplayCurvesSet_RecoilSimple");
		return ptr;
	}


	float STATIC_GetVertRecoilValue(float firingTime, float randInput);
	float STATIC_GetHorizRecoilValue(float firingTime, float randInput);
};


// Class TgGame.TgGameplayCurvesSet_RecoilVisual
// 0x0093 (0x00F4 - 0x0061)
class UTgGameplayCurvesSet_RecoilVisual : public UTgGameplayCurvesSet
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0061(0x0003) MISSED OFFSET
	struct FRawDistributionFloat                       AngleDistribution;                                        // 0x0064(0x0024) (Edit, Component, NeedCtorLink)
	struct FRawDistributionFloat                       StrengthDegreesByAngleMin;                                // 0x0088(0x0024) (Edit, Component, NeedCtorLink)
	struct FRawDistributionFloat                       StrengthDegreesByAngleMax;                                // 0x00AC(0x0024) (Edit, Component, NeedCtorLink)
	struct FRawDistributionFloat                       RecoilApplicationCurve;                                   // 0x00D0(0x0024) (Edit, Component, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGameplayCurvesSet_RecoilVisual");
		return ptr;
	}


	struct FRotator STATIC_GetRecoilValue(float fRandInput1, float fRandInput2);
};


// Class TgGame.TgGameplayCurvesSet_Simple
// 0x0037 (0x0098 - 0x0061)
class UTgGameplayCurvesSet_Simple : public UTgGameplayCurvesSet
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0061(0x0003) MISSED OFFSET
	struct FRawDistributionFloat                       PrimaryCurve;                                             // 0x0064(0x0024) (Edit, Component, NeedCtorLink)
	struct FName                                       PrimaryCurveTabName;                                      // 0x0088(0x0008) (Const)
	struct FName                                       PrimaryCurveName;                                         // 0x0090(0x0008) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGameplayCurvesSet_Simple");
		return ptr;
	}


	bool STATIC_GetPrimaryDistributionValue(float T, float* Value);
};


// Class TgGame.TgGameplayCurvesSet_TargetAimTracking
// 0x0053 (0x00B4 - 0x0061)
class UTgGameplayCurvesSet_TargetAimTracking : public UTgGameplayCurvesSet
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0061(0x0003) MISSED OFFSET
	TArray<class UTgTargetAimTrackingCurves*>          TargetTrackingCurves;                                     // 0x0064(0x0010) (Edit, NeedCtorLink, NoClear, EditInline)
	struct FTargetAimTrackingDebugVals                 DebugVals;                                                // 0x0074(0x003C) (Transient)
	unsigned long                                      bSaveDebugVals : 1;                                       // 0x00B0(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGameplayCurvesSet_TargetAimTracking");
		return ptr;
	}


	void SaveDebugInfo(bool bShouldSave);
	float STATIC_GetTargetTrackingStrength(float AssistAmt, float desiredTurnAmtPerSec, int TargetTrackingStrength, struct FRawDistributionFloat* StrengthByAccuracyCurve, struct FRawDistributionFloat* StrengthByDesiredAngleCurve);
	float STATIC_GetTargetTrackingPercY(float VertAssistAmt, float DesiredTurnAmt, int CurveSetToUse, int TargetTrackingStrength, float DeltaTime);
	float STATIC_GetTargetTrackingPercX(float HorizAssistAmt, float DesiredTurnAmt, int CurveSetToUse, int TargetTrackingStrength, float DeltaTime);
};


// Class TgGame.TgArmorPiece
// 0x0134 (0x0194 - 0x0060)
class UTgArmorPiece : public UObject
{
public:
	struct FString                                     ParamNameDesaturateCubeMap;                               // 0x0060(0x0010) (NeedCtorLink)
	struct FString                                     ParamNameDissolveColor;                                   // 0x0070(0x0010) (NeedCtorLink)
	struct FString                                     ParamNameFresnelAlpha;                                    // 0x0080(0x0010) (NeedCtorLink)
	struct FString                                     ParamNameFresnelColor;                                    // 0x0090(0x0010) (NeedCtorLink)
	struct FString                                     ParamNameReflectionColor;                                 // 0x00A0(0x0010) (NeedCtorLink)
	TEnumAsByte<EArmorPiece>                           ArmorPiece;                                               // 0x00B0(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x00B1(0x0003) MISSED OFFSET
	float                                              m_CommonDesaturateCubeMap;                                // 0x00B4(0x0004)
	float                                              m_RareDesaturateCubeMap;                                  // 0x00B8(0x0004)
	float                                              m_EpicDesaturateCubeMap;                                  // 0x00BC(0x0004)
	float                                              m_LegendaryDesaturateCubeMap;                             // 0x00C0(0x0004)
	struct FLinearColor                                m_CommonDissolveColor;                                    // 0x00C4(0x0010)
	struct FLinearColor                                m_RareDissolveColor;                                      // 0x00D4(0x0010)
	struct FLinearColor                                m_EpicDissolveColor;                                      // 0x00E4(0x0010)
	struct FLinearColor                                m_LegendaryDissolveColor;                                 // 0x00F4(0x0010)
	float                                              m_CommonFresnelAlpha;                                     // 0x0104(0x0004) (Edit)
	float                                              m_RareFresnelAlpha;                                       // 0x0108(0x0004) (Edit)
	float                                              m_EpicFresnelAlpha;                                       // 0x010C(0x0004) (Edit)
	float                                              m_LegendaryFresnelAlpha;                                  // 0x0110(0x0004) (Edit)
	struct FLinearColor                                m_CommonFresnelColor;                                     // 0x0114(0x0010) (Edit)
	struct FLinearColor                                m_RareFresnelColor;                                       // 0x0124(0x0010) (Edit)
	struct FLinearColor                                m_EpicFresnelColor;                                       // 0x0134(0x0010) (Edit)
	struct FLinearColor                                m_LegendaryFresnelColor;                                  // 0x0144(0x0010) (Edit)
	struct FLinearColor                                m_CommonReflectionColor;                                  // 0x0154(0x0010)
	struct FLinearColor                                m_RareReflectionColor;                                    // 0x0164(0x0010)
	struct FLinearColor                                m_EpicReflectionColor;                                    // 0x0174(0x0010)
	struct FLinearColor                                m_LegendaryReflectionColor;                               // 0x0184(0x0010)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgArmorPiece");
		return ptr;
	}


	void SetReflectionColor(class UMaterialInstanceConstant* pMIC, int nQuality);
	void SetFresnelColor(class UMaterialInstanceConstant* pMIC, int nQuality);
	void SetFresnelAlpha(class UMaterialInstanceConstant* pMIC, int nQuality);
	void SetDissolveColor(class UMaterialInstanceConstant* pMIC, int nQuality);
	void SetDesaturateCubeMap(class UMaterialInstanceConstant* pMIC, int nQuality);
	struct FString STATIC_GetArmorNameFromType(TEnumAsByte<EArmorPiece> ePiece);
};


// Class TgGame.TgRealmArmor
// 0x0050 (0x00B0 - 0x0060)
class UTgRealmArmor : public UObject
{
public:
	class UTgArmorPiece*                               ArmorArmArch;                                             // 0x0060(0x0008) (Edit)
	class UTgArmorPiece*                               ArmorChestArch;                                           // 0x0068(0x0008) (Edit)
	class UTgArmorPiece*                               ArmorHeadArch;                                            // 0x0070(0x0008) (Edit)
	class UTgArmorPiece*                               ArmorLegArch;                                             // 0x0078(0x0008) (Edit)
	float                                              fHeadTransitionTime;                                      // 0x0080(0x0004) (Edit)
	float                                              fChestTransitionTime;                                     // 0x0084(0x0004) (Edit)
	float                                              fArmTransitionTime;                                       // 0x0088(0x0004) (Edit)
	float                                              fLegTransitionTime;                                       // 0x008C(0x0004) (Edit)
	TArray<struct FArmorTransitionInfo>                m_TransitionInfo;                                         // 0x0090(0x0010) (NeedCtorLink)
	class UMaterialInstanceConstant*                   m_pBaseMIC;                                               // 0x00A0(0x0008) (Transient)
	class UMaterialInstanceConstant*                   m_pArmorMIC;                                              // 0x00A8(0x0008) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgRealmArmor");
		return ptr;
	}


	class UTgArmorPiece* STATIC_GetArmorPiece(int nEquipSlot);
	float STATIC_GetTransitionTime(int nEquipSlot);
	struct FName STATIC_GetMaskParameterName(int nEquipSlot);
	void DeactivateArmorMIC(int nEquipSlot, int nQuality);
	void ActiveArmorMIC(int nEquipSlot, int nQuality);
	void UpdateArmorTransition(float fDeltaTime);
	void FadeOutArmor(int nEquipSlot, int nQuality);
	void FadeInArmor(int nEquipSlot, int nQuality);
	void STATIC_OnArmorEquipped(int nEquipSlot, int nQuality);
	void Initialize(class ATgPawn* pPawn);
};


// Class TgGame.TgDevice_AndroxusInhand
// 0x000C (0x0AF8 - 0x0AEC)
class ATgDevice_AndroxusInhand : public ATgDevice
{
public:
	int                                                m_nAndroLeg2StackCount;                                   // 0x0AEC(0x0004)
	float                                              m_fQueueFireTime;                                         // 0x0AF0(0x0004)
	float                                              m_fQueueFireTimeThreshold;                                // 0x0AF4(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_AndroxusInhand");
		return ptr;
	}


	bool STATIC_InterceptLeftMousePressed(class ATgPlayerController* TgController);
	bool CanFireIfLeftMouseDown();
	class UTgGameplayCurvesSet* STATIC_GetShotSpreadTendencyCurvesSet();
};


// Class TgGame.TgDeploy_TurretEffectField
// 0x0018 (0x0494 - 0x047C)
class ATgDeploy_TurretEffectField : public ATgDeploy_EffectField
{
public:
	TArray<class AActor*>                              m_DeployTimePendingTargets;                               // 0x047C(0x0010) (NeedCtorLink)
	class ATgPawn_Turret*                              m_ParentTurret;                                           // 0x048C(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_TurretEffectField");
		return ptr;
	}


	void Tick(float DeltaSeconds);
	void STATIC_OnProxyUnTouch(class AActor* Other);
	void STATIC_OnProxyTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void TouchAllPendingTargets();
};


// Class TgGame.TgDeploy_Exhaust
// 0x0000 (0x07E0 - 0x07E0)
class ATgDeploy_Exhaust : public ATgDeploy_EffectTrail
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_Exhaust");
		return ptr;
	}

};


// Class TgGame.TgDeploy_TurretLinked
// 0x0008 (0x0450 - 0x0448)
class ATgDeploy_TurretLinked : public ATgDeploy_MatchParentFireMode
{
public:
	class ATgPawn_Turret*                              m_ParentTurret;                                           // 0x0448(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_TurretLinked");
		return ptr;
	}


	void Tick(float DeltaSeconds);
};


// Class TgGame.TgDeploy_ShieldBarik
// 0x001C (0x0468 - 0x044C)
class ATgDeploy_ShieldBarik : public ATgDeploy_Shield
{
public:
	unsigned long                                      r_bHasCapsule : 1;                                        // 0x044C(0x0004) (Net)
	unsigned long                                      r_bHasAcceleratorField : 1;                               // 0x044C(0x0004) (Net)
	unsigned long                                      r_bHasImpede : 1;                                         // 0x044C(0x0004) (Net)
	unsigned long                                      r_bHasBunker : 1;                                         // 0x044C(0x0004) (Net)
	unsigned long                                      r_bHasFortify : 1;                                        // 0x044C(0x0004) (Net)
	TArray<class AActor*>                              m_AcceleratedActors;                                      // 0x0450(0x0010) (NeedCtorLink)
	class ATgPawn*                                     m_CachedPawnOwner;                                        // 0x0460(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_ShieldBarik");
		return ptr;
	}


	void STATIC_ActivateOnWhenDeployedFx(bool bOn);
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_ReplicatedEvent(const struct FName& VarName);
	void ToggleLockdownMode(bool bSetActive);
	void ToggleFX();
	void STATIC_SetCullDistance();
};


// Class TgGame.TgDeploy_ShieldBarikDome
// 0x0004 (0x0450 - 0x044C)
class ATgDeploy_ShieldBarikDome : public ATgDeploy_Shield
{
public:
	float                                              m_fTurretSetupTime;                                       // 0x044C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_ShieldBarikDome");
		return ptr;
	}


	void STATIC_DestroyIt(bool bSkipFx);
};


// Class TgGame.TgDevice_RocketBoots
// 0x0000 (0x0B60 - 0x0B60)
class ATgDevice_RocketBoots : public ATgDevice_Charge
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_RocketBoots");
		return ptr;
	}


	bool STATIC_CanBeCanceled(class ATgDevice* NewDevice);
	float STATIC_GetChargeRange();
	float STATIC_GetChargeSpeed();
};


// Class TgGame.TgDevice_Failsafe
// 0x0008 (0x0AF4 - 0x0AEC)
class ATgDevice_Failsafe : public ATgDevice
{
public:
	class ATgDevice*                                   m_RocketBootsDevice;                                      // 0x0AEC(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Failsafe");
		return ptr;
	}


	bool ShouldCooldownAfterFire();
	bool STATIC_StartFire();
};


// Class TgGame.TgDevice_Turret
// 0x001C (0x0B08 - 0x0AEC)
class ATgDevice_Turret : public ATgDevice_Pet
{
public:
	int                                                m_FlameTurretID;                                          // 0x0AEC(0x0004)
	int                                                m_MegaTurretID;                                           // 0x0AF0(0x0004)
	int                                                m_LockdownTurretID;                                       // 0x0AF4(0x0004)
	struct FVector                                     m_SpawnLocationOverride;                                  // 0x0AF8(0x000C)
	unsigned long                                      m_bLockdownIsOn : 1;                                      // 0x0B04(0x0004)
	unsigned long                                      m_bHasFlamethrowerTurret : 1;                             // 0x0B04(0x0004)
	unsigned long                                      m_bHasMegaTurret : 1;                                     // 0x0B04(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Turret");
		return ptr;
	}


	void RevertFiremode();
	void STATIC_ArmLockdownMode(bool bEnable);
	void STATIC_ArmMegaTurretMode(bool bEnable);
	void STATIC_ArmFlamethrowerMode(bool bEnable);
	void STATIC_InterruptOtherDevices(class ATgPawn* TgP);
	int STATIC_GetPetIDOverride(int PetIndex);
	void STATIC_GetCachedAim(struct FAimData* Aim);
	void ToggleLockdownMode();
	void UpgradeActiveTurrets();
};


// Class TgGame.TgDeviceFire_BarricadeDome
// 0x0000 (0x0270 - 0x0270)
class UTgDeviceFire_BarricadeDome : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_BarricadeDome");
		return ptr;
	}


	class ATgPawn* SpawnPet(bool bPet);
};


// Class TgGame.TgDeviceFire_Lockdown
// 0x0000 (0x0270 - 0x0270)
class UTgDeviceFire_Lockdown : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Lockdown");
		return ptr;
	}


	class ATgPawn* SpawnPet(bool bPet);
};


// Class TgGame.TgDeviceFire_Turret
// 0x0000 (0x0270 - 0x0270)
class UTgDeviceFire_Turret : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Turret");
		return ptr;
	}


	class ATgPawn* SpawnPet(bool bPet);
};


// Class TgGame.TgDeviceFire_TurretShot
// 0x0000 (0x0270 - 0x0270)
class UTgDeviceFire_TurretShot : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_TurretShot");
		return ptr;
	}


	bool STATIC_IsValidTarget(class AActor* P, TEnumAsByte<EDeviceTargeterType> eTargeterType, bool bIgnoreHealth, bool bInvertTeam);
};


// Class TgGame.TgDeploy_GeometryBarrierTank
// 0x0040 (0x04B0 - 0x0470)
class ATgDeploy_GeometryBarrierTank : public ATgDeploy_Geometry
{
public:
	class ATgPawn_BarrierTank*                         m_CachedInaraPawn;                                        // 0x0470(0x0008)
	class UMeshComponent*                              m_CenterMesh;                                             // 0x0478(0x0008) (ExportObject, Component, EditInline)
	class UMeshComponent*                              m_LeftMeshes[0x2];                                        // 0x0480(0x0008) (ExportObject, Component, EditInline)
	class UMeshComponent*                              m_RightMeshes[0x2];                                       // 0x0490(0x0008) (ExportObject, Component, EditInline)
	int                                                m_WallMeshIDCenter;                                       // 0x04A0(0x0004)
	int                                                m_WallMeshIDEndCap;                                       // 0x04A4(0x0004)
	unsigned long                                      r_bGrowthModeActivationSignal : 1;                        // 0x04A8(0x0004) (Net)
	unsigned long                                      m_bInGrowthMode : 1;                                      // 0x04A8(0x0004)
	unsigned long                                      m_bDidInitialHit : 1;                                     // 0x04A8(0x0004)
	unsigned long                                      r_bEarthenGuardActive : 1;                                // 0x04A8(0x0004) (Net)
	unsigned long                                      r_bHasAlpine : 1;                                         // 0x04A8(0x0004) (Net)
	float                                              m_fGrowStartTime;                                         // 0x04AC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_GeometryBarrierTank");
		return ptr;
	}


	void STATIC_DestroyIt(bool bSkipFx);
	void DeployComplete();
	void STATIC_ActivateDisplayGroups(const struct FName& DisplayGroup, bool bActivateIndependent, bool bTurnOn);
	void STATIC_RemoveBasedPawn(class ATgPawn* basedPawn);
	void STATIC_AddBasedPawn(class ATgPawn* basedPawn);
	void STATIC_ReplicatedEvent(const struct FName& VarName);
	bool STATIC_HasCachedInaraPawn();
	struct FVector STATIC_GetSegmentWorldLocation(const struct FVector& vLocalLocation);
	void PushOverlappingActors(float DeltaSeconds);
	void DoInitialHit();
	void PushBasedActors();
	void ToggleGrowthMode(bool bTurnOn);
	void SignalGrowthModeStart();
	void STATIC_InitializeMeshSegment(class UMeshComponent* Mesh, float fOffset);
	void SpawnMeshSegments();
};


// Class TgGame.TgDeploy_WardersField
// 0x000C (0x0488 - 0x047C)
class ATgDeploy_WardersField : public ATgDeploy_EffectField
{
public:
	float                                              r_fRadiusForFX;                                           // 0x047C(0x0004) (Net)
	float                                              r_fRadiusScaleForDecal;                                   // 0x0480(0x0004) (Net)
	unsigned long                                      r_bEarthenGuardActive : 1;                                // 0x0484(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_WardersField");
		return ptr;
	}


	void STATIC_ScaleAbilityFX();
	void STATIC_ReplicatedEvent(const struct FName& VarName);
};


// Class TgGame.TgDevice_BarrierTankInhand
// 0x0038 (0x0B24 - 0x0AEC)
class ATgDevice_BarrierTankInhand : public ATgDevice
{
public:
	struct FPointer                                    VfTable_ITgDeviceInterface_MoveSpeedMultiplier;           // 0x0AEC(0x0008) (Const, Native, NoExport)
	class ATgPawn_BarrierTank*                         m_CachedBarrierTankPawn;                                  // 0x0AF4(0x0008)
	struct FVector                                     m_vProjectileSpawnOffset2;                                // 0x0AFC(0x000C)
	struct FVector                                     m_vProjectileSpawnOffset3;                                // 0x0B08(0x000C)
	struct FScriptDelegate                             __InterruptFiringDelegate__Delegate;                      // 0x0B14(0x000C) (NeedCtorLink)
	unsigned char                                      UnknownData00[0x4];                                       // 0x0B14(0x0004) FIX WRONG TYPE SIZE OF PREVIOUS PROPERTY

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_BarrierTankInhand");
		return ptr;
	}


	void SelfSlowTimer();
	void STATIC_LinkedDeviceUnequipped(class ATgDevice* Dev);
	void STATIC_LinkedDeviceEquipped(class ATgDevice* Dev);
	void STATIC_InterruptFiringDelegate();
	void STATIC_InterruptLockoutTime();
	bool STATIC_HasCachedBarrierTankPawn();
	float STATIC_GetMoveSpeedMultiplier();
	bool CanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, TEnumAsByte<EDeviceFailType>* failType);
};


// Class TgGame.TgDevice_GeometryBarrierTank
// 0x0008 (0x0AF4 - 0x0AEC)
class ATgDevice_GeometryBarrierTank : public ATgDevice
{
public:
	float                                              r_fTremorsCooldownReduction;                              // 0x0AEC(0x0004) (Net)
	float                                              m_fCachedWallHealthPercent;                               // 0x0AF0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_GeometryBarrierTank");
		return ptr;
	}


	int STATIC_GetAimAssistPriority();
	bool STATIC_CanBeCanceled(class ATgDevice* NewDevice);
	bool ShouldLockFiring(class ATgDevice* Current);
	void STATIC_OnDeployableDestroyed(class ATgDeployable* deployable);
	void STATIC_OnDeployableSpawned(class ATgDeployable* deployable);
	bool STATIC_CanFireWithoutAimResult();
	void ServerEndCustomTargeting();
	void STATIC_EndCustomTargeting();
	bool STATIC_InterceptLeftMousePressed(class ATgPlayerController* TgController);
	bool STATIC_InterceptSlotReleased(class ATgPlayerController* TgController);
	bool STATIC_InterceptSlotPressed(class ATgPlayerController* TgController);
	void UpdateTargetingModeStatus(struct FAimData* Aim);
	bool ShouldAltFireOnTick();
	void STATIC_GetGroundTargetAim(struct FAimData* Aim);
};


// Class TgGame.TgDevice_ImpasseMod
// 0x0000 (0x0AEC - 0x0AEC)
class ATgDevice_ImpasseMod : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_ImpasseMod");
		return ptr;
	}

};


// Class TgGame.TgDeviceForm_GeometryBarrierTank
// 0x0000 (0x02BC - 0x02BC)
class UTgDeviceForm_GeometryBarrierTank : public UTgDeviceForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_GeometryBarrierTank");
		return ptr;
	}


	void UpdateTargetingModeStatusForFX(class UTgSpecialFx* Fx, TEnumAsByte<ETargetingModeStatus> Status, struct FAimData* Aim);
	void UpdateTargetingModeLocation(const struct FVector& NewLocation, const struct FRotator& NewRotation, float DistanceScale);
};


// Class TgGame.TgInvListener_Tremors
// 0x0000 (0x00CC - 0x00CC)
class UTgInvListener_Tremors : public UTgInventoryObject_Listen_ActiveWhileOffCooldown
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_Tremors");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_EarthenGuard
// 0x0000 (0x00C8 - 0x00C8)
class UTgInventoryObject_Listen_EarthenGuard : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_EarthenGuard");
		return ptr;
	}


	bool STATIC_IsValidDeployable(class ATgDeployable* deployable);
};


// Class TgGame.TgInvListener_ImpasseEffect
// 0x0000 (0x00C8 - 0x00C8)
class UTgInvListener_ImpasseEffect : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_ImpasseEffect");
		return ptr;
	}

};


// Class TgGame.TgPawn_BarrierTank
// 0x0080 (0x318C - 0x310C)
class ATgPawn_BarrierTank : public ATgPawn_Character
{
public:
	struct FWallPlacementInfo                          m_WallPlacementInfos[0x5];                                // 0x310C(0x0010)
	struct FVector                                     m_vSegmentExtent;                                         // 0x315C(0x000C) (Const)
	struct FVector                                     m_vOpenSpotExtent;                                        // 0x3168(0x000C) (Const)
	float                                              m_fWallTraceDownDistance;                                 // 0x3174(0x0004) (Const)
	float                                              m_fWallOpenSpotTolerance;                                 // 0x3178(0x0004) (Const)
	float                                              m_fInitialWallScaleZ;                                     // 0x317C(0x0004) (Const)
	unsigned long                                      r_bInGaeBolg : 1;                                         // 0x3180(0x0004) (Net)
	unsigned long                                      m_bUseGaeBolgRetrieve : 1;                                // 0x3180(0x0004)
	float                                              m_fGaeBolgJumpZModifier;                                  // 0x3184(0x0004)
	int                                                r_nInhandAmmoRemaining;                                   // 0x3188(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_BarrierTank");
		return ptr;
	}


	void SetTargetingDevice(class ATgDevice* Dev, const struct FWeaponMeshSwapStrategy& SwapStrategy);
	void STATIC_OnStartTimelapseNewDeviceState();
	bool DoJump(bool bUpdating, float JumpZSpeed);
	float STATIC_GetJumpSpeedMultiplier();
	void EndGaeBolg();
	void StartGaeBolg(float fJumpZMultiplier);
	void UpdateWallPlacementInfos(const struct FVector& OriginLocation, const struct FRotator& originRotation);
};


// Class TgGame.TgDeploy_BombKingStickyBomb
// 0x0084 (0x04CC - 0x0448)
class ATgDeploy_BombKingStickyBomb : public ATgDeployable
{
public:
	unsigned long                                      r_bDetonated : 1;                                         // 0x0448(0x0004) (Net)
	unsigned long                                      c_bSuppressExplosion : 1;                                 // 0x0448(0x0004)
	unsigned long                                      r_bShouldDetach : 1;                                      // 0x0448(0x0004) (Net)
	class ATgPawn_Character*                           r_StuckPlayer;                                            // 0x044C(0x0008) (Net)
	struct FName                                       m_StuckSocket;                                            // 0x0454(0x0008)
	class ATgPawn_Character*                           m_CachedPlayer;                                           // 0x045C(0x0008)
	struct FVector                                     r_HitNormal;                                              // 0x0464(0x000C) (Net)
	float                                              m_fCachedCollisionRadius;                                 // 0x0470(0x0004)
	float                                              m_fCachedCollisionHeight;                                 // 0x0474(0x0004)
	class UTgSpecialFx*                                m_GetStuckFx;                                             // 0x0478(0x0008)
	class UTgSpecialFx*                                m_StickOtherFx;                                           // 0x0480(0x0008)
	struct FRotator                                    r_StuckRotation;                                          // 0x0488(0x000C) (Net)
	struct FVector                                     r_CartOffset;                                             // 0x0494(0x000C) (Net)
	class ATgDeployable*                               r_StuckGeometry;                                          // 0x04A0(0x0008) (Net)
	int                                                r_nOriginalProjectileID;                                  // 0x04A8(0x0004) (Net)
	float                                              r_fFXDamageRadius;                                        // 0x04AC(0x0004) (Net)
	float                                              r_fFXEffectiveRadius;                                     // 0x04B0(0x0004) (Net)
	class ATgCollisionProxy*                           m_CollisionProxy;                                         // 0x04B4(0x0008)
	TArray<class ATgPawn_Character*>                   m_PendingCollisions;                                      // 0x04BC(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_BombKingStickyBomb");
		return ptr;
	}


	void ProcessPendingCollisions();
	bool ProcessCollision(class ATgPawn_Character* TargetChar);
	void STATIC_ProxyUnTouch(class AActor* Other);
	void STATIC_ProxyTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void CheckHideHUDOverlay();
	void STATIC_InstantFireDeployable();
	void STATIC_ExplodeOnShield();
	void Landed(const struct FVector& HitNormal, class AActor* FloorActor);
	void Tick(float DeltaSeconds);
	void StickToPlayerSocket();
	void STATIC_Check1PHide();
	void STATIC_DetachFromPlayer();
	void DetachTimer();
	void STATIC_TakeDamage(int Damage, class AController* EventInstigator, const struct FVector& HitLocation, const struct FVector& Momentum, class UClass* DamageType, const struct FTraceHitInfo& HitInfo, class AActor* DamageCauser);
	void STATIC_DestroyIt(bool bSkipFx);
	void STATIC_HideSpawningProjectile();
	void STATIC_ReplicatedEvent(const struct FName& VarName);
};


// Class TgGame.TgDeploy_PoppyBomb
// 0x0038 (0x0480 - 0x0448)
class ATgDeploy_PoppyBomb : public ATgDeployable
{
public:
	unsigned long                                      r_bDetonated : 1;                                         // 0x0448(0x0004) (Net)
	class ATgPawn_Character*                           m_CachedPlayer;                                           // 0x044C(0x0008)
	struct FVector                                     r_HitNormal;                                              // 0x0454(0x000C) (Net)
	float                                              m_fCachedCollisionRadius;                                 // 0x0460(0x0004)
	float                                              m_fCachedCollisionHeight;                                 // 0x0464(0x0004)
	struct FRotator                                    r_StuckRotation;                                          // 0x0468(0x000C) (Net)
	struct FVector                                     r_CartOffset;                                             // 0x0474(0x000C) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_PoppyBomb");
		return ptr;
	}


	void STATIC_ExplodeOnShield();
	void Landed(const struct FVector& HitNormal, class AActor* FloorActor);
	void STATIC_DestroyIt(bool bSkipFx);
	void STATIC_ReplicatedEvent(const struct FName& VarName);
};


// Class TgGame.TgDevice_KingBomb
// 0x0004 (0x0B64 - 0x0B60)
class ATgDevice_KingBomb : public ATgDevice_Charge
{
public:
	float                                              m_fEndFireZoomDurationOverride;                           // 0x0B60(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_KingBomb");
		return ptr;
	}


	struct FImpactInfo CalcWeaponFire(const struct FAimData& Aim, TArray<struct FImpactInfo>* ImpactList);
	bool ShouldLockFiring(class ATgDevice* Current);
	void ApplyPostExplodeKnockback();
	void STATIC_OutroLockoutTime();
	void FireAmmunition();
	bool STATIC_CanBeCanceled(class ATgDevice* NewDevice);
	float STATIC_GetChargeRange();
	float STATIC_GetChargeSpeed();
	bool ShouldInstigatorCollideWith(class AActor* Other);
};


// Class TgGame.TgDevice_GrumpyBomb
// 0x0004 (0x0AF0 - 0x0AEC)
class ATgDevice_GrumpyBomb : public ATgDevice
{
public:
	float                                              m_fPostTargetingLockInDuration;                           // 0x0AEC(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_GrumpyBomb");
		return ptr;
	}


	void PostTargetingLockIn();
	bool CanToggleTargetingOff();
	bool STATIC_CanBeInterrupted();
	bool ShouldInterruptReloadOnBeginTargeting();
	void PutAway();
	bool STATIC_InterceptRightMousePressed(class ATgPlayerController* TgController);
};


// Class TgGame.TgDevice_PoppyBomb
// 0x0004 (0x0AF0 - 0x0AEC)
class ATgDevice_PoppyBomb : public ATgDevice
{
public:
	unsigned long                                      r_bHasActiveProjectile : 1;                               // 0x0AEC(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_PoppyBomb");
		return ptr;
	}


	bool Use();
	void PlayPoppyDetonateAnim();
	void STATIC_HandleDeviceFormStartFire(int nDeviceModeNum, float fRefireTime, struct FAimData* Aim);
	void ServerDetonatePoppyBomb();
	void DetonatePoppyBomb();
	bool STATIC_HasActivePoppyBomb();
	bool ShouldCooldownAfterFire();
	void UpdateActiveProjectiles(class ATgProjectile* Proj);
	bool CanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, TEnumAsByte<EDeviceFailType>* failType);
};


// Class TgGame.TgInvListener_Demolition
// 0x0000 (0x00D4 - 0x00D4)
class UTgInvListener_Demolition : public UTgInventoryObject_Listen_HitWithDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_Demolition");
		return ptr;
	}

};


// Class TgGame.TgProj_GrumpyBomb
// 0x0010 (0x057C - 0x056C)
class ATgProj_GrumpyBomb : public ATgProj_FreeGrenade
{
public:
	class UTgSilhouetteComponent*                      m_Silhouette;                                             // 0x056C(0x0008) (ExportObject, Component, EditInline)
	unsigned long                                      m_bSilhouetteInitialized : 1;                             // 0x0574(0x0004)
	unsigned long                                      m_bSilhouetteAllowed : 1;                                 // 0x0574(0x0004)
	float                                              m_fPostLandDurationAccelerant;                            // 0x0578(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_GrumpyBomb");
		return ptr;
	}


	void STATIC_ProxyUnTouch(class AActor* Other);
	void STATIC_ProxyTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	bool STATIC_CheckTeamPassThrough(class AActor* Other);
	void StartLandExplodeTimer();
	float STATIC_GetPostLandDuration();
	bool STATIC_IsAccelerantEquipped();
	void CheckShowOutline();
	void STATIC_ReplicatedEvent(const struct FName& VarName);
	void STATIC_InitializeSilhouetteComponent();
};


// Class TgGame.TgProj_PoppyBomb
// 0x0000 (0x056C - 0x056C)
class ATgProj_PoppyBomb : public ATgProj_FreeGrenade
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_PoppyBomb");
		return ptr;
	}


	bool STATIC_CheckTeamPassThrough(class AActor* Other);
	void PlayHitTargetFX(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal, bool bExploded);
	void STATIC_PlayHitWallExplosionFX(const struct FVector& HitNormal, const struct FVector& HitLocation);
	bool STATIC_ApplyHit(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal, int HitItem);
	void AltFireDetonate();
	class ATgDeployable* SpawnDeployable(const struct FVector& vLocation, class AActor* TargetActor, const struct FVector& vNormal);
};


// Class TgGame.TgDeviceFire_HeroicLeap
// 0x0000 (0x0270 - 0x0270)
class UTgDeviceFire_HeroicLeap : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_HeroicLeap");
		return ptr;
	}


	bool STATIC_IgnoreTargetForBlocking(class AActor* Target);
};


// Class TgGame.TgDevice_BlastShot
// 0x0000 (0x0AEC - 0x0AEC)
class ATgDevice_BlastShot : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_BlastShot");
		return ptr;
	}


	void STATIC_ScaleAbilityRadius();
};


// Class TgGame.TgDevice_Scout
// 0x002C (0x0B18 - 0x0AEC)
class ATgDevice_Scout : public ATgDevice
{
public:
	class ATgPawn*                                     m_CachedPawnOwner;                                        // 0x0AEC(0x0008)
	TArray<class ATgPawn*>                             m_AlliesScouted;                                          // 0x0AF4(0x0010) (NeedCtorLink)
	TArray<class ATgPawn*>                             m_EnemiesScouted;                                         // 0x0B04(0x0010) (NeedCtorLink)
	float                                              m_fScoutRefreshTime;                                      // 0x0B14(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Scout");
		return ptr;
	}


	bool ShouldLockFiring(class ATgDevice* Current);
	void ClearScoutTargets();
	void TickScout();
};


// Class TgGame.TgDevice_Somersault
// 0x0008 (0x0AF4 - 0x0AEC)
class ATgDevice_Somersault : public ATgDevice
{
public:
	class ATgDevice*                                   m_DodgeRollDevice;                                        // 0x0AEC(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Somersault");
		return ptr;
	}


	bool ShouldCooldownAfterFire();
	bool STATIC_StartFire();
};


// Class TgGame.TgInventoryObject_Listen_BigGame
// 0x000C (0x00D4 - 0x00C8)
class UTgInventoryObject_Listen_BigGame : public UTgInvListener
{
public:
	float                                              m_fDisengageHitTime;                                      // 0x00C8(0x0004)
	class AActor*                                      m_DisengageHitTarget;                                     // 0x00CC(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_BigGame");
		return ptr;
	}

};


// Class TgGame.TgProj_BlastShot
// 0x0000 (0x051C - 0x051C)
class ATgProj_BlastShot : public ATgProj_Simulated
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_BlastShot");
		return ptr;
	}


	void STATIC_GetExplosionFXParams(TArray<struct FParticleSysParam>* Params);
};


// Class TgGame.TgDeploy_DemonTeleport
// 0x0000 (0x0448 - 0x0448)
class ATgDeploy_DemonTeleport : public ATgDeployable
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_DemonTeleport");
		return ptr;
	}

};


// Class TgGame.TgDevice_Uppercut
// 0x0000 (0x0B60 - 0x0B60)
class ATgDevice_Uppercut : public ATgDevice_Charge
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Uppercut");
		return ptr;
	}


	void UpdateOutroLockoutTime();
	bool STATIC_CanBeInterrupted();
	void STATIC_DeliverHit(const struct FImpactInfo& Impact);
	struct FRotator STATIC_GetChargeDirection();
	void STATIC_GetTargetingAim(struct FAimData* Aim);
};


// Class TgGame.TgDevice_DemonTeleport
// 0x0024 (0x0B10 - 0x0AEC)
class ATgDevice_DemonTeleport : public ATgDevice
{
public:
	struct FPointer                                    VfTable_ITgDeviceInterface_MoveSpeedMultiplier;           // 0x0AEC(0x0008) (Const, Native, NoExport)
	unsigned long                                      m_bShouldDestroyDeployable : 1;                           // 0x0AF4(0x0004)
	unsigned long                                      m_bCancelled : 1;                                         // 0x0AF4(0x0004)
	unsigned long                                      m_bPhaseApplied : 1;                                      // 0x0AF4(0x0004)
	unsigned long                                      m_bAllowTeleport : 1;                                     // 0x0AF4(0x0004)
	float                                              m_fTeleportDelayTimer;                                    // 0x0AF8(0x0004)
	struct FVector                                     m_vTeleportToLocation;                                    // 0x0AFC(0x000C)
	class UTgSpecialFx*                                pTeleportFx;                                              // 0x0B08(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_DemonTeleport");
		return ptr;
	}


	void STATIC_OnDeployableDestroyed(class ATgDeployable* deployable);
	void TeleportAlmostFinished();
	void STATIC_OnDeployableSpawned(class ATgDeployable* deployable);
	void ClientConfirmTelportToLocation(const struct FVector& vTeleportToLocation);
	void DeviceShutDown(bool bDeactiveMode, bool bResetCooldowns);
	float STATIC_GetCustomTimerBarMaxTime();
	float STATIC_GetCustomTimerBarCurrentTime();
	void FinishPhaseIn();
	void StartPhaseIn();
	void TeleportToDeployable(const struct FVector& vDest);
	void ServerTeleportToDeployable(const struct FVector& vDest);
	void STATIC_DoTeleport();
	bool STATIC_CanTeleportNow();
	bool ShouldLockFiring(class ATgDevice* Current);
	bool STATIC_CanBeCanceled(class ATgDevice* NewDevice);
	bool STATIC_CanBeInterrupted();
	bool STATIC_InterceptSlotPressed(class ATgPlayerController* TgController);
	bool STATIC_CanFiringBeCanceledByLeftMouse();
	bool ShouldCancelSprint();
	bool ShouldCooldownAfterFire();
	bool ShouldTeleportOnTimeout();
	bool STATIC_IsDeviceFiringForUI();
	bool ShouldForce3P(class UTgDeviceForm* DeviceForm, bool bOnlyCheckDeviceForm);
	float STATIC_GetMoveSpeedMultiplier();
};


// Class TgGame.TgDevice_Telepunch
// 0x0034 (0x0B20 - 0x0AEC)
class ATgDevice_Telepunch : public ATgDevice
{
public:
	struct FPointer                                    VfTable_ITgDeviceInterface_MoveSpeedMultiplier;           // 0x0AEC(0x0008) (Const, Native, NoExport)
	class ATgPawn_Character*                           m_HitCharacter;                                           // 0x0AF4(0x0008)
	unsigned long                                      m_bLiftApplied : 1;                                       // 0x0AFC(0x0004)
	unsigned long                                      m_bStealthApplied : 1;                                    // 0x0AFC(0x0004)
	float                                              m_fLerpTime;                                              // 0x0B00(0x0004)
	struct FVector                                     m_vHitCharacterInitialLocation;                           // 0x0B04(0x000C)
	float                                              m_fHorizontalHitMaxDist;                                  // 0x0B10(0x0004)
	float                                              m_fVerticalHitMaxDist;                                    // 0x0B14(0x0004)
	float                                              m_fTeleportPreferedDistance;                              // 0x0B18(0x0004)
	float                                              m_fTargetLockTime;                                        // 0x0B1C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Telepunch");
		return ptr;
	}


	bool ShouldRemoveLift();
	bool STATIC_IsTargetInRangeToHit();
	void AbortTelepunch();
	void STATIC_OnInterruptEvent();
	void ConfirmTelepunchTarget();
	void ApplySlam(class ATgPawn_Character* Target);
	void DelayedSlam();
	void RemoveTravelStealth(class ATgPawn_Character* Target);
	void ApplyTravelStealth(class ATgPawn_Character* Target);
	void RemoveLift(class ATgPawn_Character* Target);
	void ApplyLift(class ATgPawn_Character* Target);
	void PostTeleportLockOut();
	bool STATIC_IsPostTeleportLockOutActive();
	void PostTeleportPreHit();
	bool STATIC_IsPostTeleportPreHitActive();
	bool ShouldLockFiring(class ATgDevice* Current);
	void ResetPostHitDelay();
	void ClientLerpToTarget(class ATgPawn_Character* Target, const struct FVector& vTargetLocation, float fLerpTime);
	void AltFirePostHitDelay();
	void FadeOutUltFx();
	void STATIC_LerpToTarget(class ATgPawn_Character* Target, const struct FVector& vTargetLocation, float fLerpTime);
	float STATIC_GetLerpToTargetTime(const struct FVector& vTargetLocation);
	void STATIC_DeliverHit(const struct FImpactInfo& Impact);
	struct FImpactInfo CalcWeaponFire(const struct FAimData& Aim, TArray<struct FImpactInfo>* ImpactList);
	bool STATIC_HasCachedDemon();
	bool ShouldConsumePowerPoolOnStartFire();
	float STATIC_GetMoveSpeedMultiplier();
	bool ShouldForce3P(class UTgDeviceForm* DeviceForm, bool bOnlyCheckDeviceForm);
	bool CanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, TEnumAsByte<EDeviceFailType>* failType);
	float STATIC_GetRequiredEnergyToFire();
};


// Class TgGame.TgDevice_WarpStep
// 0x0004 (0x0AF0 - 0x0AEC)
class ATgDevice_WarpStep : public ATgDevice
{
public:
	unsigned long                                      m_bRolledBackward : 1;                                    // 0x0AEC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_WarpStep");
		return ptr;
	}


	void FireAmmunition();
	struct FRotator STATIC_GetChargeDirection();
	bool ShouldInterruptReloadOnFire();
	bool ShouldTreatAmmoAsCharges();
	bool STATIC_IsInfiniteFireDevice();
};


// Class TgGame.TgDeviceFire_DemonTeleport
// 0x0000 (0x0270 - 0x0270)
class UTgDeviceFire_DemonTeleport : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_DemonTeleport");
		return ptr;
	}


	bool STATIC_GetDeployLocationAndRotation(struct FVector* OutLocation, struct FRotator* OutRotation);
};


// Class TgGame.TgDeviceFire_Telepunch
// 0x0000 (0x0270 - 0x0270)
class UTgDeviceFire_Telepunch : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Telepunch");
		return ptr;
	}

};


// Class TgGame.TgDeviceFire_Uppercut
// 0x0000 (0x0270 - 0x0270)
class UTgDeviceFire_Uppercut : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Uppercut");
		return ptr;
	}

};


// Class TgGame.TgDeviceForm_DemonTeleport
// 0x0020 (0x02DC - 0x02BC)
class UTgDeviceForm_DemonTeleport : public UTgDeviceForm
{
public:
	TArray<class UTgAnimBlendByPaladinsCharacter*>     m_DemonNodes3p;                                           // 0x02BC(0x0010) (NeedCtorLink)
	TArray<class UTgAnimBlendByPaladinsCharacter*>     m_DemonNodes1p;                                           // 0x02CC(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_DemonTeleport");
		return ptr;
	}


	void STATIC_Generic1(unsigned char byExtraData);
	void CacheAnimNode3P(class UAnimNode* Node);
	void ClearAnimNodes3P();
};


// Class TgGame.TgDeviceForm_Uppercut
// 0x0000 (0x02BC - 0x02BC)
class UTgDeviceForm_Uppercut : public UTgDeviceForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Uppercut");
		return ptr;
	}


	void SpawnAoeFx(const struct FVector& vLocation, const struct FVector& vDirection);
	void STATIC_Generic1(unsigned char byExtraData);
};


// Class TgGame.TgInvListener_BloodSense
// 0x0000 (0x00CC - 0x00CC)
class UTgInvListener_BloodSense : public UTgInventoryObject_Listen_ActiveWhileOffCooldown
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_BloodSense");
		return ptr;
	}

};


// Class TgGame.TgProj_DemonTeleport
// 0x0004 (0x0520 - 0x051C)
class ATgProj_DemonTeleport : public ATgProj_Simulated
{
public:
	unsigned long                                      m_bStopped : 1;                                           // 0x051C(0x0004)
	unsigned long                                      m_bTriggerExplosion : 1;                                  // 0x051C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_DemonTeleport");
		return ptr;
	}


	void StopMoving(const struct FVector& NewLocation);
	void RangeReached();
	void STATIC_ExplodeOnTarget(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void HitWall(const struct FVector& HitNormal, class AActor* Wall, class UPrimitiveComponent* WallComp);
	bool STATIC_ApplyHit(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal, int HitItem);
};


// Class TgGame.TgProj_Telepunch
// 0x0000 (0x051C - 0x051C)
class ATgProj_Telepunch : public ATgProj_Simulated
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Telepunch");
		return ptr;
	}


	void STATIC_ExplodeOnTarget(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal);
};


// Class TgGame.TgDevice_Booster
// 0x0000 (0x0AEC - 0x0AEC)
class ATgDevice_Booster : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Booster");
		return ptr;
	}


	bool STATIC_IsToggleDevice();
	bool STATIC_CanBeInterrupted();
	bool STATIC_CanBeCanceled(class ATgDevice* NewDevice);
	bool ShouldLockFiring(class ATgDevice* Current);
	bool CanBeCrippled();
};


// Class TgGame.TgDevice_Thrust
// 0x0000 (0x0B60 - 0x0B60)
class ATgDevice_Thrust : public ATgDevice_Charge
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Thrust");
		return ptr;
	}


	bool ShouldInterruptReloadOnFire();
	float STATIC_GetChargeRange();
	bool ShouldLockFiring(class ATgDevice* Current);
	bool ShouldTreatAmmoAsCharges();
	bool STATIC_IsInfiniteFireDevice();
	void STATIC_GetTargetingAim(struct FAimData* Aim);
};


// Class TgGame.TgDevice_DragonSlam
// 0x0014 (0x0B00 - 0x0AEC)
class ATgDevice_DragonSlam : public ATgDevice
{
public:
	unsigned long                                      m_bHasHitTarget : 1;                                      // 0x0AEC(0x0004)
	class ATgCollisionProxy_Cylinder*                  m_CollisionProxy;                                         // 0x0AF0(0x0008)
	class ATgDevice*                                   m_DrogozLeg1;                                             // 0x0AF8(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_DragonSlam");
		return ptr;
	}


	bool ShouldMountCancelFiring();
	bool ShouldLockFiring(class ATgDevice* Current);
	bool STATIC_CanBeCanceled(class ATgDevice* NewDevice);
	void FireAmmunition();
	void SpawnCollisionProxy();
	void Destroyed();
	void RefundEnergy();
	void ServerImpactTarget(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void ClientImpactTarget();
	void STATIC_OnProxyTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void CustomFire();
	bool STATIC_InterceptRightMousePressed(class ATgPlayerController* TgController);
	bool STATIC_HasDrogozLeg1();
};


// Class TgGame.TgDevice_DrogozInhand
// 0x0024 (0x0B10 - 0x0AEC)
class ATgDevice_DrogozInhand : public ATgDevice
{
public:
	class ATgDevice*                                   m_DrogozLeg2;                                             // 0x0AEC(0x0008)
	struct FVector                                     m_vSalvoProjectileSpawnOffset;                            // 0x0AF4(0x000C)
	unsigned long                                      m_bStartedSalvo : 1;                                      // 0x0B00(0x0004)
	class ATgDevice*                                   m_SalvoDevice;                                            // 0x0B04(0x0008)
	int                                                m_nSalvoRockets;                                          // 0x0B0C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_DrogozInhand");
		return ptr;
	}


	bool CanFiringBeLocked();
	bool ShouldAutoFire();
};


// Class TgGame.TgDevice_Survival
// 0x0008 (0x0AF4 - 0x0AEC)
class ATgDevice_Survival : public ATgDevice
{
public:
	class ATgDevice*                                   m_ThrustDevice;                                           // 0x0AEC(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Survival");
		return ptr;
	}


	bool ShouldCooldownAfterFire();
	bool STATIC_StartFire();
};


// Class TgGame.TgDevice_WYRMJets
// 0x0010 (0x0AFC - 0x0AEC)
class ATgDevice_WYRMJets : public ATgDevice
{
public:
	struct FPointer                                    VfTable_ITgDeviceInterface_MoveSpeedMultiplier;           // 0x0AEC(0x0008) (Const, Native, NoExport)
	class ATgDevice*                                   m_CachedBoosterDevice;                                    // 0x0AF4(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_WYRMJets");
		return ptr;
	}


	void STATIC_LinkedDeviceUnequipped(class ATgDevice* Dev);
	void STATIC_LinkedDeviceEquipped(class ATgDevice* Dev);
	float STATIC_GetMoveSpeedMultiplier();
};


// Class TgGame.TgDeviceFire_DrogozInhand
// 0x0000 (0x0270 - 0x0270)
class UTgDeviceFire_DrogozInhand : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_DrogozInhand");
		return ptr;
	}


	bool CheckValidTarget(class AActor* Target, bool bPredicting);
};


// Class TgGame.TgInvListener_Combustible
// 0x0000 (0x00CC - 0x00CC)
class UTgInvListener_Combustible : public UTgInventoryObject_Listen_ActiveWhileOffCooldown
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_Combustible");
		return ptr;
	}

};


// Class TgGame.TgInvListener_Dragonskin
// 0x0000 (0x00CC - 0x00CC)
class UTgInvListener_Dragonskin : public UTgInventoryObject_Listen_ActiveWhileOffCooldown
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_Dragonskin");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Spitfire
// 0x0000 (0x00C8 - 0x00C8)
class UTgInventoryObject_Listen_Spitfire : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Spitfire");
		return ptr;
	}

};


// Class TgGame.TgProj_DrogozRocket
// 0x0004 (0x0520 - 0x051C)
class ATgProj_DrogozRocket : public ATgProj_Simulated
{
public:
	unsigned long                                      m_bWasFromSalvo : 1;                                      // 0x051C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_DrogozRocket");
		return ptr;
	}


	bool ApplyTheHit(class UTgDeviceFire* FireMode, const struct FImpactInfo& Impact, class AActor* DamageInstigator);
};


// Class TgGame.TgProj_Loogie
// 0x0004 (0x0520 - 0x051C)
class ATgProj_Loogie : public ATgProj_Simulated
{
public:
	unsigned long                                      m_bWasExplodedByRocket : 1;                               // 0x051C(0x0004)
	unsigned long                                      m_bIgnoreRocketOwner : 1;                                 // 0x051C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Loogie");
		return ptr;
	}


	bool ApplyTheHit(class UTgDeviceFire* FireMode, const struct FImpactInfo& Impact, class AActor* DamageInstigator);
	bool UseAOE();
	void STATIC_ClientExplodeSpecial(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void DetonateFromRocket(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_ExplodeOnTarget(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_ProxyTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_ScaleAbilityFX();
	void PlayAdditionalHitFX(bool bSuccessfulHit, const struct FVector& FXLocation, const struct FVector& HitNormal, const struct FVector& ProjDir, TArray<struct FParticleSysParam>* ExplosionParams);
	void STATIC_HideProjectile();
};


// Class TgGame.TgDevice_Blink
// 0x0014 (0x0B00 - 0x0AEC)
class ATgDevice_Blink : public ATgDevice
{
public:
	struct FPointer                                    VfTable_ITgDeviceInterface_MoveSpeedMultiplier;           // 0x0AEC(0x0008) (Const, Native, NoExport)
	struct FVector                                     m_vTeleportLocation;                                      // 0x0AF4(0x000C)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Blink");
		return ptr;
	}


	bool ShouldCancelCrouch();
	int STATIC_GetAimAssistPriority();
	void STATIC_ServerNotifyTeleportLocation(const struct FVector& vLocation);
	bool CanFireIfLeftMouseDown();
	void RequireHardReset();
	bool ShouldLockFiring(class ATgDevice* Current);
	void STATIC_InterruptOtherDevices(class ATgPawn* TgP);
	bool STATIC_CanFireWithoutAimResult();
	bool STATIC_IsTargetingModeReady(TEnumAsByte<EDeviceFailType>* failType);
	float STATIC_GetFiringPreHitDelay(int nMode);
	float STATIC_GetMoveSpeedMultiplier();
	bool CanBeCrippled();
};


// Class TgGame.TgDeviceFire_Blink
// 0x0000 (0x0270 - 0x0270)
class UTgDeviceFire_Blink : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Blink");
		return ptr;
	}


	void TeleportFire();
};


// Class TgGame.TgDeviceForm_Stasis
// 0x000C (0x02C8 - 0x02BC)
class UTgDeviceForm_Stasis : public UTgDeviceForm
{
public:
	unsigned long                                      m_bNeedsLoopActivation : 1;                               // 0x02BC(0x0004)
	float                                              m_fFireStartTime;                                         // 0x02C0(0x0004)
	float                                              m_fLoopDelay;                                             // 0x02C4(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Stasis");
		return ptr;
	}


	void StopFire(int nFireModeNum);
	void STATIC_StartFire(int nFireMode, float fRefireTime, class AActor* Target, int nAmmoRemaining);
};


// Class TgGame.TgDeploy_ShieldFernando
// 0x0020 (0x046C - 0x044C)
class ATgDeploy_ShieldFernando : public ATgDeploy_Shield
{
public:
	int                                                m_nLargeShieldMeshID;                                     // 0x044C(0x0004)
	class UMeshComponent*                              m_SmallMesh;                                              // 0x0450(0x0008) (ExportObject, Component, EditInline)
	class UMeshComponent*                              m_LargeMesh;                                              // 0x0458(0x0008) (ExportObject, Component, EditInline)
	int                                                r_nToweringBarrierHealth;                                 // 0x0460(0x0004) (Net)
	int                                                r_nAegisBonusHealth;                                      // 0x0464(0x0004) (Net)
	unsigned long                                      m_bHasHeatTransfer : 1;                                   // 0x0468(0x0004)
	unsigned long                                      m_bHasRattle : 1;                                         // 0x0468(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_ShieldFernando");
		return ptr;
	}


	void STATIC_TakeDamage(int Damage, class AController* EventInstigator, const struct FVector& HitLocation, const struct FVector& Momentum, class UClass* DamageType, const struct FTraceHitInfo& HitInfo, class AActor* DamageCauser);
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_ReplicatedEvent(const struct FName& VarName);
	void ToggleLargeMesh();
};


// Class TgGame.TgDevice_ShieldFernando
// 0x0008 (0x0AF4 - 0x0AEC)
class ATgDevice_ShieldFernando : public ATgDevice
{
public:
	struct FPointer                                    VfTable_ITgDeviceInterface_MoveSpeedMultiplier;           // 0x0AEC(0x0008) (Const, Native, NoExport)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_ShieldFernando");
		return ptr;
	}


	void STATIC_LinkedDeviceUnequipped(class ATgDevice* Dev);
	void STATIC_LinkedDeviceEquipped(class ATgDevice* Dev);
	bool STATIC_CanBeCanceled(class ATgDevice* NewDevice);
	bool STATIC_HasCachedPawn();
	bool STATIC_CanBeInterrupted();
	void CancelSafetyPeriodTimer();
	void STATIC_InitMaxHealth();
	bool ShouldLockFiring(class ATgDevice* Current);
	bool STATIC_IsFunctionallyToggleDevice();
	float STATIC_GetMoveSpeedMultiplier();
	bool CanBeSilenced();
};


// Class TgGame.TgDeploy_HealingTotem
// 0x0018 (0x0460 - 0x0448)
class ATgDeploy_HealingTotem : public ATgDeployable
{
public:
	float                                              r_fRadiusScale;                                           // 0x0448(0x0004) (Net)
	unsigned long                                      r_bHasHealingRain : 1;                                    // 0x044C(0x0004) (Net)
	unsigned long                                      r_bHasWindTotem : 1;                                      // 0x044C(0x0004) (Net)
	float                                              r_fMonolithReduction;                                     // 0x0450(0x0004) (Net)
	float                                              r_fPersistTime;                                           // 0x0454(0x0004) (Net)
	class ATgPawn*                                     m_CachedPawnOwner;                                        // 0x0458(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_HealingTotem");
		return ptr;
	}


	void StartDeploy();
	void STATIC_ApplyHit(TArray<struct FImpactInfo>* ImpactList);
	void STATIC_ScaleAbilityFX();
	void STATIC_ScaleAbilityRadius();
	void STATIC_ReplicatedEvent(const struct FName& VarName);
	void ToggleWindTotemFX();
	void ToggleHealingRainFX();
	void STATIC_MitigateHealthDamage(class ATgPawn* pInstigator, class UTgEffectDamage* Effect, const struct FImpactInfo& Impact, bool bIsHeadshot, float* NewValue, float* fPercReduction);
	void AdjustHeal(int nPropertyId, struct FImpactInfo* Impact, float* fHeal);
};


// Class TgGame.TgDevice_Tempest
// 0x0000 (0x0AF4 - 0x0AF4)
class ATgDevice_Tempest : public ATgDevice_HitPulse
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Tempest");
		return ptr;
	}


	bool ShouldInterruptReloadOnFire();
	void PersistTimer();
	void STATIC_DeliverQueuedPendingHits();
	bool STATIC_CanBeCanceled(class ATgDevice* NewDevice);
	bool STATIC_CanBeInterrupted();
	bool CanFireIfLeftMouseDown();
};


// Class TgGame.TgDevice_ShockPulse
// 0x0000 (0x0AEC - 0x0AEC)
class ATgDevice_ShockPulse : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_ShockPulse");
		return ptr;
	}


	bool STATIC_IsReloading();
};


// Class TgGame.TgDeviceFire_Tempest
// 0x0000 (0x0270 - 0x0270)
class UTgDeviceFire_Tempest : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Tempest");
		return ptr;
	}


	struct FImpactInfo CalcAoeFire(class AActor* DamageInstigator, const struct FAimData& Aim, bool bPredicting, float RewindTime, TArray<struct FImpactInfo>* ImpactList);
};


// Class TgGame.TgDeviceForm_ArcingBeam
// 0x0024 (0x02E0 - 0x02BC)
class UTgDeviceForm_ArcingBeam : public UTgDeviceForm
{
public:
	TArray<struct FArcingFXInfo>                       m_ArcingBeamList;                                         // 0x02BC(0x0010) (NeedCtorLink)
	class AActor*                                      m_BeamSourceActor;                                        // 0x02CC(0x0008)
	float                                              m_fBeamPersistTime;                                       // 0x02D4(0x0004)
	unsigned long                                      m_bRequireDeviceIsFiring : 1;                             // 0x02D8(0x0004)
	unsigned long                                      m_bIsFXContinuous : 1;                                    // 0x02D8(0x0004)
	int                                                m_nBeamEffectID;                                          // 0x02DC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_ArcingBeam");
		return ptr;
	}


	bool STATIC_HasCachedGrohkPawn();
	void StopArcingBeamEffects(class AActor* Target);
	void UpdateBeamEndLocation(int Idx);
	void SetTargetArcingBeamEffect(class AActor* Target);
	void SetSourceArcingBeamEffect(class AActor* Source);
	void StopFire(int nFireModeNum);
	void STATIC_StartFire(int nFireMode, float fRefireTime, class AActor* Target, int nAmmoRemaining);
};


// Class TgGame.TgDeviceForm_Tempest
// 0x0020 (0x02DC - 0x02BC)
class UTgDeviceForm_Tempest : public UTgDeviceForm
{
public:
	class AActor*                                      m_BeamTarget1;                                            // 0x02BC(0x0008)
	class AActor*                                      m_BeamTarget2;                                            // 0x02C4(0x0008)
	unsigned long                                      m_bBeamActive1 : 1;                                       // 0x02CC(0x0004)
	unsigned long                                      m_bBeamActive2 : 1;                                       // 0x02CC(0x0004)
	unsigned long                                      m_bBeamDirty1 : 1;                                        // 0x02CC(0x0004)
	unsigned long                                      m_bBeamDirty2 : 1;                                        // 0x02CC(0x0004)
	float                                              m_fBeamStartTime1;                                        // 0x02D0(0x0004)
	float                                              m_fBeamStartTime2;                                        // 0x02D4(0x0004)
	float                                              m_fBeamOnTime;                                            // 0x02D8(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Tempest");
		return ptr;
	}


	void StopArcingBeamEffects();
	void SetTargetArcingBeamEffect(class AActor* Target);
	void STATIC_Fire(const struct FVector& HitLocation, int nFireMode, int nEquipSlot, int nSocketIndex, bool bSuccessfulHit, float fRefireTime);
	void StopFire(int nFireModeNum);
};


// Class TgGame.TgInvListener_SpiritsDomain
// 0x0000 (0x00E0 - 0x00E0)
class UTgInvListener_SpiritsDomain : public UTgInvListener_TargetOverHealed
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_SpiritsDomain");
		return ptr;
	}

};


// Class TgGame.TgDevice_Blossom
// 0x0000 (0x0B34 - 0x0B34)
class ATgDevice_Blossom : public ATgDevice_PassiveAura
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Blossom");
		return ptr;
	}


	bool ShouldAuraBeActive();
};


// Class TgGame.TgDevice_GroverInhand
// 0x000C (0x0AF8 - 0x0AEC)
class ATgDevice_GroverInhand : public ATgDevice
{
public:
	int                                                m_nProjectilesRemaining;                                  // 0x0AEC(0x0004)
	int                                                m_nProjectileCount;                                       // 0x0AF0(0x0004)
	float                                              m_fMultiProjectileDelay;                                  // 0x0AF4(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_GroverInhand");
		return ptr;
	}


	void FireNext();
};


// Class TgGame.TgDevice_Whirlwind
// 0x0000 (0x0AF4 - 0x0AF4)
class ATgDevice_Whirlwind : public ATgDevice_HitPulse
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Whirlwind");
		return ptr;
	}


	void PersistTimer();
	bool STATIC_CancelledByJumping();
	bool STATIC_CanJumpWhileFiring();
	bool STATIC_CanBeCanceled(class ATgDevice* NewDevice);
	bool STATIC_CanBeInterrupted();
	bool CanFireIfLeftMouseDown();
	bool ShouldLockFiring(class ATgDevice* Current);
};


// Class TgGame.TgDevice_OverGrowth
// 0x0008 (0x0AF4 - 0x0AEC)
class ATgDevice_OverGrowth : public ATgDevice
{
public:
	class ATgDevice*                                   m_VineDevice;                                             // 0x0AEC(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_OverGrowth");
		return ptr;
	}


	bool ShouldCooldownAfterFire();
	bool STATIC_StartFire();
};


// Class TgGame.TgDevice_Vine
// 0x0028 (0x0B14 - 0x0AEC)
class ATgDevice_Vine : public ATgDevice
{
public:
	class AActor*                                      m_PullTarget;                                             // 0x0AEC(0x0008)
	struct FVector                                     m_vPullLocation;                                          // 0x0AF4(0x000C)
	float                                              m_fPullSpeed;                                             // 0x0B00(0x0004)
	float                                              m_fTruePostfireTime;                                      // 0x0B04(0x0004)
	float                                              m_fPullEndOffset;                                         // 0x0B08(0x0004)
	unsigned long                                      m_bCanBeCanceled : 1;                                     // 0x0B0C(0x0004)
	unsigned long                                      m_bMissedPull : 1;                                        // 0x0B0C(0x0004)
	unsigned long                                      m_bIsPulling : 1;                                         // 0x0B0C(0x0004)
	unsigned long                                      m_bHasPulledOnce : 1;                                     // 0x0B0C(0x0004)
	unsigned long                                      m_bTeleportedAfterFiring : 1;                             // 0x0B0C(0x0004)
	float                                              m_fMomentumAfterPull;                                     // 0x0B10(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Vine");
		return ptr;
	}


	bool STATIC_CanBeCanceled(class ATgDevice* NewDevice);
	void AuthStartCooldown(int nMode, float fCooldownTimeOverride);
	bool ShouldCooldownAfterFire();
	void Tick(float DeltaSeconds);
	void SetIsPullingHitSpecial(bool bIsPulling);
	void ClientEndPull();
	void EndPull();
	void STATIC_MissPull();
	void STATIC_PullToTarget(class AActor* Target, const struct FVector& targetPos);
};


// Class TgGame.TgDeviceForm_Vine
// 0x0038 (0x02F4 - 0x02BC)
class UTgDeviceForm_Vine : public UTgDeviceForm
{
public:
	unsigned long                                      m_bBeamActive : 1;                                        // 0x02BC(0x0004)
	unsigned long                                      m_bVineInterrupted : 1;                                   // 0x02BC(0x0004)
	class AActor*                                      m_BeamTarget;                                             // 0x02C0(0x0008)
	struct FVector                                     m_vBeamTargetLocation;                                    // 0x02C8(0x000C)
	TArray<class UTgAnimNodeBlendByAbilityVine*>       m_VineBlendList1P;                                        // 0x02D4(0x0010) (NeedCtorLink)
	TArray<class UTgAnimNodeBlendByAbilityVine*>       m_VineBlendList3P;                                        // 0x02E4(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Vine");
		return ptr;
	}


	void STATIC_Generic1(unsigned char byExtraData);
	void StopFire(int nFireModeNum);
	void STATIC_StartFire(int nFireMode, float fRefireTime, class AActor* Target, int nAmmoRemaining);
	void DisconnectBeam();
	void ConnectBeamToTarget(class AActor* Target, const struct FVector& Location);
	void CacheAnimNode3P(class UAnimNode* Node);
	void ClearAnimNodes3P();
};


// Class TgGame.TgInventoryObject_Listen_DeepRoots
// 0x0000 (0x00C8 - 0x00C8)
class UTgInventoryObject_Listen_DeepRoots : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_DeepRoots");
		return ptr;
	}

};


// Class TgGame.TgDeploy_OppressorMine
// 0x0084 (0x04CC - 0x0448)
class ATgDeploy_OppressorMine : public ATgDeployable
{
public:
	class ATgPawn*                                     m_CachedPawnOwner;                                        // 0x0448(0x0008)
	class ATgRepInfo_TaskForce*                        m_CachedEnemyTaskForce;                                   // 0x0450(0x0008)
	class ATgPawn_Character*                           r_CurrentTargets[0x5];                                    // 0x0458(0x0008) (Net)
	int                                                m_nBeamFXID;                                              // 0x0480(0x0004)
	class UTgSpecialFx*                                m_BeamFXs[0x5];                                           // 0x0484(0x0008)
	unsigned long                                      m_bNeedsNetDirtyUpdate : 1;                               // 0x04AC(0x0004)
	struct FRotator                                    r_StuckRotation;                                          // 0x04B0(0x000C) (Net)
	struct FVector                                     r_CartOffset;                                             // 0x04BC(0x000C) (Net)
	float                                              m_fAmplitudeRadiusScale;                                  // 0x04C8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_OppressorMine");
		return ptr;
	}


	bool STATIC_DamageShouldEnterCombat();
	void STATIC_DestroyIt(bool bSkipFx);
	void STATIC_ReplicatedEvent(const struct FName& VarName);
	void UpdateAllBeams();
	void RemoveEffects(class ATgPawn_Character* Target);
	void ApplyEffects(class ATgPawn_Character* Target);
	void FilterNewTargets(TArray<class ATgPawn_Character*>* newTargets);
	int FilterCurrentTargets(int maxTargets);
	bool STATIC_IsValidTarget(class AActor* Target);
};


// Class TgGame.TgDeploy_Transporter
// 0x0030 (0x0478 - 0x0448)
class ATgDeploy_Transporter : public ATgDeployable
{
public:
	struct FVector                                     m_StartLocation;                                          // 0x0448(0x000C)
	struct FVector                                     m_ProjectileEndLocation;                                  // 0x0454(0x000C)
	float                                              m_fProjectileHeight;                                      // 0x0460(0x0004)
	class UTgSpecialFx*                                m_DeploymentFX;                                           // 0x0464(0x0008)
	struct FVector                                     r_TeleportLocation;                                       // 0x046C(0x000C) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_Transporter");
		return ptr;
	}


	void Tick(float DeltaSeconds);
	void SpawnDeployFX();
	void STATIC_ReplicatedEvent(const struct FName& VarName);
};


// Class TgGame.TgDevice_OppressorMine
// 0x0024 (0x0B10 - 0x0AEC)
class ATgDevice_OppressorMine : public ATgDevice_Throw
{
public:
	TArray<class AActor*>                              m_NewTargetSFXRecentTargets;                              // 0x0AEC(0x0010) (NeedCtorLink)
	TArray<float>                                      m_NewTargetSFXTargetTime;                                 // 0x0AFC(0x0010) (NeedCtorLink)
	float                                              m_fMinNewTargetSFXDelay;                                  // 0x0B0C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_OppressorMine");
		return ptr;
	}


	bool ShouldLockFiring(class ATgDevice* Current);
	void STATIC_PlayOppressorMineNewTargetSound(class AActor* Target);
	void ClientPlayOppressorMineNewTargetSound(class AActor* Target);
};


// Class TgGame.TgDevice_Transporter
// 0x0010 (0x0AFC - 0x0AEC)
class ATgDevice_Transporter : public ATgDevice
{
public:
	float                                              m_fDowntraceDistance;                                     // 0x0AEC(0x0004)
	struct FVector                                     c_vCurrentTargeting2Location;                             // 0x0AF0(0x000C)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Transporter");
		return ptr;
	}


	void ClientPlayTransporterDestroyedSound();
	void STATIC_OnDeployableDestroyed(class ATgDeployable* deployable);
	bool ShouldLockFiring(class ATgDevice* Current);
	void TickTargetingMode(float DeltaSeconds);
	void STATIC_GetGroundTargetAim(struct FAimData* Aim);
};


// Class TgGame.TgDeviceFire_OppressorMine
// 0x0000 (0x0270 - 0x0270)
class UTgDeviceFire_OppressorMine : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_OppressorMine");
		return ptr;
	}


	bool STATIC_IgnoreTargetForBlocking(class AActor* Target);
};


// Class TgGame.TgDeviceFire_Transporter
// 0x0000 (0x0270 - 0x0270)
class UTgDeviceFire_Transporter : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Transporter");
		return ptr;
	}


	void TeleportFire();
};


// Class TgGame.TgDeviceForm_Transporter
// 0x0020 (0x02DC - 0x02BC)
class UTgDeviceForm_Transporter : public UTgDeviceForm
{
public:
	class ATgSkeletalMeshActor*                        c_TargetingModeMeshIndicator2;                            // 0x02BC(0x0008)
	class UTgSpecialFx*                                c_TargetingModeFx2;                                       // 0x02C4(0x0008)
	struct FVector                                     c_TargetingModeFx2Location;                               // 0x02CC(0x000C)
	int                                                c_nTargetingModeFx2Id;                                    // 0x02D8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Transporter");
		return ptr;
	}


	void ShowReticle(bool bShow);
	void STATIC_ExitTargetingMode();
	void STATIC_EnterTargetingMode();
	void UpdateTargetingModeStatus(TEnumAsByte<ETargetingModeStatus> Status, struct FAimData* Aim);
	void UpdateTargetingMode2Location(const struct FVector& NewLocation, const struct FRotator& NewRotation, float DistanceScale);
	void STATIC_InitializeTargetingModeFX();
};


// Class TgGame.TgInvListener_SteadyAim
// 0x0008 (0x00D0 - 0x00C8)
class UTgInvListener_SteadyAim : public UTgInvListener
{
public:
	int                                                m_nSteadyAimStackCount;                                   // 0x00C8(0x0004)
	float                                              m_fFullyChargedHitTime;                                   // 0x00CC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_SteadyAim");
		return ptr;
	}

};


// Class TgGame.TgProj_OppressorMine
// 0x0000 (0x056C - 0x056C)
class ATgProj_OppressorMine : public ATgProj_FreeGrenade
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_OppressorMine");
		return ptr;
	}


	bool ShouldHitBounce(class AActor* Target, const struct FVector& HitNormal);
	class AActor* CalculateHitActor(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal, struct FTraceHitInfo* HitInfo);
	class ATgDeployable* SpawnDeployable(const struct FVector& vLocation, class AActor* TargetActor, const struct FVector& vNormal);
};


// Class TgGame.TgDeploy_IllusionLongbow
// 0x0068 (0x04B0 - 0x0448)
class ATgDeploy_IllusionLongbow : public ATgDeployable
{
public:
	int                                                c_nDefaultBodyMeshId;                                     // 0x0448(0x0004)
	int                                                c_nDefaultHeadMeshId;                                     // 0x044C(0x0004)
	int                                                c_nDefaultWeaponMeshId;                                   // 0x0450(0x0004)
	class UTgSkeletalMeshComponent*                    m_BodyMesh;                                               // 0x0454(0x0008) (ExportObject, Component, EditInline)
	class UTgSkeletalMeshComponent*                    m_HeadMesh;                                               // 0x045C(0x0008) (ExportObject, Component, EditInline)
	class UTgSkeletalMeshComponent_Weapon*             m_WeaponMesh;                                             // 0x0464(0x0008) (ExportObject, Component, EditInline)
	TArray<class UMaterialInstanceConstant*>           m_bodyReplacementMICs;                                    // 0x046C(0x0010) (NeedCtorLink)
	TArray<class UMaterialInstanceConstant*>           m_headReplacementMICs;                                    // 0x047C(0x0010) (NeedCtorLink)
	TArray<class UMaterialInstanceConstant*>           m_weaponReplacementMICs;                                  // 0x048C(0x0010) (NeedCtorLink)
	unsigned long                                      m_bFadingAway : 1;                                        // 0x049C(0x0004)
	float                                              m_fLifeAfterDeathOverride;                                // 0x04A0(0x0004) (Const)
	class ATgCollisionProxy_Cylinder*                  m_FxCollisionProxy;                                       // 0x04A4(0x0008)
	float                                              m_fCollisionRadius;                                       // 0x04AC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_IllusionLongbow");
		return ptr;
	}


	void SpawnCollisionProxy();
	void Destroyed();
	void STATIC_DestroyIt(bool bSkipFx);
	void STATIC_OnProxyUnTouch(class AActor* Other);
	void STATIC_OnProxyTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void ReplaceWithFadeOutMaterial();
	void FixupMeshComponent(int nMeshId, class UTgSkeletalMeshComponent* Component);
	void UpdateFadeAway();
};


// Class TgGame.TgDevice_Withdraw
// 0x0004 (0x0B64 - 0x0B60)
class ATgDevice_Withdraw : public ATgDevice_ChargeBackward
{
public:
	unsigned long                                      bInStealth : 1;                                           // 0x0B60(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Withdraw");
		return ptr;
	}


	bool CanBeCanceledByReload();
	void StealthCooldownDelay();
	void STATIC_ClientStartCooldown(int nMode, float fCooldownTime);
	void StartCooldown(int nMode, float fCooldownTimeOverride);
	bool ShouldCooldownAfterFire();
	bool ShouldInterruptInhand();
	bool ShouldInterruptADSDevices();
	bool CanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, TEnumAsByte<EDeviceFailType>* failType);
	bool STATIC_IsDeviceFiringForUI();
};


// Class TgGame.TgDevice_ImpalerArrow
// 0x0000 (0x0AEC - 0x0AEC)
class ATgDevice_ImpalerArrow : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_ImpalerArrow");
		return ptr;
	}


	void FireAmmunition();
	bool STATIC_HasCachedLongbow();
	bool ShouldInterruptInhand();
	bool ShouldCooldownAfterFire();
	bool STATIC_IsDeviceFiringForUI();
	bool ShouldAltFireOnTick();
};


// Class TgGame.TgDevice_LongbowInhand
// 0x0028 (0x0B14 - 0x0AEC)
class ATgDevice_LongbowInhand : public ATgDevice
{
public:
	float                                              s_fLastFireHoldPct;                                       // 0x0AEC(0x0004)
	float                                              m_fFireReleasePercent;                                    // 0x0AF0(0x0004)
	float                                              m_fImpalerReticleAnimationTimer;                          // 0x0AF4(0x0004)
	float                                              m_fReticleReleaseAnimationDuration;                       // 0x0AF8(0x0004) (Edit)
	float                                              m_fImpalerReticleFadeInDuration;                          // 0x0AFC(0x0004) (Edit)
	float                                              m_fImpalerReticleFadeOutDuration;                         // 0x0B00(0x0004) (Edit)
	float                                              m_fImpalerReticleGrowth;                                  // 0x0B04(0x0004) (Edit)
	struct FVector                                     m_vProjectileSpawnOffsetPlanted;                          // 0x0B08(0x000C) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_LongbowInhand");
		return ptr;
	}


	void STATIC_LinkedDeviceUnequipped(class ATgDevice* Dev);
	void STATIC_LinkedDeviceEquipped(class ATgDevice* Dev);
	bool STATIC_CanBeInterrupted();
	bool StartFireHold();
	void ReleaseFireHoldInternal();
	void AdjustSpawnedProjectile(class ATgProj_Simulated** SpawnedProjectile);
	void SetFireHoldAmt(float fFireHoldTime);
	int STATIC_GetProjectileIDOverride(int ProjectileIndex);
	class AProjectile* ProjectileFire(int ProjectileIndex);
	bool STATIC_CanBeCanceled(class ATgDevice* NewDevice);
	bool ReleaseHoldOnRightMouseReleased();
	bool CanFireIfLeftMouseDown();
	struct FVector STATIC_GetProjectileSpawnOffset();
	bool STATIC_HasCachedLongbow();
	bool ShouldAutoFire();
};


// Class TgGame.TgDeviceForm_HeatHaze
// 0x000C (0x02C8 - 0x02BC)
class UTgDeviceForm_HeatHaze : public UTgDeviceForm
{
public:
	unsigned long                                      m_bShouldBeActive : 1;                                    // 0x02BC(0x0004)
	float                                              m_fUltActivationTime;                                     // 0x02C0(0x0004)
	float                                              m_fUltActivationPercent;                                  // 0x02C4(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_HeatHaze");
		return ptr;
	}


	void STATIC_Generic1(unsigned char byExtraData);
	void StopFire(int nFireModeNum);
	void STATIC_StartFire(int nFireMode, float fRefireTime, class AActor* Target, int nAmmoRemaining);
	void UpdateMeshMICValue(class UMeshComponent* MeshComp);
	void UpdateUltMeshVisibility(float DeltaSeconds);
};


// Class TgGame.TgDeviceForm_LongbowInhand
// 0x0044 (0x0300 - 0x02BC)
class UTgDeviceForm_LongbowInhand : public UTgDeviceForm
{
public:
	unsigned long                                      m_bImpalerArrowFXIsActive : 1;                            // 0x02BC(0x0004)
	unsigned long                                      m_bBowDrawing : 1;                                        // 0x02BC(0x0004)
	float                                              m_fBowDrawPercentage;                                     // 0x02C0(0x0004)
	float                                              m_fBowDrawStartPercentage;                                // 0x02C4(0x0004)
	float                                              m_fBowDrawTime;                                           // 0x02C8(0x0004)
	float                                              m_fBowDrawTotalDuration;                                  // 0x02CC(0x0004)
	TArray<class UTgAnimBlendByPercent*>               m_BlendByPct1P;                                           // 0x02D0(0x0010) (NeedCtorLink)
	TArray<class UTgAnimBlendByPercent*>               m_BlendByPct3P;                                           // 0x02E0(0x0010) (NeedCtorLink)
	class UTgSkelControlSingleBone*                    m_ArrowSkelControl1P;                                     // 0x02F0(0x0008)
	class UTgSkelControlSingleBone*                    m_ImpalerSkelControl1P;                                   // 0x02F8(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_LongbowInhand");
		return ptr;
	}


	void SetToggleState(bool IsActive);
	void STATIC_PlayToggleTransitionAnimations(float transitionPercent, float totalTransitionTime, bool transitionToActive);
	void STATIC_DoInterrupt();
	void STATIC_Generic1(unsigned char byExtraData);
	void STATIC_Fire(const struct FVector& HitLocation, int nFireMode, int nEquipSlot, int nSocketIndex, bool bSuccessfulHit, float fRefireTime);
	void Cache1PAnimNodes(class UTgSkeletalMeshComponent* SkelComp);
	void CacheAnimNode3P(class UAnimNode* Node);
	void ClearAnimNodes3P();
};


// Class TgGame.TgProj_Greatbow
// 0x0000 (0x051C - 0x051C)
class ATgProj_Greatbow : public ATgProj_Simulated
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Greatbow");
		return ptr;
	}


	void ApplySpawnParams(float fProjectileSpeed, float fGravityScale);
};


// Class TgGame.TgProj_ImpalerArrow
// 0x0004 (0x0520 - 0x051C)
class ATgProj_ImpalerArrow : public ATgProj_Greatbow
{
public:
	float                                              m_fCollisionScale;                                        // 0x051C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_ImpalerArrow");
		return ptr;
	}


	void PlayHitTargetFX(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal, bool bExploded);
	bool ApplyTheHit(class UTgDeviceFire* FireMode, const struct FImpactInfo& Impact, class AActor* DamageInstigator);
};


// Class TgGame.TgDevice_Weightless
// 0x0008 (0x0AF4 - 0x0AEC)
class ATgDevice_Weightless : public ATgDevice
{
public:
	float                                              r_fSprintHorizontalSpeedMod;                              // 0x0AEC(0x0004) (Net)
	float                                              r_fSprintJumpSpeedMod;                                    // 0x0AF0(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Weightless");
		return ptr;
	}


	bool ShouldInterruptReloadOnFire();
	bool STATIC_CanBeCanceled(class ATgDevice* NewDevice);
	bool STATIC_CanFiringBeCanceledByLeftMouse();
	bool ShouldInterruptInhand();
	bool ShouldLockFiring(class ATgDevice* Current);
	float CalcWeightlessJumpMultiplier();
	float CalcWeightlessHorizontalMultiplier();
	float STATIC_GetJumpSpeedMultiplier();
	float STATIC_GetHorizontalSpeedMultiplier();
	bool ShouldInterruptLift();
};


// Class TgGame.TgInventoryObject_Listen_Acrobatics
// 0x0000 (0x00D4 - 0x00D4)
class UTgInventoryObject_Listen_Acrobatics : public UTgInventoryObject_Listen_UseWhileCCed
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Acrobatics");
		return ptr;
	}

};


// Class TgGame.TgInvListener_ChickenTenderizer
// 0x0000 (0x00E4 - 0x00E4)
class UTgInvListener_ChickenTenderizer : public UTgInvListener_DeathAfterHit
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_ChickenTenderizer");
		return ptr;
	}

};


// Class TgGame.TgInvListener_MegaPotion
// 0x0000 (0x00CC - 0x00CC)
class UTgInvListener_MegaPotion : public UTgInventoryObject_Listen_ActiveWhileOffCooldown
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_MegaPotion");
		return ptr;
	}

};


// Class TgGame.TgProj_HealingPotion
// 0x0000 (0x056C - 0x056C)
class ATgProj_HealingPotion : public ATgProj_FreeGrenade
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_HealingPotion");
		return ptr;
	}


	void PlayAdditionalHitFX(bool bSuccessfulHit, const struct FVector& FXLocation, const struct FVector& HitNormal, const struct FVector& ProjDir, TArray<struct FParticleSysParam>* ExplosionParams);
	void STATIC_GetExplosionFXParams(TArray<struct FParticleSysParam>* Params);
};


// Class TgGame.TgProj_HealingPotionLeadVial
// 0x0000 (0x056C - 0x056C)
class ATgProj_HealingPotionLeadVial : public ATgProj_HealingPotion
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_HealingPotionLeadVial");
		return ptr;
	}


	bool CanHitInstigator();
};


// Class TgGame.TgDevice_RepulsorField
// 0x0004 (0x0B38 - 0x0B34)
class ATgDevice_RepulsorField : public ATgDevice_ActiveAura
{
public:
	float                                              r_fAtTheReadyRadius;                                      // 0x0B34(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_RepulsorField");
		return ptr;
	}


	bool ShouldInterruptReloadOnFire();
	bool ShouldLockFiring(class ATgDevice* Current);
};


// Class TgGame.TgDevice_Emitter
// 0x0028 (0x0B14 - 0x0AEC)
class ATgDevice_Emitter : public ATgDevice
{
public:
	TArray<class AActor*>                              m_PawnsInRange;                                           // 0x0AEC(0x0010) (NeedCtorLink)
	class ATgCollisionProxy_Cylinder*                  m_CollisionProxy;                                         // 0x0AFC(0x0008)
	unsigned long                                      m_bHasProjector : 1;                                      // 0x0B04(0x0004)
	unsigned long                                      m_bIsOnOwner : 1;                                         // 0x0B04(0x0004)
	float                                              m_fProjectorPercent;                                      // 0x0B08(0x0004)
	class ATgPawn*                                     m_CachedPawnOwner;                                        // 0x0B0C(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Emitter");
		return ptr;
	}


	void SpawnCollisionProxy();
	void STATIC_ClearAllTouched();
	void STATIC_OnProxyUnTouch(class AActor* Other);
	void STATIC_OnProxyTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	bool ShouldInterruptReloadOnFire();
	bool STATIC_CanJumpWhileFiring();
	bool ShouldLockFiring(class ATgDevice* Current);
};


// Class TgGame.TgDevice_HexaFire
// 0x0018 (0x0B0C - 0x0AF4)
class ATgDevice_HexaFire : public ATgDevice_HitPulse
{
public:
	struct FPointer                                    VfTable_ITgDeviceInterface_MoveSpeedMultiplier;           // 0x0AF4(0x0008) (Const, Native, NoExport)
	struct FVector                                     m_vProjectileSpawnOffset2;                                // 0x0AFC(0x000C) (Edit)
	unsigned long                                      m_bFireLeftWeapon : 1;                                    // 0x0B08(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_HexaFire");
		return ptr;
	}


	bool ShouldInterruptReloadOnFire();
	bool ShouldLockFiring(class ATgDevice* Current);
	void FireAmmunition();
	bool STATIC_CanBeCanceled(class ATgDevice* NewDevice);
	bool STATIC_CanJumpWhileFiring();
	struct FVector STATIC_GetProjectileSpawnOffset();
	bool STATIC_HasCachedRuckus();
	float STATIC_GetMoveSpeedMultiplier();
	void STATIC_GetCachedAim(struct FAimData* Aim);
};


// Class TgGame.TgDevice_Hover
// 0x0000 (0x0AEC - 0x0AEC)
class ATgDevice_Hover : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Hover");
		return ptr;
	}


	void STATIC_OnCripple();
	bool STATIC_CanBeInterrupted();
	bool STATIC_CanBeCanceled(class ATgDevice* NewDevice);
	bool ShouldLockFiring(class ATgDevice* Current);
	bool CanBeCrippled();
};


// Class TgGame.TgDevice_RocketLauncher
// 0x0010 (0x0AFC - 0x0AEC)
class ATgDevice_RocketLauncher : public ATgDevice
{
public:
	struct FVector                                     m_vProjectileSpawnOffset2;                                // 0x0AEC(0x000C) (Edit)
	int                                                m_nFireCount;                                             // 0x0AF8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_RocketLauncher");
		return ptr;
	}


	bool UsesSimulatedAmmo();
	class AProjectile* ProjectileFire(int ProjectileIndex);
	void STATIC_GetAdjustedAim(float AccuracyValueOverride, float RandomValueOverride1, float RandomValueOverride2, struct FAimData* Aim, float* UsedAccuracyValue, float* UsedRandomValue1, float* UsedRandomValue2);
};


// Class TgGame.TgDeviceFire_RepulsorField
// 0x0000 (0x0270 - 0x0270)
class UTgDeviceFire_RepulsorField : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_RepulsorField");
		return ptr;
	}


	struct FWeaponFireResults CalcWeaponModeFire(class AActor* DamageInstigator, const struct FAimData& Aim, bool bPredicting, bool bNoBodyShotCheck, float RewindTime, TArray<struct FImpactInfo>* ImpactList, TArray<struct FImpactToValidate>* ImpactsToValidate);
	float STATIC_GetDamageRadius();
};


// Class TgGame.TgInvListener_AerialAssault
// 0x0000 (0x00CC - 0x00CC)
class UTgInvListener_AerialAssault : public UTgInventoryObject_Listen_ActiveWhileOffCooldown
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_AerialAssault");
		return ptr;
	}

};


// Class TgGame.TgInvListener_Recycler
// 0x0000 (0x00CC - 0x00CC)
class UTgInvListener_Recycler : public UTgInventoryObject_Listen_ActiveWhileOffCooldown
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_Recycler");
		return ptr;
	}

};


// Class TgGame.TgProj_HexaFireRocket
// 0x0000 (0x051C - 0x051C)
class ATgProj_HexaFireRocket : public ATgProj_Simulated
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_HexaFireRocket");
		return ptr;
	}


	void STATIC_ClearPersistTimers();
};


// Class TgGame.TgDeploy_Molotov
// 0x00AC (0x1B10 - 0x1A64)
class ATgDeploy_Molotov : public ATgDeploy_EffectSpots
{
public:
	TArray<struct FMolotovPointInfo>                   m_PointInfos;                                             // 0x1A64(0x0010) (NeedCtorLink)
	struct FMolotovCenterInfo                          m_CenterInfo;                                             // 0x1A74(0x0048)
	TArray<struct FMolotovTriangleInfo>                m_TriInfos;                                               // 0x1ABC(0x0010) (NeedCtorLink)
	TArray<struct FMolotovStrandInfo>                  m_StrandInfos;                                            // 0x1ACC(0x0010) (NeedCtorLink)
	struct FMolotovGrowthInfo                          m_GrowthInfo;                                             // 0x1ADC(0x001C)
	struct FMolotovGeneralSettings                     m_Settings;                                               // 0x1AF8(0x0018)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_Molotov");
		return ptr;
	}


	void STATIC_DestroyIt(bool bSkipFx);
	void UpdateParticleParams(int spotIndex);
	bool SpawnStrandFromCenter(int Region);
	void SpawnInitialStrands();
	void SpawnInitialCenter();
	void DeployComplete();
	void SetPointIntensity(int PointIndex, int nIntensityLevel);
	int AddNewPoint(const struct FVector& vLocation, const struct FRotator& rRotation, bool bAddEffectSpot, bool bSkipEligibilityCheck);
	struct FRotator AlignSpotByRotation(const struct FVector& HitNormal, const struct FRotator& rRotation);
	void SetMomentumDirection(const struct FVector& projVelocity, const struct FVector& HitNormal);
	void UpdateAllRanks();
	void STATIC_LinkNeighbors(int triIndex);
	int SpawnFromTriangle(int triIndex, int neighborNum);
	struct FVector STATIC_GetNewSpotLocation(int index1, int index2);
	void SpawnFromCenter();
	bool STATIC_IsSaturated(int triIndex);
	void SpawnFromPeripheral();
	void SpawnFromStrand(int strandNum);
	void PushStrandToTip(int strandNum);
	float STATIC_GetStrandSpreadWeight(int strandNum, int neighborNum);
	bool STATIC_IsInStrand(int triIndex, int strandIndex);
	void UpdateStrandAllowances();
	float CalcHeatLevel(int triIndex);
	void UpdateHeatLevels();
	void CompleteSaturationLevel5Points();
	void Tick(float DeltaSeconds);
	bool STATIC_CheckItemShopVolumeFailure(const struct FVector& TestLocation);
	void RemoveEffects(class AActor* Target);
	struct FMolotovEligibilityRecord STATIC_GetSpawnEligibility(const struct FVector& StartLocation, float Radius, float Height);
};


// Class TgGame.TgDevice_HuntersMark
// 0x0000 (0x0AEC - 0x0AEC)
class ATgDevice_HuntersMark : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_HuntersMark");
		return ptr;
	}


	struct FImpactInfo CalcWeaponFire(const struct FAimData& Aim, TArray<struct FImpactInfo>* ImpactList);
	struct FAimData ValidateReceivedAim(float ClientMovementTimeStamp, const struct FAimData& Aim);
	void STATIC_GetTargetingAim(struct FAimData* Aim);
	float STATIC_GetConePullbackDistance();
};


// Class TgGame.TgDevice_TyraInhand
// 0x0004 (0x0AF0 - 0x0AEC)
class ATgDevice_TyraInhand : public ATgDevice
{
public:
	unsigned long                                      m_bUltIsActive : 1;                                       // 0x0AEC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_TyraInhand");
		return ptr;
	}


	bool ShouldShowAmmoCount();
	bool RequiresAmmoToFire();
	bool CheckAutoReload();
};


// Class TgGame.TgProj_Molotov
// 0x0000 (0x056C - 0x056C)
class ATgProj_Molotov : public ATgProj_FreeGrenade
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Molotov");
		return ptr;
	}


	void Tick(float DeltaSeconds);
	class ATgDeployable* SpawnDeployable(const struct FVector& vLocation, class AActor* TargetActor, const struct FVector& vNormal);
};


// Class TgGame.TgDeploy_ToxicTimeBomb
// 0x0000 (0x0460 - 0x0460)
class ATgDeploy_ToxicTimeBomb : public ATgDeploy_Bomb
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_ToxicTimeBomb");
		return ptr;
	}


	void STATIC_DestroyIt(bool bSkipFx);
};


// Class TgGame.TgDeploy_SmokeScreen
// 0x0010 (0x049C - 0x048C)
class ATgDeploy_SmokeScreen : public ATgDeploy_EffectAura
{
public:
	class ATgPawn*                                     m_CachedPawnOwner;                                        // 0x048C(0x0008)
	unsigned long                                      m_bHasAppliedOwnerStealth : 1;                            // 0x0494(0x0004)
	float                                              r_fRadiusForFX;                                           // 0x0498(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_SmokeScreen");
		return ptr;
	}


	void STATIC_ScaleFX();
	void STATIC_ReplicatedEvent(const struct FName& VarName);
	void RemoveEffects(class AActor* Target);
	void ApplyEffects(class AActor* Target);
};


// Class TgGame.TgDevice_EmergencyExit
// 0x0000 (0x0AEC - 0x0AEC)
class ATgDevice_EmergencyExit : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_EmergencyExit");
		return ptr;
	}


	bool STATIC_StartFire();
};


// Class TgGame.TgDevice_SmokeScreen
// 0x0000 (0x0AEC - 0x0AEC)
class ATgDevice_SmokeScreen : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_SmokeScreen");
		return ptr;
	}


	bool ShouldInterruptStealth();
};


// Class TgGame.TgDevice_Stealth
// 0x0004 (0x0AF0 - 0x0AEC)
class ATgDevice_Stealth : public ATgDevice
{
public:
	unsigned long                                      m_bIsInCombat : 1;                                        // 0x0AEC(0x0004)
	unsigned long                                      m_bCanFireInCombat : 1;                                   // 0x0AEC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Stealth");
		return ptr;
	}


	bool ShouldMountCancelFiring();
	bool ShouldInterruptMount();
	bool ShouldCancelStealth();
	bool ShouldLockFiring(class ATgDevice* Current);
	bool CanBeCanceledByReload();
	bool STATIC_CanBeCanceled(class ATgDevice* NewDevice);
	bool STATIC_CanFiringBeCanceledByLeftMouse();
	bool STATIC_StartFire();
	bool ShouldInterruptReloadOnFire();
	bool CanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, TEnumAsByte<EDeviceFailType>* failType);
	bool CanFireWhileMounted();
	bool ShouldInterruptStealth();
};


// Class TgGame.TgDeploy_Gourd
// 0x0004 (0x0480 - 0x047C)
class ATgDeploy_Gourd : public ATgDeploy_EffectField
{
public:
	unsigned long                                      r_bHasRipenedGourd : 1;                                   // 0x047C(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_Gourd");
		return ptr;
	}


	void STATIC_OnProxyUnTouch(class AActor* Other);
	void STATIC_OnProxyTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_ReplicatedEvent(const struct FName& VarName);
	void ToggleRipenedGourdFX();
};


// Class TgGame.TgDevice_GourdMod
// 0x0020 (0x0B0C - 0x0AEC)
class ATgDevice_GourdMod : public ATgDevice
{
public:
	TArray<class AActor*>                              m_ImmuneTargets;                                          // 0x0AEC(0x0010) (NeedCtorLink)
	TArray<float>                                      m_ImmuneTimes;                                            // 0x0AFC(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_GourdMod");
		return ptr;
	}


	void RemoveEffect(class ATgDeploy_Gourd* gourd, class AActor* Target);
	void ApplyEffect(class ATgDeploy_Gourd* gourd, class AActor* Target);
	void ApplyOnTouchEffect(class AActor* Target);
};


// Class TgGame.TgDevice_RipenedGourd
// 0x0000 (0x0B0C - 0x0B0C)
class ATgDevice_RipenedGourd : public ATgDevice_GourdMod
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_RipenedGourd");
		return ptr;
	}

};


// Class TgGame.TgInvListener_SpiritsChosen
// 0x0000 (0x00E4 - 0x00E4)
class UTgInvListener_SpiritsChosen : public UTgInventoryObject_Listen_MendingSpiritsActive
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_SpiritsChosen");
		return ptr;
	}

};


// Class TgGame.TgDevice_OwlInhand
// 0x0014 (0x0B00 - 0x0AEC)
class ATgDevice_OwlInhand : public ATgDevice
{
public:
	class ATgDevice*                                   m_CachedSwapDevice;                                       // 0x0AEC(0x0008)
	class ATgDevice*                                   m_CachedScopeDevice;                                      // 0x0AF4(0x0008)
	unsigned long                                      bUsePerfectAccuracy : 1;                                  // 0x0AFC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_OwlInhand");
		return ptr;
	}


	void STATIC_LinkedDeviceUnequipped(class ATgDevice* Dev);
	void STATIC_LinkedDeviceEquipped(class ATgDevice* Dev);
	void RemoveAccuracyDelayed();
	void RemoveScopeEffects();
	void ApplyScopeEffects();
	void ShowReticle(bool bShow);
	bool ShouldLockFiring(class ATgDevice* Current);
	bool ShouldShowAmmoCount();
	float STATIC_GetAccuracy(int nMode);
};


// Class TgGame.TgDevice_OwlSidearm
// 0x0008 (0x0AF4 - 0x0AEC)
class ATgDevice_OwlSidearm : public ATgDevice
{
public:
	float                                              m_fQueueFireTime;                                         // 0x0AEC(0x0004)
	float                                              m_fQueueFireTimeThreshold;                                // 0x0AF0(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_OwlSidearm");
		return ptr;
	}


	float STATIC_GetRecoilMultiplier();
	float STATIC_GetMinAccuracy();
	bool CanEnterCombat();
	void StopFire();
	bool STATIC_InterceptLeftMousePressed(class ATgPlayerController* TgController);
	bool CanFireIfLeftMouseDown();
	void STATIC_EnterTargetingMode();
};


// Class TgGame.TgDevice_OwlStealth
// 0x0004 (0x0AF0 - 0x0AEC)
class ATgDevice_OwlStealth : public ATgDevice
{
public:
	unsigned long                                      c_bAlreadyConsumedStealthJuice : 1;                       // 0x0AEC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_OwlStealth");
		return ptr;
	}


	void STATIC_OnUnlinkDevice(class ATgPawn* TgP);
	void STATIC_OnLinkDevice(class ATgPawn* TgP);
	void STATIC_LinkedDeviceEquipped(class ATgDevice* Dev);
	void STATIC_LinkedDeviceUnequipped(class ATgDevice* Dev);
	bool ShouldInterruptReloadOnFire();
	bool ShouldCancelStealth();
	bool ShouldLockFiring(class ATgDevice* Current);
	bool STATIC_IsFunctionallyToggleDevice();
	bool STATIC_CanFiringBeCanceledByReactivation();
	void ClientConsumeStealthJuiceOnFire(int nAmtModified);
	void ConsumeStealthJuiceOnFire();
	bool STATIC_CanDeviceStartFiringNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDebugRelevant, TEnumAsByte<EDeviceFailType>* failType);
	void STATIC_DeviceConsumePowerPool(unsigned char FireModeNum);
	float STATIC_GetStealthJuicePerSec();
	bool ShouldBlockReload(class ATgDevice* Dev, bool bIsAutoReload);
};


// Class TgGame.TgDevice_Scope
// 0x000C (0x0B00 - 0x0AF4)
class ATgDevice_Scope : public ATgDevice_ToggleWithLockout
{
public:
	struct FPointer                                    VfTable_ITgDeviceInterface_MoveSpeedMultiplier;           // 0x0AF4(0x0008) (Const, Native, NoExport)
	unsigned long                                      m_bDelayMoveSpeedPenalty : 1;                             // 0x0AFC(0x0004)
	unsigned long                                      m_bIsZoomed : 1;                                          // 0x0AFC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Scope");
		return ptr;
	}


	bool ShouldStopActionOnOffhandSlotReleased();
	bool STATIC_IsFunctionallyToggleDevice();
	bool STATIC_InterceptSlotReleased(class ATgPlayerController* TgController);
	void CompleteInterrupt();
	bool STATIC_IsPlayerToggleZoomSet();
	void STATIC_LinkedDeviceUnequipped(class ATgDevice* Dev);
	void STATIC_LinkedDeviceEquipped(class ATgDevice* Dev);
	bool STATIC_CanBeInterrupted();
	bool STATIC_CanBeCanceled(class ATgDevice* NewDevice);
	void FireDescopeTimer();
	void StartFireDescopeTimer();
	bool ShouldLockFiring(class ATgDevice* Current);
	float STATIC_GetMoveSpeedMultiplier();
};


// Class TgGame.TgDevice_WeaponSwap
// 0x0008 (0x0AF4 - 0x0AEC)
class ATgDevice_WeaponSwap : public ATgDevice
{
public:
	struct FPointer                                    VfTable_ITgDeviceInterface_MoveSpeedMultiplier;           // 0x0AEC(0x0008) (Const, Native, NoExport)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_WeaponSwap");
		return ptr;
	}


	float STATIC_GetMoveSpeedMultiplier();
	void FiringEndTransition();
	void STATIC_HandleDeviceFormStartFire(int nDeviceModeNum, float fRefireTime, struct FAimData* Aim);
	void STATIC_NotifyWeaponSwap(float fSwapTime);
	bool ShouldMountCancelFiring();
	bool STATIC_IsFunctionallyToggleDevice();
	bool STATIC_CanBeCanceled(class ATgDevice* NewDevice);
	bool ShouldLockFiring(class ATgDevice* Current);
};


// Class TgGame.TgDeviceForm_OwlStealth
// 0x0000 (0x02BC - 0x02BC)
class UTgDeviceForm_OwlStealth : public UTgDeviceForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_OwlStealth");
		return ptr;
	}


	void RecoverDeviceState(TEnumAsByte<ETG_REP_DEVICE_STATE> DesiredState);
	void STATIC_DoInterrupt();
	void StopFire(int nFireModeNum);
	void STATIC_BuildUp(int nFireMode, int nEquipSlot, int nSocketIndex, float fBuildupTime);
	void StealthTransition(bool bStealthActivating, float fTransitionTime);
};


// Class TgGame.TgDeviceForm_Scope
// 0x0000 (0x02BC - 0x02BC)
class UTgDeviceForm_Scope : public UTgDeviceForm_ToggleWithLockout
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Scope");
		return ptr;
	}


	void EnableZoom(bool bIsActive);
	void STATIC_PlayToggleTransitionAnimations(float transitionPercent, float totalTransitionTime, bool transitionToActive);
	void SetToggleState(bool bIsActive);
	void StopFire(int nFireModeNum);
};


// Class TgGame.TgDeviceForm_WeaponSwap
// 0x0040 (0x02FC - 0x02BC)
class UTgDeviceForm_WeaponSwap : public UTgDeviceForm
{
public:
	TArray<class UTgSkelControlSingleBone*>            m_PistolScale1p;                                          // 0x02BC(0x0010) (NeedCtorLink)
	TArray<class UTgSkelControlSingleBone*>            m_PistolScale3p;                                          // 0x02CC(0x0010) (NeedCtorLink)
	TArray<class UTgSkelControlSingleBone*>            m_RifleScale1p;                                           // 0x02DC(0x0010) (NeedCtorLink)
	TArray<class UTgSkelControlSingleBone*>            m_RifleScale3p;                                           // 0x02EC(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_WeaponSwap");
		return ptr;
	}


	void RecoverDeviceState(TEnumAsByte<ETG_REP_DEVICE_STATE> DesiredState);
	void SetSkelControlsActive(bool bActive, TArray<class UTgSkelControlSingleBone*>* SkelControls);
	void Cache3PAnimNodes(class UTgSkeletalMeshComponent* SkelComp);
	void Cache1PAnimNodes(class UTgSkeletalMeshComponent* SkelComp);
	void CacheSkelControls(class UAnimTree* pAnimTree, const struct FName& nmPistol, const struct FName& nmRifle, TArray<class UTgSkelControlSingleBone*>* PistolSkelControls, TArray<class UTgSkelControlSingleBone*>* RifleSkelControls);
};


// Class TgGame.TgInvListener_ActiveWhileWeaponSwap
// 0x0004 (0x00CC - 0x00C8)
class UTgInvListener_ActiveWhileWeaponSwap : public UTgInvListener
{
public:
	unsigned long                                      m_bActivateWhileInhandActive : 1;                         // 0x00C8(0x0004)
	unsigned long                                      m_bIsActive : 1;                                          // 0x00C8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_ActiveWhileWeaponSwap");
		return ptr;
	}

};


// Class TgGame.TgInvListener_CooledMags
// 0x0014 (0x00DC - 0x00C8)
class UTgInvListener_CooledMags : public UTgInvListener
{
public:
	class ATgDevice*                                   m_CachedSidearm;                                          // 0x00C8(0x0008)
	class ATgDevice*                                   m_CachedInhand;                                           // 0x00D0(0x0008)
	float                                              m_fAmmoFillTime;                                          // 0x00D8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_CooledMags");
		return ptr;
	}

};


// Class TgGame.TgInvListener_CrackShot
// 0x0010 (0x00D8 - 0x00C8)
class UTgInvListener_CrackShot : public UTgInvListener
{
public:
	TArray<struct FCrackShotBonusDamageTarget>         m_Targets;                                                // 0x00C8(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_CrackShot");
		return ptr;
	}

};


// Class TgGame.TgInvListener_GuerillaTactics
// 0x0000 (0x00C8 - 0x00C8)
class UTgInvListener_GuerillaTactics : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_GuerillaTactics");
		return ptr;
	}

};


// Class TgGame.TgProj_Flare
// 0x0008 (0x0574 - 0x056C)
class ATgProj_Flare : public ATgProj_FreeGrenade
{
public:
	unsigned long                                      m_bStartedPulse : 1;                                      // 0x056C(0x0004)
	float                                              m_fLifetimeForPhysicsSubstep;                             // 0x0570(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Flare");
		return ptr;
	}


	float GetGravityZ();
	bool UseAOE();
	void PulseVisibility();
	void STATIC_PostProjectileInitialize();
	void StartPulse();
};


// Class TgGame.TgDeploy_ChurchillTurret
// 0x001C (0x0464 - 0x0448)
class ATgDeploy_ChurchillTurret : public ATgDeployable
{
public:
	struct FVector                                     m_vDroneSocketOffset;                                     // 0x0448(0x000C)
	unsigned long                                      r_bLeftDrone : 1;                                         // 0x0454(0x0004) (Net)
	struct FVector                                     m_vCurrentAccumulatedVelocity;                            // 0x0458(0x000C)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_ChurchillTurret");
		return ptr;
	}


	struct FVector STATIC_GetPhysicalFireAimDirection(const struct FVector& fireLoc, const struct FVector& TargetLocation);
	void STATIC_PlayFireFx();
	void FireAmmunitionDeployable();
	void STATIC_DestroyIt(bool bSkipFx);
	void STATIC_ReplacedByNewDeployable();
	void PlayLowHealthFX(bool bEnable);
	void STATIC_TakeDamage(int Damage, class AController* EventInstigator, const struct FVector& HitLocation, const struct FVector& Momentum, class UClass* DamageType, const struct FTraceHitInfo& HitInfo, class AActor* DamageCauser);
	void STATIC_ReplicatedEvent(const struct FName& VarName);
	void StartDeploy();
	struct FVector STATIC_GetDesiredLocation();
};


// Class TgGame.TgDeploy_ChurchillWard
// 0x0004 (0x044C - 0x0448)
class ATgDeploy_ChurchillWard : public ATgDeployable
{
public:
	unsigned long                                      r_bTargetVisible : 1;                                     // 0x0448(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_ChurchillWard");
		return ptr;
	}


	bool STATIC_HasCachedChurchill();
	void UpdateDetectedColor(bool bDetected);
	void STATIC_ApplyHit(TArray<struct FImpactInfo>* ImpactList);
	bool STATIC_DamageShouldEnterCombat();
	void STATIC_DestroyIt(bool bSkipFx);
	void STATIC_ReplicatedEvent(const struct FName& VarName);
};


// Class TgGame.TgDeploy_ChurchillShield
// 0x0004 (0x0450 - 0x044C)
class ATgDeploy_ChurchillShield : public ATgDeploy_Shield
{
public:
	float                                              m_fMinPitch;                                              // 0x044C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_ChurchillShield");
		return ptr;
	}


	void STATIC_TakeDamage(int Damage, class AController* EventInstigator, const struct FVector& HitLocation, const struct FVector& Momentum, class UClass* DamageType, const struct FTraceHitInfo& HitInfo, class AActor* DamageCauser);
	void STATIC_OnHealthUpdated();
	void StartDeploy();
};


// Class TgGame.TgDevice_ChurchillInhand
// 0x0014 (0x0B00 - 0x0AEC)
class ATgDevice_ChurchillInhand : public ATgDevice
{
public:
	float                                              m_fADSRecoilMultiplier;                                   // 0x0AEC(0x0004)
	float                                              m_fAmmoRefundChanceADS;                                   // 0x0AF0(0x0004)
	float                                              m_fAmmoRefundPercOnHit;                                   // 0x0AF4(0x0004)
	class ATgPawn_Character*                           m_CachedPawnOwner;                                        // 0x0AF8(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_ChurchillInhand");
		return ptr;
	}


	class UTgGameplayCurvesSet_RecoilSimple* STATIC_GetRecoilCurve();
	bool STATIC_HasCachedCharacter();
	void STATIC_LinkedDeviceUnequipped(class ATgDevice* Dev);
	void STATIC_LinkedDeviceEquipped(class ATgDevice* Dev);
	void EndADSBonuses();
	void StartADSBonuses();
	void ShowReticle(bool bShow);
	bool ShouldConsumeAmmo(int nFireRequestID, TArray<struct FImpactToValidate> Impacts);
};


// Class TgGame.TgDeviceForm_ChurchillInhand
// 0x0000 (0x02E8 - 0x02E8)
class UTgDeviceForm_ChurchillInhand : public UTgDeviceForm_SpinnerWhileFiring
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_ChurchillInhand");
		return ptr;
	}

};


// Class TgGame.TgDeviceForm_ChurchillADS
// 0x0008 (0x02C4 - 0x02BC)
class UTgDeviceForm_ChurchillADS : public UTgDeviceForm_ToggleWithLockout
{
public:
	float                                              m_fDesiredScopeWorld1pFOV;                                // 0x02BC(0x0004) (Config)
	float                                              m_fDesiredScopeWorld3pFOV;                                // 0x02C0(0x0004) (Config)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_ChurchillADS");
		return ptr;
	}


	void EnableZoom(bool bIsActive);
	void STATIC_PlayToggleTransitionAnimations(float transitionPercent, float totalTransitionTime, bool transitionToActive);
	void SetToggleState(bool bIsActive);
	void StopFire(int nFireModeNum);
};


// Class TgGame.TgInvListener_OpportunityInChaos
// 0x0004 (0x00CC - 0x00C8)
class UTgInvListener_OpportunityInChaos : public UTgInvListener
{
public:
	float                                              m_fStartFireTime;                                         // 0x00C8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_OpportunityInChaos");
		return ptr;
	}

};


// Class TgGame.TgInvListener_Scapegoat
// 0x0008 (0x00D0 - 0x00C8)
class UTgInvListener_Scapegoat : public UTgInvListener
{
public:
	class ATgDeploy_ChurchillShield*                   m_CachedShield;                                           // 0x00C8(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_Scapegoat");
		return ptr;
	}

};


// Class TgGame.TgInvListener_SuspectEveryone
// 0x0000 (0x00C8 - 0x00C8)
class UTgInvListener_SuspectEveryone : public UTgInvListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInvListener_SuspectEveryone");
		return ptr;
	}

};


// Class TgGame.TgProj_ChurchillWard
// 0x0000 (0x056C - 0x056C)
class ATgProj_ChurchillWard : public ATgProj_FreeGrenade
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_ChurchillWard");
		return ptr;
	}


	bool ShouldHitBounce(class AActor* Target, const struct FVector& HitNormal);
	class AActor* CalculateHitActor(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal, struct FTraceHitInfo* HitInfo);
	float GetGravityZ();
};


// Class TgGame.TgWeaponMeshActor_ChurchillInhand
// 0x004C (0x0550 - 0x0504)
class ATgWeaponMeshActor_ChurchillInhand : public ATgWeaponMeshActor
{
public:
	struct FPointer                                    VfTable_ITgObserver_ViewTargetChanged;                    // 0x0504(0x0008) (Const, Native, NoExport)
	unsigned long                                      m_bPlayingADSFX : 1;                                      // 0x050C(0x0004)
	float                                              m_fShieldLagStrength;                                     // 0x0510(0x0004)
	float                                              m_fShieldMinPitch;                                        // 0x0514(0x0004)
	float                                              m_fShieldMinPitchMaxTranslate;                            // 0x0518(0x0004)
	struct FLinearColor                                m_cDefaultColorizeRed1p;                                  // 0x051C(0x0010)
	struct FLinearColor                                m_cDefaultColorizeRed3p;                                  // 0x052C(0x0010)
	int                                                m_nColorizeRedChnageSource;                               // 0x053C(0x0004)
	struct FLinearColor                                DetectedColorWeapon;                                      // 0x0540(0x0010) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgWeaponMeshActor_ChurchillInhand");
		return ptr;
	}


	void SetCrystalDetected(bool bDetected, int nSource);
	void CacheColorizeRedOnMesh(class USkeletalMeshComponent* WeaponMesh, struct FLinearColor* cDefaultColor);
	void Tick(float DeltaTime);
	void STATIC_Initialize3P(unsigned char EquipPoint, int DeviceID);
	void FixUpReferencesToWeaponMesh1P(class USkeletalMeshComponent* WeaponMesh);
	void UseADSFireSounds(bool bShouldUse);
	void SetFOVZoomed(bool bEnabled);
	void Toggle1PVisibility(bool bVisible);
	void SetDeployablesHidden(bool bShouldHide);
	void STATIC_OnViewTargetChanged(class AActor* aNewViewTarget);
};


// Class TgGame.TgDeploy_VanguardShield
// 0x0000 (0x044C - 0x044C)
class ATgDeploy_VanguardShield : public ATgDeploy_Shield
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_VanguardShield");
		return ptr;
	}


	void STATIC_TakeDamage(int Damage, class AController* EventInstigator, const struct FVector& HitLocation, const struct FVector& Momentum, class UClass* DamageType, const struct FTraceHitInfo& HitInfo, class AActor* DamageCauser);
};


// Class TgGame.TgDevice_VanguardCharge
// 0x0018 (0x0B78 - 0x0B60)
class ATgDevice_VanguardCharge : public ATgDevice_Charge
{
public:
	struct FPointer                                    VfTable_ITgDeviceInterface_MoveSpeedMultiplier;           // 0x0B60(0x0008) (Const, Native, NoExport)
	struct FScriptDelegate                             __InterruptFiringDelegate__Delegate;                      // 0x0B68(0x000C) (NeedCtorLink)
	unsigned char                                      UnknownData00[0x4];                                       // 0x0B68(0x0004) FIX WRONG TYPE SIZE OF PREVIOUS PROPERTY

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_VanguardCharge");
		return ptr;
	}


	float STATIC_GetChargeTurnRate();
	void STATIC_LinkedDeviceUnequipped(class ATgDevice* Dev);
	void STATIC_LinkedDeviceEquipped(class ATgDevice* Dev);
	void STATIC_InterruptFiringDelegate();
	void UpdateOutroLockoutTime();
	float STATIC_GetChargeRange();
	float STATIC_GetChargeSpeed();
	bool STATIC_CanBeInterrupted();
	bool STATIC_CanBeCanceled(class ATgDevice* NewDevice);
	bool ShouldLockFiring(class ATgDevice* Current);
	bool ShouldForce3P(class UTgDeviceForm* DeviceForm, bool bOnlyCheckDeviceForm);
	float STATIC_GetMoveSpeedMultiplier();
};


// Class TgGame.TgDevice_VanguardGrab
// 0x0034 (0x0B94 - 0x0B60)
class ATgDevice_VanguardGrab : public ATgDevice_Charge
{
public:
	struct FPointer                                    VfTable_ITgDeviceInterface_MoveSpeedMultiplier;           // 0x0B60(0x0008) (Const, Native, NoExport)
	unsigned long                                      m_bWaitingForServerHit : 1;                               // 0x0B68(0x0004)
	unsigned long                                      m_bHasStartedGrab : 1;                                    // 0x0B68(0x0004)
	unsigned long                                      m_bHasHitTarget : 1;                                      // 0x0B68(0x0004)
	unsigned long                                      m_bLegendaryActive : 1;                                   // 0x0B68(0x0004)
	unsigned long                                      m_bLegendaryEnabled : 1;                                  // 0x0B68(0x0004)
	class ATgPawn_Character*                           m_HitCharacter;                                           // 0x0B6C(0x0008)
	class ATgPawn_Character*                           m_DesiredTarget;                                          // 0x0B74(0x0008)
	float                                              m_fJoinViewLerpTime;                                      // 0x0B7C(0x0004) (Const)
	float                                              m_fHorizontalGrabTargetOffset;                            // 0x0B80(0x0004) (Const)
	struct FScriptDelegate                             __InterruptFiringDelegate__Delegate;                      // 0x0B84(0x000C) (NeedCtorLink)
	unsigned char                                      UnknownData00[0x4];                                       // 0x0B84(0x0004) FIX WRONG TYPE SIZE OF PREVIOUS PROPERTY

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_VanguardGrab");
		return ptr;
	}


	float STATIC_GetCustomTimerBarMaxTime();
	float STATIC_GetCustomTimerBarCurrentTime();
	void STATIC_LinkedDeviceUnequipped(class ATgDevice* Dev);
	void STATIC_LinkedDeviceEquipped(class ATgDevice* Dev);
	void STATIC_InterruptFiringDelegate();
	bool ShouldCooldownAfterFire();
	void ServerNotifyDesiredTarget(class AActor* DesiredTarget);
	void ApplyFinalHit();
	void STATIC_LegendaryTimerExpired();
	void FinishGrab(bool bInterrupted, bool bApplyFinalHit);
	void ClientFinishGrab(bool bInterrupted, bool bApplyFinalHit);
	void ClientAbortWaitingForServerHit();
	void STATIC_GrabMoveFinished();
	void ApplyEndStunHit();
	void RemoveInitialStunHit();
	void ApplyInitialStunHit();
	void StartGrabMove();
	float STATIC_GetJoinDuration();
	void STATIC_Grab3pDelay();
	void StartGrab(class AActor* Other);
	void FindGrabLocations(struct FVector* vSelfLocation, struct FVector* vTargetLocation);
	void ClientStartGrab(class AActor* Other);
	void AbortGrab();
	void STATIC_OnInterruptEvent();
	struct FRotator STATIC_GetChargeDirection();
	void ServerStartGrab(class AActor* Other);
	bool ShouldAbortGrab();
	bool STATIC_IsTargetImmune(class ATgPawn_Character* pOther);
	bool ShouldLockFiring(class ATgDevice* Current);
	bool STATIC_HasCachedVanguard();
	void ValidateChargeHit(class AActor* Other);
	void SetDesiredTarget(class ATgPawn_Character* pTarget);
	class ATgPawn_Character* STATIC_GetDesiredTarget();
	bool CanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, TEnumAsByte<EDeviceFailType>* failType);
	float STATIC_GetCachedFiringPostHitDelay();
	bool ShouldLiftInterrupt();
	float STATIC_GetMoveSpeedMultiplier();
	void STATIC_GetTargetingAim(struct FAimData* Aim);
};


// Class TgGame.TgDevice_VanguardUlt
// 0x000C (0x0BA0 - 0x0B94)
class ATgDevice_VanguardUlt : public ATgDevice_VanguardGrab
{
public:
	float                                              m_fGrabUpdateTimer;                                       // 0x0B94(0x0004)
	float                                              m_fGrabUpdateDuration;                                    // 0x0B98(0x0004)
	float                                              m_fJoinDuration;                                          // 0x0B9C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_VanguardUlt");
		return ptr;
	}


	bool ShouldConsumePowerPoolAfterFire();
	void FinishGrab(bool bInterrupted, bool bApplyFinalHit);
	void FreezePlayers();
	void StartGrabMove();
	float STATIC_GetJoinDuration();
	void ApplyFinalHit();
	void TriggerAoE(const struct FVector& vLocation);
	bool ShouldAbortGrab();
	float STATIC_GetRequiredEnergyToFire();
	void SetDesiredTarget(class ATgPawn_Character* pTarget);
	class ATgPawn_Character* STATIC_GetDesiredTarget();
	bool CanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, TEnumAsByte<EDeviceFailType>* failType);
	void FindGrabLocations(struct FVector* vSelfLocation, struct FVector* vTargetLocation);
};


// Class TgGame.TgDevice_VortexGrip
// 0x0000 (0x0B60 - 0x0B60)
class ATgDevice_VortexGrip : public ATgDevice_Charge
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_VortexGrip");
		return ptr;
	}

};


// Class TgGame.TgDevice_ShieldWall
// 0x0000 (0x0AEC - 0x0AEC)
class ATgDevice_ShieldWall : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_ShieldWall");
		return ptr;
	}

};


// Class TgGame.TgDevice_VanguardShield
// 0x0010 (0x0AFC - 0x0AEC)
class ATgDevice_VanguardShield : public ATgDevice
{
public:
	struct FScriptDelegate                             __InterruptFiringDelegate__Delegate;                      // 0x0AEC(0x000C) (NeedCtorLink)
	unsigned char                                      UnknownData00[0x4];                                       // 0x0AEC(0x0004) FIX WRONG TYPE SIZE OF PREVIOUS PROPERTY

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_VanguardShield");
		return ptr;
	}


	void STATIC_LinkedDeviceUnequipped(class ATgDevice* Dev);
	void STATIC_LinkedDeviceEquipped(class ATgDevice* Dev);
	void STATIC_InterruptFiringDelegate();
	void UpdateOutroLockoutTime();
	bool ShouldInterruptReloadOnFire();
	bool STATIC_InterceptSlotReleased(class ATgPlayerController* TgController);
	bool STATIC_CanFiringBeCanceledByReactivation();
	bool STATIC_InterceptLeftMousePressed(class ATgPlayerController* TgController);
	bool STATIC_CanFiringBeCanceledByLeftMouse();
	bool STATIC_CanBeInterrupted();
	bool STATIC_CanBeCanceled(class ATgDevice* NewDevice);
	bool ShouldLockFiring(class ATgDevice* Current);
	bool STATIC_InterceptSlotPressed(class ATgPlayerController* TgController);
	bool STATIC_CanDeviceStartFiringNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDebugRelevant, TEnumAsByte<EDeviceFailType>* failType);
	bool ShouldAltFireOnTick();
	bool CanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, TEnumAsByte<EDeviceFailType>* failType);
};


// Class TgGame.TgDevice_VanguardShout
// 0x0000 (0x0AEC - 0x0AEC)
class ATgDevice_VanguardShout : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_VanguardShout");
		return ptr;
	}

};


// Class TgGame.TgDeviceFire_VanguardGrab
// 0x0000 (0x0270 - 0x0270)
class UTgDeviceFire_VanguardGrab : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_VanguardGrab");
		return ptr;
	}


	struct FWeaponFireResults CalcWeaponModeFire(class AActor* DamageInstigator, const struct FAimData& Aim, bool bPredicting, bool bNoBodyShotCheck, float RewindTime, TArray<struct FImpactInfo>* ImpactList, TArray<struct FImpactToValidate>* ImpactsToValidate);
};


// Class TgGame.TgDeviceFire_VanguardUlt
// 0x0000 (0x0270 - 0x0270)
class UTgDeviceFire_VanguardUlt : public UTgDeviceFire_VanguardGrab
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_VanguardUlt");
		return ptr;
	}


	bool STATIC_HandleCustomPlayerKnockbackHit(class AActor* TargetPrimary, const struct FImpactInfo& ImpactPrimary, class AActor* TargetSecondary, const struct FImpactInfo& ImpactSecondary);
	bool STATIC_HandleCustomWallKnockbackHit(class AActor* Target, const struct FImpactInfo& Impact);
};


// Class TgGame.TgPawn_Engineer
// 0x0040 (0x314C - 0x310C)
class ATgPawn_Engineer : public ATgPawn_Character
{
public:
	class UTgSkeletalMeshComponent*                    m_pJetpackMesh;                                           // 0x310C(0x0008) (ExportObject, Component, EditInline)
	TArray<class USkelControlBase*>                    m_pJetpackSkelCons;                                       // 0x3114(0x0010) (NeedCtorLink)
	TArray<struct FName>                               m_pJetpackSkelConNames;                                   // 0x3124(0x0010) (NeedCtorLink)
	unsigned long                                      m_bBoosterUseConstantSpeedReduction : 1;                  // 0x3134(0x0004)
	unsigned long                                      m_bIsInBooster : 1;                                       // 0x3134(0x0004)
	unsigned long                                      m_bInBoosterLockout : 1;                                  // 0x3134(0x0004)
	float                                              m_fBoosterSpeedReductionRate;                             // 0x3138(0x0004)
	float                                              m_fBoosterEndTime;                                        // 0x313C(0x0004)
	float                                              m_fBoosterLockoutTime;                                    // 0x3140(0x0004)
	class ATgDevice*                                   m_CachedBoosterDevice;                                    // 0x3144(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Engineer");
		return ptr;
	}


	void SetJetpackState(bool bActive);
	void STATIC_OnMeshSwapped();
};


// Class TgGame.TgPawn_Alchemist
// 0x000C (0x3118 - 0x310C)
class ATgPawn_Alchemist : public ATgPawn_Character
{
public:
	unsigned long                                      r_bWeightless : 1;                                        // 0x310C(0x0004) (Net)
	unsigned long                                      m_bWeightlessDurationEnded : 1;                           // 0x310C(0x0004)
	float                                              m_fWeightlessMaxSpeedModifier;                            // 0x3110(0x0004)
	float                                              m_fWeightlessJumpZModifier;                               // 0x3114(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Alchemist");
		return ptr;
	}


	void Landed(const struct FVector& HitNormal, class AActor* FloorActor);
	bool DoJump(bool bUpdating, float JumpZSpeed);
	float STATIC_GetJumpSpeedMultiplier();
	void EndWeightless();
	void StartWeightless(float fMaxSpeedMultiplier, float fJumpZMultiplier);
};


// Class TgGame.TgPawn_Mage
// 0x0000 (0x310C - 0x310C)
class ATgPawn_Mage : public ATgPawn_Character
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Mage");
		return ptr;
	}


	void DeviceAdjustCooldown(class ATgDevice* Dev, float* fCooldown);
	void DeviceAdjustHeal(struct FAdjustHealParams* Params, float* fHeal);
	void BuffDamage(class AActor* Target, class UTgEffectDamage* Effect, const struct FImpactInfo& Impact, float fBaseDamage, float* fProratedAmount, struct FExtraDamageInfo* ExtraInfo);
};


// Class TgGame.TgPawn_Assassin
// 0x0000 (0x310C - 0x310C)
class ATgPawn_Assassin : public ATgPawn_Character
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Assassin");
		return ptr;
	}


	void DeviceAdjustCooldown(class ATgDevice* Dev, float* fCooldown);
	void BuffDamage(class AActor* Target, class UTgEffectDamage* Effect, const struct FImpactInfo& Impact, float fBaseDamage, float* fProratedAmount, struct FExtraDamageInfo* ExtraInfo);
};


// Class TgGame.TgActorFactory_TgStaticMeshActorCapturePoint
// 0x0000 (0x00B0 - 0x00B0)
class UTgActorFactory_TgStaticMeshActorCapturePoint : public UActorFactoryStaticMesh
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgActorFactory_TgStaticMeshActorCapturePoint");
		return ptr;
	}

};


// Class TgGame.TgActorFactory_TgStaticMeshActorTeamColor
// 0x0000 (0x00B0 - 0x00B0)
class UTgActorFactory_TgStaticMeshActorTeamColor : public UActorFactoryStaticMesh
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgActorFactory_TgStaticMeshActorTeamColor");
		return ptr;
	}

};


// Class TgGame.TgActorFactoryTgEmitter_TeamColor
// 0x0000 (0x00A4 - 0x00A4)
class UTgActorFactoryTgEmitter_TeamColor : public UActorFactoryEmitter
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgActorFactoryTgEmitter_TeamColor");
		return ptr;
	}

};


// Class TgGame.TgEmitterSpawnable_TeamColor
// 0x0000 (0x029C - 0x029C)
class ATgEmitterSpawnable_TeamColor : public ATgEmitter_TeamColor
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEmitterSpawnable_TeamColor");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_SetTaskforce
// 0x0004 (0x010C - 0x0108)
class UTgSeqAct_SetTaskforce : public USequenceAction
{
public:
	int                                                TaskForceNumber;                                          // 0x0108(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_SetTaskforce");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_AssignLane
// 0x0004 (0x0098 - 0x0094)
class UTgAIBehaviorAction_AssignLane : public UTgAIBehaviorAction
{
public:
	int                                                LaneIndex;                                                // 0x0094(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_AssignLane");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_CancelFiring
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorAction_CancelFiring : public UTgAIBehaviorAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_CancelFiring");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_ClearCombatTarget
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorAction_ClearCombatTarget : public UTgAIBehaviorAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_ClearCombatTarget");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_ClearLaneMoveTarget
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorAction_ClearLaneMoveTarget : public UTgAIBehaviorAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_ClearLaneMoveTarget");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_ClearLastAttacker
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorAction_ClearLastAttacker : public UTgAIBehaviorAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_ClearLastAttacker");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_ClearLookAtTarget
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorAction_ClearLookAtTarget : public UTgAIBehaviorAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_ClearLookAtTarget");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_ClearNavigationQueue
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorAction_ClearNavigationQueue : public UTgAIBehaviorAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_ClearNavigationQueue");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_ClearRallyPoint
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorAction_ClearRallyPoint : public UTgAIBehaviorAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_ClearRallyPoint");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_ClearSpreadLocation
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorAction_ClearSpreadLocation : public UTgAIBehaviorAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_ClearSpreadLocation");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_MoveBase
// 0x0008 (0x009C - 0x0094)
class UTgAIBehaviorAction_MoveBase : public UTgAIBehaviorAction
{
public:
	unsigned long                                      bSubtractPawnRadius : 1;                                  // 0x0094(0x0004) (Edit)
	unsigned long                                      bSubtractTargetPawnRadius : 1;                            // 0x0094(0x0004) (Edit)
	unsigned long                                      bLookAtTarget : 1;                                        // 0x0094(0x0004) (Edit)
	unsigned long                                      bMustHaveLOS : 1;                                         // 0x0094(0x0004) (Edit)
	float                                              MoveTolerance;                                            // 0x0098(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_MoveBase");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_MoveToTarget
// 0x0000 (0x009C - 0x009C)
class UTgAIBehaviorAction_MoveToTarget : public UTgAIBehaviorAction_MoveBase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_MoveToTarget");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_FollowCombatTarget
// 0x0001 (0x009D - 0x009C)
class UTgAIBehaviorAction_FollowCombatTarget : public UTgAIBehaviorAction_MoveToTarget
{
public:
	TEnumAsByte<ETG_EQUIP_POINT>                       DeviceSlot;                                               // 0x009C(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_FollowCombatTarget");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_FollowLane
// 0x0004 (0x0098 - 0x0094)
class UTgAIBehaviorAction_FollowLane : public UTgAIBehaviorAction
{
public:
	unsigned long                                      bUseReverseDirection : 1;                                 // 0x0094(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_FollowLane");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_FollowPatrol
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorAction_FollowPatrol : public UTgAIBehaviorAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_FollowPatrol");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_GroupUp
// 0x000C (0x00A8 - 0x009C)
class UTgAIBehaviorAction_GroupUp : public UTgAIBehaviorAction_MoveToTarget
{
public:
	TEnumAsByte<ETG_EQUIP_POINT>                       DeviceSlot;                                               // 0x009C(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x009D(0x0003) MISSED OFFSET
	float                                              MinDistance;                                              // 0x00A0(0x0004) (Edit)
	float                                              MaxDistance;                                              // 0x00A4(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_GroupUp");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_Juke
// 0x0008 (0x009C - 0x0094)
class UTgAIBehaviorAction_Juke : public UTgAIBehaviorAction
{
public:
	float                                              JukeDist;                                                 // 0x0094(0x0004) (Edit)
	float                                              JukeProbability;                                          // 0x0098(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_Juke");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_Jump
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorAction_Jump : public UTgAIBehaviorAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_Jump");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_Leash
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorAction_Leash : public UTgAIBehaviorAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_Leash");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_LookAtCapturePoint
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorAction_LookAtCapturePoint : public UTgAIBehaviorAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_LookAtCapturePoint");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_LookAtCombatTarget
// 0x0004 (0x0098 - 0x0094)
class UTgAIBehaviorAction_LookAtCombatTarget : public UTgAIBehaviorAction
{
public:
	unsigned long                                      bAllowAimNose : 1;                                        // 0x0094(0x0004) (Edit)
	unsigned long                                      bHeadShot : 1;                                            // 0x0094(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_LookAtCombatTarget");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_LookAtFortress
// 0x0004 (0x0098 - 0x0094)
class UTgAIBehaviorAction_LookAtFortress : public UTgAIBehaviorAction
{
public:
	unsigned long                                      bMustBeEnemy : 1;                                         // 0x0094(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_LookAtFortress");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_LookAtLanepusher
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorAction_LookAtLanepusher : public UTgAIBehaviorAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_LookAtLanepusher");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_LookAtSpawnRotation
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorAction_LookAtSpawnRotation : public UTgAIBehaviorAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_LookAtSpawnRotation");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_LookAtTargetLKL
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorAction_LookAtTargetLKL : public UTgAIBehaviorAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_LookAtTargetLKL");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_MoveAroundLanePusher
// 0x0008 (0x00A4 - 0x009C)
class UTgAIBehaviorAction_MoveAroundLanePusher : public UTgAIBehaviorAction_MoveToTarget
{
public:
	TEnumAsByte<ETG_EQUIP_POINT>                       DeviceSlot;                                               // 0x009C(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x009D(0x0003) MISSED OFFSET
	unsigned long                                      bMoveClockWise : 1;                                       // 0x00A0(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_MoveAroundLanePusher");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_MoveToAssaultPosition
// 0x0000 (0x009C - 0x009C)
class UTgAIBehaviorAction_MoveToAssaultPosition : public UTgAIBehaviorAction_MoveToTarget
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_MoveToAssaultPosition");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_MoveToAvoidableProjectile
// 0x0004 (0x00A0 - 0x009C)
class UTgAIBehaviorAction_MoveToAvoidableProjectile : public UTgAIBehaviorAction_MoveToTarget
{
public:
	unsigned long                                      bMustBeEnemy : 1;                                         // 0x009C(0x0004) (Edit)
	unsigned long                                      bIgnoreInsideCollision : 1;                               // 0x009C(0x0004) (Edit)
	unsigned long                                      bMoveAway : 1;                                            // 0x009C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_MoveToAvoidableProjectile");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_MoveToCapturePoint
// 0x0008 (0x00A4 - 0x009C)
class UTgAIBehaviorAction_MoveToCapturePoint : public UTgAIBehaviorAction_MoveToTarget
{
public:
	TEnumAsByte<ESelectionArbitrator>                  Arbitrator;                                               // 0x009C(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x009D(0x0003) MISSED OFFSET
	unsigned long                                      bTeleport : 1;                                            // 0x00A0(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_MoveToCapturePoint");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_MoveToCombatLKL
// 0x0000 (0x009C - 0x009C)
class UTgAIBehaviorAction_MoveToCombatLKL : public UTgAIBehaviorAction_MoveToTarget
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_MoveToCombatLKL");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_MoveToCover
// 0x0004 (0x00A0 - 0x009C)
class UTgAIBehaviorAction_MoveToCover : public UTgAIBehaviorAction_MoveToTarget
{
public:
	unsigned long                                      bAllowPopout : 1;                                         // 0x009C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_MoveToCover");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_MoveToDamagingDeployable
// 0x0004 (0x00A0 - 0x009C)
class UTgAIBehaviorAction_MoveToDamagingDeployable : public UTgAIBehaviorAction_MoveToTarget
{
public:
	unsigned long                                      bMustBeEnemy : 1;                                         // 0x009C(0x0004) (Edit)
	unsigned long                                      bIgnoreInsideCollision : 1;                               // 0x009C(0x0004) (Edit)
	unsigned long                                      bMoveAway : 1;                                            // 0x009C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_MoveToDamagingDeployable");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_MoveToDeployable
// 0x0008 (0x00A4 - 0x009C)
class UTgAIBehaviorAction_MoveToDeployable : public UTgAIBehaviorAction_MoveToTarget
{
public:
	int                                                DeployableId;                                             // 0x009C(0x0004) (Edit)
	unsigned long                                      bMustBeEnemy : 1;                                         // 0x00A0(0x0004) (Edit)
	unsigned long                                      bIgnoreInsideCollision : 1;                               // 0x00A0(0x0004) (Edit)
	unsigned long                                      bIgnoreTaskforce : 1;                                     // 0x00A0(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_MoveToDeployable");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_MoveToLanePusher
// 0x0001 (0x009D - 0x009C)
class UTgAIBehaviorAction_MoveToLanePusher : public UTgAIBehaviorAction_MoveToTarget
{
public:
	TEnumAsByte<ETG_EQUIP_POINT>                       DeviceSlot;                                               // 0x009C(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_MoveToLanePusher");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_MoveToLanePusherFront
// 0x0001 (0x009D - 0x009C)
class UTgAIBehaviorAction_MoveToLanePusherFront : public UTgAIBehaviorAction_MoveToTarget
{
public:
	TEnumAsByte<ETG_EQUIP_POINT>                       DeviceSlot;                                               // 0x009C(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_MoveToLanePusherFront");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_MoveToLaneTarget
// 0x0000 (0x009C - 0x009C)
class UTgAIBehaviorAction_MoveToLaneTarget : public UTgAIBehaviorAction_MoveToTarget
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_MoveToLaneTarget");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_MoveToLaneVolume
// 0x0004 (0x00A0 - 0x009C)
class UTgAIBehaviorAction_MoveToLaneVolume : public UTgAIBehaviorAction_MoveToTarget
{
public:
	unsigned long                                      bMustBeSameLane : 1;                                      // 0x009C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_MoveToLaneVolume");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_MoveToRallyPoint
// 0x0008 (0x00A4 - 0x009C)
class UTgAIBehaviorAction_MoveToRallyPoint : public UTgAIBehaviorAction_MoveToTarget
{
public:
	TEnumAsByte<ESelectionArbitrator>                  ArbitratorOnMultipleValid;                                // 0x009C(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x009D(0x0003) MISSED OFFSET
	unsigned long                                      bMustBeSameLane : 1;                                      // 0x00A0(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_MoveToRallyPoint");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_MoveToShield
// 0x0004 (0x00A0 - 0x009C)
class UTgAIBehaviorAction_MoveToShield : public UTgAIBehaviorAction_MoveToTarget
{
public:
	unsigned long                                      bMustBeEnemy : 1;                                         // 0x009C(0x0004) (Edit)
	unsigned long                                      bIgnoreInsideCollision : 1;                               // 0x009C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_MoveToShield");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_PauseAI
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorAction_PauseAI : public UTgAIBehaviorAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_PauseAI");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_GetTeamIndex
// 0x0000 (0x0108 - 0x0108)
class UTgSeqAct_GetTeamIndex : public USequenceAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_GetTeamIndex");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_GetTaskForceNumber
// 0x0000 (0x0108 - 0x0108)
class UTgSeqAct_GetTaskForceNumber : public USequenceAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_GetTaskForceNumber");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_SetCrowdControlImmune
// 0x0000 (0x0108 - 0x0108)
class UTgSeqAct_SetCrowdControlImmune : public USequenceAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_SetCrowdControlImmune");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_KillBots
// 0x0000 (0x0108 - 0x0108)
class UTgSeqAct_KillBots : public USequenceAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_KillBots");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_Killpawns
// 0x0000 (0x0108 - 0x0108)
class UTgSeqAct_Killpawns : public UTgSeqAct_KillBots
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_Killpawns");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_DespawnBots
// 0x0000 (0x0108 - 0x0108)
class UTgSeqAct_DespawnBots : public USequenceAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_DespawnBots");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_JoinTeam
// 0x0008 (0x0110 - 0x0108)
class UTgSeqAct_JoinTeam : public USequenceAction
{
public:
	class AActor*                                      TeamLeader;                                               // 0x0108(0x0008) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_JoinTeam");
		return ptr;
	}

};


// Class TgGame.TgDamageType_FallOutOfWorld
// 0x0000 (0x0154 - 0x0154)
class UTgDamageType_FallOutOfWorld : public UTgDamageType
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDamageType_FallOutOfWorld");
		return ptr;
	}

};


// Class TgGame.TgControlModule
// 0x000C (0x006C - 0x0060)
class UTgControlModule : public UObject
{
public:
	class ATgPlayerController*                         Controller;                                               // 0x0060(0x0008)
	unsigned long                                      m_bIsActive : 1;                                          // 0x0068(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgControlModule");
		return ptr;
	}


	bool STATIC_InterceptFlashInput(const struct FName& ButtonName, TEnumAsByte<EInputEvent> Event);
	void AdjustAimingView(struct FVector* ViewLocation, struct FRotator* ViewRotation);
	void STATIC_OnRightMouseReleased();
	void STATIC_OnRightMousePressed();
	void STATIC_UpdateRotation(float DeltaTime);
	void STATIC_PlayerMove(float DeltaTime);
	void STATIC_ProcessMove(float DeltaTime, const struct FVector& newAccel, TEnumAsByte<EDoubleClickDir> DoubleClickMove, const struct FRotator& DeltaRot);
	struct FRotator STATIC_GetBaseAimRotation(class AWeapon* W, bool bIgnoreAutoLock);
	void STATIC_OnSettingsChanged(class UTgClientSettings* Settings);
	void STATIC_OnBecomeInActive(class UTgControlModule* NewModule);
	void STATIC_OnBecomeActive(class UTgControlModule* OldModule);
	void Init();
};


// Class TgGame.TgControlModule_ThirdPerson
// 0x0060 (0x00CC - 0x006C)
class UTgControlModule_ThirdPerson : public UTgControlModule
{
public:
	int                                                CameraYawOffset;                                          // 0x006C(0x0004)
	float                                              fRotInterpSpeed;                                          // 0x0070(0x0004)
	float                                              fAimPitch;                                                // 0x0074(0x0004)
	struct FInterpCurveFloat                           PitchCurve;                                               // 0x0078(0x0014) (NeedCtorLink)
	struct FInterpCurveFloat                           AimCurve;                                                 // 0x008C(0x0014) (NeedCtorLink)
	unsigned long                                      m_bWasInCatapultLastTick : 1;                             // 0x00A0(0x0004)
	struct FRotator                                    m_InitialRotationToCatapult;                              // 0x00A4(0x000C)
	class UCameraAnim*                                 m_StrafeCameraAnim;                                       // 0x00B0(0x0008)
	float                                              fOrientationResetStartPitch;                              // 0x00B8(0x0004)
	float                                              fOrientationResetRemaining;                               // 0x00BC(0x0004)
	float                                              fOrientationResetDuration;                                // 0x00C0(0x0004)
	float                                              fOrientationResetCooldown;                                // 0x00C4(0x0004)
	float                                              fOrientationResetLastUsed;                                // 0x00C8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgControlModule_ThirdPerson");
		return ptr;
	}


	void AdjustAimingView(struct FVector* ViewLocation, struct FRotator* ViewRotation);
	bool STATIC_IsFixedPitchMode();
	bool STATIC_IsYawLocked();
	bool STATIC_IsCameraLocked();
	bool STATIC_IsRotationLocked();
	bool STATIC_IsInputLocked();
	void UpdateAimPitch();
	void STATIC_UpdateRotationCatapult(const struct FRotator& DeltaRot, float DeltaTime, class ATgPawn* TgP, class ATgCatapultActor* Catapult);
	void STATIC_UpdateRotation(float DeltaTime);
	bool STATIC_IsPlayingForcedViewCameraAnim();
	struct FVector CalcNewAccel();
	struct FVector CalcSkydiveAccel();
	void STATIC_PlayerMove(float DeltaTime);
	void STATIC_ProcessMove(float DeltaTime, const struct FVector& newAccel, TEnumAsByte<EDoubleClickDir> DoubleClickMove, const struct FRotator& DeltaRot);
	void STATIC_ResetViewOrientation();
	struct FRotator STATIC_GetBaseAimRotation(class AWeapon* W, bool bIgnoreAutoLock);
	void STATIC_OnBecomeActive(class UTgControlModule* OldModule);
	void UpdatePitchCurve();
	void STATIC_OnSettingsChanged(class UTgClientSettings* Settings);
	void Init();
};


// Class TgGame.TgControlModule_StunTaunted
// 0x000C (0x00D8 - 0x00CC)
class UTgControlModule_StunTaunted : public UTgControlModule_ThirdPerson
{
public:
	float                                              m_fInitialYaw;                                            // 0x00CC(0x0004)
	float                                              m_fInterpTime;                                            // 0x00D0(0x0004) (Const)
	float                                              m_fRemainingInterpTime;                                   // 0x00D4(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgControlModule_StunTaunted");
		return ptr;
	}


	void STATIC_UpdateRotation(float DeltaTime);
	struct FVector CalcNewAccel();
	void STATIC_OnBecomeInActive(class UTgControlModule* NewModule);
	void STATIC_OnBecomeActive(class UTgControlModule* OldModule);
};


// Class TgGame.TgDamageType_Rider
// 0x0000 (0x0154 - 0x0154)
class UTgDamageType_Rider : public UTgDamageType
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDamageType_Rider");
		return ptr;
	}

};


// Class TgGame.TgCameraModule_FallOutOfWorld
// 0x0000 (0x007C - 0x007C)
class UTgCameraModule_FallOutOfWorld : public UTgCameraModule_Free
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCameraModule_FallOutOfWorld");
		return ptr;
	}


	struct FVector STATIC_GetCamLocationOffset(class APawn* P);
	void STATIC_UpdateCamera(class APawn* P, class ATgPlayerCamera* CameraActor, float DeltaTime, struct FTViewTarget* OutVT);
};


// Class TgGame.TgDevice_JumpPack
// 0x0000 (0x0AEC - 0x0AEC)
class ATgDevice_JumpPack : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_JumpPack");
		return ptr;
	}


	bool STATIC_CanFireWithoutAimResult();
};


// Class TgGame.TgNearObjectiveVolume
// 0x0000 (0x02BC - 0x02BC)
class ATgNearObjectiveVolume : public AVolume
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgNearObjectiveVolume");
		return ptr;
	}


	void UnTouch(class AActor* Other);
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
};


// Class TgGame.TgWeatherVolume
// 0x0008 (0x02C4 - 0x02BC)
class ATgWeatherVolume : public AVolume
{
public:
	class UParticleSystem*                             m_Template;                                               // 0x02BC(0x0008) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgWeatherVolume");
		return ptr;
	}


	void UnTouch(class AActor* Other);
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
};


// Class TgGame.TgAIBehaviorAction_PlayEmote
// 0x0001 (0x0095 - 0x0094)
class UTgAIBehaviorAction_PlayEmote : public UTgAIBehaviorAction
{
public:
	TEnumAsByte<EEmote>                                EmoteToPlay;                                              // 0x0094(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_PlayEmote");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_PurchaseBurnCards
// 0x000C (0x00A0 - 0x0094)
class UTgAIBehaviorAction_PurchaseBurnCards : public UTgAIBehaviorAction
{
public:
	int                                                BurnCardId;                                               // 0x0094(0x0004) (Edit)
	int                                                DesiredRank;                                              // 0x0098(0x0004) (Edit)
	unsigned long                                      bDontPay : 1;                                             // 0x009C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_PurchaseBurnCards");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_PurchaseItems
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorAction_PurchaseItems : public UTgAIBehaviorAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_PurchaseItems");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_PurchaseSkills
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorAction_PurchaseSkills : public UTgAIBehaviorAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_PurchaseSkills");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_Regen
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorAction_Regen : public UTgAIBehaviorAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_Regen");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_ReloadDevice
// 0x0001 (0x0095 - 0x0094)
class UTgAIBehaviorAction_ReloadDevice : public UTgAIBehaviorAction
{
public:
	TEnumAsByte<ETG_EQUIP_POINT>                       DeviceToUse;                                              // 0x0094(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_ReloadDevice");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_RunToOwner
// 0x0000 (0x009C - 0x009C)
class UTgAIBehaviorAction_RunToOwner : public UTgAIBehaviorAction_MoveToTarget
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_RunToOwner");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_RunToSpawn
// 0x0000 (0x009C - 0x009C)
class UTgAIBehaviorAction_RunToSpawn : public UTgAIBehaviorAction_MoveToTarget
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_RunToSpawn");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_RunToSpreadLocation
// 0x0000 (0x009C - 0x009C)
class UTgAIBehaviorAction_RunToSpreadLocation : public UTgAIBehaviorAction_MoveToTarget
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_RunToSpreadLocation");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_SelectLaneCombatTarget
// 0x0014 (0x00A8 - 0x0094)
class UTgAIBehaviorAction_SelectLaneCombatTarget : public UTgAIBehaviorAction
{
public:
	unsigned long                                      bMustBeEnemy : 1;                                         // 0x0094(0x0004) (Edit)
	unsigned long                                      bMustBeSameLane : 1;                                      // 0x0094(0x0004) (Edit)
	unsigned long                                      bMustHaveLineOfSight : 1;                                 // 0x0094(0x0004) (Edit)
	unsigned long                                      bMustHaveDamagedGod : 1;                                  // 0x0094(0x0004) (Edit)
	unsigned long                                      bMustNotBeImmune : 1;                                     // 0x0094(0x0004) (Edit)
	unsigned long                                      bMustBeInForwardCone : 1;                                 // 0x0094(0x0004) (Edit)
	unsigned long                                      bEffectGroupCategoryCheckInstigator : 1;                  // 0x0094(0x0004) (Edit)
	unsigned long                                      bMustBeHittable : 1;                                      // 0x0094(0x0004) (Edit)
	unsigned long                                      bMustNotBeNearShield : 1;                                 // 0x0094(0x0004) (Edit)
	TEnumAsByte<ETargetSelector>                       TargetSelector;                                           // 0x0098(0x0001) (Edit)
	TEnumAsByte<ECombatTargetType>                     TargetType;                                               // 0x0099(0x0001) (Edit)
	TEnumAsByte<ECombatTargetType>                     IgnoreTargetType;                                         // 0x009A(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x1];                                       // 0x009B(0x0001) MISSED OFFSET
	int                                                EffectCategoryId;                                         // 0x009C(0x0004) (Edit)
	float                                              DistanceThreshold;                                        // 0x00A0(0x0004) (Edit)
	float                                              ForwardConeAngle;                                         // 0x00A4(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_SelectLaneCombatTarget");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_SelectAllyAttackerAsTarget
// 0x000C (0x00B4 - 0x00A8)
class UTgAIBehaviorAction_SelectAllyAttackerAsTarget : public UTgAIBehaviorAction_SelectLaneCombatTarget
{
public:
	float                                              TimeThreshold;                                            // 0x00A8(0x0004) (Edit)
	float                                              AllyDistanceThreshold;                                    // 0x00AC(0x0004) (Edit)
	float                                              AttackerDistanceThreshold;                                // 0x00B0(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_SelectAllyAttackerAsTarget");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_SelectCombatTarget_FortressObjective
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorAction_SelectCombatTarget_FortressObjective : public UTgAIBehaviorAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_SelectCombatTarget_FortressObjective");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_SelectCombatTarget_LanepusherLastAttacker
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorAction_SelectCombatTarget_LanepusherLastAttacker : public UTgAIBehaviorAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_SelectCombatTarget_LanepusherLastAttacker");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_SelectCombatTarget_OwnerLastAttacker
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorAction_SelectCombatTarget_OwnerLastAttacker : public UTgAIBehaviorAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_SelectCombatTarget_OwnerLastAttacker");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_SelectCombatTargetsTarget
// 0x0004 (0x0098 - 0x0094)
class UTgAIBehaviorAction_SelectCombatTargetsTarget : public UTgAIBehaviorAction
{
public:
	unsigned long                                      bGodsOnly : 1;                                            // 0x0094(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_SelectCombatTargetsTarget");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_SelectLaneCombatTarget_Jungle
// 0x0005 (0x0099 - 0x0094)
class UTgAIBehaviorAction_SelectLaneCombatTarget_Jungle : public UTgAIBehaviorAction
{
public:
	unsigned long                                      bMustBeWeakest : 1;                                       // 0x0094(0x0004) (Edit)
	TEnumAsByte<EJungleTargetType>                     TargetType;                                               // 0x0098(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_SelectLaneCombatTarget_Jungle");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_SelectLaneCombatTarget_LastAttacker
// 0x0005 (0x0099 - 0x0094)
class UTgAIBehaviorAction_SelectLaneCombatTarget_LastAttacker : public UTgAIBehaviorAction
{
public:
	unsigned long                                      bSkipPawnNotify : 1;                                      // 0x0094(0x0004) (Edit)
	unsigned long                                      bMustBeHittable : 1;                                      // 0x0094(0x0004) (Edit)
	TEnumAsByte<ECombatTargetType>                     IgnoreTargetType;                                         // 0x0098(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_SelectLaneCombatTarget_LastAttacker");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_SelectLaneMoveTarget
// 0x0004 (0x0098 - 0x0094)
class UTgAIBehaviorAction_SelectLaneMoveTarget : public UTgAIBehaviorAction
{
public:
	unsigned long                                      bMustBeEnemy : 1;                                         // 0x0094(0x0004) (Edit)
	unsigned long                                      bMustBePhoenix : 1;                                       // 0x0094(0x0004) (Edit)
	unsigned long                                      bMustBeSameLane : 1;                                      // 0x0094(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_SelectLaneMoveTarget");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_SelectLaneMoveTarget_Jungle
// 0x0001 (0x0095 - 0x0094)
class UTgAIBehaviorAction_SelectLaneMoveTarget_Jungle : public UTgAIBehaviorAction
{
public:
	TEnumAsByte<EJungleTargetType>                     TargetType;                                               // 0x0094(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_SelectLaneMoveTarget_Jungle");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_SelectLaneMoveTarget_Minotaur
// 0x0004 (0x0098 - 0x0094)
class UTgAIBehaviorAction_SelectLaneMoveTarget_Minotaur : public UTgAIBehaviorAction
{
public:
	unsigned long                                      bMustBeEnemy : 1;                                         // 0x0094(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_SelectLaneMoveTarget_Minotaur");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_SelectLaneMoveTargetAsCombatTarget
// 0x0004 (0x0098 - 0x0094)
class UTgAIBehaviorAction_SelectLaneMoveTargetAsCombatTarget : public UTgAIBehaviorAction
{
public:
	unsigned long                                      bSkipPawnNotify : 1;                                      // 0x0094(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_SelectLaneMoveTargetAsCombatTarget");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_SelectLanepusherCombatTarget
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorAction_SelectLanepusherCombatTarget : public UTgAIBehaviorAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_SelectLanepusherCombatTarget");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_SelectLeashCombatTarget
// 0x000C (0x00A0 - 0x0094)
class UTgAIBehaviorAction_SelectLeashCombatTarget : public UTgAIBehaviorAction
{
public:
	unsigned long                                      bMustBeEnemy : 1;                                         // 0x0094(0x0004) (Edit)
	unsigned long                                      bMustBeWeakest : 1;                                       // 0x0094(0x0004) (Edit)
	unsigned long                                      bMustHaveLineOfSight : 1;                                 // 0x0094(0x0004) (Edit)
	unsigned long                                      bMustHaveDamagedGod : 1;                                  // 0x0094(0x0004) (Edit)
	unsigned long                                      bMustNotBeImmune : 1;                                     // 0x0094(0x0004) (Edit)
	unsigned long                                      bEffectGroupCategoryCheckInstigator : 1;                  // 0x0094(0x0004) (Edit)
	unsigned long                                      bMustBeHittable : 1;                                      // 0x0094(0x0004) (Edit)
	TEnumAsByte<ECombatTargetType>                     TargetType;                                               // 0x0098(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0099(0x0003) MISSED OFFSET
	int                                                EffectCategoryId;                                         // 0x009C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_SelectLeashCombatTarget");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_SelectOwnerCombatTarget
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorAction_SelectOwnerCombatTarget : public UTgAIBehaviorAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_SelectOwnerCombatTarget");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_SelectSquadCombatTarget
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorAction_SelectSquadCombatTarget : public UTgAIBehaviorAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_SelectSquadCombatTarget");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_SelectThreatCombatTarget
// 0x000C (0x00A0 - 0x0094)
class UTgAIBehaviorAction_SelectThreatCombatTarget : public UTgAIBehaviorAction
{
public:
	unsigned long                                      bMustBeHighestThreat : 1;                                 // 0x0094(0x0004) (Edit)
	unsigned long                                      bMustBeInLeash : 1;                                       // 0x0094(0x0004) (Edit)
	unsigned long                                      bMustBeInSightRadius : 1;                                 // 0x0094(0x0004) (Edit)
	unsigned long                                      bEffectGroupCategoryCheckInstigator : 1;                  // 0x0094(0x0004) (Edit)
	unsigned long                                      bMustBeHittable : 1;                                      // 0x0094(0x0004) (Edit)
	TEnumAsByte<ECombatTargetType>                     TargetType;                                               // 0x0098(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0099(0x0003) MISSED OFFSET
	int                                                EffectCategoryId;                                         // 0x009C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_SelectThreatCombatTarget");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_SetAimDevice
// 0x0001 (0x0095 - 0x0094)
class UTgAIBehaviorAction_SetAimDevice : public UTgAIBehaviorAction
{
public:
	TEnumAsByte<ETG_EQUIP_POINT>                       DeviceToUse;                                              // 0x0094(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_SetAimDevice");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_SetBotBehaviorState
// 0x0001 (0x0095 - 0x0094)
class UTgAIBehaviorAction_SetBotBehaviorState : public UTgAIBehaviorAction
{
public:
	TEnumAsByte<EBotBehaviorState>                     DesiredBehaviorState;                                     // 0x0094(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_SetBotBehaviorState");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_SpreadFromSquad
// 0x0004 (0x00A0 - 0x009C)
class UTgAIBehaviorAction_SpreadFromSquad : public UTgAIBehaviorAction_MoveToTarget
{
public:
	float                                              SpreadDistance;                                           // 0x009C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_SpreadFromSquad");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_StopDevice
// 0x0001 (0x0095 - 0x0094)
class UTgAIBehaviorAction_StopDevice : public UTgAIBehaviorAction
{
public:
	TEnumAsByte<ETG_EQUIP_POINT>                       DeviceToUse;                                              // 0x0094(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_StopDevice");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_Strafe
// 0x0008 (0x00A4 - 0x009C)
class UTgAIBehaviorAction_Strafe : public UTgAIBehaviorAction_MoveToTarget
{
public:
	float                                              StrafeUpdateTime;                                         // 0x009C(0x0004) (Edit)
	float                                              DistanceMultiplier;                                       // 0x00A0(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_Strafe");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_SuggestSquadCombatTarget
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorAction_SuggestSquadCombatTarget : public UTgAIBehaviorAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_SuggestSquadCombatTarget");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_UpdateTargetLastKnownLocation
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorAction_UpdateTargetLastKnownLocation : public UTgAIBehaviorAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_UpdateTargetLastKnownLocation");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_UseActive
// 0x0001 (0x0095 - 0x0094)
class UTgAIBehaviorAction_UseActive : public UTgAIBehaviorAction
{
public:
	TEnumAsByte<EActiveType>                           ActiveType;                                               // 0x0094(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_UseActive");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_UseConsumable
// 0x0001 (0x0095 - 0x0094)
class UTgAIBehaviorAction_UseConsumable : public UTgAIBehaviorAction
{
public:
	TEnumAsByte<EConsumableType>                       ConsumableType;                                           // 0x0094(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_UseConsumable");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_UseDevice
// 0x0008 (0x009C - 0x0094)
class UTgAIBehaviorAction_UseDevice : public UTgAIBehaviorAction
{
public:
	TEnumAsByte<ETG_EQUIP_POINT>                       DeviceToUse;                                              // 0x0094(0x0001) (Edit)
	TEnumAsByte<EUseDeviceAimType>                     aimType;                                                  // 0x0095(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x2];                                       // 0x0096(0x0002) MISSED OFFSET
	unsigned long                                      bContinuousFire : 1;                                      // 0x0098(0x0004) (Edit)
	unsigned long                                      bPayNoEnergy : 1;                                         // 0x0098(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_UseDevice");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_Wiggle
// 0x0004 (0x0098 - 0x0094)
class UTgAIBehaviorAction_Wiggle : public UTgAIBehaviorAction
{
public:
	float                                              WiggleIntensity;                                          // 0x0094(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_Wiggle");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorComposite_SequenceAND
// 0x0000 (0x00BC - 0x00BC)
class UTgAIBehaviorComposite_SequenceAND : public UTgAIBehaviorComposite_Sequence
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorComposite_SequenceAND");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorComposite_SequenceOR
// 0x0000 (0x00BC - 0x00BC)
class UTgAIBehaviorComposite_SequenceOR : public UTgAIBehaviorComposite_Sequence
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorComposite_SequenceOR");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_AmmoAfterShot
// 0x000B (0x00A0 - 0x0095)
class UTgAIBehaviorCondition_AmmoAfterShot : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	TEnumAsByte<ETG_EQUIP_POINT>                       DeviceSlot;                                               // 0x0098(0x0001) (Edit)
	unsigned char                                      UnknownData01[0x3];                                       // 0x0099(0x0003) MISSED OFFSET
	int                                                AmmoThreshold;                                            // 0x009C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_AmmoAfterShot");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_AmmoCostPerShot
// 0x000B (0x00A0 - 0x0095)
class UTgAIBehaviorCondition_AmmoCostPerShot : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	TEnumAsByte<ETG_EQUIP_POINT>                       DeviceSlot;                                               // 0x0098(0x0001) (Edit)
	unsigned char                                      UnknownData01[0x3];                                       // 0x0099(0x0003) MISSED OFFSET
	int                                                AmmoThreshold;                                            // 0x009C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_AmmoCostPerShot");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_AmmoCount
// 0x000B (0x00A0 - 0x0095)
class UTgAIBehaviorCondition_AmmoCount : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	TEnumAsByte<ETG_EQUIP_POINT>                       DeviceSlot;                                               // 0x0098(0x0001) (Edit)
	unsigned char                                      UnknownData01[0x3];                                       // 0x0099(0x0003) MISSED OFFSET
	int                                                AmmoThreshold;                                            // 0x009C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_AmmoCount");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_CanPurchaseItems
// 0x0003 (0x0098 - 0x0095)
class UTgAIBehaviorCondition_CanPurchaseItems : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_CanPurchaseItems");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_CanPurchaseSkills
// 0x0003 (0x0098 - 0x0095)
class UTgAIBehaviorCondition_CanPurchaseSkills : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_CanPurchaseSkills");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_CombatTargetDamageable
// 0x0003 (0x0098 - 0x0095)
class UTgAIBehaviorCondition_CombatTargetDamageable : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_CombatTargetDamageable");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_CombatTargetDamageableByDevice
// 0x0004 (0x0099 - 0x0095)
class UTgAIBehaviorCondition_CombatTargetDamageableByDevice : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	TEnumAsByte<ETG_EQUIP_POINT>                       DeviceSlot;                                               // 0x0098(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_CombatTargetDamageableByDevice");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_CombatTargetDamagedFriendlyGod
// 0x0003 (0x0098 - 0x0095)
class UTgAIBehaviorCondition_CombatTargetDamagedFriendlyGod : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_CombatTargetDamagedFriendlyGod");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_DistanceBase
// 0x0007 (0x009C - 0x0095)
class UTgAIBehaviorCondition_DistanceBase : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	float                                              DistanceThreshold;                                        // 0x0098(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_DistanceBase");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_CombatTargetDistanceFromCapturePoint
// 0x0000 (0x009C - 0x009C)
class UTgAIBehaviorCondition_CombatTargetDistanceFromCapturePoint : public UTgAIBehaviorCondition_DistanceBase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_CombatTargetDistanceFromCapturePoint");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_CombatTargetDistanceOwner
// 0x0000 (0x009C - 0x009C)
class UTgAIBehaviorCondition_CombatTargetDistanceOwner : public UTgAIBehaviorCondition_DistanceBase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_CombatTargetDistanceOwner");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_CombatTargetDropped
// 0x0003 (0x0098 - 0x0095)
class UTgAIBehaviorCondition_CombatTargetDropped : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_CombatTargetDropped");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_CombatTargetHealthPercent
// 0x0007 (0x009C - 0x0095)
class UTgAIBehaviorCondition_CombatTargetHealthPercent : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	float                                              HealthPct;                                                // 0x0098(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_CombatTargetHealthPercent");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_CombatTargetHealthPercentAfterAttack
// 0x000B (0x00A0 - 0x0095)
class UTgAIBehaviorCondition_CombatTargetHealthPercentAfterAttack : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	TEnumAsByte<ETG_EQUIP_POINT>                       DeviceSlot;                                               // 0x0098(0x0001) (Edit)
	unsigned char                                      UnknownData01[0x3];                                       // 0x0099(0x0003) MISSED OFFSET
	float                                              HealthPct;                                                // 0x009C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_CombatTargetHealthPercentAfterAttack");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_CombatTargetInDeviceVolume
// 0x000B (0x00A0 - 0x0095)
class UTgAIBehaviorCondition_CombatTargetInDeviceVolume : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	int                                                DeviceID;                                                 // 0x0098(0x0004) (Edit)
	unsigned long                                      bMustBeEnemy : 1;                                         // 0x009C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_CombatTargetInDeviceVolume");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_CombatTargetIsInMinotaurRadius
// 0x0007 (0x009C - 0x0095)
class UTgAIBehaviorCondition_CombatTargetIsInMinotaurRadius : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	unsigned long                                      bMustBeEnemy : 1;                                         // 0x0098(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_CombatTargetIsInMinotaurRadius");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_CombatTargetIsInTowerRadius
// 0x0007 (0x009C - 0x0095)
class UTgAIBehaviorCondition_CombatTargetIsInTowerRadius : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	unsigned long                                      bMustBeEnemy : 1;                                         // 0x0098(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_CombatTargetIsInTowerRadius");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_CombatTargetIsTargetOfFriendlyTowerOrMinotaur
// 0x0003 (0x0098 - 0x0095)
class UTgAIBehaviorCondition_CombatTargetIsTargetOfFriendlyTowerOrMinotaur : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_CombatTargetIsTargetOfFriendlyTowerOrMinotaur");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_CombatTargetPhysicsState
// 0x0004 (0x0099 - 0x0095)
class UTgAIBehaviorCondition_CombatTargetPhysicsState : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	TEnumAsByte<EPhysics>                              PhysicsState;                                             // 0x0098(0x0001)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_CombatTargetPhysicsState");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_CurrentLevel
// 0x0007 (0x009C - 0x0095)
class UTgAIBehaviorCondition_CurrentLevel : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	int                                                LevelThreshold;                                           // 0x0098(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_CurrentLevel");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_DeltaGodsInCapturePoint
// 0x0007 (0x009C - 0x0095)
class UTgAIBehaviorCondition_DeltaGodsInCapturePoint : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	int                                                GodThreshold;                                             // 0x0098(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_DeltaGodsInCapturePoint");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_DeviceIsFiring
// 0x0004 (0x0099 - 0x0095)
class UTgAIBehaviorCondition_DeviceIsFiring : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	TEnumAsByte<ETG_EQUIP_POINT>                       DeviceSlot;                                               // 0x0098(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_DeviceIsFiring");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_DeviceReadyToUse
// 0x0004 (0x0099 - 0x0095)
class UTgAIBehaviorCondition_DeviceReadyToUse : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	TEnumAsByte<ETG_EQUIP_POINT>                       DeviceSlot;                                               // 0x0098(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_DeviceReadyToUse");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_DifficultyLevel
// 0x0004 (0x0099 - 0x0095)
class UTgAIBehaviorCondition_DifficultyLevel : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	TEnumAsByte<EBotDifficultyLevel>                   Difficulty;                                               // 0x0098(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_DifficultyLevel");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_DistanceFromAssaultPoint
// 0x0000 (0x009C - 0x009C)
class UTgAIBehaviorCondition_DistanceFromAssaultPoint : public UTgAIBehaviorCondition_DistanceBase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_DistanceFromAssaultPoint");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_DistanceFromAvoidableProjectile
// 0x0004 (0x00A0 - 0x009C)
class UTgAIBehaviorCondition_DistanceFromAvoidableProjectile : public UTgAIBehaviorCondition_DistanceBase
{
public:
	unsigned long                                      bMustBeEnemy : 1;                                         // 0x009C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_DistanceFromAvoidableProjectile");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_DistanceFromCapturePoint
// 0x0000 (0x009C - 0x009C)
class UTgAIBehaviorCondition_DistanceFromCapturePoint : public UTgAIBehaviorCondition_DistanceBase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_DistanceFromCapturePoint");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_DistanceFromCombatTarget
// 0x0000 (0x009C - 0x009C)
class UTgAIBehaviorCondition_DistanceFromCombatTarget : public UTgAIBehaviorCondition_DistanceBase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_DistanceFromCombatTarget");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_DistanceFromDamagingDeployable
// 0x0004 (0x00A0 - 0x009C)
class UTgAIBehaviorCondition_DistanceFromDamagingDeployable : public UTgAIBehaviorCondition_DistanceBase
{
public:
	unsigned long                                      bMustBeEnemy : 1;                                         // 0x009C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_DistanceFromDamagingDeployable");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_DistanceFromFortressObjective
// 0x0000 (0x009C - 0x009C)
class UTgAIBehaviorCondition_DistanceFromFortressObjective : public UTgAIBehaviorCondition_DistanceBase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_DistanceFromFortressObjective");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_DistanceFromLanePusher
// 0x0000 (0x009C - 0x009C)
class UTgAIBehaviorCondition_DistanceFromLanePusher : public UTgAIBehaviorCondition_DistanceBase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_DistanceFromLanePusher");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_DistanceFromLaneTarget
// 0x0000 (0x009C - 0x009C)
class UTgAIBehaviorCondition_DistanceFromLaneTarget : public UTgAIBehaviorCondition_DistanceBase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_DistanceFromLaneTarget");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_DistanceFromNavigationDestination
// 0x0000 (0x009C - 0x009C)
class UTgAIBehaviorCondition_DistanceFromNavigationDestination : public UTgAIBehaviorCondition_DistanceBase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_DistanceFromNavigationDestination");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_DistanceFromOwner
// 0x0000 (0x009C - 0x009C)
class UTgAIBehaviorCondition_DistanceFromOwner : public UTgAIBehaviorCondition_DistanceBase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_DistanceFromOwner");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_DistanceFromSelectedTarget
// 0x000C (0x00A8 - 0x009C)
class UTgAIBehaviorCondition_DistanceFromSelectedTarget : public UTgAIBehaviorCondition_DistanceBase
{
public:
	unsigned long                                      bMustBeEnemy : 1;                                         // 0x009C(0x0004) (Edit)
	unsigned long                                      bIgnoreTaskforce : 1;                                     // 0x009C(0x0004) (Edit)
	TEnumAsByte<ETargetSelector>                       TargetSelector;                                           // 0x00A0(0x0001) (Edit)
	TEnumAsByte<ECombatTargetType>                     TargetType;                                               // 0x00A1(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x2];                                       // 0x00A2(0x0002) MISSED OFFSET
	int                                                DeployableId;                                             // 0x00A4(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_DistanceFromSelectedTarget");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_DistanceFromShield
// 0x0004 (0x00A0 - 0x009C)
class UTgAIBehaviorCondition_DistanceFromShield : public UTgAIBehaviorCondition_DistanceBase
{
public:
	unsigned long                                      bMustBeEnemy : 1;                                         // 0x009C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_DistanceFromShield");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_DistanceFromSpawn
// 0x0000 (0x009C - 0x009C)
class UTgAIBehaviorCondition_DistanceFromSpawn : public UTgAIBehaviorCondition_DistanceBase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_DistanceFromSpawn");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_DistanceFromSquadTarget
// 0x0000 (0x009C - 0x009C)
class UTgAIBehaviorCondition_DistanceFromSquadTarget : public UTgAIBehaviorCondition_DistanceBase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_DistanceFromSquadTarget");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_Energy
// 0x0007 (0x009C - 0x0095)
class UTgAIBehaviorCondition_Energy : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	float                                              energy;                                                   // 0x0098(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_Energy");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_GameType
// 0x0004 (0x0099 - 0x0095)
class UTgAIBehaviorCondition_GameType : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	TEnumAsByte<ETG_GAME_TYPE>                         GameType;                                                 // 0x0098(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_GameType");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_HasActive
// 0x0004 (0x0099 - 0x0095)
class UTgAIBehaviorCondition_HasActive : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	TEnumAsByte<EActiveType>                           ActiveType;                                               // 0x0098(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_HasActive");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_HasCombatTarget
// 0x0003 (0x0098 - 0x0095)
class UTgAIBehaviorCondition_HasCombatTarget : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_HasCombatTarget");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_HasConsumable
// 0x0004 (0x0099 - 0x0095)
class UTgAIBehaviorCondition_HasConsumable : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	TEnumAsByte<EConsumableType>                       ConsumableType;                                           // 0x0098(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_HasConsumable");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_HasIncomingDamage
// 0x0003 (0x0098 - 0x0095)
class UTgAIBehaviorCondition_HasIncomingDamage : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_HasIncomingDamage");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_HasLaneTarget
// 0x0003 (0x0098 - 0x0095)
class UTgAIBehaviorCondition_HasLaneTarget : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_HasLaneTarget");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_HasMoveTarget
// 0x0003 (0x0098 - 0x0095)
class UTgAIBehaviorCondition_HasMoveTarget : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_HasMoveTarget");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_HasNavigation
// 0x0003 (0x0098 - 0x0095)
class UTgAIBehaviorCondition_HasNavigation : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_HasNavigation");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_HasSpreadLocation
// 0x0003 (0x0098 - 0x0095)
class UTgAIBehaviorCondition_HasSpreadLocation : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_HasSpreadLocation");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_HealthPercent
// 0x0007 (0x009C - 0x0095)
class UTgAIBehaviorCondition_HealthPercent : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	float                                              HealthPct;                                                // 0x0098(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_HealthPercent");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_InsideDeviceVolume
// 0x000B (0x00A0 - 0x0095)
class UTgAIBehaviorCondition_InsideDeviceVolume : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	int                                                DeviceID;                                                 // 0x0098(0x0004) (Edit)
	unsigned long                                      bMustBeEnemy : 1;                                         // 0x009C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_InsideDeviceVolume");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsActiveCapturePoint
// 0x0003 (0x0098 - 0x0095)
class UTgAIBehaviorCondition_IsActiveCapturePoint : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsActiveCapturePoint");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsActiveReady
// 0x0004 (0x0099 - 0x0095)
class UTgAIBehaviorCondition_IsActiveReady : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	TEnumAsByte<EActiveType>                           ActiveType;                                               // 0x0098(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsActiveReady");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsAtCapturePoint
// 0x0003 (0x0098 - 0x0095)
class UTgAIBehaviorCondition_IsAtCapturePoint : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsAtCapturePoint");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsAtRallyPoint
// 0x0003 (0x0098 - 0x0095)
class UTgAIBehaviorCondition_IsAtRallyPoint : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsAtRallyPoint");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsAtSpawn
// 0x0003 (0x0098 - 0x0095)
class UTgAIBehaviorCondition_IsAtSpawn : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsAtSpawn");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsAttackingTaskForce
// 0x0003 (0x0098 - 0x0095)
class UTgAIBehaviorCondition_IsAttackingTaskForce : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsAttackingTaskForce");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsBotBehaviorState
// 0x0004 (0x0099 - 0x0095)
class UTgAIBehaviorCondition_IsBotBehaviorState : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	TEnumAsByte<EBotBehaviorState>                     TestBehaviorState;                                        // 0x0098(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsBotBehaviorState");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_VisibilityBase
// 0x0007 (0x009C - 0x0095)
class UTgAIBehaviorCondition_VisibilityBase : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	unsigned long                                      bRestrictFoV : 1;                                         // 0x0098(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_VisibilityBase");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsCapturePointVisible
// 0x0000 (0x009C - 0x009C)
class UTgAIBehaviorCondition_IsCapturePointVisible : public UTgAIBehaviorCondition_VisibilityBase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsCapturePointVisible");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsCombatTargetHittable
// 0x0003 (0x0098 - 0x0095)
class UTgAIBehaviorCondition_IsCombatTargetHittable : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsCombatTargetHittable");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsCombatTargetHostile
// 0x0003 (0x0098 - 0x0095)
class UTgAIBehaviorCondition_IsCombatTargetHostile : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsCombatTargetHostile");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsCombatTargetInFountain
// 0x0003 (0x0098 - 0x0095)
class UTgAIBehaviorCondition_IsCombatTargetInFountain : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsCombatTargetInFountain");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsCombatTargetInLeash
// 0x0003 (0x0098 - 0x0095)
class UTgAIBehaviorCondition_IsCombatTargetInLeash : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsCombatTargetInLeash");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsCombatTargetInSightRadius
// 0x0003 (0x0098 - 0x0095)
class UTgAIBehaviorCondition_IsCombatTargetInSightRadius : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsCombatTargetInSightRadius");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsCombatTargetLastAttacker
// 0x0003 (0x0098 - 0x0095)
class UTgAIBehaviorCondition_IsCombatTargetLastAttacker : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsCombatTargetLastAttacker");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsCombatTargetOfType
// 0x0004 (0x0099 - 0x0095)
class UTgAIBehaviorCondition_IsCombatTargetOfType : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	TEnumAsByte<ECombatTargetType>                     TargetType;                                               // 0x0098(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsCombatTargetOfType");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsCombatTargetShielded
// 0x0003 (0x0098 - 0x0095)
class UTgAIBehaviorCondition_IsCombatTargetShielded : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsCombatTargetShielded");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsCombatTargetSquadTarget
// 0x0003 (0x0098 - 0x0095)
class UTgAIBehaviorCondition_IsCombatTargetSquadTarget : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsCombatTargetSquadTarget");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsCombatTargetStealthed
// 0x0003 (0x0098 - 0x0095)
class UTgAIBehaviorCondition_IsCombatTargetStealthed : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsCombatTargetStealthed");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsCombatTargetVisible
// 0x0000 (0x009C - 0x009C)
class UTgAIBehaviorCondition_IsCombatTargetVisible : public UTgAIBehaviorCondition_VisibilityBase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsCombatTargetVisible");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsDecoyState
// 0x0004 (0x0099 - 0x0095)
class UTgAIBehaviorCondition_IsDecoyState : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	unsigned char                                      DecoyState;                                               // 0x0098(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsDecoyState");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsDesiredAimDevice
// 0x0004 (0x0099 - 0x0095)
class UTgAIBehaviorCondition_IsDesiredAimDevice : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	TEnumAsByte<ETG_EQUIP_POINT>                       DeviceSlot;                                               // 0x0098(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsDesiredAimDevice");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsFortressObjectiveVulnerable
// 0x0003 (0x0098 - 0x0095)
class UTgAIBehaviorCondition_IsFortressObjectiveVulnerable : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsFortressObjectiveVulnerable");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsInFortress
// 0x0007 (0x009C - 0x0095)
class UTgAIBehaviorCondition_IsInFortress : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	unsigned long                                      bMustBeEnemy : 1;                                         // 0x0098(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsInFortress");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsInHostileAbility
// 0x0003 (0x0098 - 0x0095)
class UTgAIBehaviorCondition_IsInHostileAbility : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsInHostileAbility");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsInMinotaurRadius
// 0x0007 (0x009C - 0x0095)
class UTgAIBehaviorCondition_IsInMinotaurRadius : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	unsigned long                                      bMustBeEnemy : 1;                                         // 0x0098(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsInMinotaurRadius");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsInTowerRadius
// 0x0007 (0x009C - 0x0095)
class UTgAIBehaviorCondition_IsInTowerRadius : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	unsigned long                                      bMustBeEnemy : 1;                                         // 0x0098(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsInTowerRadius");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsLanepusherActive
// 0x0003 (0x0098 - 0x0095)
class UTgAIBehaviorCondition_IsLanepusherActive : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsLanepusherActive");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsLanepusherHostile
// 0x0003 (0x0098 - 0x0095)
class UTgAIBehaviorCondition_IsLanepusherHostile : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsLanepusherHostile");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsLanepusherLastAttackerOfType
// 0x0004 (0x0099 - 0x0095)
class UTgAIBehaviorCondition_IsLanepusherLastAttackerOfType : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	TEnumAsByte<ECombatTargetType>                     TargetType;                                               // 0x0098(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsLanepusherLastAttackerOfType");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsLanePusherVisible
// 0x0000 (0x009C - 0x009C)
class UTgAIBehaviorCondition_IsLanePusherVisible : public UTgAIBehaviorCondition_VisibilityBase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsLanePusherVisible");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsLastAttackerOfType
// 0x0004 (0x0099 - 0x0095)
class UTgAIBehaviorCondition_IsLastAttackerOfType : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	TEnumAsByte<ECombatTargetType>                     TargetType;                                               // 0x0098(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsLastAttackerOfType");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsLookingAtCapturePoint
// 0x0007 (0x009C - 0x0095)
class UTgAIBehaviorCondition_IsLookingAtCapturePoint : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	float                                              VisibilityAngle;                                          // 0x0098(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsLookingAtCapturePoint");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsLookingAtCombatTarget
// 0x0007 (0x009C - 0x0095)
class UTgAIBehaviorCondition_IsLookingAtCombatTarget : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	float                                              VisibilityAngle;                                          // 0x0098(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsLookingAtCombatTarget");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsMetaGameState
// 0x0004 (0x0099 - 0x0095)
class UTgAIBehaviorCondition_IsMetaGameState : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	TEnumAsByte<EMetaGameState>                        TestGameState;                                            // 0x0098(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsMetaGameState");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsOutsideLeash
// 0x0003 (0x0098 - 0x0095)
class UTgAIBehaviorCondition_IsOutsideLeash : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsOutsideLeash");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsSafeToRecall
// 0x0003 (0x0098 - 0x0095)
class UTgAIBehaviorCondition_IsSafeToRecall : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsSafeToRecall");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsSpawnGateOpen
// 0x0003 (0x0098 - 0x0095)
class UTgAIBehaviorCondition_IsSpawnGateOpen : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsSpawnGateOpen");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsSquadTargetShielded
// 0x0003 (0x0098 - 0x0095)
class UTgAIBehaviorCondition_IsSquadTargetShielded : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsSquadTargetShielded");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsSquadTargetVisible
// 0x0000 (0x009C - 0x009C)
class UTgAIBehaviorCondition_IsSquadTargetVisible : public UTgAIBehaviorCondition_VisibilityBase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsSquadTargetVisible");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsTargetOfEnemyTowerOrMinotaur
// 0x0003 (0x0098 - 0x0095)
class UTgAIBehaviorCondition_IsTargetOfEnemyTowerOrMinotaur : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsTargetOfEnemyTowerOrMinotaur");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsTargetTypeInLeash
// 0x0004 (0x0099 - 0x0095)
class UTgAIBehaviorCondition_IsTargetTypeInLeash : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	TEnumAsByte<ECombatTargetType>                     TargetType;                                               // 0x0098(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsTargetTypeInLeash");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsTooFarFromLane
// 0x0004 (0x0099 - 0x0095)
class UTgAIBehaviorCondition_IsTooFarFromLane : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	TEnumAsByte<ECombatTargetType>                     TargetType;                                               // 0x0098(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsTooFarFromLane");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsWithinCombatDistance
// 0x000C (0x00A1 - 0x0095)
class UTgAIBehaviorCondition_IsWithinCombatDistance : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	unsigned long                                      bSubtractTargetPawnRadius : 1;                            // 0x0098(0x0004) (Edit)
	float                                              DistanceThresholdPercent;                                 // 0x009C(0x0004) (Edit)
	TEnumAsByte<ETG_EQUIP_POINT>                       DeviceSlot;                                               // 0x00A0(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsWithinCombatDistance");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsWithinDistance
// 0x000B (0x00A0 - 0x0095)
class UTgAIBehaviorCondition_IsWithinDistance : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	unsigned long                                      bIsXYOnly : 1;                                            // 0x0098(0x0004) (Edit)
	float                                              DistanceCheck;                                            // 0x009C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsWithinDistance");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_LanepusherHealthPercent
// 0x0007 (0x009C - 0x0095)
class UTgAIBehaviorCondition_LanepusherHealthPercent : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	float                                              HealthPct;                                                // 0x0098(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_LanepusherHealthPercent");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_ManaPercent
// 0x0007 (0x009C - 0x0095)
class UTgAIBehaviorCondition_ManaPercent : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	float                                              ManaPct;                                                  // 0x0098(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_ManaPercent");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_NearbyAllyAttacked
// 0x000F (0x00A4 - 0x0095)
class UTgAIBehaviorCondition_NearbyAllyAttacked : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	float                                              TimeThreshold;                                            // 0x0098(0x0004) (Edit)
	float                                              AllyDistanceThreshold;                                    // 0x009C(0x0004) (Edit)
	float                                              AttackerDistanceThreshold;                                // 0x00A0(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_NearbyAllyAttacked");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_NearbyGodCount
// 0x000C (0x00A8 - 0x009C)
class UTgAIBehaviorCondition_NearbyGodCount : public UTgAIBehaviorCondition_DistanceBase
{
public:
	unsigned long                                      bMustBeEnemy : 1;                                         // 0x009C(0x0004) (Edit)
	unsigned long                                      bMustBeInForwardCone : 1;                                 // 0x009C(0x0004) (Edit)
	int                                                GodThreshold;                                             // 0x00A0(0x0004) (Edit)
	float                                              ForwardConeAngle;                                         // 0x00A4(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_NearbyGodCount");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_NearbyGodDelta
// 0x000C (0x00A8 - 0x009C)
class UTgAIBehaviorCondition_NearbyGodDelta : public UTgAIBehaviorCondition_DistanceBase
{
public:
	int                                                GodThreshold;                                             // 0x009C(0x0004) (Edit)
	unsigned long                                      bMustBeInForwardCone : 1;                                 // 0x00A0(0x0004) (Edit)
	float                                              ForwardConeAngle;                                         // 0x00A4(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_NearbyGodDelta");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_NearbyTargetTypeCount
// 0x0010 (0x00AC - 0x009C)
class UTgAIBehaviorCondition_NearbyTargetTypeCount : public UTgAIBehaviorCondition_DistanceBase
{
public:
	unsigned long                                      bMustBeEnemy : 1;                                         // 0x009C(0x0004) (Edit)
	unsigned long                                      bMustBeInForwardCone : 1;                                 // 0x009C(0x0004) (Edit)
	int                                                TargetTypeThreshold;                                      // 0x00A0(0x0004) (Edit)
	TEnumAsByte<ECombatTargetType>                     TargetType;                                               // 0x00A4(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x00A5(0x0003) MISSED OFFSET
	float                                              ForwardConeAngle;                                         // 0x00A8(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_NearbyTargetTypeCount");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_NearbyTargetTypeDelta
// 0x0010 (0x00AC - 0x009C)
class UTgAIBehaviorCondition_NearbyTargetTypeDelta : public UTgAIBehaviorCondition_DistanceBase
{
public:
	int                                                TargetTypeThreshold;                                      // 0x009C(0x0004) (Edit)
	TEnumAsByte<ECombatTargetType>                     TargetType;                                               // 0x00A0(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x00A1(0x0003) MISSED OFFSET
	unsigned long                                      bMustBeInForwardCone : 1;                                 // 0x00A4(0x0004) (Edit)
	float                                              ForwardConeAngle;                                         // 0x00A8(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_NearbyTargetTypeDelta");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_NearestTowerHealthPercent
// 0x000B (0x00A0 - 0x0095)
class UTgAIBehaviorCondition_NearestTowerHealthPercent : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	unsigned long                                      bMustBeEnemy : 1;                                         // 0x0098(0x0004) (Edit)
	float                                              HealthPct;                                                // 0x009C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_NearestTowerHealthPercent");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_NumberDevicesFiring
// 0x0013 (0x00A8 - 0x0095)
class UTgAIBehaviorCondition_NumberDevicesFiring : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	TEnumAsByte<ETG_EQUIP_POINT>                       DeviceSlot;                                               // 0x0098(0x0001) (Edit)
	unsigned char                                      UnknownData01[0x3];                                       // 0x0099(0x0003) MISSED OFFSET
	unsigned long                                      bMustBeEnemy : 1;                                         // 0x009C(0x0004) (Edit)
	unsigned long                                      bIsFiring : 1;                                            // 0x009C(0x0004) (Edit)
	int                                                GodThreshold;                                             // 0x00A0(0x0004) (Edit)
	float                                              DistanceThreshold;                                        // 0x00A4(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_NumberDevicesFiring");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_NumDeaths
// 0x0007 (0x009C - 0x0095)
class UTgAIBehaviorCondition_NumDeaths : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	int                                                DeathThreshold;                                           // 0x0098(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_NumDeaths");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_NumGodsInCapturePointRadius
// 0x0008 (0x00A4 - 0x009C)
class UTgAIBehaviorCondition_NumGodsInCapturePointRadius : public UTgAIBehaviorCondition_DistanceBase
{
public:
	unsigned long                                      bGodsMustBeEnemy : 1;                                     // 0x009C(0x0004) (Edit)
	int                                                GodThreshold;                                             // 0x00A0(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_NumGodsInCapturePointRadius");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_NumGodsInLanePusherRadius
// 0x0008 (0x00A4 - 0x009C)
class UTgAIBehaviorCondition_NumGodsInLanePusherRadius : public UTgAIBehaviorCondition_DistanceBase
{
public:
	unsigned long                                      bGodsMustBeEnemy : 1;                                     // 0x009C(0x0004) (Edit)
	int                                                GodThreshold;                                             // 0x00A0(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_NumGodsInLanePusherRadius");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_NumGodsInTowerRadius
// 0x000B (0x00A0 - 0x0095)
class UTgAIBehaviorCondition_NumGodsInTowerRadius : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	unsigned long                                      bGodsMustBeEnemy : 1;                                     // 0x0098(0x0004) (Edit)
	unsigned long                                      bTowerMustBeEnemy : 1;                                    // 0x0098(0x0004) (Edit)
	int                                                GodThreshold;                                             // 0x009C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_NumGodsInTowerRadius");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_NumGodsNearDeployable
// 0x000C (0x00A8 - 0x009C)
class UTgAIBehaviorCondition_NumGodsNearDeployable : public UTgAIBehaviorCondition_DistanceBase
{
public:
	unsigned long                                      bMustBeEnemy : 1;                                         // 0x009C(0x0004) (Edit)
	int                                                DeployableId;                                             // 0x00A0(0x0004) (Edit)
	int                                                GodThreshold;                                             // 0x00A4(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_NumGodsNearDeployable");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_NumGodsNearProjectile
// 0x000C (0x00A8 - 0x009C)
class UTgAIBehaviorCondition_NumGodsNearProjectile : public UTgAIBehaviorCondition_DistanceBase
{
public:
	unsigned long                                      bMustBeEnemy : 1;                                         // 0x009C(0x0004) (Edit)
	int                                                ProjectileId;                                             // 0x00A0(0x0004) (Edit)
	int                                                GodThreshold;                                             // 0x00A4(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_NumGodsNearProjectile");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_NumMinionsInTowerRadius
// 0x000B (0x00A0 - 0x0095)
class UTgAIBehaviorCondition_NumMinionsInTowerRadius : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	unsigned long                                      bMinionsMustBeEnemy : 1;                                  // 0x0098(0x0004) (Edit)
	unsigned long                                      bTowerMustBeEnemy : 1;                                    // 0x0098(0x0004) (Edit)
	int                                                MinionThreshold;                                          // 0x009C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_NumMinionsInTowerRadius");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_NumRallyPoints
// 0x000B (0x00A0 - 0x0095)
class UTgAIBehaviorCondition_NumRallyPoints : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	int                                                nRallyPointsThreshold;                                    // 0x0098(0x0004) (Edit)
	unsigned long                                      bMustBeEnemy : 1;                                         // 0x009C(0x0004) (Edit)
	unsigned long                                      bMustBeSameTaskForce : 1;                                 // 0x009C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_NumRallyPoints");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_PetPhase
// 0x0004 (0x0099 - 0x0095)
class UTgAIBehaviorCondition_PetPhase : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	TEnumAsByte<EPetPhase>                             Phase;                                                    // 0x0098(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_PetPhase");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_PhysicsState
// 0x0004 (0x0099 - 0x0095)
class UTgAIBehaviorCondition_PhysicsState : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	TEnumAsByte<EPhysics>                              PhysicsState;                                             // 0x0098(0x0001)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_PhysicsState");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_ReturnAlways
// 0x0004 (0x0099 - 0x0095)
class UTgAIBehaviorCondition_ReturnAlways : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	TEnumAsByte<EBehaviorStatus>                       AlwaysReturn;                                             // 0x0098(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_ReturnAlways");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_SelectedTargetHealthPercent
// 0x0010 (0x00AC - 0x009C)
class UTgAIBehaviorCondition_SelectedTargetHealthPercent : public UTgAIBehaviorCondition_DistanceBase
{
public:
	unsigned long                                      bMustBeEnemy : 1;                                         // 0x009C(0x0004) (Edit)
	unsigned long                                      bIgnoreTaskforce : 1;                                     // 0x009C(0x0004) (Edit)
	TEnumAsByte<ETargetSelector>                       TargetSelector;                                           // 0x00A0(0x0001) (Edit)
	TEnumAsByte<ECombatTargetType>                     TargetType;                                               // 0x00A1(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x2];                                       // 0x00A2(0x0002) MISSED OFFSET
	int                                                TargetId;                                                 // 0x00A4(0x0004) (Edit)
	float                                              HealthPct;                                                // 0x00A8(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_SelectedTargetHealthPercent");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_SiegeScore
// 0x000B (0x00A0 - 0x0095)
class UTgAIBehaviorCondition_SiegeScore : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	int                                                ScoreThreshold;                                           // 0x0098(0x0004) (Edit)
	unsigned long                                      bMustBeEnemy : 1;                                         // 0x009C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_SiegeScore");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_SquadAverageDistance
// 0x0000 (0x009C - 0x009C)
class UTgAIBehaviorCondition_SquadAverageDistance : public UTgAIBehaviorCondition_DistanceBase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_SquadAverageDistance");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_SquadTargetHealthPercent
// 0x0007 (0x009C - 0x0095)
class UTgAIBehaviorCondition_SquadTargetHealthPercent : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	float                                              HealthPct;                                                // 0x0098(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_SquadTargetHealthPercent");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_TargetsDamageableByDevice
// 0x000B (0x00A0 - 0x0095)
class UTgAIBehaviorCondition_TargetsDamageableByDevice : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	TEnumAsByte<ETG_EQUIP_POINT>                       DeviceSlot;                                               // 0x0098(0x0001) (Edit)
	TEnumAsByte<ECombatTargetType>                     TargetType;                                               // 0x0099(0x0001) (Edit)
	unsigned char                                      UnknownData01[0x2];                                       // 0x009A(0x0002) MISSED OFFSET
	int                                                TargetCount;                                              // 0x009C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_TargetsDamageableByDevice");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_Taskforce
// 0x0007 (0x009C - 0x0095)
class UTgAIBehaviorCondition_Taskforce : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	int                                                Taskforce;                                                // 0x0098(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_Taskforce");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_TeamDeathCount
// 0x000B (0x00A0 - 0x0095)
class UTgAIBehaviorCondition_TeamDeathCount : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	unsigned long                                      bMustBeEnemy : 1;                                         // 0x0098(0x0004) (Edit)
	int                                                DeathThreshold;                                           // 0x009C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_TeamDeathCount");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_TimeInPayloadMode
// 0x0007 (0x009C - 0x0095)
class UTgAIBehaviorCondition_TimeInPayloadMode : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	float                                              TimeThreshold;                                            // 0x0098(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_TimeInPayloadMode");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_Timer
// 0x000F (0x00A4 - 0x0095)
class UTgAIBehaviorCondition_Timer : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	float                                              TimerLength;                                              // 0x0098(0x0004) (Edit)
	float                                              MinTime;                                                  // 0x009C(0x0004) (Edit)
	unsigned long                                      RandomTime : 1;                                           // 0x00A0(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_Timer");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_TimeSinceLanepusherTookDamage
// 0x0007 (0x009C - 0x0095)
class UTgAIBehaviorCondition_TimeSinceLanepusherTookDamage : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	float                                              TimeThreshold;                                            // 0x0098(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_TimeSinceLanepusherTookDamage");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_TimeSinceLastTookDamage
// 0x000B (0x00A0 - 0x0095)
class UTgAIBehaviorCondition_TimeSinceLastTookDamage : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	float                                              TimeThreshold;                                            // 0x0098(0x0004) (Edit)
	unsigned long                                      bMustBeCombatTarget : 1;                                  // 0x009C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_TimeSinceLastTookDamage");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_WhatIsCombatTargetTargeting
// 0x0004 (0x0099 - 0x0095)
class UTgAIBehaviorCondition_WhatIsCombatTargetTargeting : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	TEnumAsByte<ECombatTargetType>                     TargetType;                                               // 0x0098(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_WhatIsCombatTargetTargeting");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_WhatIsLastAttackerTargeting
// 0x0004 (0x0099 - 0x0095)
class UTgAIBehaviorCondition_WhatIsLastAttackerTargeting : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	TEnumAsByte<ECombatTargetType>                     TargetType;                                               // 0x0098(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_WhatIsLastAttackerTargeting");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_WonLastPoint
// 0x0003 (0x0098 - 0x0095)
class UTgAIBehaviorCondition_WonLastPoint : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_WonLastPoint");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorSensor_Devices
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorSensor_Devices : public UTgAIBehaviorSensor
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorSensor_Devices");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorSensor_Fortress
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorSensor_Fortress : public UTgAIBehaviorSensor
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorSensor_Fortress");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorSensor_Gods
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorSensor_Gods : public UTgAIBehaviorSensor
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorSensor_Gods");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorSensor_IncomingDamage
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorSensor_IncomingDamage : public UTgAIBehaviorSensor
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorSensor_IncomingDamage");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorSensor_InHostileAbility
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorSensor_InHostileAbility : public UTgAIBehaviorSensor
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorSensor_InHostileAbility");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorSensor_Lane
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorSensor_Lane : public UTgAIBehaviorSensor
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorSensor_Lane");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorSensor_Leash
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorSensor_Leash : public UTgAIBehaviorSensor
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorSensor_Leash");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorSensor_PurchaseSkills
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorSensor_PurchaseSkills : public UTgAIBehaviorSensor
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorSensor_PurchaseSkills");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorSensor_RallyPoints
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorSensor_RallyPoints : public UTgAIBehaviorSensor
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorSensor_RallyPoints");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorSensor_SafeToRecall
// 0x0004 (0x0098 - 0x0094)
class UTgAIBehaviorSensor_SafeToRecall : public UTgAIBehaviorSensor
{
public:
	float                                              SafeRecallDist;                                           // 0x0094(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorSensor_SafeToRecall");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorSensor_SightRadius
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorSensor_SightRadius : public UTgAIBehaviorSensor
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorSensor_SightRadius");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorSensor_Towers
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorSensor_Towers : public UTgAIBehaviorSensor
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorSensor_Towers");
		return ptr;
	}

};


// Class TgGame.TgAIController_BehaviorAerialDrone
// 0x0000 (0x090C - 0x090C)
class ATgAIController_BehaviorAerialDrone : public ATgAIController_Behavior
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIController_BehaviorAerialDrone");
		return ptr;
	}

};


// Class TgGame.TgAILocalPositionSolver_God
// 0x0000 (0x00A0 - 0x00A0)
class UTgAILocalPositionSolver_God : public UTgAILocalPositionSolver
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAILocalPositionSolver_God");
		return ptr;
	}

};


// Class TgGame.TgAILocalPositionSolver_Pet
// 0x0000 (0x00A0 - 0x00A0)
class UTgAILocalPositionSolver_Pet : public UTgAILocalPositionSolver
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAILocalPositionSolver_Pet");
		return ptr;
	}

};


// Class TgGame.TgAIScout
// 0x0000 (0x065C - 0x065C)
class ATgAIScout : public AScout
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIScout");
		return ptr;
	}

};


// Class TgGame.TgAIUtilityFilter
// 0x0004 (0x00C0 - 0x00BC)
class UTgAIUtilityFilter : public UTgAIUtility
{
public:
	unsigned long                                      bSoftFilter : 1;                                          // 0x00BC(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIUtilityFilter");
		return ptr;
	}

};


// Class TgGame.TgAIUtilityFilter_AssaultRangeType
// 0x0001 (0x00C1 - 0x00C0)
class UTgAIUtilityFilter_AssaultRangeType : public UTgAIUtilityFilter
{
public:
	TEnumAsByte<ERangeType>                            RangeType;                                                // 0x00C0(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIUtilityFilter_AssaultRangeType");
		return ptr;
	}

};


// Class TgGame.TgAIUtilityFilter_CapturePoint
// 0x0004 (0x00C4 - 0x00C0)
class UTgAIUtilityFilter_CapturePoint : public UTgAIUtilityFilter
{
public:
	float                                              DistanceCutoff;                                           // 0x00C0(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIUtilityFilter_CapturePoint");
		return ptr;
	}

};


// Class TgGame.TgAIUtilityFilter_DistanceFromPawn
// 0x0008 (0x00C8 - 0x00C0)
class UTgAIUtilityFilter_DistanceFromPawn : public UTgAIUtilityFilter
{
public:
	float                                              DistanceCutoff;                                           // 0x00C0(0x0004) (Edit)
	unsigned long                                      bInverse : 1;                                             // 0x00C4(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIUtilityFilter_DistanceFromPawn");
		return ptr;
	}

};


// Class TgGame.TgAIUtilityFilter_DistanceFromTarget
// 0x0008 (0x00C8 - 0x00C0)
class UTgAIUtilityFilter_DistanceFromTarget : public UTgAIUtilityFilter
{
public:
	float                                              DistanceCutoff;                                           // 0x00C0(0x0004) (Edit)
	unsigned long                                      bInverse : 1;                                             // 0x00C4(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIUtilityFilter_DistanceFromTarget");
		return ptr;
	}

};


// Class TgGame.TgAIUtilityFilter_GameState
// 0x0000 (0x00C0 - 0x00C0)
class UTgAIUtilityFilter_GameState : public UTgAIUtilityFilter
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIUtilityFilter_GameState");
		return ptr;
	}

};


// Class TgGame.TgAIUtilityFilter_InsideActiveRallyPoint
// 0x0004 (0x00C4 - 0x00C0)
class UTgAIUtilityFilter_InsideActiveRallyPoint : public UTgAIUtilityFilter
{
public:
	unsigned long                                      bAllowEnemyRally : 1;                                     // 0x00C0(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIUtilityFilter_InsideActiveRallyPoint");
		return ptr;
	}

};


// Class TgGame.TgAIUtilityFilter_LoSToTarget
// 0x0004 (0x00C4 - 0x00C0)
class UTgAIUtilityFilter_LoSToTarget : public UTgAIUtilityFilter
{
public:
	unsigned long                                      bInverse : 1;                                             // 0x00C0(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIUtilityFilter_LoSToTarget");
		return ptr;
	}

};


// Class TgGame.TgAIUtilityFilter_LoSToTargetLastKnownLocation
// 0x0004 (0x00C4 - 0x00C0)
class UTgAIUtilityFilter_LoSToTargetLastKnownLocation : public UTgAIUtilityFilter
{
public:
	unsigned long                                      bInverse : 1;                                             // 0x00C0(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIUtilityFilter_LoSToTargetLastKnownLocation");
		return ptr;
	}

};


// Class TgGame.TgAIUtilityFilter_Payload
// 0x0004 (0x00C4 - 0x00C0)
class UTgAIUtilityFilter_Payload : public UTgAIUtilityFilter
{
public:
	float                                              DistanceCutoff;                                           // 0x00C0(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIUtilityFilter_Payload");
		return ptr;
	}

};


// Class TgGame.TgAIUtilityFilter_StayInTargetFOV
// 0x0004 (0x00C4 - 0x00C0)
class UTgAIUtilityFilter_StayInTargetFOV : public UTgAIUtilityFilter
{
public:
	unsigned long                                      bInverse : 1;                                             // 0x00C0(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIUtilityFilter_StayInTargetFOV");
		return ptr;
	}

};


// Class TgGame.TgAIUtilityFunction
// 0x0018 (0x00D4 - 0x00BC)
class UTgAIUtilityFunction : public UTgAIUtility
{
public:
	float                                              MinInput;                                                 // 0x00BC(0x0004) (Edit)
	float                                              MaxInput;                                                 // 0x00C0(0x0004) (Edit)
	TEnumAsByte<EGraphType>                            FunctionType;                                             // 0x00C4(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x00C5(0x0003) MISSED OFFSET
	float                                              DesiredValue;                                             // 0x00C8(0x0004) (Edit)
	float                                              UtilityScale;                                             // 0x00CC(0x0004) (Edit)
	unsigned long                                      bInvert : 1;                                              // 0x00D0(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIUtilityFunction");
		return ptr;
	}

};


// Class TgGame.TgAIUtilityFunction_CombatTargetDistance
// 0x0000 (0x00D4 - 0x00D4)
class UTgAIUtilityFunction_CombatTargetDistance : public UTgAIUtilityFunction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIUtilityFunction_CombatTargetDistance");
		return ptr;
	}

};


// Class TgGame.TgAIUtilityFunction_CombatTargetDistanceToNormal
// 0x0000 (0x00D4 - 0x00D4)
class UTgAIUtilityFunction_CombatTargetDistanceToNormal : public UTgAIUtilityFunction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIUtilityFunction_CombatTargetDistanceToNormal");
		return ptr;
	}

};


// Class TgGame.TgAIUtilityFunction_DistanceToPawn
// 0x0000 (0x00D4 - 0x00D4)
class UTgAIUtilityFunction_DistanceToPawn : public UTgAIUtilityFunction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIUtilityFunction_DistanceToPawn");
		return ptr;
	}

};


// Class TgGame.TgAIUtilityFunction_FortressDistance
// 0x0000 (0x00D4 - 0x00D4)
class UTgAIUtilityFunction_FortressDistance : public UTgAIUtilityFunction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIUtilityFunction_FortressDistance");
		return ptr;
	}

};


// Class TgGame.TgAIUtilityFunction_PawnDistanceToNormal
// 0x0000 (0x00D4 - 0x00D4)
class UTgAIUtilityFunction_PawnDistanceToNormal : public UTgAIUtilityFunction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIUtilityFunction_PawnDistanceToNormal");
		return ptr;
	}

};


// Class TgGame.TgAIUtilityFunction_RandomUtility
// 0x0000 (0x00D4 - 0x00D4)
class UTgAIUtilityFunction_RandomUtility : public UTgAIUtilityFunction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIUtilityFunction_RandomUtility");
		return ptr;
	}

};


// Class TgGame.TgSkeletalMeshActor_Posture
// 0x0014 (0x02FC - 0x02E8)
class ATgSkeletalMeshActor_Posture : public ASkeletalMeshActor
{
public:
	TEnumAsByte<ETG_POSTURE>                           r_CurrentPosture;                                         // 0x02E8(0x0001) (Edit, Net)
	unsigned char                                      UnknownData00[0x3];                                       // 0x02E9(0x0003) MISSED OFFSET
	TArray<class UTgAnimBlendByPosture*>               m_PostureBlendNodes;                                      // 0x02EC(0x0010) (Transient, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkeletalMeshActor_Posture");
		return ptr;
	}


	void STATIC_OnSetSkelPosture(class UTgSeqAct_SetSkelPosture* Action);
	void STATIC_InitPostureNodes();
	void STATIC_PostInitAnimTree(class USkeletalMeshComponent* SkelComp);
	void SetActivePosture(TEnumAsByte<ETG_POSTURE> Posture);
	void STATIC_ReplicatedEvent(const struct FName& VarName);
	void PostBeginPlay();
};


// Class TgGame.TgMuzzleFlash
// 0x0000 (0x0274 - 0x0274)
class UTgMuzzleFlash : public UTgExplosionLight
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgMuzzleFlash");
		return ptr;
	}

};


// Class TgGame.TgAnimBlendByTeleportBeacon
// 0x0004 (0x016C - 0x0168)
class UTgAnimBlendByTeleportBeacon : public UTgAnimNodeBlendList
{
public:
	unsigned long                                      m_bDeployed : 1;                                          // 0x0168(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendByTeleportBeacon");
		return ptr;
	}


	void Undeploy(float fUndeployTime);
	void Deploy(float fDeployTime);
};


// Class TgGame.TgAnimMetaData_SkelControlKeyFrame
// 0x0000 (0x0098 - 0x0098)
class UTgAnimMetaData_SkelControlKeyFrame : public UTgAnimMetaData_SkelControl_BoneScale_KeyFrame
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimMetaData_SkelControlKeyFrame");
		return ptr;
	}

};


// Class TgGame.TgAnimNodeBlendByAbilityDragChain
// 0x0000 (0x0168 - 0x0168)
class UTgAnimNodeBlendByAbilityDragChain : public UTgAnimNodeBlendList
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendByAbilityDragChain");
		return ptr;
	}


	void ChainInvalid();
	void ChainMiss();
	void ChainHit();
	void ChainThrow();
};


// Class TgGame.TgAnimNodeBlendNPC
// 0x003C (0x01A4 - 0x0168)
class UTgAnimNodeBlendNPC : public UTgAnimNodeBlendList
{
public:
	float                                              m_NoCustomerPresentBlendInTime;                           // 0x0168(0x0004) (Edit)
	float                                              m_CustomerPresentBlendInTime;                             // 0x016C(0x0004) (Edit)
	float                                              m_GreetingBlendInTime;                                    // 0x0170(0x0004) (Edit)
	float                                              m_NoSaleBlendInTime;                                      // 0x0174(0x0004) (Edit)
	float                                              m_CallOutBlendInTime;                                     // 0x0178(0x0004) (Edit)
	float                                              m_SaleBlendInTime;                                        // 0x017C(0x0004) (Edit)
	float                                              m_TransCustomerPresentToNotPresentBlendInTime;            // 0x0180(0x0004) (Edit)
	TArray<struct FName>                               m_UninterruptibleAnims;                                   // 0x0184(0x0010) (Edit, NeedCtorLink)
	TEnumAsByte<ENPCAnimationStates>                   m_QueuedChild;                                            // 0x0194(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0195(0x0003) MISSED OFFSET
	float                                              m_QueuedBlendTime;                                        // 0x0198(0x0004)
	struct FName                                       m_CurrentAnimPlaying;                                     // 0x019C(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendNPC");
		return ptr;
	}


	void STATIC_OnChildAnimEnd(const struct FAnimationEndInformation& Information);
	void PlaySaleAnimation();
	void PlayNoSaleAnimation();
	void PlayCallOutAnimation();
	void PlayCustomerPresentAnimation();
	void PlayGreetingAnimation();
	void PlayNoCustomerPresentAnimation();
	void QueueActiveChild(TEnumAsByte<ENPCAnimationStates> QueuedChild, float BlendTime);
	bool STATIC_IsAnUninterruptableAnim(const struct FName& AnimName);
};


// Class TgGame.TgAnimNodeBlendPerBone_Bakasura_ConsumeMinion
// 0x0000 (0x0158 - 0x0158)
class UTgAnimNodeBlendPerBone_Bakasura_ConsumeMinion : public UAnimNodeBlendPerBone
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendPerBone_Bakasura_ConsumeMinion");
		return ptr;
	}

};


// Class TgGame.TgAnimNodeSequence_ZhongKui_Exorcism
// 0x0000 (0x01BC - 0x01BC)
class UTgAnimNodeSequence_ZhongKui_Exorcism : public UTgAnimNodeSequence
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeSequence_ZhongKui_Exorcism");
		return ptr;
	}

};


// Class TgGame.TgAnimNodeSequenceByBoneRotation
// 0x001C (0x01C8 - 0x01AC)
class UTgAnimNodeSequenceByBoneRotation : public UAnimNodeSequence
{
public:
	struct FName                                       BoneName;                                                 // 0x01AC(0x0008) (Edit)
	TEnumAsByte<EAxis>                                 BoneAxis;                                                 // 0x01B4(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x01B5(0x0003) MISSED OFFSET
	TArray<struct FAnimByRotation>                     AnimList;                                                 // 0x01B8(0x0010) (Edit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeSequenceByBoneRotation");
		return ptr;
	}


	void STATIC_OnBecomeRelevant();
};


// Class TgGame.TgHavokNavigationHandleAudio
// 0x0000 (0x01E8 - 0x01E8)
class UTgHavokNavigationHandleAudio : public UHavokNavigationHandle
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgHavokNavigationHandleAudio");
		return ptr;
	}

};


// Class TgGame.TgControlModule_Spectator
// 0x000C (0x0078 - 0x006C)
class UTgControlModule_Spectator : public UTgControlModule
{
public:
	float                                              RotationLimit;                                            // 0x006C(0x0004) (Edit, Config)
	float                                              SpectatorStallZ;                                          // 0x0070(0x0004) (Edit, Const, Config)
	float                                              SpectatorMinStallZ;                                       // 0x0074(0x0004) (Edit, Const, Config)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgControlModule_Spectator");
		return ptr;
	}


	void STATIC_OnLeftMousePressed();
	void STATIC_OnRightMouseReleased();
	void STATIC_OnRightMousePressed();
	bool STATIC_InterceptFlashInput(const struct FName& ButtonName, TEnumAsByte<EInputEvent> Event);
	void STATIC_GetActorListAtCursor(TArray<class AActor*>* ActorList);
	class APawn* STATIC_GetPawnAtCursor();
	void STATIC_UpdateRotation(float DeltaTime);
	void STATIC_PlayerMove(float DeltaTime);
	void STATIC_ProcessMove(float DeltaTime, const struct FVector& newAccel, TEnumAsByte<EDoubleClickDir> DoubleClickMove, const struct FRotator& DeltaRot);
	struct FRotator STATIC_GetBaseAimRotation(class AWeapon* W, bool bIgnoreAutoLock);
};


// Class TgGame.TgSeqAct_GetBot
// 0x0004 (0x010C - 0x0108)
class UTgSeqAct_GetBot : public USequenceAction
{
public:
	int                                                m_nBotNumber;                                             // 0x0108(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_GetBot");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_KillCurrentSquad
// 0x0000 (0x0108 - 0x0108)
class UTgSeqAct_KillCurrentSquad : public USequenceAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_KillCurrentSquad");
		return ptr;
	}

};


// Class TgGame.TgBotStart
// 0x0000 (0x0380 - 0x0380)
class ATgBotStart : public ATgNavigationPoint
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgBotStart");
		return ptr;
	}

};


// Class TgGame.TgCameraModule_Attached
// 0x0000 (0x0068 - 0x0068)
class UTgCameraModule_Attached : public UTgCameraModule
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCameraModule_Attached");
		return ptr;
	}


	void STATIC_UpdateCamera(class APawn* P, class ATgPlayerCamera* CameraActor, float DeltaTime, struct FTViewTarget* OutVT);
	struct FRotator STATIC_GetAttachRotation(class APawn* ViewTarget);
	struct FVector STATIC_GetAttachLocation(class APawn* ViewTarget);
};


// Class TgGame.TgCameraModule_Cinematic
// 0x0000 (0x0068 - 0x0068)
class UTgCameraModule_Cinematic : public UTgCameraModule
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCameraModule_Cinematic");
		return ptr;
	}

};


// Class TgGame.TgCameraModule_Dead
// 0x0000 (0x007C - 0x007C)
class UTgCameraModule_Dead : public UTgCameraModule_Free
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCameraModule_Dead");
		return ptr;
	}


	struct FVector STATIC_GetCamLocationOffset(class APawn* P);
};


// Class TgGame.TgCameraModule_FrontFacingCamera
// 0x0010 (0x01DC - 0x01CC)
class UTgCameraModule_FrontFacingCamera : public UTgCameraModule_ThirdPerson
{
public:
	struct FRotator                                    m_rWorldRotationOffset;                                   // 0x01CC(0x000C) (Edit)
	float                                              m_fFOV;                                                   // 0x01D8(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCameraModule_FrontFacingCamera");
		return ptr;
	}


	void STATIC_UpdateCamera(class APawn* P, class ATgPlayerCamera* CameraActor, float DeltaTime, struct FTViewTarget* OutVT);
	struct FRotator STATIC_GetWorldRotation(class ATgPlayerCamera* CameraActor);
	void STATIC_OnBecomeInActive(class UTgCameraModule* NewCamera);
	void STATIC_OnBecomeActive(class UTgCameraModule* OldCamera);
};


// Class TgGame.TgControlModule_FrontFacingCamera
// 0x0000 (0x00CC - 0x00CC)
class UTgControlModule_FrontFacingCamera : public UTgControlModule_ThirdPerson
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgControlModule_FrontFacingCamera");
		return ptr;
	}


	void STATIC_UpdateRotation(float DeltaTime);
	struct FVector CalcNewAccel();
	void STATIC_ProcessMove(float DeltaTime, const struct FVector& newAccel, TEnumAsByte<EDoubleClickDir> DoubleClickMove, const struct FRotator& DeltaRot);
};


// Class TgGame.TgCameraModule_SpectatorThirdPerson
// 0x002C (0x01F8 - 0x01CC)
class UTgCameraModule_SpectatorThirdPerson : public UTgCameraModule_ThirdPerson
{
public:
	struct FTPOV                                       OldViewpoint;                                             // 0x01CC(0x0024) (Transient)
	float                                              RemainingBlendTime;                                       // 0x01F0(0x0004) (Transient)
	float                                              TotalBlendTime;                                           // 0x01F4(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCameraModule_SpectatorThirdPerson");
		return ptr;
	}


	void BlendToTarget(float BlendTime);
};


// Class TgGame.TgCameraModule_SpectatorFirstPerson
// 0x0000 (0x01F8 - 0x01F8)
class UTgCameraModule_SpectatorFirstPerson : public UTgCameraModule_SpectatorThirdPerson
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCameraModule_SpectatorFirstPerson");
		return ptr;
	}

};


// Class TgGame.TgCameraModule_SpectatorLockedView
// 0x001C (0x00B8 - 0x009C)
class UTgCameraModule_SpectatorLockedView : public UTgCameraModule_Spectator
{
public:
	struct FRotator                                    WorldViewRotation;                                        // 0x009C(0x000C) (Edit)
	unsigned long                                      bAutoRotate : 1;                                          // 0x00A8(0x0004) (Edit)
	float                                              FOV;                                                      // 0x00AC(0x0004)
	float                                              ZoomIncrement;                                            // 0x00B0(0x0004)
	int                                                CurrentWorldViewTargetIndex;                              // 0x00B4(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCameraModule_SpectatorLockedView");
		return ptr;
	}


	void RotateView();
	void ZoomOut();
	void ZoomIn();
	void STATIC_UpdateCamera(class APawn* P, class ATgPlayerCamera* CameraActor, float DeltaTime, struct FTViewTarget* OutVT);
	void BlendCameraToLocation(const struct FVector& NewLocation, float BlendTime, bool bUseFocalPoint);
	void STATIC_OnBecomeInActive(class UTgCameraModule* NewCamera);
	void STATIC_OnBecomeActive(class UTgCameraModule* OldCamera);
};


// Class TgGame.TgControlModule_SpectatorLockedView
// 0x0008 (0x0080 - 0x0078)
class UTgControlModule_SpectatorLockedView : public UTgControlModule_Spectator
{
public:
	float                                              DirectorModeSpectatorStallZ;                              // 0x0078(0x0004) (Const, Config)
	float                                              DirectorModeSpectatorMinStallZ;                           // 0x007C(0x0004) (Const, Config)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgControlModule_SpectatorLockedView");
		return ptr;
	}


	void STATIC_PlayerMove(float DeltaTime);
	float STATIC_GetMinStallZ();
	float STATIC_GetMaxStallZ();
};


// Class TgGame.TgControlModule_SpectatorOverview
// 0x0008 (0x0080 - 0x0078)
class UTgControlModule_SpectatorOverview : public UTgControlModule_Spectator
{
public:
	float                                              DirectorModeSpectatorStallZ;                              // 0x0078(0x0004) (Edit, Const, Config)
	float                                              DirectorModeSpectatorMinStallZ;                           // 0x007C(0x0004) (Edit, Const, Config)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgControlModule_SpectatorOverview");
		return ptr;
	}


	void STATIC_OnLeftMousePressed();
	void STATIC_UpdateRotation(float DeltaTime);
	void STATIC_PlayerMove(float DeltaTime);
	void STATIC_ProcessMove(float DeltaTime, const struct FVector& newAccel, TEnumAsByte<EDoubleClickDir> DoubleClickMove, const struct FRotator& DeltaRot);
	float STATIC_GetMinStallZ();
	float STATIC_GetMaxStallZ();
};


// Class TgGame.TgCameraModule_ThirdPersonVariableHeight
// 0x0004 (0x01D0 - 0x01CC)
class UTgCameraModule_ThirdPersonVariableHeight : public UTgCameraModule_ThirdPerson
{
public:
	float                                              ZOffset;                                                  // 0x01CC(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCameraModule_ThirdPersonVariableHeight");
		return ptr;
	}


	void ZoomOut();
	void ZoomIn();
	struct FVector STATIC_GetCamLocationOffset(const struct FRotator& PawnRot, const struct FVector& vInCameraSpaceTranslation);
	void STATIC_OnBecomeActive(class UTgCameraModule* OldCamera);
};


// Class TgGame.TgCameraModule_TopDown
// 0x000C (0x00A8 - 0x009C)
class UTgCameraModule_TopDown : public UTgCameraModule_Spectator
{
public:
	struct FRotator                                    WorldViewRotation;                                        // 0x009C(0x000C)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCameraModule_TopDown");
		return ptr;
	}


	void BlendToTarget(float BlendTime);
	void STATIC_OnBecomeInActive(class UTgCameraModule* NewCamera);
	void STATIC_OnBecomeActive(class UTgCameraModule* OldCamera);
	void STATIC_UpdateCamera(class APawn* P, class ATgPlayerCamera* CameraActor, float DeltaTime, struct FTViewTarget* OutVT);
};


// Class TgGame.TgControlModule_TopDown
// 0x0004 (0x007C - 0x0078)
class UTgControlModule_TopDown : public UTgControlModule_Spectator
{
public:
	float                                              DefaultStartHeight;                                       // 0x0078(0x0004) (Const, Config)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgControlModule_TopDown");
		return ptr;
	}


	void STATIC_PlayerMove(float DeltaTime);
	void STATIC_ProcessMove(float DeltaTime, const struct FVector& newAccel, TEnumAsByte<EDoubleClickDir> DoubleClickMove, const struct FRotator& DeltaRot);
};


// Class TgGame.TgSeqEvent_ControlPointOwnershipChange
// 0x0004 (0x012C - 0x0128)
class UTgSeqEvent_ControlPointOwnershipChange : public USequenceEvent
{
public:
	int                                                PointIndex;                                               // 0x0128(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_ControlPointOwnershipChange");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_ControlPointOwnershipChange_Server
// 0x0004 (0x012C - 0x0128)
class UTgSeqEvent_ControlPointOwnershipChange_Server : public USequenceEvent
{
public:
	int                                                PointIndex;                                               // 0x0128(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_ControlPointOwnershipChange_Server");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_ChaosObjectiveActive
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_ChaosObjectiveActive : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_ChaosObjectiveActive");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_ChaosObjectiveStatus
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_ChaosObjectiveStatus : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_ChaosObjectiveStatus");
		return ptr;
	}


	void UpdateLinkedVars(bool bFriendlyTaskForce);
};


// Class TgGame.TgOnlineGameSettings
// 0x0000 (0x0144 - 0x0144)
class UTgOnlineGameSettings : public UOnlineGameSettings
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgOnlineGameSettings");
		return ptr;
	}

};


// Class TgGame.TgCollisionProxy_LootCrate
// 0x0000 (0x02BC - 0x02BC)
class ATgCollisionProxy_LootCrate : public ATgCollisionProxy_Cylinder
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCollisionProxy_LootCrate");
		return ptr;
	}

};


// Class TgGame.TgControlModule_BaseEngine
// 0x0000 (0x006C - 0x006C)
class UTgControlModule_BaseEngine : public UTgControlModule
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgControlModule_BaseEngine");
		return ptr;
	}


	void STATIC_UpdateRotation(float DeltaTime);
	void STATIC_PlayerMove(float DeltaTime);
	void STATIC_ProcessMove(float DeltaTime, const struct FVector& newAccel, TEnumAsByte<EDoubleClickDir> DoubleClickMove, const struct FRotator& DeltaRot);
};


// Class TgGame.TgControlModule_Dead
// 0x0000 (0x006C - 0x006C)
class UTgControlModule_Dead : public UTgControlModule
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgControlModule_Dead");
		return ptr;
	}


	struct FRotator STATIC_GetBaseAimRotation(class AWeapon* W, bool bIgnoreAutoLock);
	void STATIC_UpdateRotation(float DeltaTime);
	void STATIC_PlayerMove(float DeltaTime);
	void STATIC_ProcessMove(float DeltaTime, const struct FVector& newAccel, TEnumAsByte<EDoubleClickDir> DoubleClickMove, const struct FRotator& DeltaRot);
	void STATIC_OnBecomeInActive(class UTgControlModule* NewModule);
	void STATIC_OnBecomeActive(class UTgControlModule* OldModule);
};


// Class TgGame.TgControlModule_Dummy
// 0x0000 (0x006C - 0x006C)
class UTgControlModule_Dummy : public UTgControlModule
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgControlModule_Dummy");
		return ptr;
	}

};


// Class TgGame.TgControlModule_Feared
// 0x0014 (0x00E0 - 0x00CC)
class UTgControlModule_Feared : public UTgControlModule_ThirdPerson
{
public:
	float                                              c_fLastSwitchTime;                                        // 0x00CC(0x0004)
	float                                              c_fNextSwitchTime;                                        // 0x00D0(0x0004)
	struct FVector                                     c_vCurrentDirection;                                      // 0x00D4(0x000C)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgControlModule_Feared");
		return ptr;
	}


	void STATIC_UpdateRotation(float DeltaTime);
	void ChangeDirections();
	struct FVector CalcNewAccel();
	void STATIC_OnBecomeActive(class UTgControlModule* OldModule);
};


// Class TgGame.TgControlModule_Free
// 0x0004 (0x0070 - 0x006C)
class UTgControlModule_Free : public UTgControlModule
{
public:
	int                                                CameraYawOffset;                                          // 0x006C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgControlModule_Free");
		return ptr;
	}


	void STATIC_UpdateRotation(float DeltaTime);
	void STATIC_PlayerMove(float DeltaTime);
	void STATIC_ProcessMove(float DeltaTime, const struct FVector& newAccel, TEnumAsByte<EDoubleClickDir> DoubleClickMove, const struct FRotator& DeltaRot);
	struct FRotator STATIC_GetBaseAimRotation(class AWeapon* W, bool bIgnoreAutoLock);
};


// Class TgGame.TgControlModule_Stoker
// 0x0000 (0x00CC - 0x00CC)
class UTgControlModule_Stoker : public UTgControlModule_ThirdPerson
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgControlModule_Stoker");
		return ptr;
	}


	void STATIC_ProcessMove(float DeltaTime, const struct FVector& newAccel, TEnumAsByte<EDoubleClickDir> DoubleClickMove, const struct FRotator& DeltaRot);
};


// Class TgGame.TgControlModule_Stunned
// 0x0000 (0x00CC - 0x00CC)
class UTgControlModule_Stunned : public UTgControlModule_ThirdPerson
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgControlModule_Stunned");
		return ptr;
	}


	void STATIC_UpdateRotation(float DeltaTime);
	struct FVector CalcNewAccel();
	void STATIC_ProcessMove(float DeltaTime, const struct FVector& newAccel, TEnumAsByte<EDoubleClickDir> DoubleClickMove, const struct FRotator& DeltaRot);
};


// Class TgGame.TgControlModule_StunDisoriented
// 0x0010 (0x00DC - 0x00CC)
class UTgControlModule_StunDisoriented : public UTgControlModule_Stunned
{
public:
	int                                                m_nInitialYaw;                                            // 0x00CC(0x0004)
	int                                                m_nTargetYaw;                                             // 0x00D0(0x0004)
	float                                              m_fInterpTime;                                            // 0x00D4(0x0004) (Const)
	float                                              m_fRemainingInterpTime;                                   // 0x00D8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgControlModule_StunDisoriented");
		return ptr;
	}


	void STATIC_UpdateRotation(float DeltaTime);
	void STATIC_OnBecomeActive(class UTgControlModule* OldModule);
};


// Class TgGame.TgDamageType_PaladinsConcussive
// 0x0000 (0x0154 - 0x0154)
class UTgDamageType_PaladinsConcussive : public UTgDamageType
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDamageType_PaladinsConcussive");
		return ptr;
	}

};


// Class TgGame.TgDamageType_PaladinsConcussive_Latent
// 0x0000 (0x0154 - 0x0154)
class UTgDamageType_PaladinsConcussive_Latent : public UTgDamageType
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDamageType_PaladinsConcussive_Latent");
		return ptr;
	}

};


// Class TgGame.TgDamageType_DragonSlam
// 0x0000 (0x0154 - 0x0154)
class UTgDamageType_DragonSlam : public UTgDamageType_PaladinsConcussive
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDamageType_DragonSlam");
		return ptr;
	}

};


// Class TgGame.TgDamageType_GeneralAfflicted
// 0x0000 (0x0154 - 0x0154)
class UTgDamageType_GeneralAfflicted : public UTgDamageType
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDamageType_GeneralAfflicted");
		return ptr;
	}

};


// Class TgGame.TgDamageType_GeneralCharred
// 0x0000 (0x0154 - 0x0154)
class UTgDamageType_GeneralCharred : public UTgDamageType
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDamageType_GeneralCharred");
		return ptr;
	}

};


// Class TgGame.TgDamageType_GeneralConcussion
// 0x0000 (0x0154 - 0x0154)
class UTgDamageType_GeneralConcussion : public UTgDamageType
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDamageType_GeneralConcussion");
		return ptr;
	}

};


// Class TgGame.TgDamageType_GeneralElectric
// 0x0000 (0x0154 - 0x0154)
class UTgDamageType_GeneralElectric : public UTgDamageType
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDamageType_GeneralElectric");
		return ptr;
	}

};


// Class TgGame.TgDamageType_GeneralFlattened
// 0x0000 (0x0154 - 0x0154)
class UTgDamageType_GeneralFlattened : public UTgDamageType
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDamageType_GeneralFlattened");
		return ptr;
	}

};


// Class TgGame.TgDamageType_GeneralImpulseOut
// 0x0000 (0x0154 - 0x0154)
class UTgDamageType_GeneralImpulseOut : public UTgDamageType
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDamageType_GeneralImpulseOut");
		return ptr;
	}

};


// Class TgGame.TgDamageType_GeneralMidImpulse
// 0x0000 (0x0154 - 0x0154)
class UTgDamageType_GeneralMidImpulse : public UTgDamageType
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDamageType_GeneralMidImpulse");
		return ptr;
	}

};


// Class TgGame.TgDamageType_GeneralOnFire
// 0x0000 (0x0154 - 0x0154)
class UTgDamageType_GeneralOnFire : public UTgDamageType
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDamageType_GeneralOnFire");
		return ptr;
	}

};


// Class TgGame.TgDamageType_MeleeBasicAttack
// 0x0000 (0x0154 - 0x0154)
class UTgDamageType_MeleeBasicAttack : public UTgDamageType
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDamageType_MeleeBasicAttack");
		return ptr;
	}

};


// Class TgGame.TgDamageType_MeleeBasicAttackImpulse
// 0x0000 (0x0154 - 0x0154)
class UTgDamageType_MeleeBasicAttackImpulse : public UTgDamageType
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDamageType_MeleeBasicAttackImpulse");
		return ptr;
	}

};


// Class TgGame.TgDamageType_PaladinsAcid
// 0x0000 (0x0154 - 0x0154)
class UTgDamageType_PaladinsAcid : public UTgDamageType
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDamageType_PaladinsAcid");
		return ptr;
	}

};


// Class TgGame.TgDamageType_PaladinsAcid_Latent
// 0x0000 (0x0154 - 0x0154)
class UTgDamageType_PaladinsAcid_Latent : public UTgDamageType
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDamageType_PaladinsAcid_Latent");
		return ptr;
	}

};


// Class TgGame.TgDamageType_PaladinsBullet
// 0x0000 (0x0154 - 0x0154)
class UTgDamageType_PaladinsBullet : public UTgDamageType
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDamageType_PaladinsBullet");
		return ptr;
	}

};


// Class TgGame.TgDamageType_PaladinsBullet_Latent
// 0x0000 (0x0154 - 0x0154)
class UTgDamageType_PaladinsBullet_Latent : public UTgDamageType
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDamageType_PaladinsBullet_Latent");
		return ptr;
	}

};


// Class TgGame.TgDamageType_PaladinsExplosive
// 0x0000 (0x0154 - 0x0154)
class UTgDamageType_PaladinsExplosive : public UTgDamageType
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDamageType_PaladinsExplosive");
		return ptr;
	}

};


// Class TgGame.TgDamageType_PaladinsExplosive_Latent
// 0x0000 (0x0154 - 0x0154)
class UTgDamageType_PaladinsExplosive_Latent : public UTgDamageType
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDamageType_PaladinsExplosive_Latent");
		return ptr;
	}

};


// Class TgGame.TgDamageType_PaladinsFire
// 0x0000 (0x0154 - 0x0154)
class UTgDamageType_PaladinsFire : public UTgDamageType
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDamageType_PaladinsFire");
		return ptr;
	}

};


// Class TgGame.TgDamageType_PaladinsFire_Latent
// 0x0000 (0x0154 - 0x0154)
class UTgDamageType_PaladinsFire_Latent : public UTgDamageType
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDamageType_PaladinsFire_Latent");
		return ptr;
	}

};


// Class TgGame.TgDamageType_PaladinsIce
// 0x0000 (0x0154 - 0x0154)
class UTgDamageType_PaladinsIce : public UTgDamageType
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDamageType_PaladinsIce");
		return ptr;
	}

};


// Class TgGame.TgDamageType_PaladinsIce_Latent
// 0x0000 (0x0154 - 0x0154)
class UTgDamageType_PaladinsIce_Latent : public UTgDamageType
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDamageType_PaladinsIce_Latent");
		return ptr;
	}

};


// Class TgGame.TgDamageType_PaladinsLightning
// 0x0000 (0x0154 - 0x0154)
class UTgDamageType_PaladinsLightning : public UTgDamageType
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDamageType_PaladinsLightning");
		return ptr;
	}

};


// Class TgGame.TgDamageType_PaladinsLightning_Latent
// 0x0000 (0x0154 - 0x0154)
class UTgDamageType_PaladinsLightning_Latent : public UTgDamageType
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDamageType_PaladinsLightning_Latent");
		return ptr;
	}

};


// Class TgGame.TgDamageType_PaladinsPiercing
// 0x0000 (0x0154 - 0x0154)
class UTgDamageType_PaladinsPiercing : public UTgDamageType
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDamageType_PaladinsPiercing");
		return ptr;
	}

};


// Class TgGame.TgDamageType_PaladinsPiercing_Latent
// 0x0000 (0x0154 - 0x0154)
class UTgDamageType_PaladinsPiercing_Latent : public UTgDamageType
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDamageType_PaladinsPiercing_Latent");
		return ptr;
	}

};


// Class TgGame.TgDamageType_PaladinsPoison
// 0x0000 (0x0154 - 0x0154)
class UTgDamageType_PaladinsPoison : public UTgDamageType
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDamageType_PaladinsPoison");
		return ptr;
	}

};


// Class TgGame.TgDamageType_PaladinsPoison_Latent
// 0x0000 (0x0154 - 0x0154)
class UTgDamageType_PaladinsPoison_Latent : public UTgDamageType
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDamageType_PaladinsPoison_Latent");
		return ptr;
	}

};


// Class TgGame.TgDamageType_PaladinsRoyaleLifeDrain
// 0x0000 (0x0154 - 0x0154)
class UTgDamageType_PaladinsRoyaleLifeDrain : public UTgDamageType
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDamageType_PaladinsRoyaleLifeDrain");
		return ptr;
	}

};


// Class TgGame.TgDamageType_RangedBasicAttack
// 0x0000 (0x0154 - 0x0154)
class UTgDamageType_RangedBasicAttack : public UTgDamageType
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDamageType_RangedBasicAttack");
		return ptr;
	}

};


// Class TgGame.TgDamageType_RangedBasicAttackImpulse
// 0x0000 (0x0154 - 0x0154)
class UTgDamageType_RangedBasicAttackImpulse : public UTgDamageType
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDamageType_RangedBasicAttackImpulse");
		return ptr;
	}

};


// Class TgGame.TgDamageType_RangedShot
// 0x0000 (0x0154 - 0x0154)
class UTgDamageType_RangedShot : public UTgDamageType
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDamageType_RangedShot");
		return ptr;
	}

};


// Class TgGame.TgDebugCameraController
// 0x0000 (0x07C8 - 0x07C8)
class ATgDebugCameraController : public ADebugCameraController
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDebugCameraController");
		return ptr;
	}


	void STATIC_DisableDebugCamera();
	void Camera(const struct FName& NewMode);
};


// Class TgGame.TgDebugCameraInput
// 0x0000 (0x02D4 - 0x02D4)
class UTgDebugCameraInput : public UDebugCameraInput
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDebugCameraInput");
		return ptr;
	}

};


// Class TgGame.TgDefensePoint
// 0x0024 (0x03A4 - 0x0380)
class ATgDefensePoint : public ATgNavigationPoint
{
public:
	class AController*                                 CurrentUser;                                              // 0x0380(0x0008)
	class ATgDefensePoint*                             NextDefensePoint;                                         // 0x0388(0x0008)
	unsigned long                                      bFirstScript : 1;                                         // 0x0390(0x0004)
	unsigned long                                      bSniping : 1;                                             // 0x0390(0x0004) (Edit)
	unsigned long                                      bDontChangePosition : 1;                                  // 0x0390(0x0004) (Edit)
	unsigned long                                      bAvoid : 1;                                               // 0x0390(0x0004)
	unsigned long                                      bDisabled : 1;                                            // 0x0390(0x0004)
	unsigned long                                      bNotInVehicle : 1;                                        // 0x0390(0x0004) (Edit)
	unsigned char                                      Priority;                                                 // 0x0394(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0395(0x0003) MISSED OFFSET
	class UClass*                                      WeaponPreference;                                         // 0x0398(0x0008) (Edit)
	float                                              NumChecked;                                               // 0x03A0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDefensePoint");
		return ptr;
	}


	class AActor* STATIC_GetMoveTarget();
	bool STATIC_HigherPriorityThan(class ATgDefensePoint* S, class ATgAIController* B);
	void PreBeginPlay();
	void FreePoint();
	void STATIC_Reset();
};


// Class TgGame.TgSeqEvent_TimeLapse
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_TimeLapse : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_TimeLapse");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_RestartPlayers
// 0x0000 (0x0108 - 0x0108)
class UTgSeqAct_RestartPlayers : public USequenceAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_RestartPlayers");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_TgCameraShake
// 0x0010 (0x0118 - 0x0108)
class UTgSeqAct_TgCameraShake : public USequenceAction
{
public:
	class UTgCameraShake*                              m_CameraShake;                                            // 0x0108(0x0008) (Edit)
	class AActor*                                      m_LocationActor;                                          // 0x0110(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_TgCameraShake");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_LogTutorialAction
// 0x0008 (0x0110 - 0x0108)
class UTgSeqAct_LogTutorialAction : public USequenceAction
{
public:
	int                                                PlayerAction;                                             // 0x0108(0x0004) (Edit)
	int                                                EventData;                                                // 0x010C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_LogTutorialAction");
		return ptr;
	}

};


// Class TgGame.TgTutorialAnnouncer
// 0x0030 (0x0090 - 0x0060)
class UTgTutorialAnnouncer : public UObject
{
public:
	TArray<class USoundCue*>                           TutorialSounds;                                           // 0x0060(0x0010) (NeedCtorLink)
	TArray<class USoundCue*>                           QueuedSounds;                                             // 0x0070(0x0010) (Transient, NeedCtorLink)
	class UAudioComponent*                             CurrentSoundAC;                                           // 0x0080(0x0008) (ExportObject, Transient, Component, EditInline)
	class ATgPlayerController*                         OwnerPC;                                                  // 0x0088(0x0008) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgTutorialAnnouncer");
		return ptr;
	}


	void PlayAnnouncement(int SoundIndex, class USoundCue* OptionalCue, bool bPlayImmediately, bool bFlushOthers);
	void AudioFinishedPlaying(class UAudioComponent* AC);
	void Destroyed();
	void Init();
};


// Class TgGame.TgSeqEvent_CrowdEvent
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_CrowdEvent : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_CrowdEvent");
		return ptr;
	}

};


// Class TgGame.TgFatalityFactory
// 0x000C (0x028C - 0x0280)
class ATgFatalityFactory : public AActor
{
public:
	class ATgFatalityMeshActor*                        m_FatalityMeshActor;                                      // 0x0280(0x0008)
	struct FLightingChannelContainer                   m_LightingChannels;                                       // 0x0288(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgFatalityFactory");
		return ptr;
	}


	void STATIC_PlayEpicFatality(int MeshAsmId);
};


// Class TgGame.TgSeqEvent_LoginComplete
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_LoginComplete : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_LoginComplete");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_SpectatorReady
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_SpectatorReady : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_SpectatorReady");
		return ptr;
	}


	bool TriggerGlobal(class ATgSpectatorController* InInstigator);
};


// Class TgGame.TgSpectatorTempCam
// 0x0004 (0x0424 - 0x0420)
class ATgSpectatorTempCam : public ADynamicCameraActor
{
public:
	unsigned long                                      bIsViewTarget : 1;                                        // 0x0420(0x0004)
	unsigned long                                      bIsBookmark : 1;                                          // 0x0420(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSpectatorTempCam");
		return ptr;
	}


	void DestroyIfNeeded();
	void SetIsBookmark(bool bBookmark);
	void STATIC_EndViewTarget(class APlayerController* PC);
	void STATIC_BecomeViewTarget(class APlayerController* PC);
};


// Class TgGame.TgDeploy_AmmoCrate
// 0x0000 (0x04B8 - 0x04B8)
class ATgDeploy_AmmoCrate : public ATgDeploy_LootCrateBasic
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_AmmoCrate");
		return ptr;
	}

};


// Class TgGame.TgDeploy_DeadZone
// 0x0000 (0x047C - 0x047C)
class ATgDeploy_DeadZone : public ATgDeploy_EffectField
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_DeadZone");
		return ptr;
	}

};


// Class TgGame.TgDeploy_DreadSerpent
// 0x0010 (0x048C - 0x047C)
class ATgDeploy_DreadSerpent : public ATgDeploy_EffectField
{
public:
	TArray<class AActor*>                              s_HitActors;                                              // 0x047C(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_DreadSerpent");
		return ptr;
	}


	void ProxyTouchHit(class AActor* Other);
};


// Class TgGame.TgDeploy_Epicenter
// 0x0000 (0x0494 - 0x0494)
class ATgDeploy_Epicenter : public ATgDeploy_TurretEffectField
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_Epicenter");
		return ptr;
	}


	void STATIC_OnProxyUnTouch(class AActor* Other);
};


// Class TgGame.TgDeploy_EpicLootCrate
// 0x0004 (0x04BC - 0x04B8)
class ATgDeploy_EpicLootCrate : public ATgDeploy_LootCrateBasic
{
public:
	float                                              m_fTimeoutTime;                                           // 0x04B8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_EpicLootCrate");
		return ptr;
	}


	void STATIC_OnPickedUp(class APlayerReplicationInfo* PRI);
	void STATIC_PlayChestOpenEffects(bool bOpen);
	void STATIC_OpenChest();
	void PostBeginPlay();
};


// Class TgGame.TgDeploy_Expose
// 0x0000 (0x0494 - 0x0494)
class ATgDeploy_Expose : public ATgDeploy_TurretEffectField
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_Expose");
		return ptr;
	}


	void FireAmmunitionDeployable();
};


// Class TgGame.TgDeploy_GeometryBuck
// 0x0004 (0x0474 - 0x0470)
class ATgDeploy_GeometryBuck : public ATgDeploy_Geometry
{
public:
	unsigned long                                      m_bInteriorEffectApplied : 1;                             // 0x0470(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_GeometryBuck");
		return ptr;
	}


	void Destroyed();
	void Tick(float DeltaSeconds);
};


// Class TgGame.TgDeploy_Pickup_OwnerOnly
// 0x0000 (0x0448 - 0x0448)
class ATgDeploy_Pickup_OwnerOnly : public ATgDeployable
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_Pickup_OwnerOnly");
		return ptr;
	}


	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
};


// Class TgGame.TgDeploy_RespawnBeacon
// 0x0000 (0x0448 - 0x0448)
class ATgDeploy_RespawnBeacon : public ATgDeployable
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_RespawnBeacon");
		return ptr;
	}


	void DeployComplete();
};


// Class TgGame.TgDevice_RespawnBeacon
// 0x000C (0x0AF8 - 0x0AEC)
class ATgDevice_RespawnBeacon : public ATgDevice
{
public:
	class ATgRespawnBeaconExit*                        s_BeaconExit;                                             // 0x0AEC(0x0008)
	unsigned long                                      r_bHasBeacon : 1;                                         // 0x0AF4(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_RespawnBeacon");
		return ptr;
	}


	void DeviceShutDown(bool bDeactiveMode, bool bResetCooldowns);
	bool ShouldSwitchBackToBasicAttackTargeting(TEnumAsByte<ECastMode> CastMode);
	void STATIC_HandlePickUpAndDrop(bool bPickedUp);
	void FireAmmunition();
	bool ShouldInterruptMount();
	bool STATIC_InterceptLeftMouseReleased(class ATgPlayerController* TgController);
	bool STATIC_InterceptLeftMousePressed(class ATgPlayerController* TgController);
	bool ShouldLockFiring(class ATgDevice* Current);
	void STATIC_ReplicatedEvent(const struct FName& VarName);
};


// Class TgGame.TgDeployable_ArmorPotion
// 0x0000 (0x04E0 - 0x04E0)
class ATgDeployable_ArmorPotion : public ATgDeployable_Ammo
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_ArmorPotion");
		return ptr;
	}

};


// Class TgGame.TgDeployable_HealthPotion
// 0x0000 (0x04E0 - 0x04E0)
class ATgDeployable_HealthPotion : public ATgDeployable_Ammo
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_HealthPotion");
		return ptr;
	}

};


// Class TgGame.TgDevice_Ammo_Consumable
// 0x0000 (0x0AEC - 0x0AEC)
class ATgDevice_Ammo_Consumable : public ATgDevice_Ammo
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Ammo_Consumable");
		return ptr;
	}

};


// Class TgGame.TgDevice_Ammo_Offhand
// 0x0000 (0x0AEC - 0x0AEC)
class ATgDevice_Ammo_Offhand : public ATgDevice_Ammo
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Ammo_Offhand");
		return ptr;
	}

};


// Class TgGame.TgDevice_Ammo_Repair
// 0x0000 (0x0AEC - 0x0AEC)
class ATgDevice_Ammo_Repair : public ATgDevice_Ammo
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Ammo_Repair");
		return ptr;
	}

};


// Class TgGame.TgDevice_Ammo_Stim
// 0x0000 (0x0AEC - 0x0AEC)
class ATgDevice_Ammo_Stim : public ATgDevice_Ammo
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Ammo_Stim");
		return ptr;
	}

};


// Class TgGame.TgDevice_Ammo_Weapon1
// 0x0000 (0x0AEC - 0x0AEC)
class ATgDevice_Ammo_Weapon1 : public ATgDevice_Ammo
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Ammo_Weapon1");
		return ptr;
	}

};


// Class TgGame.TgDevice_Ammo_Weapon2
// 0x0000 (0x0AEC - 0x0AEC)
class ATgDevice_Ammo_Weapon2 : public ATgDevice_Ammo
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Ammo_Weapon2");
		return ptr;
	}

};


// Class TgGame.TgDevice_AssaultRifle
// 0x0000 (0x0AEC - 0x0AEC)
class ATgDevice_AssaultRifle : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_AssaultRifle");
		return ptr;
	}

};


// Class TgGame.TgDevice_BarikInhand
// 0x0000 (0x0AEC - 0x0AEC)
class ATgDevice_BarikInhand : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_BarikInhand");
		return ptr;
	}


	void STATIC_InterruptOtherDevices(class ATgPawn* TgP);
};


// Class TgGame.TgDevice_Barrier
// 0x0000 (0x0AEC - 0x0AEC)
class ATgDevice_Barrier : public ATgDevice_Throw
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Barrier");
		return ptr;
	}


	void STATIC_InterruptOtherDevices(class ATgPawn* TgP);
	void STATIC_InitMaxHealth();
};


// Class TgGame.TgDevice_IceBlock
// 0x0000 (0x0AEC - 0x0AEC)
class ATgDevice_IceBlock : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_IceBlock");
		return ptr;
	}


	bool STATIC_CanBeCanceled(class ATgDevice* NewDevice);
};


// Class TgGame.TgDevice_BraceYourselves
// 0x0000 (0x0AEC - 0x0AEC)
class ATgDevice_BraceYourselves : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_BraceYourselves");
		return ptr;
	}

};


// Class TgGame.TgDevice_ChainLightning
// 0x0008 (0x0B0C - 0x0B04)
class ATgDevice_ChainLightning : public ATgDevice_ArcingBeam
{
public:
	class ATgDevice*                                   m_CachedInhand;                                           // 0x0B04(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_ChainLightning");
		return ptr;
	}

};


// Class TgGame.TgDevice_ChargeFernando
// 0x0004 (0x0B64 - 0x0B60)
class ATgDevice_ChargeFernando : public ATgDevice_Charge
{
public:
	float                                              m_fCooldownReduction;                                     // 0x0B60(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_ChargeFernando");
		return ptr;
	}


	bool ShouldLockFiring(class ATgDevice* Current);
	void AuthStartCooldown(int nMode, float fCooldownTimeOverride);
	bool STATIC_CanBeCanceled(class ATgDevice* NewDevice);
};


// Class TgGame.TgDevice_ChargeDelay
// 0x0000 (0x0B64 - 0x0B64)
class ATgDevice_ChargeDelay : public ATgDevice_ChargeFernando
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_ChargeDelay");
		return ptr;
	}

};


// Class TgGame.TgDevice_ChurchillWard
// 0x0000 (0x0AEC - 0x0AEC)
class ATgDevice_ChurchillWard : public ATgDevice_Throw
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_ChurchillWard");
		return ptr;
	}

};


// Class TgGame.TgDevice_Crossbow
// 0x0000 (0x0AEC - 0x0AEC)
class ATgDevice_Crossbow : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Crossbow");
		return ptr;
	}

};


// Class TgGame.TgDevice_Devastation
// 0x0000 (0x0AEC - 0x0AEC)
class ATgDevice_Devastation : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Devastation");
		return ptr;
	}


	void FireAmmunition();
};


// Class TgGame.TgDevice_Disengage
// 0x0000 (0x0AEC - 0x0AEC)
class ATgDevice_Disengage : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Disengage");
		return ptr;
	}

};


// Class TgGame.TgDevice_DrogozLeg1
// 0x0000 (0x0AEC - 0x0AEC)
class ATgDevice_DrogozLeg1 : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_DrogozLeg1");
		return ptr;
	}

};


// Class TgGame.TgDevice_DreadSerpent
// 0x0004 (0x0AF0 - 0x0AEC)
class ATgDevice_DreadSerpent : public ATgDevice
{
public:
	unsigned long                                      s_bQueueVoodooDeploy : 1;                                 // 0x0AEC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_DreadSerpent");
		return ptr;
	}


	float STATIC_GetLockoutExtensionTime();
	bool STATIC_InterceptSlotPressed(class ATgPlayerController* TgController);
	bool STATIC_InterceptLeftMousePressed(class ATgPlayerController* TgController);
	void STATIC_ClientInterrupt(bool bServerFireFailed);
	void STATIC_InterruptFiring(bool bServerFireFailed);
	void ServerDeployVoodoo();
	void UpdateActiveProjectiles(class ATgProjectile* Proj);
	bool TryDeployVoodoo();
};


// Class TgGame.TgDevice_DrogozLeg2
// 0x0000 (0x0AEC - 0x0AEC)
class ATgDevice_DrogozLeg2 : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_DrogozLeg2");
		return ptr;
	}

};


// Class TgGame.TgDevice_DualFire
// 0x0010 (0x0B04 - 0x0AF4)
class ATgDevice_DualFire : public ATgDevice_ToggleWithLockout
{
public:
	struct FScriptDelegate                             __InterruptFiringDelegate__Delegate;                      // 0x0AF4(0x000C) (NeedCtorLink)
	unsigned char                                      UnknownData00[0x4];                                       // 0x0AF4(0x0004) FIX WRONG TYPE SIZE OF PREVIOUS PROPERTY

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_DualFire");
		return ptr;
	}


	void STATIC_LinkedDeviceUnequipped(class ATgDevice* Dev);
	void STATIC_LinkedDeviceEquipped(class ATgDevice* Dev);
	void STATIC_InterruptFiringDelegate();
};


// Class TgGame.TgDevice_EarthenGuard
// 0x0000 (0x0AEC - 0x0AEC)
class ATgDevice_EarthenGuard : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_EarthenGuard");
		return ptr;
	}


	bool ShouldLockFiring(class ATgDevice* Current);
};


// Class TgGame.TgDevice_EvieInhand
// 0x0000 (0x0AEC - 0x0AEC)
class ATgDevice_EvieInhand : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_EvieInhand");
		return ptr;
	}


	void STATIC_InterruptOtherDevices(class ATgPawn* TgP);
};


// Class TgGame.TgWeaponMeshActor_IceStaff
// 0x0000 (0x0504 - 0x0504)
class ATgWeaponMeshActor_IceStaff : public ATgWeaponMeshActor
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgWeaponMeshActor_IceStaff");
		return ptr;
	}

};


// Class TgGame.TgDevice_EvilMojo
// 0x0000 (0x0AEC - 0x0AEC)
class ATgDevice_EvilMojo : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_EvilMojo");
		return ptr;
	}

};


// Class TgGame.TgDevice_ExplosiveFlask
// 0x0000 (0x0AEC - 0x0AEC)
class ATgDevice_ExplosiveFlask : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_ExplosiveFlask");
		return ptr;
	}

};


// Class TgGame.TgDevice_EyesOnThePrize
// 0x0000 (0x0AEC - 0x0AEC)
class ATgDevice_EyesOnThePrize : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_EyesOnThePrize");
		return ptr;
	}


	void STATIC_OnUnlinkDevice(class ATgPawn* TgP);
	void STATIC_OnLinkDevice(class ATgPawn* TgP);
	void STATIC_LinkedDeviceUnequipped(class ATgDevice* Dev);
	void STATIC_LinkedDeviceEquipped(class ATgDevice* Dev);
};


// Class TgGame.TgDevice_FernandoImmortal
// 0x0000 (0x0B34 - 0x0B34)
class ATgDevice_FernandoImmortal : public ATgDevice_ActiveAura
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_FernandoImmortal");
		return ptr;
	}


	void EndLockOutEarly();
	bool STATIC_CanJumpWhileFiring();
	bool ShouldLockFiring(class ATgDevice* Current);
	bool STATIC_CanBeCanceled(class ATgDevice* NewDevice);
};


// Class TgGame.TgDevice_Fireball
// 0x0000 (0x0AEC - 0x0AEC)
class ATgDevice_Fireball : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Fireball");
		return ptr;
	}

};


// Class TgGame.TgDevice_FireSpit
// 0x0000 (0x0AEC - 0x0AEC)
class ATgDevice_FireSpit : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_FireSpit");
		return ptr;
	}


	int STATIC_GetAimAssistPriority();
	bool ShouldLockFiring(class ATgDevice* Current);
};


// Class TgGame.TgDevice_FlamethrowerTurret
// 0x0000 (0x0AEC - 0x0AEC)
class ATgDevice_FlamethrowerTurret : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_FlamethrowerTurret");
		return ptr;
	}


	float GetRange();
	float STATIC_GetEffectiveRange();
	bool STATIC_HasCachedBarik();
};


// Class TgGame.TgDevice_FragGrenade
// 0x0004 (0x0AF0 - 0x0AEC)
class ATgDevice_FragGrenade : public ATgDevice_Throw
{
public:
	unsigned long                                      m_bThrownGrenade : 1;                                     // 0x0AEC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_FragGrenade");
		return ptr;
	}


	bool ShouldCooldownAfterFire();
	bool STATIC_CanBeCanceled(class ATgDevice* NewDevice);
	bool STATIC_CanBeInterrupted();
	void STATIC_ClientInterrupt(bool bServerFireFailed);
	void STATIC_InterruptFiring(bool bServerFireFailed);
	void FireAmmunition();
	void SetThrowSpeedMultiplier(float Mult);
	void DropGrenade();
};


// Class TgGame.TgDevice_FragGrenadeModWhileCook
// 0x0000 (0x0AEC - 0x0AEC)
class ATgDevice_FragGrenadeModWhileCook : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_FragGrenadeModWhileCook");
		return ptr;
	}


	void STATIC_LinkedDeviceUnequipped(class ATgDevice* Dev);
	void STATIC_LinkedDeviceEquipped(class ATgDevice* Dev);
	void STATIC_RemoveHitSpecial();
	void STATIC_ApplyHitSpecial();
};


// Class TgGame.TgDevice_GaeBolg
// 0x0000 (0x0AEC - 0x0AEC)
class ATgDevice_GaeBolg : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_GaeBolg");
		return ptr;
	}

};


// Class TgGame.TgDevice_GreaterGood
// 0x0000 (0x0AEC - 0x0AEC)
class ATgDevice_GreaterGood : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_GreaterGood");
		return ptr;
	}


	void STATIC_OnUnlinkDevice(class ATgPawn* TgP);
	void STATIC_OnLinkDevice(class ATgPawn* TgP);
};


// Class TgGame.TgDevice_GroverInhandAxe
// 0x0000 (0x0AEC - 0x0AEC)
class ATgDevice_GroverInhandAxe : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_GroverInhandAxe");
		return ptr;
	}


	void FireAmmunition();
};


// Class TgGame.TgWeaponMeshActor_GroverInhandAxe
// 0x0008 (0x050C - 0x0504)
class ATgWeaponMeshActor_GroverInhandAxe : public ATgWeaponMeshActor
{
public:
	class UTgAnimNodeStanceTransitionerSynchronized*   StanceNode;                                               // 0x0504(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgWeaponMeshActor_GroverInhandAxe");
		return ptr;
	}


	void Play3pFireAimedFX();
	void FixUpReferencesToPawnMesh(class USkeletalMeshComponent* PawnMesh);
};


// Class TgGame.TgDevice_HealingPotion
// 0x0004 (0x0AF0 - 0x0AEC)
class ATgDevice_HealingPotion : public ATgDevice_Throw
{
public:
	unsigned long                                      s_bQueueDetonation : 1;                                   // 0x0AEC(0x0004)
	unsigned long                                      m_bAttemptingToDetonate : 1;                              // 0x0AEC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_HealingPotion");
		return ptr;
	}


	bool CanEnterCatapultEvenWhenFiring();
	void STATIC_ScaleAbilityRadius();
	void STATIC_ClientInterrupt(bool bServerFireFailed);
	void STATIC_InterruptFiring(bool bServerFireFailed);
	void ServerTryDetonate();
	bool TryDetonate();
	bool STATIC_InterceptSlotPressed(class ATgPlayerController* TgController);
	void UpdateActiveProjectiles(class ATgProjectile* Proj);
	void STATIC_ClientEndCooldown();
	void STATIC_ClientStartCooldown(int nMode, float fCooldownTimeOverride);
	void FireAmmunition();
	void DetonationGracePeriod();
	void STATIC_LockOutOtherDevices();
	bool ShouldLockFiring(class ATgDevice* Current);
	bool STATIC_IsLeadVialActive();
};


// Class TgGame.TgDevice_HealingTotem
// 0x0000 (0x0AEC - 0x0AEC)
class ATgDevice_HealingTotem : public ATgDevice_Throw
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_HealingTotem");
		return ptr;
	}


	bool ShouldInterruptReloadOnFire();
	bool ShouldLockFiring(class ATgDevice* Current);
};


// Class TgGame.TgDevice_HeatHaze
// 0x0000 (0x0AEC - 0x0AEC)
class ATgDevice_HeatHaze : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_HeatHaze");
		return ptr;
	}


	void STATIC_LinkedDeviceUnequipped(class ATgDevice* Dev);
	void STATIC_LinkedDeviceEquipped(class ATgDevice* Dev);
	bool ShouldLockFiring(class ATgDevice* Current);
	void STATIC_InhandFired();
};


// Class TgGame.TgDevice_HeroicLeap
// 0x0000 (0x0AF0 - 0x0AF0)
class ATgDevice_HeroicLeap : public ATgDevice_Leap
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_HeroicLeap");
		return ptr;
	}


	bool ShouldCancelCrouch();
	void STATIC_OnLeapEnded();
	void STATIC_OnLeapStarted();
	bool ShouldLockFiring(class ATgDevice* Current);
	bool ShouldInterruptReloadOnFire();
	bool ShouldMountCancelFiring();
	void SetLeapParams(float* scaleLateral, float* scaleVertical, float* additiveLateral, float* additiveVertical);
};


// Class TgGame.TgDevice_QuadWield
// 0x001C (0x0B18 - 0x0AFC)
class ATgDevice_QuadWield : public ATgDevice_DualWield
{
public:
	struct FVector                                     m_vProjectileSpawnOffset3;                                // 0x0AFC(0x000C) (Edit)
	struct FVector                                     m_vProjectileSpawnOffset4;                                // 0x0B08(0x000C) (Edit)
	int                                                m_nWeaponFireNumber;                                      // 0x0B14(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_QuadWield");
		return ptr;
	}


	void FireAmmunition();
	struct FVector STATIC_GetProjectileSpawnOffset();
};


// Class TgGame.TgDevice_HexaFireGuns
// 0x0000 (0x0B18 - 0x0B18)
class ATgDevice_HexaFireGuns : public ATgDevice_QuadWield
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_HexaFireGuns");
		return ptr;
	}


	bool ShouldLockFiring(class ATgDevice* Current);
	bool STATIC_HasCachedRuckusOwner();
	bool STATIC_InterceptRightMouseReleased(class ATgPlayerController* TgController);
	bool STATIC_InterceptRightMousePressed(class ATgPlayerController* TgController);
	bool STATIC_InterceptLeftMouseReleased(class ATgPlayerController* TgController);
	bool STATIC_InterceptLeftMousePressed(class ATgPlayerController* TgController);
};


// Class TgGame.TgDevice_HiddenReserves
// 0x0000 (0x0AEC - 0x0AEC)
class ATgDevice_HiddenReserves : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_HiddenReserves");
		return ptr;
	}


	void STATIC_LinkedDeviceUnequipped(class ATgDevice* Dev);
	void STATIC_LinkedDeviceEquipped(class ATgDevice* Dev);
};


// Class TgGame.TgDevice_HunterRollDelay
// 0x0000 (0x0B64 - 0x0B64)
class ATgDevice_HunterRollDelay : public ATgDevice_HunterRoll
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_HunterRollDelay");
		return ptr;
	}

};


// Class TgGame.TgDevice_IceStorm
// 0x0000 (0x0AEC - 0x0AEC)
class ATgDevice_IceStorm : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_IceStorm");
		return ptr;
	}

};


// Class TgGame.TgDevice_Lockdown
// 0x0000 (0x0AEC - 0x0AEC)
class ATgDevice_Lockdown : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Lockdown");
		return ptr;
	}

};


// Class TgGame.TgWeaponMeshActor_LongbowInhand
// 0x0004 (0x0508 - 0x0504)
class ATgWeaponMeshActor_LongbowInhand : public ATgWeaponMeshActor
{
public:
	unsigned long                                      m_bPlayingPlantedFireSFX : 1;                             // 0x0504(0x0004)
	unsigned long                                      m_bPlayingUltimateFireSFX : 1;                            // 0x0504(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgWeaponMeshActor_LongbowInhand");
		return ptr;
	}


	void UseUltimateFireSounds(bool bShouldUse);
	void UsePlantedFireSounds(bool bShouldUse);
	void PlayFireEffects(int nEquipSlot, float fRefireTime, int nFireMode, TEnumAsByte<EDeviceSubtype> eDeviceSubtype, TEnumAsByte<EeMovementType> eMoveType, bool bForceBlendOutOnAnimEnd);
	bool STATIC_HasCachedLongbow();
};


// Class TgGame.TgDevice_LongbowPlanted
// 0x0008 (0x0AF4 - 0x0AEC)
class ATgDevice_LongbowPlanted : public ATgDevice_Stim
{
public:
	class ATgDevice_LongbowInhand*                     m_CachedInhand;                                           // 0x0AEC(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_LongbowPlanted");
		return ptr;
	}


	bool RequireMovementForAimAssist();
	void STATIC_LinkedDeviceEquipped(class ATgDevice* Dev);
	bool STATIC_HasCachedLongbow();
	void TransitionOut();
	bool ShouldLockFiring(class ATgDevice* Current);
	bool STATIC_CanBeInterrupted();
	bool STATIC_CanBeCanceled(class ATgDevice* NewDevice);
};


// Class TgGame.TgDevice_MarkAndRecall
// 0x001C (0x0B08 - 0x0AEC)
class ATgDevice_MarkAndRecall : public ATgDevice
{
public:
	struct FVector                                     m_markedLocation;                                         // 0x0AEC(0x000C)
	struct FRotator                                    m_markedRotation;                                         // 0x0AF8(0x000C)
	unsigned long                                      m_bMarked : 1;                                            // 0x0B04(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_MarkAndRecall");
		return ptr;
	}


	void FireAmmunition();
};


// Class TgGame.TgDevice_Molotov
// 0x0000 (0x0AEC - 0x0AEC)
class ATgDevice_Molotov : public ATgDevice_Throw
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Molotov");
		return ptr;
	}

};


// Class TgGame.TgDevice_MountMorph
// 0x0000 (0x0B0C - 0x0B0C)
class ATgDevice_MountMorph : public ATgDevice_Mount
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_MountMorph");
		return ptr;
	}

};


// Class TgGame.TgDevice_MountNoHorse
// 0x0000 (0x0B0C - 0x0B0C)
class ATgDevice_MountNoHorse : public ATgDevice_Mount
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_MountNoHorse");
		return ptr;
	}

};


// Class TgGame.TgDevice_NetShot
// 0x0000 (0x0AEC - 0x0AEC)
class ATgDevice_NetShot : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_NetShot");
		return ptr;
	}

};


// Class TgGame.TgDevice_NovaColt
// 0x0000 (0x0AEC - 0x0AEC)
class ATgDevice_NovaColt : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_NovaColt");
		return ptr;
	}

};


// Class TgGame.TgDevice_OverTheMoon
// 0x0000 (0x0AEC - 0x0AEC)
class ATgDevice_OverTheMoon : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_OverTheMoon");
		return ptr;
	}

};


// Class TgGame.TgDevice_OwlFlare
// 0x0000 (0x0AEC - 0x0AEC)
class ATgDevice_OwlFlare : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_OwlFlare");
		return ptr;
	}

};


// Class TgGame.TgDevice_OwlFlashbang
// 0x0000 (0x0AEC - 0x0AEC)
class ATgDevice_OwlFlashbang : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_OwlFlashbang");
		return ptr;
	}

};


// Class TgGame.TgWeaponMeshActor_OwlInhand
// 0x0000 (0x0504 - 0x0504)
class ATgWeaponMeshActor_OwlInhand : public ATgWeaponMeshActor
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgWeaponMeshActor_OwlInhand");
		return ptr;
	}


	bool STATIC_HasCachedOwl();
	void PlayTracerEffects(const struct FVector& endLocation, int nEquipSlot);
	void PlayInstantHitImpactEffects(const struct FVector& HitLocation, bool bSuccessfulHit, class AActor* HitActor, const struct FVector& HitNormal, const struct FVector& FireOrigin, int nEquipSlot);
};


// Class TgGame.TgDevice_PlasmaGun
// 0x0000 (0x0AEC - 0x0AEC)
class ATgDevice_PlasmaGun : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_PlasmaGun");
		return ptr;
	}

};


// Class TgGame.TgDevice_PostFireTimerBar
// 0x0000 (0x0AEC - 0x0AEC)
class ATgDevice_PostFireTimerBar : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_PostFireTimerBar");
		return ptr;
	}

};


// Class TgGame.TgDevice_PotionLauncher
// 0x0000 (0x0AEC - 0x0AEC)
class ATgDevice_PotionLauncher : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_PotionLauncher");
		return ptr;
	}

};


// Class TgGame.TgWeaponMeshActor_PotionLauncher
// 0x0000 (0x0504 - 0x0504)
class ATgWeaponMeshActor_PotionLauncher : public ATgWeaponMeshActor
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgWeaponMeshActor_PotionLauncher");
		return ptr;
	}

};


// Class TgGame.TgDevice_Presence
// 0x0000 (0x0AEC - 0x0AEC)
class ATgDevice_Presence : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Presence");
		return ptr;
	}

};


// Class TgGame.TgDevice_PrincessF
// 0x0010 (0x0B70 - 0x0B60)
class ATgDevice_PrincessF : public ATgDevice_Charge
{
public:
	class ATgDevice*                                   m_cachedSupportDevice;                                    // 0x0B60(0x0008)
	int                                                m_nEyeheightAdjustmentWhileSliding;                       // 0x0B68(0x0004) (Edit)
	float                                              m_fEyeHeightSmoothFactor;                                 // 0x0B6C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_PrincessF");
		return ptr;
	}


	struct FRotator STATIC_GetChargeDirection();
	bool STATIC_HasCachedSupportDevice();
};


// Class TgGame.TgDevice_PrincessInhand
// 0x0000 (0x0AEC - 0x0AEC)
class ATgDevice_PrincessInhand : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_PrincessInhand");
		return ptr;
	}

};


// Class TgGame.TgDevice_PrincessRMB
// 0x0000 (0x0AEC - 0x0AEC)
class ATgDevice_PrincessRMB : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_PrincessRMB");
		return ptr;
	}


	bool ShouldLockFiring(class ATgDevice* Current);
};


// Class TgGame.TgDevice_Recovery
// 0x0000 (0x0AEC - 0x0AEC)
class ATgDevice_Recovery : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Recovery");
		return ptr;
	}


	bool ShouldLockFiring(class ATgDevice* Current);
};


// Class TgGame.TgDevice_RiderLegUltBonus
// 0x0000 (0x0AEC - 0x0AEC)
class ATgDevice_RiderLegUltBonus : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_RiderLegUltBonus");
		return ptr;
	}


	void STATIC_LinkedDeviceUnequipped(class ATgDevice* Dev);
	void STATIC_LinkedDeviceEquipped(class ATgDevice* Dev);
	void ApplyExtraEatEffects();
};


// Class TgGame.TgDevice_RiderShield
// 0x0000 (0x0AEC - 0x0AEC)
class ATgDevice_RiderShield : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_RiderShield");
		return ptr;
	}

};


// Class TgGame.TgDevice_Shotgun
// 0x0000 (0x0AEC - 0x0AEC)
class ATgDevice_Shotgun : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Shotgun");
		return ptr;
	}

};


// Class TgGame.TgDevice_SMG
// 0x0000 (0x0AEC - 0x0AEC)
class ATgDevice_SMG : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_SMG");
		return ptr;
	}

};


// Class TgGame.TgDevice_SniperRifle
// 0x0000 (0x0AEC - 0x0AEC)
class ATgDevice_SniperRifle : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_SniperRifle");
		return ptr;
	}

};


// Class TgGame.TgDevice_Spinfusor
// 0x0000 (0x0AEC - 0x0AEC)
class ATgDevice_Spinfusor : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Spinfusor");
		return ptr;
	}

};


// Class TgGame.TgDevice_Spray
// 0x0004 (0x0AF0 - 0x0AEC)
class ATgDevice_Spray : public ATgDevice
{
public:
	unsigned long                                      m_bMissedSpray : 1;                                       // 0x0AEC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Spray");
		return ptr;
	}


	void STATIC_OnInstantShotVerified(const struct FImpactInfo& VerifiedPrimaryImpact);
	void PlayClientFireFx(const struct FVector& HitLocation, int nSocketIndex, bool bSuccessfulHit, float fRefireTime);
	void AuthStartCooldown(int nMode, float fCooldownTimeOverride);
	bool ShouldCooldownAfterFire();
};


// Class TgGame.TgDevice_Sword
// 0x0000 (0x0AF8 - 0x0AF8)
class ATgDevice_Sword : public ATgDevice_Melee
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Sword");
		return ptr;
	}

};


// Class TgGame.TgDevice_ThrownProjectile
// 0x0008 (0x0AF4 - 0x0AEC)
class ATgDevice_ThrownProjectile : public ATgDevice
{
public:
	unsigned long                                      m_bEndCook : 1;                                           // 0x0AEC(0x0004)
	unsigned long                                      m_bThrownGrenade : 1;                                     // 0x0AEC(0x0004)
	unsigned long                                      s_bFullCook : 1;                                          // 0x0AEC(0x0004)
	float                                              m_fExplodeTime;                                           // 0x0AF0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_ThrownProjectile");
		return ptr;
	}


	bool RequiresAmmoToFire();
	bool STATIC_CanBeCanceled(class ATgDevice* NewDevice);
	bool STATIC_CanBeInterrupted();
	void STATIC_ClientInterrupt(bool bServerFireFailed);
	void STATIC_InterruptFiring(bool bServerFireFailed);
	void ServerEndCook(float fCookPct);
	void SetAndSendGrenadeTimingsViaStartThrowTimer();
	bool STATIC_InterceptSlotReleased(class ATgPlayerController* TgController);
	void SetGrenadeCookTime(float fCookAmt, bool bSendToServer);
	void StartThrow();
	void StartThrowValidation();
	void FireAmmunition();
	void DropGrenade();
	void SetThrowSpeedMultiplier(float Mult);
};


// Class TgGame.TgDevice_Tinkerin
// 0x0000 (0x0AEC - 0x0AEC)
class ATgDevice_Tinkerin : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Tinkerin");
		return ptr;
	}

};


// Class TgGame.TgDevice_ToggleInhandFiremode
// 0x0008 (0x0AF4 - 0x0AEC)
class ATgDevice_ToggleInhandFiremode : public ATgDevice
{
public:
	class ATgDevice*                                   m_CachedInhand;                                           // 0x0AEC(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_ToggleInhandFiremode");
		return ptr;
	}


	bool ShouldCooldownAfterFire();
	bool STATIC_HasCachedInhand();
	void FireAmmunition();
	bool ShouldStopActionOnOffhandSlotReleased();
	bool ShouldLockFiring(class ATgDevice* Current);
	bool ShouldInterruptReloadOnFire();
};


// Class TgGame.TgDevice_ToxicTimeBomb
// 0x0000 (0x0AEC - 0x0AEC)
class ATgDevice_ToxicTimeBomb : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_ToxicTimeBomb");
		return ptr;
	}

};


// Class TgGame.TgDevice_TurretShot
// 0x0000 (0x0AEC - 0x0AEC)
class ATgDevice_TurretShot : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_TurretShot");
		return ptr;
	}

};


// Class TgGame.TgDevice_Twinfusor
// 0x0000 (0x0AEC - 0x0AEC)
class ATgDevice_Twinfusor : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Twinfusor");
		return ptr;
	}

};


// Class TgGame.TgDevice_TyraAltFire
// 0x0000 (0x0AEC - 0x0AEC)
class ATgDevice_TyraAltFire : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_TyraAltFire");
		return ptr;
	}

};


// Class TgGame.TgDevice_TyraUlt
// 0x0000 (0x0AEC - 0x0AEC)
class ATgDevice_TyraUlt : public ATgDevice_Stim
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_TyraUlt");
		return ptr;
	}


	void TransitionOut();
	bool ShouldLockFiring(class ATgDevice* Current);
	bool STATIC_CanBeCanceled(class ATgDevice* NewDevice);
};


// Class TgGame.TgDevice_UncheckedAmbition
// 0x0000 (0x0AEC - 0x0AEC)
class ATgDevice_UncheckedAmbition : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_UncheckedAmbition");
		return ptr;
	}


	void STATIC_LinkedDeviceUnequipped(class ATgDevice* Dev);
	void STATIC_LinkedDeviceEquipped(class ATgDevice* Dev);
};


// Class TgGame.TgDevice_VenomousGourd
// 0x0000 (0x0AEC - 0x0AEC)
class ATgDevice_VenomousGourd : public ATgDevice_Throw
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_VenomousGourd");
		return ptr;
	}

};


// Class TgGame.TgDevice_ViktorAmmoRefill
// 0x0000 (0x0AEC - 0x0AEC)
class ATgDevice_ViktorAmmoRefill : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_ViktorAmmoRefill");
		return ptr;
	}


	void FireAmmunition();
};


// Class TgGame.TgDevice_WardersField
// 0x0000 (0x0AEC - 0x0AEC)
class ATgDevice_WardersField : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_WardersField");
		return ptr;
	}


	bool ShouldLockFiring(class ATgDevice* Current);
	void STATIC_OnDeployableDestroyed(class ATgDeployable* deployable);
	bool STATIC_CanBeCanceled(class ATgDevice* NewDevice);
	bool STATIC_InterceptSlotPressed(class ATgPlayerController* TgController);
};


// Class TgGame.TgDevice_Whirl
// 0x0000 (0x0B60 - 0x0B60)
class ATgDevice_Whirl : public ATgDevice_Charge
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Whirl");
		return ptr;
	}


	struct FRotator STATIC_GetChargeDirection();
};


// Class TgGame.TgDevice_Whirlwind2
// 0x0000 (0x0B34 - 0x0B34)
class ATgDevice_Whirlwind2 : public ATgDevice_ActiveAura
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Whirlwind2");
		return ptr;
	}


	bool STATIC_CanBeCanceled(class ATgDevice* NewDevice);
	bool ShouldLockFiring(class ATgDevice* Current);
};


// Class TgGame.TgDeviceFire_DrogozLeg1
// 0x0004 (0x0274 - 0x0270)
class UTgDeviceFire_DrogozLeg1 : public UTgDeviceFire
{
public:
	float                                              m_DamageAmount;                                           // 0x0270(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_DrogozLeg1");
		return ptr;
	}


	void SubmitEffect(const struct FImpactInfo& Impact, class UTgEffectGroup* effectGroup, bool bRemove, int StackCount, class AActor* InstigatorOverride);
	void SetDamageAmount(class AActor* pHitTarget);
};


// Class TgGame.TgDeviceFire_Emitter
// 0x0000 (0x0270 - 0x0270)
class UTgDeviceFire_Emitter : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Emitter");
		return ptr;
	}


	void SubmitEffect(const struct FImpactInfo& Impact, class UTgEffectGroup* effectGroup, bool bRemove, int StackCount, class AActor* InstigatorOverride);
};


// Class TgGame.TgDeviceFire_EmitterEffect
// 0x0000 (0x0270 - 0x0270)
class UTgDeviceFire_EmitterEffect : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_EmitterEffect");
		return ptr;
	}


	void SubmitEffect(const struct FImpactInfo& Impact, class UTgEffectGroup* effectGroup, bool bRemove, int StackCount, class AActor* InstigatorOverride);
};


// Class TgGame.TgDeviceFire_FlameTurret
// 0x0000 (0x0270 - 0x0270)
class UTgDeviceFire_FlameTurret : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_FlameTurret");
		return ptr;
	}

};


// Class TgGame.TgDeviceFire_GeometryInara
// 0x0000 (0x0270 - 0x0270)
class UTgDeviceFire_GeometryInara : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_GeometryInara");
		return ptr;
	}


	float STATIC_GetMinCooldownTime();
	float STATIC_GetCooldownTime();
};


// Class TgGame.TgDeviceFire_GroverInhandAxe
// 0x0000 (0x0270 - 0x0270)
class UTgDeviceFire_GroverInhandAxe : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_GroverInhandAxe");
		return ptr;
	}

};


// Class TgGame.TgDeviceFire_HeatHaze
// 0x0000 (0x0270 - 0x0270)
class UTgDeviceFire_HeatHaze : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_HeatHaze");
		return ptr;
	}

};


// Class TgGame.TgDeviceFire_IgnoreDeployableForBlocking
// 0x0000 (0x0270 - 0x0270)
class UTgDeviceFire_IgnoreDeployableForBlocking : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_IgnoreDeployableForBlocking");
		return ptr;
	}

};


// Class TgGame.TgDeviceFire_IgnoreDeployablesCannotCounter
// 0x0000 (0x0270 - 0x0270)
class UTgDeviceFire_IgnoreDeployablesCannotCounter : public UTgDeviceFire_IgnoreDeployableForBlocking
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_IgnoreDeployablesCannotCounter");
		return ptr;
	}

};


// Class TgGame.TgDeviceFire_HuntersMark
// 0x0000 (0x0270 - 0x0270)
class UTgDeviceFire_HuntersMark : public UTgDeviceFire_IgnoreDeployablesCannotCounter
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_HuntersMark");
		return ptr;
	}

};


// Class TgGame.TgDeviceFire_Mount
// 0x0000 (0x0270 - 0x0270)
class UTgDeviceFire_Mount : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Mount");
		return ptr;
	}


	float STATIC_GetPreHitDelay();
};


// Class TgGame.TgDeviceFire_PoppyBomb
// 0x0000 (0x0270 - 0x0270)
class UTgDeviceFire_PoppyBomb : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_PoppyBomb");
		return ptr;
	}


	void SubmitEffect(const struct FImpactInfo& Impact, class UTgEffectGroup* effectGroup, bool bRemove, int StackCount, class AActor* InstigatorOverride);
};


// Class TgGame.TgDeviceFire_SelfResurrection
// 0x0000 (0x0270 - 0x0270)
class UTgDeviceFire_SelfResurrection : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_SelfResurrection");
		return ptr;
	}


	void SubmitEffect(const struct FImpactInfo& Impact, class UTgEffectGroup* effectGroup, bool bRemove, int StackCount, class AActor* InstigatorOverride);
};


// Class TgGame.TgDeviceFire_ShellShield
// 0x0000 (0x0270 - 0x0270)
class UTgDeviceFire_ShellShield : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_ShellShield");
		return ptr;
	}

};


// Class TgGame.TgDeviceFire_ShieldFernando
// 0x0000 (0x0270 - 0x0270)
class UTgDeviceFire_ShieldFernando : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_ShieldFernando");
		return ptr;
	}


	float STATIC_GetCooldownTime();
};


// Class TgGame.TgDeviceFire_Soar
// 0x0000 (0x0270 - 0x0270)
class UTgDeviceFire_Soar : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Soar");
		return ptr;
	}


	float STATIC_GetMinCooldownTime();
};


// Class TgGame.TgDeviceFire_SpawnAtOwnerLocation
// 0x0000 (0x0270 - 0x0270)
class UTgDeviceFire_SpawnAtOwnerLocation : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_SpawnAtOwnerLocation");
		return ptr;
	}

};


// Class TgGame.TgDeviceFire_Sword
// 0x0000 (0x0270 - 0x0270)
class UTgDeviceFire_Sword : public UTgDeviceFire_Melee
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Sword");
		return ptr;
	}

};


// Class TgGame.TgDeviceFire_TurtlePower
// 0x0000 (0x0270 - 0x0270)
class UTgDeviceFire_TurtlePower : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_TurtlePower");
		return ptr;
	}


	void SubmitEffect(const struct FImpactInfo& Impact, class UTgEffectGroup* effectGroup, bool bRemove, int StackCount, class AActor* InstigatorOverride);
};


// Class TgGame.TgDeviceFire_Valor
// 0x0000 (0x0270 - 0x0270)
class UTgDeviceFire_Valor : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Valor");
		return ptr;
	}

};


// Class TgGame.TgDeviceFire_Whirlwind
// 0x0000 (0x0270 - 0x0270)
class UTgDeviceFire_Whirlwind : public UTgDeviceFire_Cylinder
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Whirlwind");
		return ptr;
	}

};


// Class TgGame.TgDeviceForm_Advance
// 0x0000 (0x02BC - 0x02BC)
class UTgDeviceForm_Advance : public UTgDeviceForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Advance");
		return ptr;
	}


	void STATIC_Generic2(unsigned char byExtraData);
	void STATIC_Generic1(unsigned char byExtraData);
};


// Class TgGame.TgDeviceForm_AssaultRifle
// 0x0000 (0x02BC - 0x02BC)
class UTgDeviceForm_AssaultRifle : public UTgDeviceForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_AssaultRifle");
		return ptr;
	}


	void STATIC_SetAmmoBlendNodesAmount(int nAmmoAmt, bool bTickOnly);
};


// Class TgGame.TgDeviceForm_BarikInhand
// 0x0000 (0x02BC - 0x02BC)
class UTgDeviceForm_BarikInhand : public UTgDeviceForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_BarikInhand");
		return ptr;
	}

};


// Class TgGame.TgDeviceForm_Barrage
// 0x0008 (0x02C4 - 0x02BC)
class UTgDeviceForm_Barrage : public UTgDeviceForm
{
public:
	class ATgPlayerController*                         m_CachedActiveOverlayController;                          // 0x02BC(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Barrage");
		return ptr;
	}


	void StopFire(int nFireModeNum);
	void STATIC_Fire(const struct FVector& HitLocation, int nFireMode, int nEquipSlot, int nSocketIndex, bool bSuccessfulHit, float fRefireTime);
	void STATIC_StartFire(int nFireMode, float fRefireTime, class AActor* Target, int nAmmoRemaining);
};


// Class TgGame.TgDeviceForm_Booster
// 0x0000 (0x02BC - 0x02BC)
class UTgDeviceForm_Booster : public UTgDeviceForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Booster");
		return ptr;
	}


	void StopFire(int nFireModeNum);
	void STATIC_StartFire(int nFireMode, float fRefireTime, class AActor* Target, int nAmmoRemaining);
};


// Class TgGame.TgDeviceForm_CombatSlide
// 0x0004 (0x02C0 - 0x02BC)
class UTgDeviceForm_CombatSlide : public UTgDeviceForm
{
public:
	float                                              m_fTransitionTime;                                        // 0x02BC(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_CombatSlide");
		return ptr;
	}


	void StopFire(int nFireModeNum);
	void STATIC_StartFire(int nFireMode, float fRefireTime, class AActor* Target, int nAmmoRemaining);
};


// Class TgGame.TgDeviceForm_DarkConvergenceSub
// 0x0000 (0x02BC - 0x02BC)
class UTgDeviceForm_DarkConvergenceSub : public UTgDeviceForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_DarkConvergenceSub");
		return ptr;
	}

};


// Class TgGame.TgDeviceForm_DemonStim
// 0x0004 (0x02C0 - 0x02BC)
class UTgDeviceForm_DemonStim : public UTgDeviceForm
{
public:
	float                                              m_fTransitionTime;                                        // 0x02BC(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_DemonStim");
		return ptr;
	}


	void StopFire(int nFireModeNum);
	void STATIC_StartFire(int nFireMode, float fRefireTime, class AActor* Target, int nAmmoRemaining);
};


// Class TgGame.TgDeviceForm_DimensionalLink
// 0x0000 (0x02BC - 0x02BC)
class UTgDeviceForm_DimensionalLink : public UTgDeviceForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_DimensionalLink");
		return ptr;
	}


	bool STATIC_HasCachedYingPawn();
	void STATIC_Fire(const struct FVector& HitLocation, int nFireMode, int nEquipSlot, int nSocketIndex, bool bSuccessfulHit, float fRefireTime);
};


// Class TgGame.TgDeviceForm_Disengage
// 0x0000 (0x02BC - 0x02BC)
class UTgDeviceForm_Disengage : public UTgDeviceForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Disengage");
		return ptr;
	}

};


// Class TgGame.TgDeviceForm_GaeBolg
// 0x0000 (0x02BC - 0x02BC)
class UTgDeviceForm_GaeBolg : public UTgDeviceForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_GaeBolg");
		return ptr;
	}


	void STATIC_DoInterrupt();
	void STATIC_Fire(const struct FVector& HitLocation, int nFireMode, int nEquipSlot, int nSocketIndex, bool bSuccessfulHit, float fRefireTime);
	void STATIC_StartFire(int nFireMode, float fRefireTime, class AActor* Target, int nAmmoRemaining);
};


// Class TgGame.TgDeviceForm_GrumpyBomb
// 0x0000 (0x02BC - 0x02BC)
class UTgDeviceForm_GrumpyBomb : public UTgDeviceForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_GrumpyBomb");
		return ptr;
	}

};


// Class TgGame.TgDeviceForm_HeadHunter
// 0x0000 (0x02BC - 0x02BC)
class UTgDeviceForm_HeadHunter : public UTgDeviceForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_HeadHunter");
		return ptr;
	}


	void StopFire(int nFireModeNum);
	void STATIC_StartFire(int nFireMode, float fRefireTime, class AActor* Target, int nAmmoRemaining);
};


// Class TgGame.TgDeviceForm_HeroicLeap
// 0x0000 (0x02BC - 0x02BC)
class UTgDeviceForm_HeroicLeap : public UTgDeviceForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_HeroicLeap");
		return ptr;
	}

};


// Class TgGame.TgDeviceForm_Hover
// 0x0000 (0x02BC - 0x02BC)
class UTgDeviceForm_Hover : public UTgDeviceForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Hover");
		return ptr;
	}

};


// Class TgGame.TgDeviceForm_Hustle
// 0x0000 (0x02BC - 0x02BC)
class UTgDeviceForm_Hustle : public UTgDeviceForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Hustle");
		return ptr;
	}


	void StopFire(int nFireModeNum);
	void STATIC_StartFire(int nFireMode, float fRefireTime, class AActor* Target, int nAmmoRemaining);
};


// Class TgGame.TgDeviceForm_HyperBeam
// 0x0000 (0x02E8 - 0x02E8)
class UTgDeviceForm_HyperBeam : public UTgDeviceForm_SpinnerWhileFiring
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_HyperBeam");
		return ptr;
	}


	void SetSpinnersActive(bool bActive);
	void PlayTracerEffects(const struct FVector& endLocation, int nEquipSlot);
	void STATIC_Fire(const struct FVector& HitLocation, int nFireMode, int nEquipSlot, int nSocketIndex, bool bSuccessfulHit, float fRefireTime);
};


// Class TgGame.TgDeviceForm_KingBomb
// 0x0004 (0x02C0 - 0x02BC)
class UTgDeviceForm_KingBomb : public UTgDeviceForm
{
public:
	unsigned long                                      m_bKingBombActive : 1;                                    // 0x02BC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_KingBomb");
		return ptr;
	}


	void CleanUpKingBomb();
	void SetUpKingBomb();
	void STATIC_Generic1(unsigned char byExtraData);
	void STATIC_DoInterrupt();
	void StopFire(int nFireModeNum);
	void STATIC_Fire(const struct FVector& HitLocation, int nFireMode, int nEquipSlot, int nSocketIndex, bool bSuccessfulHit, float fRefireTime);
	void STATIC_StartFire(int nFireMode, float fRefireTime, class AActor* Target, int nAmmoRemaining);
	void STATIC_BuildUp(int nFireMode, int nEquipSlot, int nSocketIndex, float fBuildupTime);
	void RecoverDeviceState(TEnumAsByte<ETG_REP_DEVICE_STATE> DesiredState);
};


// Class TgGame.TgDeviceForm_Lockdown
// 0x0000 (0x02BC - 0x02BC)
class UTgDeviceForm_Lockdown : public UTgDeviceForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Lockdown");
		return ptr;
	}


	void StopFire(int nFireModeNum);
	void STATIC_Fire(const struct FVector& HitLocation, int nFireMode, int nEquipSlot, int nSocketIndex, bool bSuccessfulHit, float fRefireTime);
};


// Class TgGame.TgDeviceForm_LongbowPlanted
// 0x0000 (0x02BC - 0x02BC)
class UTgDeviceForm_LongbowPlanted : public UTgDeviceForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_LongbowPlanted");
		return ptr;
	}


	void STATIC_DoInterrupt();
	void StopFire(int nFireModeNum);
	void STATIC_StartFire(int nFireMode, float fRefireTime, class AActor* Target, int nAmmoRemaining);
};


// Class TgGame.TgDeviceForm_MendingSpirits
// 0x0000 (0x02BC - 0x02BC)
class UTgDeviceForm_MendingSpirits : public UTgDeviceForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_MendingSpirits");
		return ptr;
	}


	void STATIC_Fire(const struct FVector& HitLocation, int nFireMode, int nEquipSlot, int nSocketIndex, bool bSuccessfulHit, float fRefireTime);
};


// Class TgGame.TgDeviceForm_MountMorph
// 0x0000 (0x02DC - 0x02DC)
class UTgDeviceForm_MountMorph : public UTgDeviceForm_Mount
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_MountMorph");
		return ptr;
	}

};


// Class TgGame.TgDeviceForm_MountNoHorse
// 0x000C (0x02E8 - 0x02DC)
class UTgDeviceForm_MountNoHorse : public UTgDeviceForm_Mount
{
public:
	int                                                c_SparkleFXID;                                            // 0x02DC(0x0004)
	class UTgSpecialFx*                                c_SparkleFX;                                              // 0x02E0(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_MountNoHorse");
		return ptr;
	}


	void STATIC_GetAnimSetStringsForBot(int PlayerBotId, TArray<struct FString>* sPaths);
	void StopFire(int nFireModeNum);
	void STATIC_StartFire(int nFireMode, float fRefireTime, class AActor* Target, int nAmmoRemaining);
};


// Class TgGame.TgDeviceForm_PoppyBomb
// 0x0000 (0x02BC - 0x02BC)
class UTgDeviceForm_PoppyBomb : public UTgDeviceForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_PoppyBomb");
		return ptr;
	}

};


// Class TgGame.TgDeviceForm_Presence
// 0x0000 (0x02BC - 0x02BC)
class UTgDeviceForm_Presence : public UTgDeviceForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Presence");
		return ptr;
	}

};


// Class TgGame.TgDeviceForm_Recharge
// 0x0000 (0x02E8 - 0x02E8)
class UTgDeviceForm_Recharge : public UTgDeviceForm_SpinnerWhileFiring
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Recharge");
		return ptr;
	}


	void SetLockedForBlendNodes(bool bLocked);
	void STATIC_StartFire(int nFireMode, float fRefireTime, class AActor* Target, int nAmmoRemaining);
	void STATIC_Fire(const struct FVector& HitLocation, int nFireMode, int nEquipSlot, int nSocketIndex, bool bSuccessfulHit, float fRefireTime);
};


// Class TgGame.TgDeviceForm_RendSoul
// 0x0000 (0x02BC - 0x02BC)
class UTgDeviceForm_RendSoul : public UTgDeviceForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_RendSoul");
		return ptr;
	}


	void STATIC_Generic1(unsigned char byExtraData);
	void ActivateFx(class UTgSpecialFx* Fx, float fHealStacks);
};


// Class TgGame.TgDeviceForm_RestoreSoul
// 0x0000 (0x02BC - 0x02BC)
class UTgDeviceForm_RestoreSoul : public UTgDeviceForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_RestoreSoul");
		return ptr;
	}


	void RecoverDeviceState(TEnumAsByte<ETG_REP_DEVICE_STATE> DesiredState);
	bool STATIC_HasCachedOracle();
};


// Class TgGame.TgDeviceForm_RiderMovement
// 0x000C (0x02C8 - 0x02BC)
class UTgDeviceForm_RiderMovement : public UTgDeviceForm
{
public:
	struct FVector                                     m_vActiveCameraOffset;                                    // 0x02BC(0x000C)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_RiderMovement");
		return ptr;
	}


	bool STATIC_HasCachedRider();
	void StopFire(int nFireModeNum);
	void STATIC_StartFire(int nFireMode, float fRefireTime, class AActor* Target, int nAmmoRemaining);
};


// Class TgGame.TgDeviceForm_RocketLauncher
// 0x0000 (0x02BC - 0x02BC)
class UTgDeviceForm_RocketLauncher : public UTgDeviceForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_RocketLauncher");
		return ptr;
	}


	void STATIC_Generic1(unsigned char byExtraData);
};


// Class TgGame.TgDeviceForm_ShadowTravel
// 0x0000 (0x02BC - 0x02BC)
class UTgDeviceForm_ShadowTravel : public UTgDeviceForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_ShadowTravel");
		return ptr;
	}


	void StopFire(int nFireModeNum);
};


// Class TgGame.TgDeviceForm_Shatterfall
// 0x0000 (0x02BC - 0x02BC)
class UTgDeviceForm_Shatterfall : public UTgDeviceForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Shatterfall");
		return ptr;
	}


	void STATIC_Generic1(unsigned char byExtraData);
};


// Class TgGame.TgDeviceForm_ShockPulseSubdevice
// 0x0000 (0x02E0 - 0x02E0)
class UTgDeviceForm_ShockPulseSubdevice : public UTgDeviceForm_ArcingBeam
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_ShockPulseSubdevice");
		return ptr;
	}

};


// Class TgGame.TgDeviceForm_SilenceBeam
// 0x0000 (0x02E8 - 0x02E8)
class UTgDeviceForm_SilenceBeam : public UTgDeviceForm_SpinnerWhileFiring
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_SilenceBeam");
		return ptr;
	}


	void SetLockedForBlendNodes(bool bLocked);
	void STATIC_Fire(const struct FVector& HitLocation, int nFireMode, int nEquipSlot, int nSocketIndex, bool bSuccessfulHit, float fRefireTime);
};


// Class TgGame.TgDeviceForm_SniperRifle
// 0x0000 (0x02BC - 0x02BC)
class UTgDeviceForm_SniperRifle : public UTgDeviceForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_SniperRifle");
		return ptr;
	}

};


// Class TgGame.TgDeviceForm_Soar
// 0x0000 (0x02BC - 0x02BC)
class UTgDeviceForm_Soar : public UTgDeviceForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Soar");
		return ptr;
	}


	void StopFire(int nFireModeNum);
	void STATIC_Fire(const struct FVector& HitLocation, int nFireMode, int nEquipSlot, int nSocketIndex, bool bSuccessfulHit, float fRefireTime);
};


// Class TgGame.TgDeviceForm_Thrust
// 0x0000 (0x02BC - 0x02BC)
class UTgDeviceForm_Thrust : public UTgDeviceForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Thrust");
		return ptr;
	}


	void StopFire(int nFireModeNum);
	void STATIC_StartFire(int nFireMode, float fRefireTime, class AActor* Target, int nAmmoRemaining);
};


// Class TgGame.TgDeviceForm_TyraInhand
// 0x0000 (0x02BC - 0x02BC)
class UTgDeviceForm_TyraInhand : public UTgDeviceForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_TyraInhand");
		return ptr;
	}


	void STATIC_Hit(int nFireMode, class AActor* Target, float fDamageAmount, const struct FVector& HitLocation, const struct FVector& HitNormal, struct FExtraDamageInfo* ExtraInfo);
};


// Class TgGame.TgDeviceForm_TyraUlt
// 0x0000 (0x02BC - 0x02BC)
class UTgDeviceForm_TyraUlt : public UTgDeviceForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_TyraUlt");
		return ptr;
	}


	void StopFire(int nFireModeNum);
	void STATIC_StartFire(int nFireMode, float fRefireTime, class AActor* Target, int nAmmoRemaining);
};


// Class TgGame.TgDeviceForm_Valor
// 0x0000 (0x02BC - 0x02BC)
class UTgDeviceForm_Valor : public UTgDeviceForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Valor");
		return ptr;
	}


	void STATIC_Hit(int nFireMode, class AActor* Target, float fDamageAmount, const struct FVector& HitLocation, const struct FVector& HitNormal, struct FExtraDamageInfo* ExtraInfo);
};


// Class TgGame.TgDeviceForm_Whirlwind
// 0x0000 (0x02BC - 0x02BC)
class UTgDeviceForm_Whirlwind : public UTgDeviceForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Whirlwind");
		return ptr;
	}


	void StopFire(int nFireModeNum);
	void STATIC_Generic1(unsigned char byExtraData);
	void STATIC_DoInterrupt();
	void STATIC_StartFire(int nFireMode, float fRefireTime, class AActor* Target, int nAmmoRemaining);
};


// Class TgGame.TgDeviceForm_Whirlwind2
// 0x0000 (0x02BC - 0x02BC)
class UTgDeviceForm_Whirlwind2 : public UTgDeviceForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Whirlwind2");
		return ptr;
	}


	void StopFire(int nFireModeNum);
	void STATIC_DoInterrupt();
	void STATIC_StartFire(int nFireMode, float fRefireTime, class AActor* Target, int nAmmoRemaining);
};


// Class TgGame.TgDeviceVolumeInfo
// 0x0008 (0x0288 - 0x0280)
class ATgDeviceVolumeInfo : public AInfo
{
public:
	class ATgDeviceVolume*                             V;                                                        // 0x0280(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceVolumeInfo");
		return ptr;
	}


	void Timer();
	void PostBeginPlay();
};


// Class TgGame.TgDamageType_ArmorHit
// 0x0000 (0x0154 - 0x0154)
class UTgDamageType_ArmorHit : public UTgDamageType
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDamageType_ArmorHit");
		return ptr;
	}

};


// Class TgGame.TgEffectDamage_NoLifeSteal
// 0x0000 (0x00C8 - 0x00C8)
class UTgEffectDamage_NoLifeSteal : public UTgEffectDamage
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectDamage_NoLifeSteal");
		return ptr;
	}

};


// Class TgGame.TgEffectModifyProperty_Ability1
// 0x0000 (0x00BC - 0x00BC)
class UTgEffectModifyProperty_Ability1 : public UTgEffectModifyProperty
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectModifyProperty_Ability1");
		return ptr;
	}

};


// Class TgGame.TgEffectModifyProperty_Ability2
// 0x0000 (0x00BC - 0x00BC)
class UTgEffectModifyProperty_Ability2 : public UTgEffectModifyProperty
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectModifyProperty_Ability2");
		return ptr;
	}

};


// Class TgGame.TgEffectModifyProperty_EnergyCharge
// 0x0000 (0x00BC - 0x00BC)
class UTgEffectModifyProperty_EnergyCharge : public UTgEffectModifyProperty
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectModifyProperty_EnergyCharge");
		return ptr;
	}

};


// Class TgGame.TgEffectModifyProperty_Inhand
// 0x0000 (0x00BC - 0x00BC)
class UTgEffectModifyProperty_Inhand : public UTgEffectModifyProperty
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectModifyProperty_Inhand");
		return ptr;
	}

};


// Class TgGame.TgEffectModifyProperty_Movement
// 0x0000 (0x00BC - 0x00BC)
class UTgEffectModifyProperty_Movement : public UTgEffectModifyProperty
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectModifyProperty_Movement");
		return ptr;
	}

};


// Class TgGame.TgElevatingVolume
// 0x0000 (0x0314 - 0x0314)
class ATgElevatingVolume : public APhysicsVolume
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgElevatingVolume");
		return ptr;
	}

};


// Class TgGame.TgEmitter_CameraEffect_Bleed
// 0x0000 (0x02B4 - 0x02B4)
class ATgEmitter_CameraEffect_Bleed : public ATgEmitter_CameraEffect
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEmitter_CameraEffect_Bleed");
		return ptr;
	}

};


// Class TgGame.TgEmitter_CameraEffect_CCImmune
// 0x0000 (0x02B4 - 0x02B4)
class ATgEmitter_CameraEffect_CCImmune : public ATgEmitter_CameraEffect
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEmitter_CameraEffect_CCImmune");
		return ptr;
	}

};


// Class TgGame.TgEmitter_CameraEffect_Cripple
// 0x0000 (0x02B4 - 0x02B4)
class ATgEmitter_CameraEffect_Cripple : public ATgEmitter_CameraEffect
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEmitter_CameraEffect_Cripple");
		return ptr;
	}

};


// Class TgGame.TgEmitter_CameraEffect_DamageBottom
// 0x0003 (0x02B8 - 0x02B5)
class ATgEmitter_CameraEffect_DamageBottom : public ATgEmitter_CameraEffect_DamageBase
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x02B5(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEmitter_CameraEffect_DamageBottom");
		return ptr;
	}

};


// Class TgGame.TgEmitter_CameraEffect_DamageBottomLeft
// 0x0003 (0x02B8 - 0x02B5)
class ATgEmitter_CameraEffect_DamageBottomLeft : public ATgEmitter_CameraEffect_DamageBase
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x02B5(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEmitter_CameraEffect_DamageBottomLeft");
		return ptr;
	}

};


// Class TgGame.TgEmitter_CameraEffect_DamageBottomRight
// 0x0003 (0x02B8 - 0x02B5)
class ATgEmitter_CameraEffect_DamageBottomRight : public ATgEmitter_CameraEffect_DamageBase
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x02B5(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEmitter_CameraEffect_DamageBottomRight");
		return ptr;
	}

};


// Class TgGame.TgEmitter_CameraEffect_DamageLeft
// 0x0003 (0x02B8 - 0x02B5)
class ATgEmitter_CameraEffect_DamageLeft : public ATgEmitter_CameraEffect_DamageBase
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x02B5(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEmitter_CameraEffect_DamageLeft");
		return ptr;
	}

};


// Class TgGame.TgEmitter_CameraEffect_DamageRight
// 0x0003 (0x02B8 - 0x02B5)
class ATgEmitter_CameraEffect_DamageRight : public ATgEmitter_CameraEffect_DamageBase
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x02B5(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEmitter_CameraEffect_DamageRight");
		return ptr;
	}

};


// Class TgGame.TgEmitter_CameraEffect_DamageTop
// 0x0003 (0x02B8 - 0x02B5)
class ATgEmitter_CameraEffect_DamageTop : public ATgEmitter_CameraEffect_DamageBase
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x02B5(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEmitter_CameraEffect_DamageTop");
		return ptr;
	}

};


// Class TgGame.TgEmitter_CameraEffect_DamageTopLeft
// 0x0003 (0x02B8 - 0x02B5)
class ATgEmitter_CameraEffect_DamageTopLeft : public ATgEmitter_CameraEffect_DamageBase
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x02B5(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEmitter_CameraEffect_DamageTopLeft");
		return ptr;
	}

};


// Class TgGame.TgEmitter_CameraEffect_DamageTopRight
// 0x0003 (0x02B8 - 0x02B5)
class ATgEmitter_CameraEffect_DamageTopRight : public ATgEmitter_CameraEffect_DamageBase
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x02B5(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEmitter_CameraEffect_DamageTopRight");
		return ptr;
	}

};


// Class TgGame.TgEmitter_CameraEffect_Daze
// 0x0000 (0x02B4 - 0x02B4)
class ATgEmitter_CameraEffect_Daze : public ATgEmitter_CameraEffect
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEmitter_CameraEffect_Daze");
		return ptr;
	}

};


// Class TgGame.TgEmitter_CameraEffect_Fire
// 0x0000 (0x02B4 - 0x02B4)
class ATgEmitter_CameraEffect_Fire : public ATgEmitter_CameraEffect
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEmitter_CameraEffect_Fire");
		return ptr;
	}

};


// Class TgGame.TgEmitter_CameraEffect_Freeze
// 0x0000 (0x02B4 - 0x02B4)
class ATgEmitter_CameraEffect_Freeze : public ATgEmitter_CameraEffect
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEmitter_CameraEffect_Freeze");
		return ptr;
	}

};


// Class TgGame.TgEmitter_CameraEffect_Heal
// 0x0000 (0x02B4 - 0x02B4)
class ATgEmitter_CameraEffect_Heal : public ATgEmitter_CameraEffect
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEmitter_CameraEffect_Heal");
		return ptr;
	}


	void SetHealIntensity(float fHealIntensity, bool bCritical);
};


// Class TgGame.TgEmitter_CameraEffect_Hidden
// 0x0000 (0x02B4 - 0x02B4)
class ATgEmitter_CameraEffect_Hidden : public ATgEmitter_CameraEffect
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEmitter_CameraEffect_Hidden");
		return ptr;
	}


	void ChangeTemplate(class UParticleSystem* NewTemplate);
};


// Class TgGame.TgEmitter_CameraEffect_Knockback
// 0x0000 (0x02B4 - 0x02B4)
class ATgEmitter_CameraEffect_Knockback : public ATgEmitter_CameraEffect
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEmitter_CameraEffect_Knockback");
		return ptr;
	}

};


// Class TgGame.TgEmitter_CameraEffect_Mark
// 0x0000 (0x02B4 - 0x02B4)
class ATgEmitter_CameraEffect_Mark : public ATgEmitter_CameraEffect
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEmitter_CameraEffect_Mark");
		return ptr;
	}

};


// Class TgGame.TgEmitter_CameraEffect_Poison
// 0x0000 (0x02B4 - 0x02B4)
class ATgEmitter_CameraEffect_Poison : public ATgEmitter_CameraEffect
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEmitter_CameraEffect_Poison");
		return ptr;
	}

};


// Class TgGame.TgEmitter_CameraEffect_PreTeleport
// 0x0000 (0x02B4 - 0x02B4)
class ATgEmitter_CameraEffect_PreTeleport : public ATgEmitter_CameraEffect
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEmitter_CameraEffect_PreTeleport");
		return ptr;
	}

};


// Class TgGame.TgEmitter_CameraEffect_Revealed
// 0x0000 (0x02B4 - 0x02B4)
class ATgEmitter_CameraEffect_Revealed : public ATgEmitter_CameraEffect
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEmitter_CameraEffect_Revealed");
		return ptr;
	}

};


// Class TgGame.TgEmitter_CameraEffect_Root
// 0x0000 (0x02B4 - 0x02B4)
class ATgEmitter_CameraEffect_Root : public ATgEmitter_CameraEffect
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEmitter_CameraEffect_Root");
		return ptr;
	}

};


// Class TgGame.TgEmitter_CameraEffect_Slow
// 0x0000 (0x02B4 - 0x02B4)
class ATgEmitter_CameraEffect_Slow : public ATgEmitter_CameraEffect
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEmitter_CameraEffect_Slow");
		return ptr;
	}

};


// Class TgGame.TgEmitter_CameraEffect_Stun
// 0x0000 (0x02B4 - 0x02B4)
class ATgEmitter_CameraEffect_Stun : public ATgEmitter_CameraEffect
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEmitter_CameraEffect_Stun");
		return ptr;
	}

};


// Class TgGame.TgEmitter_CameraEffect_Teleport
// 0x0000 (0x02B4 - 0x02B4)
class ATgEmitter_CameraEffect_Teleport : public ATgEmitter_CameraEffect
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEmitter_CameraEffect_Teleport");
		return ptr;
	}

};


// Class TgGame.TgEmitter_CameraEffect_Venom
// 0x0000 (0x02B4 - 0x02B4)
class ATgEmitter_CameraEffect_Venom : public ATgEmitter_CameraEffect
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEmitter_CameraEffect_Venom");
		return ptr;
	}

};


// Class TgGame.TgEmitterCrashlanding
// 0x0024 (0x02B8 - 0x0294)
class ATgEmitterCrashlanding : public ATgEmitterSpawnable
{
public:
	class UStaticMeshComponent*                        m_PrimaryMesh;                                            // 0x0294(0x0008) (ExportObject, Component, EditInline)
	class UStaticMeshComponent*                        m_SecondaryMesh;                                          // 0x029C(0x0008) (ExportObject, Component, EditInline)
	float                                              ParticleDurationAfterImpact;                              // 0x02A4(0x0004)
	class ULensFlareComponent*                         m_LensFlare;                                              // 0x02A8(0x0008) (ExportObject, Component, EditInline)
	class UAudioComponent*                             m_AudioComponent;                                         // 0x02B0(0x0008) (ExportObject, Component, EditInline)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEmitterCrashlanding");
		return ptr;
	}


	void PostImpactComplete();
	void STATIC_OnImpact();
	void SetAudio(class USoundCue* SoundCueToSet);
	void SetSecondaryMesh(class UStaticMesh* StaticMeshToSet);
	void SetPrimaryMesh(class UStaticMesh* StaticMeshToSet);
};


// Class TgGame.TgSeqEvent_CaptureAndPayloadSuccessfulPushTF1
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_CaptureAndPayloadSuccessfulPushTF1 : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_CaptureAndPayloadSuccessfulPushTF1");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_CaptureAndPayloadSuccessfulPushTF2
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_CaptureAndPayloadSuccessfulPushTF2 : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_CaptureAndPayloadSuccessfulPushTF2");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_CaptureAndPayloadSuccessfulDefenseTF1
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_CaptureAndPayloadSuccessfulDefenseTF1 : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_CaptureAndPayloadSuccessfulDefenseTF1");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_CaptureAndPayloadSuccessfulDefenseTF2
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_CaptureAndPayloadSuccessfulDefenseTF2 : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_CaptureAndPayloadSuccessfulDefenseTF2");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_SurvivalGameBegin
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_SurvivalGameBegin : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_SurvivalGameBegin");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_SurvivalGameStateChange
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_SurvivalGameStateChange : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_SurvivalGameStateChange");
		return ptr;
	}


	int STATIC_GetIndex(TEnumAsByte<EBG_GAME_STATE> GameState);
};


// Class TgGame.TgGame_RoyaleExTestMap
// 0x0000 (0x09C0 - 0x09C0)
class ATgGame_RoyaleExTestMap : public ATgGame_RoyaleEx
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_RoyaleExTestMap");
		return ptr;
	}

};


// Class TgGame.TgGame_RoyaleTraining
// 0x0000 (0x09C0 - 0x09C0)
class ATgGame_RoyaleTraining : public ATgGame_Royale
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_RoyaleTraining");
		return ptr;
	}

};


// Class TgGame.TgGameInfo
// 0x0000 (0x0280 - 0x0280)
class ATgGameInfo : public AInfo
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGameInfo");
		return ptr;
	}

};


// Class TgGame.TgGameInfo_TeamDeathMatch
// 0x0004 (0x0284 - 0x0280)
class ATgGameInfo_TeamDeathMatch : public ATgGameInfo
{
public:
	unsigned long                                      m_bSpawnInputLock : 1;                                    // 0x0280(0x0004) (Edit)
	unsigned long                                      m_bAllowSpawnGuardDuringDeviceFire : 1;                   // 0x0280(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGameInfo_TeamDeathMatch");
		return ptr;
	}

};


// Class TgGame.TgGameplayCurvesSet_Accuracy
// 0x0000 (0x0098 - 0x0098)
class UTgGameplayCurvesSet_Accuracy : public UTgGameplayCurvesSet_Simple
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGameplayCurvesSet_Accuracy");
		return ptr;
	}

};


// Class TgGame.TgGameplayCurvesSet_AimAssistBoundsByFOV
// 0x0000 (0x0098 - 0x0098)
class UTgGameplayCurvesSet_AimAssistBoundsByFOV : public UTgGameplayCurvesSet_Simple
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGameplayCurvesSet_AimAssistBoundsByFOV");
		return ptr;
	}

};


// Class TgGame.TgGameplayCurvesSet_AirControlFromZVelocity
// 0x0000 (0x0098 - 0x0098)
class UTgGameplayCurvesSet_AirControlFromZVelocity : public UTgGameplayCurvesSet_Simple
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGameplayCurvesSet_AirControlFromZVelocity");
		return ptr;
	}

};


// Class TgGame.TgGameplayCurvesSet_DamagePerShotHit
// 0x0000 (0x0098 - 0x0098)
class UTgGameplayCurvesSet_DamagePerShotHit : public UTgGameplayCurvesSet_Simple
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGameplayCurvesSet_DamagePerShotHit");
		return ptr;
	}

};


// Class TgGame.TgGameplayCurvesSet_FlakInhandKnockback
// 0x0000 (0x0098 - 0x0098)
class UTgGameplayCurvesSet_FlakInhandKnockback : public UTgGameplayCurvesSet_Simple
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGameplayCurvesSet_FlakInhandKnockback");
		return ptr;
	}

};


// Class TgGame.TgGameplayCurvesSet_FlakInhandSlow
// 0x0000 (0x0098 - 0x0098)
class UTgGameplayCurvesSet_FlakInhandSlow : public UTgGameplayCurvesSet_Simple
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGameplayCurvesSet_FlakInhandSlow");
		return ptr;
	}

};


// Class TgGame.TgGameplayCurvesSet_GravityFromCustom
// 0x0000 (0x0098 - 0x0098)
class UTgGameplayCurvesSet_GravityFromCustom : public UTgGameplayCurvesSet_Simple
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGameplayCurvesSet_GravityFromCustom");
		return ptr;
	}

};


// Class TgGame.TgGameplayCurvesSet_GravityFromZVelocity
// 0x0000 (0x0098 - 0x0098)
class UTgGameplayCurvesSet_GravityFromZVelocity : public UTgGameplayCurvesSet_Simple
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGameplayCurvesSet_GravityFromZVelocity");
		return ptr;
	}

};


// Class TgGame.TgGameplayCurvesSet_HitMarkerScaleByDamage
// 0x0000 (0x0098 - 0x0098)
class UTgGameplayCurvesSet_HitMarkerScaleByDamage : public UTgGameplayCurvesSet_Simple
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGameplayCurvesSet_HitMarkerScaleByDamage");
		return ptr;
	}

};


// Class TgGame.TgGameplayCurvesSet_MoveSpeedOverTime
// 0x0000 (0x0098 - 0x0098)
class UTgGameplayCurvesSet_MoveSpeedOverTime : public UTgGameplayCurvesSet_Simple
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGameplayCurvesSet_MoveSpeedOverTime");
		return ptr;
	}

};


// Class TgGame.TgGameplayCurvesSet_ProjectileSpeedOverTime
// 0x0000 (0x0098 - 0x0098)
class UTgGameplayCurvesSet_ProjectileSpeedOverTime : public UTgGameplayCurvesSet_Simple
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGameplayCurvesSet_ProjectileSpeedOverTime");
		return ptr;
	}

};


// Class TgGame.TgGameplayCurvesSet_ProjFrictionOverTime
// 0x0000 (0x0098 - 0x0098)
class UTgGameplayCurvesSet_ProjFrictionOverTime : public UTgGameplayCurvesSet_Simple
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGameplayCurvesSet_ProjFrictionOverTime");
		return ptr;
	}

};


// Class TgGame.TgGameplayCurvesSet_ProjGravityOverTime
// 0x0000 (0x0098 - 0x0098)
class UTgGameplayCurvesSet_ProjGravityOverTime : public UTgGameplayCurvesSet_Simple
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGameplayCurvesSet_ProjGravityOverTime");
		return ptr;
	}

};


// Class TgGame.TgGameplayCurvesSet_RuckusSpinUpControl
// 0x0000 (0x0098 - 0x0098)
class UTgGameplayCurvesSet_RuckusSpinUpControl : public UTgGameplayCurvesSet_Simple
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGameplayCurvesSet_RuckusSpinUpControl");
		return ptr;
	}

};


// Class TgGame.TgGameplayCurvesSet_ScopeWeaponFOV
// 0x0000 (0x0098 - 0x0098)
class UTgGameplayCurvesSet_ScopeWeaponFOV : public UTgGameplayCurvesSet_Simple
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGameplayCurvesSet_ScopeWeaponFOV");
		return ptr;
	}

};


// Class TgGame.TgGameplayCurvesSet_ScopeWorldFOV
// 0x0000 (0x0098 - 0x0098)
class UTgGameplayCurvesSet_ScopeWorldFOV : public UTgGameplayCurvesSet_Simple
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGameplayCurvesSet_ScopeWorldFOV");
		return ptr;
	}

};


// Class TgGame.TgGameplayCurvesSet_SpeedOverDistance
// 0x0000 (0x0098 - 0x0098)
class UTgGameplayCurvesSet_SpeedOverDistance : public UTgGameplayCurvesSet_Simple
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGameplayCurvesSet_SpeedOverDistance");
		return ptr;
	}

};


// Class TgGame.TgGameplayCurvesSet_SpreadTendency
// 0x0000 (0x0098 - 0x0098)
class UTgGameplayCurvesSet_SpreadTendency : public UTgGameplayCurvesSet_Simple
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGameplayCurvesSet_SpreadTendency");
		return ptr;
	}

};


// Class TgGame.TgGameplayCurvesSet_StackDamageMultiplier
// 0x0000 (0x0098 - 0x0098)
class UTgGameplayCurvesSet_StackDamageMultiplier : public UTgGameplayCurvesSet_Simple
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGameplayCurvesSet_StackDamageMultiplier");
		return ptr;
	}

};


// Class TgGame.TgGameplayCurvesSet_ThreatLevelByRange
// 0x0000 (0x0098 - 0x0098)
class UTgGameplayCurvesSet_ThreatLevelByRange : public UTgGameplayCurvesSet_Simple
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGameplayCurvesSet_ThreatLevelByRange");
		return ptr;
	}

};


// Class TgGame.TgGameplayCurvesSet_WallRunVerticalMovement
// 0x0000 (0x0098 - 0x0098)
class UTgGameplayCurvesSet_WallRunVerticalMovement : public UTgGameplayCurvesSet_Simple
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGameplayCurvesSet_WallRunVerticalMovement");
		return ptr;
	}

};


// Class TgGame.TgHoldSpot
// 0x0008 (0x03AC - 0x03A4)
class ATgHoldSpot : public ATgDefensePoint
{
public:
	class AVehicle*                                    HoldVehicle;                                              // 0x03A4(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgHoldSpot");
		return ptr;
	}


	void FreePoint();
	class AActor* STATIC_GetMoveTarget();
};


// Class TgGame.TgIdol
// 0x001C (0x029C - 0x0280)
class ATgIdol : public AActor
{
public:
	int                                                r_nDefenderTaskForce;                                     // 0x0280(0x0004) (Net, Transient)
	class ATgPawn_Character*                           m_Holder;                                                 // 0x0284(0x0008) (Transient)
	class ATgRepInfo_Player*                           r_HolderPRI;                                              // 0x028C(0x0008) (Net, Transient)
	class ATgPawn_Character*                           m_OldHolder;                                              // 0x0294(0x0008) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgIdol");
		return ptr;
	}

};


// Class TgGame.TgInterpolatingCameraActor
// 0x001C (0x043C - 0x0420)
class ATgInterpolatingCameraActor : public ACameraActor
{
public:
	TArray<struct FInterpolatingCameraInfo>            m_CameraArray;                                            // 0x0420(0x0010) (Edit, NeedCtorLink)
	int                                                m_nCurrentCameraIndex;                                    // 0x0430(0x0004) (Edit)
	float                                              m_fCurrentInterpValue;                                    // 0x0434(0x0004)
	float                                              m_fTargetInterpValue;                                     // 0x0438(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInterpolatingCameraActor");
		return ptr;
	}


	void Tick(float DeltaTime);
	void GetCameraView(float DeltaTime, bool bOnlyFOV, struct FTPOV* OutPOV);
	void STATIC_GetActorEyesViewPoint(struct FVector* out_Location, struct FRotator* out_Rotation);
};


// Class TgGame.TgInventoryObject_Listen_ActiveDuringPassive
// 0x0000 (0x00D8 - 0x00D8)
class UTgInventoryObject_Listen_ActiveDuringPassive : public UTgInventoryObject_Listen_ActiveDuringAbility
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_ActiveDuringPassive");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_ActiveDuringPassive_WhileOutOfCombat
// 0x0000 (0x00DC - 0x00DC)
class UTgInventoryObject_Listen_ActiveDuringPassive_WhileOutOfCombat : public UTgInventoryObject_Listen_ActiveDuringAbility_WhileOutOfCombat
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_ActiveDuringPassive_WhileOutOfCombat");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_ActiveDuringPostFire
// 0x0000 (0x00D8 - 0x00D8)
class UTgInventoryObject_Listen_ActiveDuringPostFire : public UTgInventoryObject_Listen_ActiveDuringAbility
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_ActiveDuringPostFire");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_ActiveDuringPreFire
// 0x0000 (0x00D8 - 0x00D8)
class UTgInventoryObject_Listen_ActiveDuringPreFire : public UTgInventoryObject_Listen_ActiveDuringAbility
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_ActiveDuringPreFire");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_BlastShotHitSelfEffect
// 0x0000 (0x00DC - 0x00DC)
class UTgInventoryObject_Listen_BlastShotHitSelfEffect : public UTgInventoryObject_Listen_BlastShotHitEffect
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_BlastShotHitSelfEffect");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_CooldownDelayAbility1
// 0x0003 (0x00D8 - 0x00D5)
class UTgInventoryObject_Listen_CooldownDelayAbility1 : public UTgInventoryObject_Listen_CooldownDelayer
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x00D5(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_CooldownDelayAbility1");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_CooldownDelayAbility2
// 0x0003 (0x00D8 - 0x00D5)
class UTgInventoryObject_Listen_CooldownDelayAbility2 : public UTgInventoryObject_Listen_CooldownDelayer
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x00D5(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_CooldownDelayAbility2");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_CooldownDelayMovementAbility
// 0x0003 (0x00D8 - 0x00D5)
class UTgInventoryObject_Listen_CooldownDelayMovementAbility : public UTgInventoryObject_Listen_CooldownDelayer
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x00D5(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_CooldownDelayMovementAbility");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_DeployedWhileMounted
// 0x0000 (0x00D8 - 0x00D8)
class UTgInventoryObject_Listen_DeployedWhileMounted : public UTgInventoryObject_Listen_DeployedDuringAbility
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_DeployedWhileMounted");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_DeployOnAbilityEnd
// 0x0003 (0x00D4 - 0x00D1)
class UTgInventoryObject_Listen_DeployOnAbilityEnd : public UTgInventoryObject_Listen_DeployOnAbility
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x00D1(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_DeployOnAbilityEnd");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_DeployOnAbilityStart
// 0x0003 (0x00D4 - 0x00D1)
class UTgInventoryObject_Listen_DeployOnAbilityStart : public UTgInventoryObject_Listen_DeployOnAbility
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x00D1(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_DeployOnAbilityStart");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_HitWithDeviceAllyTarget
// 0x0000 (0x00D4 - 0x00D4)
class UTgInventoryObject_Listen_HitWithDeviceAllyTarget : public UTgInventoryObject_Listen_HitWithDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_HitWithDeviceAllyTarget");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_HitWithDeviceInhand
// 0x0000 (0x00D4 - 0x00D4)
class UTgInventoryObject_Listen_HitWithDeviceInhand : public UTgInventoryObject_Listen_HitWithDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_HitWithDeviceInhand");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_HitWithDeviceAsIfInhand
// 0x0000 (0x00D4 - 0x00D4)
class UTgInventoryObject_Listen_HitWithDeviceAsIfInhand : public UTgInventoryObject_Listen_HitWithDeviceInhand
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_HitWithDeviceAsIfInhand");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_HitWithDeviceInhandOnly
// 0x0000 (0x00D4 - 0x00D4)
class UTgInventoryObject_Listen_HitWithDeviceInhandOnly : public UTgInventoryObject_Listen_HitWithDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_HitWithDeviceInhandOnly");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_MountEnd
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_MountEnd : public UTgInventoryObject_Listen_AbilityEnd
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_MountEnd");
		return ptr;
	}

};


// Class TgGame.TgKismetTestActor
// 0x0040 (0x0310 - 0x02D0)
class ATgKismetTestActor : public ADynamicSMActor
{
public:
	int                                                m_nTestCount;                                             // 0x02D0(0x0004) (Edit)
	int                                                r_nCurrentTest;                                           // 0x02D4(0x0004) (Edit, Net)
	int                                                r_nPassCount;                                             // 0x02D8(0x0004) (Net)
	int                                                r_nFailCount;                                             // 0x02DC(0x0004) (Net)
	TArray<class UTexture2D*>                          c_aTextures;                                              // 0x02E0(0x0010) (Edit, NeedCtorLink)
	class USoundCue*                                   c_PassSound;                                              // 0x02F0(0x0008) (Edit)
	class USoundCue*                                   c_FailSound;                                              // 0x02F8(0x0008) (Edit)
	TArray<class AInterpActor*>                        c_aResultActors;                                          // 0x0300(0x0010) (Edit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgKismetTestActor");
		return ptr;
	}


	void STATIC_ReplicatedEvent(const struct FName& VarName);
	void StartTest(int Num);
	void FailTest(int Num);
	void STATIC_PassTest(int Num);
	void PostBeginPlay();
	void SetTestColor(int Num, const struct FLinearColor& Col);
	class APlayerController* GetLocalPlayer();
	void STATIC_OnTestResult(class UTgSeqAct_TestResult* Action);
};


// Class TgGame.TgSeqAct_TestResult
// 0x0000 (0x0108 - 0x0108)
class UTgSeqAct_TestResult : public USequenceAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_TestResult");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_LobbyCameraSetActive
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_LobbyCameraSetActive : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_LobbyCameraSetActive");
		return ptr;
	}

};


// Class TgGame.TgMenuTransitionActor
// 0x0018 (0x0298 - 0x0280)
class ATgMenuTransitionActor : public AActor
{
public:
	class UParticleSystemComponent*                    m_IntroPSC;                                               // 0x0280(0x0008) (ExportObject, Component, EditInline)
	class UParticleSystemComponent*                    m_LoopPSC;                                                // 0x0288(0x0008) (ExportObject, Component, EditInline)
	class UParticleSystemComponent*                    m_OutroPSC;                                               // 0x0290(0x0008) (ExportObject, Component, EditInline)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgMenuTransitionActor");
		return ptr;
	}


	void StopLoop();
	void PlayLoop();
	void PlayOutro();
	void PlayIntro();
};


// Class TgGame.TgMidnightFogVolumeDensityInfo
// 0x0020 (0x02B4 - 0x0294)
class ATgMidnightFogVolumeDensityInfo : public AFogVolumeSphericalDensityInfo
{
public:
	unsigned long                                      m_bFogOn : 1;                                             // 0x0294(0x0004)
	unsigned long                                      m_bFogUpdateNeeded : 1;                                   // 0x0294(0x0004)
	unsigned long                                      m_bIsFadingOut : 1;                                       // 0x0294(0x0004)
	float                                              m_fCurrentStartDistance;                                  // 0x0298(0x0004)
	float                                              m_fFadeOutDuration;                                       // 0x029C(0x0004)
	float                                              m_fFadeOutTimer;                                          // 0x02A0(0x0004)
	float                                              m_fTargetMaxDensity;                                      // 0x02A4(0x0004)
	float                                              m_fDestroyTimer;                                          // 0x02A8(0x0004)
	class UFogVolumeSphericalDensityComponent*         SphericalDensityComponent;                                // 0x02AC(0x0008) (ExportObject, Component, EditInline)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgMidnightFogVolumeDensityInfo");
		return ptr;
	}


	void STATIC_SetAlpha(float fNewAlpha);
	void Tick(float DeltaTime);
	void FadeOut(float fFadeTime);
	void SetStartDistance(float fNewStartDistance);
	void STATIC_SetOrigin(const struct FVector& vOrigin);
	void ToggleFog(bool bOn);
	void PostBeginPlay();
};


// Class TgGame.TgMobileAmbientSound
// 0x0000 (0x0294 - 0x0294)
class ATgMobileAmbientSound : public AAkAmbientSound
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgMobileAmbientSound");
		return ptr;
	}

};


// Class TgGame.TgMuzzleFlash_Bow
// 0x0000 (0x0274 - 0x0274)
class UTgMuzzleFlash_Bow : public UTgMuzzleFlash
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgMuzzleFlash_Bow");
		return ptr;
	}

};


// Class TgGame.TgMuzzleFlash_IceStaff
// 0x0000 (0x0274 - 0x0274)
class UTgMuzzleFlash_IceStaff : public UTgMuzzleFlash
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgMuzzleFlash_IceStaff");
		return ptr;
	}

};


// Class TgGame.TgMuzzleFlash_Lance
// 0x0000 (0x0274 - 0x0274)
class UTgMuzzleFlash_Lance : public UTgMuzzleFlash
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgMuzzleFlash_Lance");
		return ptr;
	}

};


// Class TgGame.TgMuzzleFlash_Orb
// 0x0000 (0x0274 - 0x0274)
class UTgMuzzleFlash_Orb : public UTgMuzzleFlash
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgMuzzleFlash_Orb");
		return ptr;
	}

};


// Class TgGame.TgMuzzleFlash_PotionLauncher
// 0x0000 (0x0274 - 0x0274)
class UTgMuzzleFlash_PotionLauncher : public UTgMuzzleFlash
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgMuzzleFlash_PotionLauncher");
		return ptr;
	}

};


// Class TgGame.TgMuzzleFlash_SkyeInHand
// 0x0000 (0x0274 - 0x0274)
class UTgMuzzleFlash_SkyeInHand : public UTgMuzzleFlash
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgMuzzleFlash_SkyeInHand");
		return ptr;
	}

};


// Class TgGame.TgMuzzleFlash_Sniper
// 0x0000 (0x0274 - 0x0274)
class UTgMuzzleFlash_Sniper : public UTgMuzzleFlash
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgMuzzleFlash_Sniper");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_ParentAnimComponent
// 0x0004 (0x010C - 0x0108)
class UTgSeqAct_ParentAnimComponent : public USequenceAction
{
public:
	unsigned long                                      bDetach : 1;                                              // 0x0108(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_ParentAnimComponent");
		return ptr;
	}

};


// Class TgGame.TgPawn_Turret_DefaultCone
// 0x0000 (0x2EF4 - 0x2EF4)
class ATgPawn_Turret_DefaultCone : public ATgPawn_Turret
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Turret_DefaultCone");
		return ptr;
	}

};


// Class TgGame.TgPhysAnimTestActor
// 0x00A8 (0x0328 - 0x0280)
class ATgPhysAnimTestActor : public AActor
{
public:
	TArray<struct FName>                               LowerBoneNames;                                           // 0x0280(0x0010) (Edit, NeedCtorLink)
	TArray<struct FName>                               LinearBoneSpringNames;                                    // 0x0290(0x0010) (Edit, NeedCtorLink)
	TArray<struct FName>                               AngularBoneSpringNames;                                   // 0x02A0(0x0010) (Edit, NeedCtorLink)
	class USkeletalMeshComponent*                      SkeletalMeshComponent;                                    // 0x02B0(0x0008) (Edit, ExportObject, Component, EditInline)
	TEnumAsByte<EPATAState>                            CurrentState;                                             // 0x02B8(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x02B9(0x0003) MISSED OFFSET
	unsigned long                                      bBlendToGetUp : 1;                                        // 0x02BC(0x0004)
	unsigned long                                      bBlendingBack : 1;                                        // 0x02BC(0x0004)
	unsigned long                                      bRampingDownMotors : 1;                                   // 0x02BC(0x0004)
	unsigned long                                      bNextPokeKnocksDown : 1;                                  // 0x02BC(0x0004)
	float                                              GetUpBlendStartTime;                                      // 0x02C0(0x0004)
	float                                              GetUpBlendTime;                                           // 0x02C4(0x0004) (Edit)
	float                                              GetUpToIdleTime;                                          // 0x02C8(0x0004) (Edit)
	float                                              ActorOriginHeight;                                        // 0x02CC(0x0004) (Edit)
	float                                              PokePauseTime;                                            // 0x02D0(0x0004) (Edit)
	float                                              PokeBlendTime;                                            // 0x02D4(0x0004) (Edit)
	float                                              BlendBackStartTime;                                       // 0x02D8(0x0004)
	float                                              MotorDownStartTime;                                       // 0x02DC(0x0004)
	float                                              MotorDownTime;                                            // 0x02E0(0x0004) (Edit)
	float                                              MotorDownAnimTime;                                        // 0x02E4(0x0004) (Edit)
	float                                              BlendStaggerAnimTime;                                     // 0x02E8(0x0004) (Edit)
	float                                              StaggerSpeedAdj;                                          // 0x02EC(0x0004) (Edit)
	float                                              StaggerVel;                                               // 0x02F0(0x0004) (Edit)
	struct FVector                                     MoveDir;                                                  // 0x02F4(0x000C)
	float                                              AngularHipDriveScale;                                     // 0x0300(0x0004) (Edit)
	float                                              StaggerMuscleScale;                                       // 0x0304(0x0004) (Edit)
	class UAnimNodeBlend*                              BlendNode;                                                // 0x0308(0x0008)
	class UAnimNodeSequence*                           GetUpNode;                                                // 0x0310(0x0008)
	class UAnimNodeSequence*                           RunNode;                                                  // 0x0318(0x0008)
	class URB_BodyInstance*                            HipBody;                                                  // 0x0320(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPhysAnimTestActor");
		return ptr;
	}


	void STATIC_OnAnimEnd(class UAnimNodeSequence* SeqNode, float PlayedTime, float ExcessTime);
	void Tick(float DeltaSeconds);
	void SetAllMotorsAngularDriveStrength(float InAngularSpringStrength, float InAngularDampingStrength, float InAngularForceLimitStrength, class USkeletalMeshComponent* SkelMeshComp);
	void RecoverFromRagdoll();
	void SetBoneSprings(bool bEnabled);
	bool STATIC_IsAngularBoneSpringName(const struct FName& InName);
	bool STATIC_IsLinearBoneSpringName(const struct FName& InName);
	void SetLowerFixed();
	void DetachAttachments();
	bool STATIC_IsLowerBodyName(const struct FName& InName);
	void SetBodiesFixed(bool InFixed);
	void EnableMotors(bool InEnabled);
	void SetPATAState(TEnumAsByte<EPATAState> NewState);
	void EndGrab();
	bool PreGrab();
	bool PrePokeActor(const struct FVector& PokeDir);
	void BoneImpulse(const struct FVector& Impulse, const struct FName& BoneName);
	void PostBeginPlay();
};


// Class TgGame.TgPickupFactory_Item
// 0x001C (0x03F0 - 0x03D4)
class ATgPickupFactory_Item : public ATgPickupFactory
{
public:
	class USoundCue*                                   PickupSound;                                              // 0x03D4(0x0008)
	struct FString                                     PickupMessage;                                            // 0x03DC(0x0010) (Const, Localized, NeedCtorLink)
	float                                              RespawnTime;                                              // 0x03EC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPickupFactory_Item");
		return ptr;
	}


	float BotDesireability(class APawn* P);
	float GetRespawnTime();
	void STATIC_SetRespawn();
	void STATIC_SpawnCopyFor(class APawn* Recipient);
	struct FString GetLocalString(int Switch, class APlayerReplicationInfo* RelatedPRI_2, class APlayerReplicationInfo* RelatedPRI_3);
	void InitializePickup();
};


// Class TgGame.TgProj_BoobyTrap
// 0x0000 (0x056C - 0x056C)
class ATgProj_BoobyTrap : public ATgProj_FreeGrenade
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_BoobyTrap");
		return ptr;
	}


	class AActor* CalculateHitActor(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal, struct FTraceHitInfo* HitInfo);
};


// Class TgGame.TgProj_DivineWrath
// 0x0000 (0x0524 - 0x0524)
class ATgProj_DivineWrath : public ATgProj_ColumnBeam
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_DivineWrath");
		return ptr;
	}


	void RangeReached();
};


// Class TgGame.TgProj_DreadSerpent
// 0x0000 (0x051C - 0x051C)
class ATgProj_DreadSerpent : public ATgProj_Simulated
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_DreadSerpent");
		return ptr;
	}

};


// Class TgGame.TgProj_Enlightenment
// 0x0000 (0x051C - 0x051C)
class ATgProj_Enlightenment : public ATgProj_Simulated
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Enlightenment");
		return ptr;
	}

};


// Class TgGame.TgProj_EvilMojo
// 0x0000 (0x056C - 0x056C)
class ATgProj_EvilMojo : public ATgProj_FreeGrenade
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_EvilMojo");
		return ptr;
	}


	bool STATIC_CheckTeamPassThrough(class AActor* Other);
};


// Class TgGame.TgProj_ExplodeAtMaxRange
// 0x0000 (0x051C - 0x051C)
class ATgProj_ExplodeAtMaxRange : public ATgProj_Simulated
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_ExplodeAtMaxRange");
		return ptr;
	}

};


// Class TgGame.TgProj_ExplosiveFlask
// 0x0000 (0x056C - 0x056C)
class ATgProj_ExplosiveFlask : public ATgProj_FreeGrenade
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_ExplosiveFlask");
		return ptr;
	}

};


// Class TgGame.TgProj_Fireball
// 0x0000 (0x051C - 0x051C)
class ATgProj_Fireball : public ATgProj_Simulated
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Fireball");
		return ptr;
	}

};


// Class TgGame.TgProj_FlakRocket
// 0x0000 (0x051C - 0x051C)
class ATgProj_FlakRocket : public ATgProj_Simulated
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_FlakRocket");
		return ptr;
	}


	bool ShouldExplodeAtMaxRange();
	struct FName STATIC_GetHitWallFxGroup();
	struct FName STATIC_GetHitTargetFxGroup();
};


// Class TgGame.TgProj_FragGrenade
// 0x0000 (0x056C - 0x056C)
class ATgProj_FragGrenade : public ATgProj_FreeGrenade
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_FragGrenade");
		return ptr;
	}


	void PlayBounceSound();
	void STATIC_ApplyBounce(const struct FVector& HitLocation, const struct FVector& HitNormal, class AActor* Wall, class UPrimitiveComponent* WallComp);
};


// Class TgGame.TgProj_GaeBolg
// 0x0000 (0x051C - 0x051C)
class ATgProj_GaeBolg : public ATgProj_Simulated
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_GaeBolg");
		return ptr;
	}

};


// Class TgGame.TgProj_Gravity
// 0x0000 (0x051C - 0x051C)
class ATgProj_Gravity : public ATgProj_Simulated
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Gravity");
		return ptr;
	}

};


// Class TgGame.TgProj_IceStorm
// 0x0004 (0x0520 - 0x051C)
class ATgProj_IceStorm : public ATgProj_Simulated
{
public:
	unsigned long                                      m_bStopped : 1;                                           // 0x051C(0x0004)
	unsigned long                                      m_bCheckLOSForHit : 1;                                    // 0x051C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_IceStorm");
		return ptr;
	}


	float STATIC_GetRemainingTime();
	void STATIC_ExplodeOnTarget(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void Tick(float DeltaSeconds);
	void STATIC_HandleTick();
	void CompleteInitialization();
};


// Class TgGame.TgProj_KnifeLongRange
// 0x0000 (0x051C - 0x051C)
class ATgProj_KnifeLongRange : public ATgProj_Simulated
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_KnifeLongRange");
		return ptr;
	}

};


// Class TgGame.TgProj_KnifeShortRange
// 0x0000 (0x056C - 0x056C)
class ATgProj_KnifeShortRange : public ATgProj_FreeGrenade
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_KnifeShortRange");
		return ptr;
	}

};


// Class TgGame.TgProj_LanepusherCannon
// 0x0000 (0x051C - 0x051C)
class ATgProj_LanepusherCannon : public ATgProj_Simulated
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_LanepusherCannon");
		return ptr;
	}


	void Tick(float fDeltaTime);
	struct FVector STATIC_GetSeekLocation();
};


// Class TgGame.TgProj_PotionLauncherProjectile
// 0x0000 (0x056C - 0x056C)
class ATgProj_PotionLauncherProjectile : public ATgProj_FreeGrenade
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_PotionLauncherProjectile");
		return ptr;
	}


	void PlayAdditionalHitFX(bool bSuccessfulHit, const struct FVector& FXLocation, const struct FVector& HitNormal, const struct FVector& ProjDir, TArray<struct FParticleSysParam>* ExplosionParams);
};


// Class TgGame.TgProj_PotionLauncherProjectile_HighFireAngleTest
// 0x0000 (0x056C - 0x056C)
class ATgProj_PotionLauncherProjectile_HighFireAngleTest : public ATgProj_PotionLauncherProjectile
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_PotionLauncherProjectile_HighFireAngleTest");
		return ptr;
	}

};


// Class TgGame.TgProj_SmokeScreen
// 0x0000 (0x056C - 0x056C)
class ATgProj_SmokeScreen : public ATgProj_FreeGrenade
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_SmokeScreen");
		return ptr;
	}

};


// Class TgGame.TgProj_SoulOrb
// 0x0000 (0x051C - 0x051C)
class ATgProj_SoulOrb : public ATgProj_Fireball
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_SoulOrb");
		return ptr;
	}

};


// Class TgGame.TgProj_Spinfusor
// 0x0000 (0x051C - 0x051C)
class ATgProj_Spinfusor : public ATgProj_Simulated
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Spinfusor");
		return ptr;
	}


	void SpawnFlightEffects();
};


// Class TgGame.TgProj_TimeBomb
// 0x0000 (0x056C - 0x056C)
class ATgProj_TimeBomb : public ATgProj_FreeGrenade
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_TimeBomb");
		return ptr;
	}

};


// Class TgGame.TgProj_Tracer
// 0x0008 (0x0458 - 0x0450)
class ATgProj_Tracer : public ATgProjectile
{
public:
	class UTgParticleSystemComponent*                  PSC;                                                      // 0x0450(0x0008) (ExportObject, Component, EditInline)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Tracer");
		return ptr;
	}


	void STATIC_ShutDown();
	bool CheckProjectileRange(const struct FVector& vLocOverride);
	void Tick(float DeltaSeconds);
	void STATIC_InitTracer(class UTgSpecialFx* Fx, bool bIsEnemy, bool bConfused);
};


// Class TgGame.TgProj_VenomousGourd
// 0x0000 (0x056C - 0x056C)
class ATgProj_VenomousGourd : public ATgProj_FreeGrenade
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_VenomousGourd");
		return ptr;
	}

};


// Class TgGame.TgProj_Vine
// 0x0008 (0x0524 - 0x051C)
class ATgProj_Vine : public ATgProj_Simulated
{
public:
	class UTgDeviceForm_Vine*                          m_VineForm;                                               // 0x051C(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Vine");
		return ptr;
	}


	void StartPull(class AActor* Target, const struct FVector& HitLocation);
	void STATIC_Fizzle();
	void STATIC_ExplodeOnTarget(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void SpawnFlightEffects();
};


// Class TgGame.TgSeqEvent_ControlPointOwnershipPercent
// 0x0008 (0x0130 - 0x0128)
class UTgSeqEvent_ControlPointOwnershipPercent : public USequenceEvent
{
public:
	float                                              OwnershipPercent;                                         // 0x0128(0x0004) (Edit)
	int                                                PointIndex;                                               // 0x012C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_ControlPointOwnershipPercent");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_TaskForceScoreUpdated
// 0x0008 (0x0130 - 0x0128)
class UTgSeqEvent_TaskForceScoreUpdated : public USequenceEvent
{
public:
	int                                                DefenderTaskForce;                                        // 0x0128(0x0004) (Edit)
	int                                                currentScore;                                             // 0x012C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_TaskForceScoreUpdated");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_BeaconEntranceSetActive
// 0x0004 (0x010C - 0x0108)
class UTgSeqAct_BeaconEntranceSetActive : public USequenceAction
{
public:
	unsigned long                                      m_bSetActive : 1;                                         // 0x0108(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_BeaconEntranceSetActive");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_BeaconExitSetRespawn
// 0x000C (0x0114 - 0x0108)
class UTgSeqAct_BeaconExitSetRespawn : public USequenceAction
{
public:
	class AActor*                                      m_RespawnPoint;                                           // 0x0108(0x0008)
	unsigned long                                      m_bRespawnImmediately : 1;                                // 0x0110(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_BeaconExitSetRespawn");
		return ptr;
	}

};


// Class TgGame.TgRoyaleCatapult
// 0x000C (0x028C - 0x0280)
class ATgRoyaleCatapult : public AActor
{
public:
	class UStaticMeshComponent*                        SMC;                                                      // 0x0280(0x0008) (ExportObject, Component, EditInline)
	int                                                m_nCatapultGroupID;                                       // 0x0288(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgRoyaleCatapult");
		return ptr;
	}

};


// Class TgGame.TgRoyaleCatapultGroup
// 0x0004 (0x0284 - 0x0280)
class ATgRoyaleCatapultGroup : public AActor
{
public:
	int                                                m_nCatapultGroupID;                                       // 0x0280(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgRoyaleCatapultGroup");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_AddAnimSets
// 0x0024 (0x012C - 0x0108)
class UTgSeqAct_AddAnimSets : public USequenceAction
{
public:
	TArray<class UAnimSet*>                            m_MaleAnimSets;                                           // 0x0108(0x0010) (Edit, NeedCtorLink)
	TArray<class UAnimSet*>                            m_FemaleAnimSets;                                         // 0x0118(0x0010) (Edit, NeedCtorLink)
	unsigned long                                      m_bAppendToExisting : 1;                                  // 0x0128(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_AddAnimSets");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_AIStartFireAt
// 0x0001 (0x0109 - 0x0108)
class UTgSeqAct_AIStartFireAt : public USequenceAction
{
public:
	unsigned char                                      ForcedFireMode;                                           // 0x0108(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_AIStartFireAt");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_AIStopFire
// 0x0000 (0x0108 - 0x0108)
class UTgSeqAct_AIStopFire : public USequenceAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_AIStopFire");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_ChangeScale
// 0x0014 (0x011C - 0x0108)
class UTgSeqAct_ChangeScale : public USequenceAction
{
public:
	float                                              TargetScale;                                              // 0x0108(0x0004) (Edit)
	struct FVector                                     TargetScale3D;                                            // 0x010C(0x000C) (Edit)
	float                                              TransitionTime;                                           // 0x0118(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_ChangeScale");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_GetCharClass
// 0x0000 (0x0108 - 0x0108)
class UTgSeqAct_GetCharClass : public USequenceAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_GetCharClass");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_HackBot
// 0x0008 (0x0110 - 0x0108)
class UTgSeqAct_HackBot : public USequenceAction
{
public:
	class AActor*                                      m_ControlPawn;                                            // 0x0108(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_HackBot");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_LaunchHomeInstance
// 0x0000 (0x0108 - 0x0108)
class UTgSeqAct_LaunchHomeInstance : public USequenceAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_LaunchHomeInstance");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_MarkSpawnReturn
// 0x0008 (0x0110 - 0x0108)
class UTgSeqAct_MarkSpawnReturn : public USequenceAction
{
public:
	class ATeleporter*                                 m_Teleporter;                                             // 0x0108(0x0008) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_MarkSpawnReturn");
		return ptr;
	}


	void STATIC_Activated();
};


// Class TgGame.TgSeqAct_PauseSetupTimer
// 0x0008 (0x0110 - 0x0108)
class UTgSeqAct_PauseSetupTimer : public USequenceAction
{
public:
	unsigned long                                      PauseImmediately : 1;                                     // 0x0108(0x0004) (Edit)
	float                                              PauseAtTimeRemaining;                                     // 0x010C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_PauseSetupTimer");
		return ptr;
	}


	void STATIC_Activated();
};


// Class TgGame.TgSeqAct_PlayAnnouncement
// 0x0010 (0x0118 - 0x0108)
class UTgSeqAct_PlayAnnouncement : public USequenceAction
{
public:
	unsigned long                                      bPlayImmediately : 1;                                     // 0x0108(0x0004) (Edit)
	unsigned long                                      bFlushOthers : 1;                                         // 0x0108(0x0004) (Edit)
	int                                                SoundIndex;                                               // 0x010C(0x0004) (Edit)
	class USoundCue*                                   OptionalCue;                                              // 0x0110(0x0008) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_PlayAnnouncement");
		return ptr;
	}


	int STATIC_GetObjClassVersion();
	void STATIC_Activated();
};


// Class TgGame.TgSeqAct_PlayCameraAnim
// 0x0018 (0x0120 - 0x0108)
class UTgSeqAct_PlayCameraAnim : public USequenceAction
{
public:
	class UCameraAnim*                                 AnimToPlay;                                               // 0x0108(0x0008) (Edit)
	float                                              BlendInTime;                                              // 0x0110(0x0004) (Edit)
	float                                              BlendOutTime;                                             // 0x0114(0x0004) (Edit)
	float                                              Rate;                                                     // 0x0118(0x0004) (Edit)
	float                                              IntensityScale;                                           // 0x011C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_PlayCameraAnim");
		return ptr;
	}


	int STATIC_GetObjClassVersion();
};


// Class TgGame.TgSeqAct_SelectBestSpawnPoint
// 0x0018 (0x0120 - 0x0108)
class UTgSeqAct_SelectBestSpawnPoint : public USequenceAction
{
public:
	TArray<class UObject*>                             Points;                                                   // 0x0108(0x0010) (Edit, NeedCtorLink)
	class AActor*                                      PlayerReceived;                                           // 0x0118(0x0008) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_SelectBestSpawnPoint");
		return ptr;
	}


	void STATIC_Activated();
};


// Class TgGame.TgSeqAct_SetSkelPosture
// 0x0001 (0x0109 - 0x0108)
class UTgSeqAct_SetSkelPosture : public USequenceAction
{
public:
	TEnumAsByte<ETG_POSTURE>                           m_Posture;                                                // 0x0108(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_SetSkelPosture");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_SetUltimateEnergy
// 0x0004 (0x010C - 0x0108)
class UTgSeqAct_SetUltimateEnergy : public USequenceAction
{
public:
	float                                              fChargePercent;                                           // 0x0108(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_SetUltimateEnergy");
		return ptr;
	}


	void STATIC_Activated();
};


// Class TgGame.TgSeqAct_ShowGameTip
// 0x000C (0x0114 - 0x0108)
class UTgSeqAct_ShowGameTip : public USequenceAction
{
public:
	int                                                GameTipId;                                                // 0x0108(0x0004) (Edit)
	class ATgPlayerController*                         TargetPlayer;                                             // 0x010C(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_ShowGameTip");
		return ptr;
	}


	void STATIC_Activated();
};


// Class TgGame.TgSeqAct_SpawnProjectile
// 0x0008 (0x0110 - 0x0108)
class UTgSeqAct_SpawnProjectile : public USequenceAction
{
public:
	class UClass*                                      ProjectileClass;                                          // 0x0108(0x0008) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_SpawnProjectile");
		return ptr;
	}


	void STATIC_Activated();
};


// Class TgGame.TgSeqAct_TriggerInterpActor
// 0x0010 (0x0118 - 0x0108)
class UTgSeqAct_TriggerInterpActor : public USequenceAction
{
public:
	struct FString                                     m_sStateName;                                             // 0x0108(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_TriggerInterpActor");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_UnpauseSetupTimer
// 0x0000 (0x0108 - 0x0108)
class UTgSeqAct_UnpauseSetupTimer : public USequenceAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_UnpauseSetupTimer");
		return ptr;
	}


	void STATIC_Activated();
};


// Class TgGame.TgSeqEvent_CaptureAndPayloadCapturePointVictory
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_CaptureAndPayloadCapturePointVictory : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_CaptureAndPayloadCapturePointVictory");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_CaptureAndPayloadRoundBegin
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_CaptureAndPayloadRoundBegin : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_CaptureAndPayloadRoundBegin");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_CaptureAndPayloadRoundEnd
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_CaptureAndPayloadRoundEnd : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_CaptureAndPayloadRoundEnd");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_CaptureAndPayloadWinTF1
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_CaptureAndPayloadWinTF1 : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_CaptureAndPayloadWinTF1");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_CaptureAndPayloadWinTF2
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_CaptureAndPayloadWinTF2 : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_CaptureAndPayloadWinTF2");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_PayloadAttackersWin
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_PayloadAttackersWin : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_PayloadAttackersWin");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_PayloadBeginTF1
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_PayloadBeginTF1 : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_PayloadBeginTF1");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_PayloadBeginTF2
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_PayloadBeginTF2 : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_PayloadBeginTF2");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_PayloadCP1Reached
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_PayloadCP1Reached : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_PayloadCP1Reached");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_PayloadCP2Reached
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_PayloadCP2Reached : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_PayloadCP2Reached");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_PayloadDefendersWin
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_PayloadDefendersWin : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_PayloadDefendersWin");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_PayloadEndTF1
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_PayloadEndTF1 : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_PayloadEndTF1");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_PayloadEndTF2
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_PayloadEndTF2 : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_PayloadEndTF2");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_SetupTimeEnded
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_SetupTimeEnded : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_SetupTimeEnded");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_SiegePush
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_SiegePush : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_SiegePush");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_SpawnGateActivate
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_SpawnGateActivate : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_SpawnGateActivate");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_SpawnGateDeactivate
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_SpawnGateDeactivate : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_SpawnGateDeactivate");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_SpawnGateDeactivate_Attackers
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_SpawnGateDeactivate_Attackers : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_SpawnGateDeactivate_Attackers");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_SpawnGateDeactivate_Defenders
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_SpawnGateDeactivate_Defenders : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_SpawnGateDeactivate_Defenders");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_SurvivalGameEnd
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_SurvivalGameEnd : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_SurvivalGameEnd");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_Tutorial
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_Tutorial : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_Tutorial");
		return ptr;
	}


	bool TriggerGlobal(class AActor* InInstigator, TEnumAsByte<EPaladinsTutorialEvent> TutEvent);
};


// Class TgGame.TgSiegePushActor
// 0x0034 (0x02B4 - 0x0280)
class ATgSiegePushActor : public AActor
{
public:
	class ATgCollisionProxy_Cylinder*                  s_CollisionProxy;                                         // 0x0280(0x0008)
	float                                              m_fCollisionProxyRadius;                                  // 0x0288(0x0004) (Edit, Const)
	float                                              m_fCollisionProxyHeight;                                  // 0x028C(0x0004) (Edit, Const)
	class USkeletalMeshComponent*                      m_SkelMesh;                                               // 0x0290(0x0008) (Edit, ExportObject, Component, EditInline)
	class UStaticMeshComponent*                        m_RadiusMesh;                                             // 0x0298(0x0008) (Edit, ExportObject, Component, EditInline)
	int                                                m_nTF1Count;                                              // 0x02A0(0x0004) (Transient)
	int                                                m_nTF2Count;                                              // 0x02A4(0x0004) (Transient)
	int                                                m_nDefenderTaskForce;                                     // 0x02A8(0x0004) (Edit)
	TEnumAsByte<EPushState>                            m_CurrentPushState;                                       // 0x02AC(0x0001) (Transient)
	unsigned char                                      UnknownData00[0x3];                                       // 0x02AD(0x0003) MISSED OFFSET
	float                                              m_fPendingReverseTime;                                    // 0x02B0(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSiegePushActor");
		return ptr;
	}


	void SetCurrentPushState(TEnumAsByte<EPushState> NewPushState);
	void SetReversePushState();
	void STATIC_NearbyPawnsUpdated();
	void STATIC_CollisionProxyOnUnTouch(class AActor* Other);
	void STATIC_CollisionProxyOnTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void PostBeginPlay();
};


// Class TgGame.TgSkeletalMeshActor_DestructibleTowerChunk
// 0x0008 (0x0334 - 0x032C)
class ATgSkeletalMeshActor_DestructibleTowerChunk : public ATgSkeletalMeshActorSpawnable
{
public:
	class UTgSkeletalMeshComponent*                    TgSkeletalMeshComp;                                       // 0x032C(0x0008) (ExportObject, Component, EditInline)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkeletalMeshActor_DestructibleTowerChunk");
		return ptr;
	}


	bool STATIC_PlayParticleEffect(class UAnimNotify_PlayParticleEffect* AnimNotifyData);
};


// Class TgGame.TgSkeletalMeshComponent_WeaponFirstPerson
// 0x0000 (0x088C - 0x088C)
class UTgSkeletalMeshComponent_WeaponFirstPerson : public UTgSkeletalMeshComponent_Weapon
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkeletalMeshComponent_WeaponFirstPerson");
		return ptr;
	}

};


// Class TgGame.TgSkeletalMeshComponent_WeaponFirstPersonLance
// 0x0000 (0x088C - 0x088C)
class UTgSkeletalMeshComponent_WeaponFirstPersonLance : public UTgSkeletalMeshComponent_WeaponFirstPerson
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkeletalMeshComponent_WeaponFirstPersonLance");
		return ptr;
	}

};


// Class TgGame.TgSoundInsulationVolume
// 0x0000 (0x0320 - 0x0320)
class ATgSoundInsulationVolume : public AReverbVolume
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSoundInsulationVolume");
		return ptr;
	}

};


// Class TgGame.TgSplineActor_Payload
// 0x0008 (0x02F8 - 0x02F0)
class ATgSplineActor_Payload : public ATgSplineActor
{
public:
	unsigned long                                      m_bReached : 1;                                           // 0x02F0(0x0004)
	float                                              m_fSecondsToAdd;                                          // 0x02F4(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSplineActor_Payload");
		return ptr;
	}

};


// Class TgGame.TgStaticMeshActorGrass
// 0x0014 (0x02B8 - 0x02A4)
class ATgStaticMeshActorGrass : public AStaticMeshActor
{
public:
	float                                              m_fTargetScale;                                           // 0x02A4(0x0004)
	struct FVector                                     m_TargetScale3D;                                          // 0x02A8(0x000C)
	float                                              m_fScaleTransitionTime;                                   // 0x02B4(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgStaticMeshActorGrass");
		return ptr;
	}


	void Tick(float DeltaTime);
	void STATIC_OnChangeScale(class UTgSeqAct_ChangeScale* SeqAct_ChangeScale);
};


// Class TgGame.TgTimeDilationVolume
// 0x0028 (0x033C - 0x0314)
class ATgTimeDilationVolume : public APhysicsVolume
{
public:
	float                                              m_fTimeMultiplier;                                        // 0x0314(0x0004)
	unsigned long                                      m_bAffectInstigator : 1;                                  // 0x0318(0x0004)
	TArray<class AActor*>                              m_AffectedActors;                                         // 0x031C(0x0010) (NeedCtorLink)
	TArray<class APawn*>                               m_AffectedPawns;                                          // 0x032C(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgTimeDilationVolume");
		return ptr;
	}


	void Destroyed();
	void STATIC_PawnLeavingVolume(class APawn* Other);
	void STATIC_PawnEnteredVolume(class APawn* Other);
	void STATIC_ActorLeavingVolume(class AActor* Other);
	void STATIC_ActorEnteredVolume(class AActor* Other);
	void PostBeginPlay();
};


// Class TgGame.TgTutorialInfo
// 0x00CC (0x034C - 0x0280)
class ATgTutorialInfo : public AActor
{
public:
	float                                              fButtonHoldTime;                                          // 0x0280(0x0004) (Edit)
	float                                              fVolumeStandTime;                                         // 0x0284(0x0004) (Edit)
	float                                              fBotRespawnTime;                                          // 0x0288(0x0004) (Edit)
	float                                              fBotTargetsKilledWaitTime;                                // 0x028C(0x0004) (Edit)
	float                                              fPlayerTeamCaptureMultiplier;                             // 0x0290(0x0004) (Edit)
	float                                              fRepeatInstructionTime;                                   // 0x0294(0x0004) (Edit)
	float                                              fExtendedRepeatInstructionTime;                           // 0x0298(0x0004) (Edit)
	float                                              fIntroExtensionTime;                                      // 0x029C(0x0004) (Edit)
	float                                              fBotDelayTravelToMovementTime;                            // 0x02A0(0x0004) (Edit)
	float                                              fBotDelayTravelToUltRangeTime;                            // 0x02A4(0x0004) (Edit)
	float                                              fPayloadContestPercent;                                   // 0x02A8(0x0004) (Edit)
	float                                              fLanePusherGroundSpeed;                                   // 0x02AC(0x0004) (Edit)
	float                                              fEnergyChargeMultiplier;                                  // 0x02B0(0x0004) (Edit)
	class ATgTutorialVolume*                           ApproachHelperArea;                                       // 0x02B4(0x0008) (Edit)
	class ATgTutorialVolume*                           AutoShootingRangeStandingTargetArea;                      // 0x02BC(0x0008) (Edit)
	class ATgTutorialVolume*                           UltimateShootingRangeStandingTargetArea;                  // 0x02C4(0x0008) (Edit)
	class ATgTutorialVolume*                           JumpLowerArea;                                            // 0x02CC(0x0008) (Edit)
	class ATgTutorialVolume*                           JumpUpperArea;                                            // 0x02D4(0x0008) (Edit)
	class ATgBotFactory*                               HelperBotFactory;                                         // 0x02DC(0x0008) (Edit)
	class ATgBotFactory*                               AutoBotFactory;                                           // 0x02E4(0x0008) (Edit)
	class ATgBotFactory*                               MultipleAutoBotFactory;                                   // 0x02EC(0x0008) (Edit)
	class ATgBotFactory*                               BattleAbilityBotFactory;                                  // 0x02F4(0x0008) (Edit)
	class ATgBotFactory*                               AltAbilityBotFactory;                                     // 0x02FC(0x0008) (Edit)
	class ATgBotFactory*                               UltimateChargeBotFactory;                                 // 0x0304(0x0008) (Edit)
	class ATgBotFactory*                               UltimateAbilityBotFactory;                                // 0x030C(0x0008) (Edit)
	class ATgBotFactory*                               ContestCapturePointBotFactory;                            // 0x0314(0x0008) (Edit)
	class ATgBotFactory*                               ContestPayloadBotsFactory;                                // 0x031C(0x0008) (Edit)
	class AActor*                                      HelperMoveTargetAutoRange;                                // 0x0324(0x0008) (Edit)
	class AActor*                                      HelperMoveTargetMovementAbility;                          // 0x032C(0x0008) (Edit)
	class AActor*                                      HelperMoveTargetUltRange;                                 // 0x0334(0x0008) (Edit)
	class AActor*                                      EndGameFocus;                                             // 0x033C(0x0008) (Edit)
	class ATgAIController_Behavior*                    HelperBotController;                                      // 0x0344(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgTutorialInfo");
		return ptr;
	}


	void TeleportHelperToActor(class AActor* Destination);
	void STATIC_MoveHelperToActor(class AActor* Destination);
	bool STATIC_HelperIsNavigatingToOrAtDestination(class AActor* Destination);
	void DestroyHelperBot();
	void SpawnHelperBot();
};


// Class TgGame.TgTutorialVolume
// 0x0004 (0x02C0 - 0x02BC)
class ATgTutorialVolume : public AVolume
{
public:
	unsigned long                                      m_bHasLocalPawn : 1;                                      // 0x02BC(0x0004)
	unsigned long                                      m_bHasSeenLocalPawnBefore : 1;                            // 0x02BC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgTutorialVolume");
		return ptr;
	}


	void UnTouch(class AActor* Other);
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
};


// Class TgGame.TgVolume
// 0x0000 (0x02BC - 0x02BC)
class ATgVolume : public AVolume
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgVolume");
		return ptr;
	}

};


// Class TgGame.TgWaterVolume
// 0x0000 (0x0334 - 0x0334)
class ATgWaterVolume : public AWaterVolume
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgWaterVolume");
		return ptr;
	}

};


// Class TgGame.TgWeaponMeshActor_BarrierTankInhand
// 0x0004 (0x0508 - 0x0504)
class ATgWeaponMeshActor_BarrierTankInhand : public ATgWeaponMeshActor
{
public:
	unsigned long                                      m_bHasFinishedBurst : 1;                                  // 0x0504(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgWeaponMeshActor_BarrierTankInhand");
		return ptr;
	}


	void StopFireEffects(int nEquipSlot, TEnumAsByte<EDeviceSubtype> eDeviceSubtype, bool bForceBlendOutOnAnimEnd);
	void PlayFireEffects(int nEquipSlot, float fRefireTime, int nFireMode, TEnumAsByte<EDeviceSubtype> eDeviceSubtype, TEnumAsByte<EeMovementType> eMoveType, bool bForceBlendOutOnAnimEnd);
};


// Class TgGame.TgWeaponMeshActor_Lance
// 0x0000 (0x0504 - 0x0504)
class ATgWeaponMeshActor_Lance : public ATgWeaponMeshActor
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgWeaponMeshActor_Lance");
		return ptr;
	}

};


// Class TgGame.TgWeaponMeshActor_Orb
// 0x0008 (0x050C - 0x0504)
class ATgWeaponMeshActor_Orb : public ATgWeaponMeshActor
{
public:
	float                                              m_fFireGlowFadeTime;                                      // 0x0504(0x0004) (Edit)
	float                                              m_fRemainingGlowFadeTime;                                 // 0x0508(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgWeaponMeshActor_Orb");
		return ptr;
	}


	bool STATIC_GetSimulatedBeamTarget(int nEquipSlot, struct FVector* HitLocation);
	void Tick(float DeltaTime);
	void StopFireEffects(int nEquipSlot, TEnumAsByte<EDeviceSubtype> eDeviceSubtype, bool bForceBlendOutOnAnimEnd);
	void PlayFireEffects(int nEquipSlot, float fRefireTime, int nFireMode, TEnumAsByte<EDeviceSubtype> eDeviceSubtype, TEnumAsByte<EeMovementType> eMoveType, bool bForceBlendOutOnAnimEnd);
};


// Class TgGame.TgWeaponMeshActor_Sniper
// 0x0000 (0x0504 - 0x0504)
class ATgWeaponMeshActor_Sniper : public ATgWeaponMeshActor
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgWeaponMeshActor_Sniper");
		return ptr;
	}


	void SetLoopingMuzzleEffects(bool bSetActive, int nEquipSlot);
};


// Class TgGame.TgWeaponMeshActor_TyraInhand
// 0x000C (0x0510 - 0x0504)
class ATgWeaponMeshActor_TyraInhand : public ATgWeaponMeshActor
{
public:
	float                                              m_fWeaponZoomFOV;                                         // 0x0504(0x0004) (Edit)
	float                                              m_fWeaponFOVDefault;                                      // 0x0508(0x0004) (Edit)
	float                                              m_fDoFMultiplier;                                         // 0x050C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgWeaponMeshActor_TyraInhand");
		return ptr;
	}


	void UpdateTransform(float DeltaTime, bool bFromCameraUpdate);
	bool STATIC_HasCachedTyra();
};


// Class TgGame.TgGameplayCurvesSet_GyroSensitivity
// 0x0000 (0x0098 - 0x0098)
class UTgGameplayCurvesSet_GyroSensitivity : public UTgGameplayCurvesSet_Simple
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGameplayCurvesSet_GyroSensitivity");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_ClearDropLocation
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorAction_ClearDropLocation : public UTgAIBehaviorAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_ClearDropLocation");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_ClearInteractTarget
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorAction_ClearInteractTarget : public UTgAIBehaviorAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_ClearInteractTarget");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_DisenchantItem
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorAction_DisenchantItem : public UTgAIBehaviorAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_DisenchantItem");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_FollowLoop
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorAction_FollowLoop : public UTgAIBehaviorAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_FollowLoop");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_JumpFromZeppelin
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorAction_JumpFromZeppelin : public UTgAIBehaviorAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_JumpFromZeppelin");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_LookAtInteractTarget
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorAction_LookAtInteractTarget : public UTgAIBehaviorAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_LookAtInteractTarget");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_MoveToDropLocation
// 0x0000 (0x009C - 0x009C)
class UTgAIBehaviorAction_MoveToDropLocation : public UTgAIBehaviorAction_MoveToTarget
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_MoveToDropLocation");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_MoveToFogCenter
// 0x0004 (0x00A0 - 0x009C)
class UTgAIBehaviorAction_MoveToFogCenter : public UTgAIBehaviorAction_MoveToTarget
{
public:
	float                                              Percent;                                                  // 0x009C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_MoveToFogCenter");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_MoveToInteractTarget
// 0x0000 (0x009C - 0x009C)
class UTgAIBehaviorAction_MoveToInteractTarget : public UTgAIBehaviorAction_MoveToTarget
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_MoveToInteractTarget");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_OpenChest
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorAction_OpenChest : public UTgAIBehaviorAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_OpenChest");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_PickUpItem
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorAction_PickUpItem : public UTgAIBehaviorAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_PickUpItem");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_RunInRandomDirection
// 0x0008 (0x009C - 0x0094)
class UTgAIBehaviorAction_RunInRandomDirection : public UTgAIBehaviorAction
{
public:
	float                                              TraceDistance;                                            // 0x0094(0x0004) (Edit)
	float                                              Acceleration;                                             // 0x0098(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_RunInRandomDirection");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_SelectDropLocation
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorAction_SelectDropLocation : public UTgAIBehaviorAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_SelectDropLocation");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_SetGoblinState
// 0x0001 (0x0095 - 0x0094)
class UTgAIBehaviorAction_SetGoblinState : public UTgAIBehaviorAction
{
public:
	TEnumAsByte<EGoblinState>                          GoblinState;                                              // 0x0094(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_SetGoblinState");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_Sprint
// 0x0004 (0x0098 - 0x0094)
class UTgAIBehaviorAction_Sprint : public UTgAIBehaviorAction
{
public:
	unsigned long                                      Sprint : 1;                                               // 0x0094(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_Sprint");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_Suicide
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorAction_Suicide : public UTgAIBehaviorAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_Suicide");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_TargetNearestChest
// 0x0004 (0x0098 - 0x0094)
class UTgAIBehaviorAction_TargetNearestChest : public UTgAIBehaviorAction
{
public:
	unsigned long                                      SeenAsOpen : 1;                                           // 0x0094(0x0004) (Edit)
	unsigned long                                      CheckLOS : 1;                                             // 0x0094(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_TargetNearestChest");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_TargetNearestItem
// 0x0004 (0x0098 - 0x0094)
class UTgAIBehaviorAction_TargetNearestItem : public UTgAIBehaviorAction
{
public:
	unsigned long                                      CheckLOS : 1;                                             // 0x0094(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_TargetNearestItem");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_TargetRoyaleObjective
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorAction_TargetRoyaleObjective : public UTgAIBehaviorAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_TargetRoyaleObjective");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_UseAltFire
// 0x0008 (0x009C - 0x0094)
class UTgAIBehaviorAction_UseAltFire : public UTgAIBehaviorAction
{
public:
	TEnumAsByte<ETG_EQUIP_POINT>                       DeviceToUse;                                              // 0x0094(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	unsigned long                                      Start : 1;                                                // 0x0098(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_UseAltFire");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_ArmorPercent
// 0x0007 (0x009C - 0x0095)
class UTgAIBehaviorCondition_ArmorPercent : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	float                                              ArmorPct;                                                 // 0x0098(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_ArmorPercent");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_AtDropLocation
// 0x0007 (0x009C - 0x0095)
class UTgAIBehaviorCondition_AtDropLocation : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	float                                              Tolerance;                                                // 0x0098(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_AtDropLocation");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_AtJumpLocation
// 0x0007 (0x009C - 0x0095)
class UTgAIBehaviorCondition_AtJumpLocation : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	float                                              Tolerance;                                                // 0x0098(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_AtJumpLocation");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_AtMaxShards
// 0x0003 (0x0098 - 0x0095)
class UTgAIBehaviorCondition_AtMaxShards : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_AtMaxShards");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_CombatTargetPolymorphState
// 0x0004 (0x0099 - 0x0095)
class UTgAIBehaviorCondition_CombatTargetPolymorphState : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	TEnumAsByte<EPolymorphType>                        PolymorphState;                                           // 0x0098(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_CombatTargetPolymorphState");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_DistanceFromFogCenter
// 0x0007 (0x009C - 0x0095)
class UTgAIBehaviorCondition_DistanceFromFogCenter : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	float                                              Percent;                                                  // 0x0098(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_DistanceFromFogCenter");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_DistanceFromInteractTarget
// 0x0007 (0x009C - 0x0095)
class UTgAIBehaviorCondition_DistanceFromInteractTarget : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	float                                              Distance;                                                 // 0x0098(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_DistanceFromInteractTarget");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_GoblinState
// 0x0004 (0x0099 - 0x0095)
class UTgAIBehaviorCondition_GoblinState : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	TEnumAsByte<EGoblinState>                          GoblinState;                                              // 0x0098(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_GoblinState");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_HasDropLocation
// 0x0003 (0x0098 - 0x0095)
class UTgAIBehaviorCondition_HasDropLocation : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_HasDropLocation");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsChestInRadius
// 0x000B (0x00A0 - 0x0095)
class UTgAIBehaviorCondition_IsChestInRadius : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	float                                              Radius;                                                   // 0x0098(0x0004) (Edit)
	unsigned long                                      SeenAsOpen : 1;                                           // 0x009C(0x0004) (Edit)
	unsigned long                                      CheckLOS : 1;                                             // 0x009C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsChestInRadius");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsChestLooted
// 0x0007 (0x009C - 0x0095)
class UTgAIBehaviorCondition_IsChestLooted : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	unsigned long                                      SeenAsOpen : 1;                                           // 0x0098(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsChestLooted");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsCombatTargetTrackable
// 0x0003 (0x0098 - 0x0095)
class UTgAIBehaviorCondition_IsCombatTargetTrackable : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsCombatTargetTrackable");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsEquippedWeaponRanged
// 0x0003 (0x0098 - 0x0095)
class UTgAIBehaviorCondition_IsEquippedWeaponRanged : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsEquippedWeaponRanged");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsInteractTargetVisible
// 0x0003 (0x0098 - 0x0095)
class UTgAIBehaviorCondition_IsInteractTargetVisible : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsInteractTargetVisible");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsItemInRadius
// 0x000B (0x00A0 - 0x0095)
class UTgAIBehaviorCondition_IsItemInRadius : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	float                                              Radius;                                                   // 0x0098(0x0004) (Edit)
	unsigned long                                      CheckLOS : 1;                                             // 0x009C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsItemInRadius");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsLookingAtInteractTarget
// 0x0007 (0x009C - 0x0095)
class UTgAIBehaviorCondition_IsLookingAtInteractTarget : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	float                                              VisibilityAngle;                                          // 0x0098(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsLookingAtInteractTarget");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsSafeFromFog
// 0x0003 (0x0098 - 0x0095)
class UTgAIBehaviorCondition_IsSafeFromFog : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsSafeFromFog");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsSprinting
// 0x0003 (0x0098 - 0x0095)
class UTgAIBehaviorCondition_IsSprinting : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsSprinting");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_ItemIsValid
// 0x0003 (0x0098 - 0x0095)
class UTgAIBehaviorCondition_ItemIsValid : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_ItemIsValid");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_OnNavMesh
// 0x0003 (0x0098 - 0x0095)
class UTgAIBehaviorCondition_OnNavMesh : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_OnNavMesh");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_PlayerDeployState
// 0x0004 (0x0099 - 0x0095)
class UTgAIBehaviorCondition_PlayerDeployState : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	TEnumAsByte<EPlayerDeployState>                    DeployState;                                              // 0x0098(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_PlayerDeployState");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_PolymorphState
// 0x0004 (0x0099 - 0x0095)
class UTgAIBehaviorCondition_PolymorphState : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	TEnumAsByte<EPolymorphType>                        PolymorphState;                                           // 0x0098(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_PolymorphState");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_TimeSinceOpenedChest
// 0x0007 (0x009C - 0x0095)
class UTgAIBehaviorCondition_TimeSinceOpenedChest : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	float                                              TimeThreshold;                                            // 0x0098(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_TimeSinceOpenedChest");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorSensor_Fog
// 0x0008 (0x009C - 0x0094)
class UTgAIBehaviorSensor_Fog : public UTgAIBehaviorSensor
{
public:
	float                                              UnsafeRatio;                                              // 0x0094(0x0004) (Edit)
	float                                              SafePercent;                                              // 0x0098(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorSensor_Fog");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorSensor_GodsAndMonsters
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorSensor_GodsAndMonsters : public UTgAIBehaviorSensor_Gods
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorSensor_GodsAndMonsters");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorSensor_NearbyChests
// 0x0004 (0x0098 - 0x0094)
class UTgAIBehaviorSensor_NearbyChests : public UTgAIBehaviorSensor
{
public:
	float                                              MaxRadius;                                                // 0x0094(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorSensor_NearbyChests");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorSensor_NearbyItems
// 0x0004 (0x0098 - 0x0094)
class UTgAIBehaviorSensor_NearbyItems : public UTgAIBehaviorSensor
{
public:
	float                                              MaxRadius;                                                // 0x0094(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorSensor_NearbyItems");
		return ptr;
	}

};


// Class TgGame.TgHavokNavigationHandle
// 0x0000 (0x01E8 - 0x01E8)
class UTgHavokNavigationHandle : public UHavokNavigationHandle
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgHavokNavigationHandle");
		return ptr;
	}

};


// Class TgGame.TgDeploy_Chirper
// 0x0000 (0x0448 - 0x0448)
class ATgDeploy_Chirper : public ATgDeployable
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_Chirper");
		return ptr;
	}


	bool STATIC_DamageShouldEnterCombat();
};


// Class TgGame.TgDeploy_LootCrateTutorialAbility
// 0x0000 (0x04B8 - 0x04B8)
class ATgDeploy_LootCrateTutorialAbility : public ATgDeploy_LootCrateBasic
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_LootCrateTutorialAbility");
		return ptr;
	}

};


// Class TgGame.TgDeploy_LootCrateTutorialDisenchant
// 0x0000 (0x04B8 - 0x04B8)
class ATgDeploy_LootCrateTutorialDisenchant : public ATgDeploy_LootCrateBasic
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_LootCrateTutorialDisenchant");
		return ptr;
	}

};


// Class TgGame.TgDeploy_LootCrateTutorialWeapon
// 0x0000 (0x04B8 - 0x04B8)
class ATgDeploy_LootCrateTutorialWeapon : public ATgDeploy_LootCrateBasic
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_LootCrateTutorialWeapon");
		return ptr;
	}

};


// Class TgGame.TgDevice_AssassinPassive
// 0x0000 (0x0AEC - 0x0AEC)
class ATgDevice_AssassinPassive : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_AssassinPassive");
		return ptr;
	}

};


// Class TgGame.TgDevice_AutoSniper
// 0x0000 (0x0AEC - 0x0AEC)
class ATgDevice_AutoSniper : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_AutoSniper");
		return ptr;
	}

};


// Class TgGame.TgDevice_BattleCry
// 0x0000 (0x0AEC - 0x0AEC)
class ATgDevice_BattleCry : public ATgDevice_VanguardShout
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_BattleCry");
		return ptr;
	}

};


// Class TgGame.TgDevice_Bazooka
// 0x0000 (0x0AEC - 0x0AEC)
class ATgDevice_Bazooka : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Bazooka");
		return ptr;
	}

};


// Class TgGame.TgDevice_BoltStaff
// 0x0000 (0x0AEC - 0x0AEC)
class ATgDevice_BoltStaff : public ATgDevice_EvieInhand
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_BoltStaff");
		return ptr;
	}

};


// Class TgGame.TgDevice_ChickenCharge
// 0x0000 (0x0B60 - 0x0B60)
class ATgDevice_ChickenCharge : public ATgDevice_Uppercut
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_ChickenCharge");
		return ptr;
	}

};


// Class TgGame.TgDevice_Chirper
// 0x0000 (0x0AEC - 0x0AEC)
class ATgDevice_Chirper : public ATgDevice_Throw
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Chirper");
		return ptr;
	}

};


// Class TgGame.TgDevice_ConcussionBomb
// 0x0000 (0x0AEC - 0x0AEC)
class ATgDevice_ConcussionBomb : public ATgDevice_ExplosiveFlask
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_ConcussionBomb");
		return ptr;
	}

};


// Class TgGame.TgDevice_Decoy
// 0x0000 (0x0B08 - 0x0B08)
class ATgDevice_Decoy : public ATgDevice_Turret
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Decoy");
		return ptr;
	}

};


// Class TgGame.TgDevice_Frostblast
// 0x0000 (0x0AEC - 0x0AEC)
class ATgDevice_Frostblast : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Frostblast");
		return ptr;
	}

};


// Class TgGame.TgDevice_GrapplingHook
// 0x0000 (0x0B14 - 0x0B14)
class ATgDevice_GrapplingHook : public ATgDevice_Vine
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_GrapplingHook");
		return ptr;
	}

};


// Class TgGame.TgDevice_GrenadeLauncher
// 0x0000 (0x0AEC - 0x0AEC)
class ATgDevice_GrenadeLauncher : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_GrenadeLauncher");
		return ptr;
	}

};


// Class TgGame.TgDevice_GroundingShock
// 0x0000 (0x0AEC - 0x0AEC)
class ATgDevice_GroundingShock : public ATgDevice_ExplosiveFlask
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_GroundingShock");
		return ptr;
	}

};


// Class TgGame.TgDevice_MagicEye
// 0x0000 (0x0AEC - 0x0AEC)
class ATgDevice_MagicEye : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_MagicEye");
		return ptr;
	}

};


// Class TgGame.TgDevice_PeckAttack
// 0x0000 (0x0AF8 - 0x0AF8)
class ATgDevice_PeckAttack : public ATgDevice_Sword
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_PeckAttack");
		return ptr;
	}


	int STATIC_GetChainMax();
};


// Class TgGame.TgDevice_ProximityMine
// 0x0000 (0x0AEC - 0x0AEC)
class ATgDevice_ProximityMine : public ATgDevice_Throw
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_ProximityMine");
		return ptr;
	}

};


// Class TgGame.TgDevice_RepairPack
// 0x0000 (0x0AF8 - 0x0AF8)
class ATgDevice_RepairPack : public ATgDevice_HealthPack
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_RepairPack");
		return ptr;
	}

};


// Class TgGame.TgDevice_ShieldingPotion
// 0x0000 (0x0AF0 - 0x0AF0)
class ATgDevice_ShieldingPotion : public ATgDevice_HealingPotion
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_ShieldingPotion");
		return ptr;
	}

};


// Class TgGame.TgDevice_SilentRun
// 0x0000 (0x0AEC - 0x0AEC)
class ATgDevice_SilentRun : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_SilentRun");
		return ptr;
	}

};


// Class TgGame.TgDevice_SpeedPotion
// 0x0000 (0x0AF0 - 0x0AF0)
class ATgDevice_SpeedPotion : public ATgDevice_HealingPotion
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_SpeedPotion");
		return ptr;
	}

};


// Class TgGame.TgDevice_StoneSpear
// 0x0000 (0x0B24 - 0x0B24)
class ATgDevice_StoneSpear : public ATgDevice_BarrierTankInhand
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_StoneSpear");
		return ptr;
	}


	void StopAltFire();
};


// Class TgGame.TgDeviceForm_GrenadeLauncher
// 0x0000 (0x02BC - 0x02BC)
class UTgDeviceForm_GrenadeLauncher : public UTgDeviceForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_GrenadeLauncher");
		return ptr;
	}

};


// Class TgGame.TgDeviceForm_Longbow
// 0x0000 (0x02BC - 0x02BC)
class UTgDeviceForm_Longbow : public UTgDeviceForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Longbow");
		return ptr;
	}


	void STATIC_Generic1(unsigned char byExtraData);
};


// Class TgGame.TgForgeObjective_Tutorial
// 0x0000 (0x03A4 - 0x03A4)
class ATgForgeObjective_Tutorial : public ATgForgeObjective
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgForgeObjective_Tutorial");
		return ptr;
	}

};


// Class TgGame.TgHavokNavMeshActor
// 0x0000 (0x036C - 0x036C)
class ATgHavokNavMeshActor : public AHavokNavMeshActor
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgHavokNavMeshActor");
		return ptr;
	}

};


// Class TgGame.TgProj_Chirper
// 0x0000 (0x056C - 0x056C)
class ATgProj_Chirper : public ATgProj_FreeGrenade
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Chirper");
		return ptr;
	}


	bool ShouldHitBounce(class AActor* Target, const struct FVector& HitNormal);
	class AActor* CalculateHitActor(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal, struct FTraceHitInfo* HitInfo);
};


// Class TgGame.TgProj_GrenadeLauncher
// 0x0000 (0x056C - 0x056C)
class ATgProj_GrenadeLauncher : public ATgProj_FragGrenade
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_GrenadeLauncher");
		return ptr;
	}

};


// Class TgGame.TgProj_HolyHammer
// 0x0004 (0x0520 - 0x051C)
class ATgProj_HolyHammer : public ATgProj_Simulated
{
public:
	unsigned long                                      bReachedLimit : 1;                                        // 0x051C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_HolyHammer");
		return ptr;
	}


	void HitWall(const struct FVector& HitNormal, class AActor* Wall, class UPrimitiveComponent* WallComp);
	void RangeReached();
	bool STATIC_ApplyHit(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal, int HitItem);
	void STATIC_ProcessTouch(class AActor* Other, const struct FVector& HitLocation, const struct FVector& HitNormal, float VelocityZ);
};


// Class TgGame.TgProj_MagicEye
// 0x0008 (0x0524 - 0x051C)
class ATgProj_MagicEye : public ATgProj_Simulated
{
public:
	unsigned long                                      m_bStartedPulse : 1;                                      // 0x051C(0x0004)
	float                                              m_fLifetimeForPhysicsSubstep;                             // 0x0520(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_MagicEye");
		return ptr;
	}


	bool UseAOE();
	void PulseVisibility();
	void STATIC_PostProjectileInitialize();
	void StartPulse();
};


// Class TgGame.TgProj_SoulGust
// 0x0000 (0x051C - 0x051C)
class ATgProj_SoulGust : public ATgProj_Simulated
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_SoulGust");
		return ptr;
	}


	void RangeReached();
};


// Class TgGame.TgSeqAct_SetDisenchantEnabled
// 0x0004 (0x010C - 0x0108)
class UTgSeqAct_SetDisenchantEnabled : public USequenceAction
{
public:
	unsigned long                                      bEnabled : 1;                                             // 0x0108(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_SetDisenchantEnabled");
		return ptr;
	}


	void STATIC_Activated();
};


// Class TgGame.TgSeqAct_SetMountingEnabled
// 0x0004 (0x010C - 0x0108)
class UTgSeqAct_SetMountingEnabled : public USequenceAction
{
public:
	unsigned long                                      bEnabled : 1;                                             // 0x0108(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_SetMountingEnabled");
		return ptr;
	}


	void STATIC_Activated();
};


// Class TgGame.TgSeqAct_ShowSubtitle
// 0x0008 (0x0110 - 0x0108)
class UTgSeqAct_ShowSubtitle : public USequenceAction
{
public:
	int                                                m_nMessageId;                                             // 0x0108(0x0004) (Edit)
	float                                              m_fShowTime;                                              // 0x010C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_ShowSubtitle");
		return ptr;
	}


	void STATIC_Activated();
};


}

#ifdef _MSC_VER
	#pragma pack(pop)
#endif
